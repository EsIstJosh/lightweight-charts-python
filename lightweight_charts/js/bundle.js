var Lib = (function (exports, lightweightCharts, monaco, url) {
    'use strict';

    function _interopNamespaceDefault(e) {
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n.default = e;
        return Object.freeze(n);
    }

    var monaco__namespace = /*#__PURE__*/_interopNamespaceDefault(monaco);

    function ensureDefined(value) {
        if (value === undefined) {
            throw new Error('Value is undefined');
        }
        return value;
    }

    //* PluginBase is a useful base to build a plugin upon which
    //* already handles creating getters for the chart and series,
    //* and provides a requestUpdate method.
    class PluginBase {
        _chart = undefined;
        _series = undefined;
        requestUpdate() {
            if (this._requestUpdate)
                this._requestUpdate();
        }
        _requestUpdate;
        attached({ chart, series, requestUpdate, }) {
            this._chart = chart;
            this._series = series;
            this._series.subscribeDataChanged(this._fireDataUpdated);
            this._requestUpdate = requestUpdate;
            this.requestUpdate();
        }
        detached() {
            this._chart = undefined;
            this._series = undefined;
            this._requestUpdate = undefined;
        }
        get chart() {
            return ensureDefined(this._chart);
        }
        get series() {
            return ensureDefined(this._series);
        }
        _fireDataUpdated(scope) {
            if (this.dataUpdated) {
                this.dataUpdated(scope);
            }
        }
        /**
         * Serializes the plugin state.
         * Default implementation returns an empty object.
         * Subclasses should override this method to export any relevant state.
         *
         * @returns A JSON-compatible representation of the plugin state.
         */
        toJSON() {
            return {};
        }
        /**
         * Restores the plugin state from the provided JSON.
         * Default implementation does nothing.
         * Subclasses should override this method to restore their state.
         *
         * @param json - The JSON object representing the plugin state.
         */
        fromJSON(json) {
            // Default implementation: do nothing.
        }
    }

    // Converts a hex color to RGBA with specified opacity
    function hexToRGBA(hex, opacity) {
        hex = hex.replace(/^#/, '');
        if (!/^([0-9A-F]{3}){1,2}$/i.test(hex)) {
            throw new Error("Invalid hex color format.");
        }
        const getRGB = (h) => {
            return h.length === 3
                ? [parseInt(h[0] + h[0], 16), parseInt(h[1] + h[1], 16), parseInt(h[2] + h[2], 16)]
                : [parseInt(h.slice(0, 2), 16), parseInt(h.slice(2, 4), 16), parseInt(h.slice(4, 6), 16)];
        };
        const [r, g, b] = getRGB(hex);
        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
    // Adjusts the opacity of a color (hex, rgb, or rgba)
    function setOpacity(color, newOpacity) {
        if (color.startsWith('#')) {
            return hexToRGBA(color, newOpacity);
        }
        else {
            // Match rgb or rgba
            const rgbRegex = /^rgb(a)?\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)(?:,\s*([\d.]+))?\)/i;
            const match = color.match(rgbRegex);
            if (match) {
                const r = match[2];
                const g = match[3];
                const b = match[4];
                // If alpha not specified, assume 1.0
                const a = match[1] ? (match[5] ?? '1') : '1';
                return `rgba(${r}, ${g}, ${b}, ${newOpacity ?? a})`;
            }
            else {
                throw new Error("Unsupported color format. Use hex, rgb, or rgba.");
            }
        }
    }
    // Darkens a color (hex or rgba) by a specified amount
    function darkenColor(color, amount = 0.2) {
        const hexToRgb = (hex) => {
            hex = hex.replace(/^#/, '');
            return hex.length === 3
                ? [parseInt(hex[0] + hex[0], 16), parseInt(hex[1] + hex[1], 16), parseInt(hex[2] + hex[2], 16)]
                : [parseInt(hex.slice(0, 2), 16), parseInt(hex.slice(2, 4), 16), parseInt(hex.slice(4, 6), 16)];
        };
        const rgbaToArray = (rgba) => rgba.match(/\d+(\.\d+)?/g).map(Number);
        let [r, g, b, a = 1] = color.startsWith('#')
            ? [...hexToRgb(color), 1]
            : rgbaToArray(color);
        r = Math.max(0, Math.min(255, r * (1 - amount)));
        g = Math.max(0, Math.min(255, g * (1 - amount)));
        b = Math.max(0, Math.min(255, b * (1 - amount)));
        return color.startsWith('#')
            ? `#${((1 << 24) + (Math.round(r) << 16) + (Math.round(g) << 8) + Math.round(b)).toString(16).slice(1)}`
            : `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;
    }
    function generateShades(count) {
        // List of potential base colors.
        const colors = {
            "#ff0000": [
                "#ff0000",
                "#f20000",
                "#e60000",
                "#d90000",
                "#cc0000",
                "#bf0000",
                "#b30000",
                "#a60000",
                "#990000",
                "#8c0000"
            ],
            "#ff8700": [
                "#ff8700",
                "#f28000",
                "#e67a00",
                "#d97300",
                "#cc6c00",
                "#bf6500",
                "#b35f00",
                "#a65800",
                "#995100",
                "#8c4a00"
            ],
            "#ffd300": [
                "#ffd300",
                "#fcca00",
                "#e6c000",
                "#d9b600",
                "#ccb000",
                "#bfaa00",
                "#b3a000",
                "#a69a00",
                "#999000",
                "#8c8600"
            ],
            "#a1ff0a": [
                "#a1ff0a",
                "#97f207",
                "#8ded04",
                "#83e701",
                "#79db00",
                "#6fd200",
                "#65c900",
                "#5bc000",
                "#51b700",
                "#47ae00"
            ],
            "#117a03": [
                "#117a03",
                "#107203",
                "#0e6c03",
                "#0c6603",
                "#0a6003",
                "#085a03",
                "#065403",
                "#044e03",
                "#024803",
                "#004203"
            ],
            "#580aff": [
                "#580aff",
                "#5109f2",
                "#4a08e6",
                "#4307da",
                "#3c06ce",
                "#3505c2",
                "#2e04b6",
                "#2703aa",
                "#2002a0",
                "#190196"
            ],
            "#be0aff": [
                "#be0aff",
                "#b308f2",
                "#aa07e6",
                "#a005da",
                "#9704ce",
                "#8e03c2",
                "#8502b6",
                "#7c01aa",
                "#7300a0",
                "#6a0096"
            ]
        };
        // Tell TypeScript that the keys are exactly those of the colors object.
        const baseColors = Object.keys(colors);
        // Pick a random base color.
        const randomKey = baseColors[Math.floor(Math.random() * baseColors.length)];
        const fullShades = colors[randomKey];
        // If the requested count equals the full set, return it directly.
        if (count === fullShades.length) {
            return fullShades;
        }
        // Otherwise, return an evenly spaced selection of shades.
        const result = [];
        for (let i = 0; i < count; i++) {
            const index = count === 1 ? 0 : Math.round(i * (fullShades.length - 1) / (count - 1));
            result.push(fullShades[index]);
        }
        return result;
    }
    /**
    * Safely extracts the alpha component from an RGBA or HSLA color string.
    * Returns 1.0 if parsing fails or if no alpha is found (e.g. "rgb(...)").
    */
    function getAlphaFromColor(color) {
        // Attempt to parse 'rgba(...)' or 'hsla(...)' format.
        const rgbaMatch = color.match(/rgba?\(([^)]+)\)/i);
        const hslaMatch = color.match(/hsla?\(([^)]+)\)/i);
        let alpha = 1.0; // Default if we fail to parse or if no alpha is present
        if (rgbaMatch) {
            // Extract the comma-separated values inside the parentheses
            const parts = rgbaMatch[1].split(',').map((p) => parseFloat(p.trim()));
            // If there are 4 parts (r, g, b, a), use the last as alpha
            if (parts.length === 4) {
                alpha = parts[3];
            }
        }
        else if (hslaMatch) {
            // Extract the comma-separated values inside the parentheses
            const parts = hslaMatch[1].split(',').map((p) => parseFloat(p.trim()));
            // If there are 4 parts (h, s, l, a), use the last as alpha
            if (parts.length === 4) {
                alpha = parts[3];
            }
        }
        return alpha;
    }

    class ClosestTimeIndexFinder {
        numbers;
        cache;
        constructor(sortedNumbers) {
            this.numbers = sortedNumbers;
            this.cache = new Map();
        }
        findClosestIndex(target, direction) {
            const cacheKey = `${target}:${direction}`;
            if (this.cache.has(cacheKey)) {
                return this.cache.get(cacheKey);
            }
            const closestIndex = this._performSearch(target, direction);
            this.cache.set(cacheKey, closestIndex);
            return closestIndex;
        }
        _performSearch(target, direction) {
            let low = 0;
            let high = this.numbers.length - 1;
            if (target <= this.numbers[0].time)
                return 0;
            if (target >= this.numbers[high].time)
                return high;
            while (low <= high) {
                const mid = Math.floor((low + high) / 2);
                const num = this.numbers[mid].time;
                if (num === target) {
                    return mid;
                }
                else if (num > target) {
                    high = mid - 1;
                }
                else {
                    low = mid + 1;
                }
            }
            return direction === 'left' ? low : high;
        }
    }

    /**
     * Enumeration for different candle shapes.
     */
    var CandleShape;
    (function (CandleShape) {
        CandleShape["Rectangle"] = "Rectangle";
        CandleShape["Rounded"] = "Rounded";
        CandleShape["Ellipse"] = "Ellipse";
        CandleShape["Arrow"] = "Arrow";
        CandleShape["Cube"] = "3d";
        CandleShape["Polygon"] = "Polygon";
        CandleShape["Bar"] = "Bar";
        CandleShape["Slanted"] = "Slanted";
    })(CandleShape || (CandleShape = {}));
    function parseCandleShape(input) {
        switch (input.trim().toLowerCase()) {
            case 'rectangle':
                return CandleShape.Rectangle;
            case 'rounded':
                return CandleShape.Rounded;
            case 'ellipse':
                return CandleShape.Ellipse;
            case 'arrow':
                return CandleShape.Arrow;
            case '3d':
                return CandleShape.Cube;
            case 'polygon':
                return CandleShape.Polygon;
            case 'bar':
                return CandleShape.Bar;
            case 'slanted':
                return CandleShape.Slanted;
            default:
                console.warn(`Unknown CandleShape: ${input}`);
                return CandleShape.Rectangle;
        }
    }

    function isSolidColor(background) {
        return background.type === lightweightCharts.ColorType.Solid;
    }
    function isVerticalGradientColor(background) {
        return background.type === lightweightCharts.ColorType.VerticalGradient;
    }
    // Type checks for data
    function isSingleValueData(data) {
        return "value" in data;
    }
    function isOHLCData(data) {
        return "close" in data && "open" in data && "high" in data && "low" in data;
    }
    function isWhitespaceData(data) {
        if (!data || typeof data !== "object") {
            return false;
        }
        // Must have time
        if (!("time" in data)) {
            return false;
        }
        // Must NOT have single-value or OHLC fields
        if ("value" in data ||
            "open" in data ||
            "close" in data ||
            "high" in data ||
            "low" in data) {
            return false;
        }
        return true;
    }
    function hasColorOption(series) {
        const seriesOptions = series.options();
        return 'lineColor' in seriesOptions || 'color' in seriesOptions;
    }
    // utils/typeGuards.ts
    /**
     * Type guard to check if a primitive is FillArea.
     *
     * @param primitive - The primitive to check.
     * @returns True if primitive is FillArea, else false.
     */
    function isFillArea(primitive) {
        return (primitive.options.originColor !== null &&
            primitive.options.destinationColor !== null);
    }
    function isCandleShape(value) {
        return Object.values(CandleShape).includes(value);
    }
    function isISeriesApi(series) {
        return (typeof series === "object" &&
            series !== null &&
            typeof series.data === "function" &&
            typeof series.options === "function");
    }
    // Type Guard: Check if the series is an ISeriesIndicator
    function isISeriesIndicator(series) {
        return series.figures !== undefined &&
            series.sourceSeries !== undefined &&
            series.indicator !== undefined;
    }

    class FillArea extends PluginBase {
        static type = "Fill Area"; // Explicitly set the type name
        _paneViews;
        _originSeries;
        _destinationSeries;
        _bandsData = [];
        options;
        _timeIndices;
        constructor(originSeries, destinationSeries, options) {
            super();
            // Existing logic for setting colors
            const defaultOriginColor = setOpacity('#0000FF', 0.25); // Blue
            const defaultDestinationColor = setOpacity('#FF0000', 0.25); // Red
            const originSeriesColor = hasColorOption(originSeries)
                ? setOpacity(originSeries.options().lineColor || defaultOriginColor, 0.3)
                : setOpacity(defaultOriginColor, 0.3);
            const destinationSeriesColor = hasColorOption(destinationSeries)
                ? setOpacity(destinationSeries.options().lineColor || defaultDestinationColor, 0.3)
                : setOpacity(defaultDestinationColor, 0.3);
            this.options = {
                ...defaultFillAreaOptions,
                ...options,
                originColor: options.originColor ?? originSeriesColor,
                destinationColor: options.destinationColor ?? destinationSeriesColor,
            };
            this._paneViews = [new FillAreaPaneView(this)];
            this._timeIndices = new ClosestTimeIndexFinder([]);
            this._originSeries = originSeries;
            this._destinationSeries = destinationSeries;
            // Subscribe to data changes in both series
            this._originSeries.subscribeDataChanged(() => {
                console.log("Origin series data has changed. Recalculating bands.");
                this.dataUpdated('full');
                this.updateAllViews();
            });
            this._destinationSeries.subscribeDataChanged(() => {
                console.log("Destination series data has changed. Recalculating bands.");
                this.dataUpdated('full');
                this.updateAllViews();
            });
        }
        updateAllViews() {
            this._paneViews.forEach(pw => pw.update());
        }
        applyOptions(options) {
            this.options = {
                ...this.options,
                ...options,
            };
            this.calculateBands();
            this.updateAllViews();
            super.requestUpdate();
            console.log("FillArea options updated:", this.options);
        }
        paneViews() {
            return this._paneViews;
        }
        attached(p) {
            super.attached(p);
            this.dataUpdated('full');
        }
        dataUpdated(scope) {
            this.calculateBands();
            if (scope === 'full') {
                const originData = this._originSeries.data();
                this._timeIndices = new ClosestTimeIndexFinder([...originData]);
            }
        }
        calculateBands() {
            const originData = this._originSeries.data();
            const destinationData = this._destinationSeries.data();
            // Ensure both datasets have the same length
            const alignedData = this._alignDataLengths([...originData], [...destinationData]);
            const bandData = [];
            for (let i = 0; i < alignedData.origin.length; i++) {
                let points = extractPrices(alignedData.origin[i], alignedData.destination[i]);
                if (points?.originValue === undefined || points?.destinationValue === undefined)
                    continue;
                // Determine which series is upper and lower
                const upper = Math.max(points?.originValue, points?.destinationValue);
                const lower = Math.min(points?.originValue, points?.destinationValue);
                bandData.push({
                    time: alignedData.origin[i].time,
                    origin: points?.originValue,
                    destination: points?.destinationValue,
                    upper,
                    lower,
                });
            }
            this._bandsData = bandData;
        }
        _alignDataLengths(originData, destinationData) {
            const originLength = originData.length;
            const destinationLength = destinationData.length;
            if (originLength > destinationLength) {
                const lastKnown = destinationData[destinationLength - 1];
                while (destinationData.length < originLength) {
                    destinationData.push({ ...lastKnown });
                }
            }
            else if (destinationLength > originLength) {
                const lastKnown = originData[originLength - 1];
                while (originData.length < destinationLength) {
                    originData.push({ ...lastKnown });
                }
            }
            return { origin: originData, destination: destinationData };
        }
        autoscaleInfo(startTimePoint, endTimePoint) {
            const ts = this.chart.timeScale();
            const startTime = (ts.coordinateToTime(ts.logicalToCoordinate(startTimePoint) ?? 0) ?? 0);
            const endTime = (ts.coordinateToTime(ts.logicalToCoordinate(endTimePoint) ?? 5000000000) ?? 5000000000);
            const startIndex = this._timeIndices.findClosestIndex(startTime, 'left');
            const endIndex = this._timeIndices.findClosestIndex(endTime, 'right');
            const range = {
                minValue: Math.min(...this._bandsData.map(b => b.lower).slice(startIndex, endIndex + 1)),
                maxValue: Math.max(...this._bandsData.map(b => b.upper).slice(startIndex, endIndex + 1)),
            };
            return {
                priceRange: {
                    minValue: range.minValue,
                    maxValue: range.maxValue,
                },
            };
        }
    }
    class FillAreaPaneRenderer {
        _viewData;
        _options;
        constructor(data) {
            this._viewData = data;
            this._options = data.options;
        }
        draw() { }
        drawBackground(target) {
            const points = this._viewData.data;
            const options = this._options;
            if (points.length < 2)
                return; // Ensure there are enough points to draw
            target.useBitmapCoordinateSpace((scope) => {
                const ctx = scope.context;
                ctx.scale(scope.horizontalPixelRatio, scope.verticalPixelRatio);
                let currentPathStarted = false;
                let startIndex = 0;
                for (let i = 0; i < points.length - 1; i++) {
                    const current = points[i];
                    const next = points[i + 1];
                    if (!currentPathStarted || current.isOriginAbove !== points[i - 1]?.isOriginAbove) {
                        if (currentPathStarted) {
                            for (let j = i - 1; j >= startIndex; j--) {
                                ctx.lineTo(points[j].x, points[j].destination);
                            }
                            ctx.closePath();
                            ctx.fill();
                        }
                        ctx.beginPath();
                        ctx.moveTo(current.x, current.origin);
                        ctx.fillStyle = current.isOriginAbove
                            ? options.originColor || 'rgba(0, 0, 0, 0)' // Default to transparent if null
                            : options.destinationColor || 'rgba(0, 0, 0, 0)'; // Default to transparent if null
                        startIndex = i;
                        currentPathStarted = true;
                    }
                    ctx.lineTo(next.x, next.origin);
                    if (i === points.length - 2 || next.isOriginAbove !== current.isOriginAbove) {
                        for (let j = i + 1; j >= startIndex; j--) {
                            ctx.lineTo(points[j].x, points[j].destination);
                        }
                        ctx.closePath();
                        ctx.fill();
                        currentPathStarted = false;
                    }
                }
                if (options.lineWidth) {
                    ctx.lineWidth = options.lineWidth;
                    ctx.strokeStyle = options.originColor || 'rgba(0, 0, 0, 0)';
                    ctx.stroke();
                }
            });
        }
    }
    class FillAreaPaneView {
        _source;
        _data;
        constructor(source) {
            this._source = source;
            this._data = {
                data: [],
                options: this._source.options, // Pass the options for the renderer
            };
        }
        update() {
            const timeScale = this._source.chart.timeScale();
            this._data.data = this._source._bandsData.map((d) => ({
                x: timeScale.timeToCoordinate(d.time),
                origin: this._source._originSeries.priceToCoordinate(d.origin),
                destination: this._source._destinationSeries.priceToCoordinate(d.destination),
                isOriginAbove: d.origin > d.destination,
            }));
            // Ensure options are updated in the data
            this._data.options = this._source.options;
        }
        renderer() {
            return new FillAreaPaneRenderer(this._data);
        }
        zOrder() {
            return 'bottom';
        }
    }
    const defaultFillAreaOptions = {
        originColor: null,
        destinationColor: null,
        lineWidth: null,
    };
    function extractPrices(originPoint, destinationPoint) {
        let originPrice;
        let destinationPrice;
        // Extract origin price
        if (originPoint.close !== undefined) {
            const originBar = originPoint;
            originPrice = originBar.close; // Use close price for comparison
        }
        else if (originPoint.value !== undefined) {
            originPrice = originPoint.value; // Use value for LineData
        }
        // Extract destination price
        if (destinationPoint.close !== undefined) {
            const destinationBar = destinationPoint;
            destinationPrice = destinationBar.close; // Use close price for comparison
        }
        else if (destinationPoint.value !== undefined) {
            destinationPrice = destinationPoint.value; // Use value for LineData
        }
        // Ensure both prices are defined
        if (originPrice === undefined || destinationPrice === undefined) {
            return undefined;
        }
        // Handle mixed types and determine the appropriate values to return
        if (originPrice < destinationPrice) {
            // origin > destination: min(open, close) for BarData (if applicable), otherwise value
            const originValue = originPoint.close !== undefined
                ? Math.min(originPoint.open, originPoint.close)
                : originPrice;
            const destinationValue = destinationPoint.close !== undefined
                ? Math.max(destinationPoint.open, destinationPoint.close)
                : destinationPrice;
            return { originValue, destinationValue };
        }
        else {
            // origin <= destination: max(open, close) for BarData (if applicable), otherwise value
            const originValue = originPoint.close !== undefined
                ? Math.max(originPoint.open, originPoint.close)
                : originPrice;
            const destinationValue = destinationPoint.close !== undefined
                ? Math.min(destinationPoint.open, destinationPoint.close)
                : destinationPrice;
            return { originValue, destinationValue };
        }
    }

    const paneStyleDefault = {
        backgroundColor: '#0c0d0f',
        hoverBackgroundColor: '#3c434c',
        clickBackgroundColor: '#50565E',
        activeBackgroundColor: 'rgba(0, 122, 255, 0.7)',
        mutedBackgroundColor: 'rgba(0, 122, 255, 0.3)',
        borderColor: '#3C434C',
        color: '#d8d9db',
        activeColor: '#ececed',
    };
    function globalParamInit() {
        window.pane = {
            ...paneStyleDefault,
        };
        window.containerDiv = document.getElementById("container") || document.createElement('div');
        window.setCursor = (type) => {
            if (type)
                window.cursor = type;
            document.body.style.cursor = window.cursor;
        };
        window.cursor = 'default';
        window.textBoxFocused = false;
    }
    const setCursor = (type) => {
        if (type)
            window.cursor = type;
        document.body.style.cursor = window.cursor;
    };
    const openEye = `
<svg xmlns="http://www.w3.org/2000/svg" width="22" height="16" viewBox="0 0 24 24">
    <path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:#FFF;stroke-opacity:1;stroke-miterlimit:4;" 
          d="M 21.998437 12 C 21.998437 12 18.998437 18 12 18 
             C 5.001562 18 2.001562 12 2.001562 12 
             C 2.001562 12 5.001562 6 12 6 
             C 18.998437 6 21.998437 12 21.998437 12 Z" />
    <path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:#FFF;stroke-opacity:1;stroke-miterlimit:4;" 
          d="M 15 12 
             C 15 13.654687 13.654687 15 12 15 
             C 10.345312 15 9 13.654687 9 12 
             C 9 10.345312 10.345312 9 12 9 
             C 13.654687 9 15 10.345312 15 12 Z" />
</svg>
`;
    const closedEye = `
<svg xmlns="http://www.w3.org/2000/svg" width="22" height="16" viewBox="0 0 24 24">
 <path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:#FFF;stroke-opacity:1;stroke-miterlimit:4;" 
          d="M 3 3 L 21 21" />
    <path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:#FFF;stroke-opacity:1;stroke-miterlimit:4;" 
          d="M 21.998437 12 
             C 21.998437 12 18.998437 18 12 18 
             C 5.001562 18 2.001562 12 2.001562 12 
             C 2.001562 12 5.001562 6 12 6 
             C 14.211 6 16.106 6.897 17.7 8.1" />
    <path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:#FFF;stroke-opacity:1;stroke-miterlimit:4;" 
          d="M 9.9 9.9 
             C 9.367 10.434 9 11.178 9 12 
             C 9 13.654687 10.345312 15 12 15 
             C 12.822 15 13.566 14.633 14.1 14.1" />
</svg>
`;

    // legend-menu.ts
    class LegendMenu {
        contextMenu;
        handler; // Replace with your actual Handler type
        constructor(options) {
            this.contextMenu = options.contextMenu;
            this.handler = options.handler;
        }
        /**
         * Populates the context menu with options specific to a legend item (series or group).
         * @param legendItem The LegendSeries or LegendGroup item that was right-clicked.
         * @param event The MouseEvent triggering the context menu.
         */
        populateLegendMenu(legendItem, event) {
            // Clear existing menu items
            this.contextMenu.clearMenu();
            // Determine if the legendItem is a series or a group
            const isGroup = (item) => {
                return item.seriesList !== undefined;
            };
            if (isGroup(legendItem)) {
                // Populate menu for a LegendGroup
                this.populateGroupMenu(legendItem, event);
            }
            else {
                // Populate menu for a LegendSeries
                this.populateSeriesMenu(legendItem, event);
            }
            // Optionally, add a "Close Menu" option
            this.contextMenu.separator();
            this.contextMenu.addMenuItem("Close Menu", () => this.contextMenu.hideMenu());
            // Position and display the menu
            this.contextMenu.showMenu(event);
        }
        populateGroupMenu(group, event) {
            // Add Group-Specific Options
            this.contextMenu.addMenuItem("Rename", () => {
                const newName = prompt("Enter new group name:", group.name);
                if (newName && newName.trim() !== "") {
                    this.renameGroup(group, newName.trim());
                }
            }, false);
            this.contextMenu.addMenuItem("Remove", () => {
                if (confirm(`Are you sure you want to remove the group "${group.name}"? This will also remove all contained series.`)) {
                    group.seriesList.forEach((seriesItem) => {
                        this.handler.legend.removeLegendSeries(seriesItem.series);
                        this.handler.removeSeries(seriesItem.series);
                    });
                    // Remove the group after all series have been removed
                    this.removeGroup(group);
                }
            });
            this.contextMenu.addMenuItem("Ungroup", () => {
                this.ungroupSeries(group);
            });
            // Add Hybrid Input for moving all series within the group to another pane.
            if (group.seriesList && group.seriesList.length > 0) {
                // Use the first series as reference to get the current pane index.
                const firstSeries = group.seriesList[0].series;
                const currentPaneIndex = firstSeries.getPane().paneIndex();
                const panes = this.handler.chart.panes();
                const currentValue = `Pane ${currentPaneIndex}`;
                // Define the default action:
                // If the series is in the main pane (pane 0), move all to pane 1 (if available) or to a new pane.
                // Otherwise, move them back to the main pane (pane 0).
                const defaultAction = () => {
                    if (currentPaneIndex === 0) {
                        if (panes.length > 1) {
                            group.seriesList.forEach((seriesItem) => {
                                seriesItem.series.moveToPane(1);
                            });
                            console.log(`Default: Moved group "${group.name}" series from pane ${currentPaneIndex} to pane 1.`);
                        }
                        else {
                            group.seriesList.forEach((seriesItem) => {
                                seriesItem.series.moveToPane(panes.length); // creates a new pane
                            });
                            console.log(`Default: Moved group "${group.name}" series from pane ${currentPaneIndex} to a new pane at index ${panes.length}.`);
                        }
                    }
                    else {
                        group.seriesList.forEach((seriesItem) => {
                            seriesItem.series.moveToPane(0);
                        });
                        console.log(`Default: Moved group "${group.name}" series from pane ${currentPaneIndex} back to main pane (0).`);
                    }
                };
                const options = [];
                for (let i = 0; i < panes.length; i++) {
                    options.push({
                        name: `Pane ${i}`,
                        action: () => {
                            group.seriesList.forEach((seriesItem) => {
                                seriesItem.series.moveToPane(i);
                            });
                            console.log(`Moved group "${group.name}" series to existing pane ${i}.`);
                        }
                    });
                }
                options.push({
                    name: "New Pane",
                    action: () => {
                        group.seriesList.forEach((seriesItem) => {
                            seriesItem.series.moveToPane(panes.length);
                        });
                        console.log(`Moved group "${group.name}" series to a new pane at index ${panes.length}.`);
                    }
                });
                // Create the hybrid input using the contextMenu's addMenuInput helper.
                // Make sure to pass the parent element (this.div) and the configuration object.
                this.contextMenu.addMenuInput(this.contextMenu.div, // Parent HTMLElement. Replace this.div with your actual container if needed.
                {
                    type: "hybrid",
                    label: "Move to",
                    sublabel: currentValue,
                    value: currentValue,
                    onChange: (newValue) => {
                        // When the user selects an option, look it up in the options array and execute its action.
                        const selectedOption = options.find(opt => opt.name === newValue);
                        if (selectedOption) {
                            selectedOption.action();
                        }
                    },
                    hybridConfig: {
                        defaultAction: defaultAction,
                        options: options.map(opt => ({
                            name: opt.name,
                            action: opt.action
                        }))
                    }
                });
            }
            // Optionally, add a "Close Menu" option.
            this.contextMenu.separator();
            this.contextMenu.addMenuItem("Close Menu", () => this.contextMenu.hideMenu());
            // Position and display the menu at the event location.
            this.contextMenu.showMenu(event);
        }
        /**
         * Populates the context menu for a LegendSeries.
         * @param seriesItem The LegendSeries to populate the menu for.
         */
        populateSeriesMenu(seriesItem, event) {
            // Add Series-Specific Options
            this.contextMenu.addMenuItem("Open Series Menu", () => {
                // Assuming you have a method to open a detailed series menu
                this.contextMenu.populateSeriesMenu(seriesItem.series, event);
            }, false);
            this.contextMenu.addMenuItem("Move to Group ▸", () => {
                this.populateMoveToGroupMenu(seriesItem);
            }, false);
            this.contextMenu.addMenuItem("Remove Series", () => {
                if (confirm(`Are you sure you want to remove the series "${seriesItem.name}"?`)) {
                    this.handler.legend.removeLegendSeries(seriesItem.series);
                    this.handler.removeSeries(seriesItem.series);
                }
            });
            if (seriesItem.primitives) {
                this.contextMenu.addMenuItem("Remove Primitives", () => {
                    this.removePrimitivesFromSeries(seriesItem);
                });
            }
            if (seriesItem.group) {
                this.contextMenu.addMenuItem("Ungroup", () => {
                    this.ungroupSeriesFromGroup(seriesItem);
                });
            }
            this.contextMenu.showMenu(event);
        }
        /**
         * Populates the "Move to Group" submenu.
         * @param seriesItem The LegendSeries to move.
         */
        populateMoveToGroupMenu(seriesItem) {
            // Clear existing menu items
            this.contextMenu.clearMenu();
            // List existing groups
            const existingGroups = this.handler.legend._groups;
            existingGroups.forEach((group) => {
                this.contextMenu.addMenuItem(group.name, () => {
                    this.handler.legend.moveSeriesToGroup(seriesItem, group);
                });
            });
            // Option to create a new group
            this.contextMenu.addMenuItem("Create New Group...", () => {
                const newGroupName = prompt("Enter new group name:", "New Group");
                if (newGroupName && newGroupName.trim() !== "") {
                    this.createNewGroup(seriesItem, newGroupName.trim());
                }
            });
            if (seriesItem.group) {
                this.contextMenu.addMenuItem("Ungroup", () => {
                    this.ungroupSeriesFromGroup(seriesItem);
                });
            }
        }
        /**
         * Renames a LegendGroup.
         * @param group The LegendGroup to rename.
         * @param newName The new name for the group.
         */
        renameGroup(group, newName) {
            // Update the group's name in the data structure
            group.name = newName;
            group.seriesList.forEach(seriesItem => {
                seriesItem.group = newName;
            });
            // Update the DOM element displaying the group name
            const groupHeader = group.row.querySelector('.group-header span');
            if (groupHeader) {
                groupHeader.textContent = newName;
            }
            console.log(`Group renamed to: ${newName}`);
        }
        /**
         * Removes a LegendGroup and all its contained series.
         * @param group The LegendGroup to remove.
         */
        removeGroup(group) {
            this.handler.legend.removeLegendGroup(group);
            // Remove the group from the internal groups array
            this.handler.legend._groups = this.handler.legend._groups.filter((g) => g !== group);
            console.log(`Group "${group.name}" removed along with its series.`);
        }
        /**
         * Creates a new group and moves the series into it.
         * @param seriesItem The LegendSeries to move.
         * @param newGroupName The name of the new group.
         */
        createNewGroup(seriesItem, newGroupName) {
            this.handler.legend.deleteLegendEntry(seriesItem);
            seriesItem.group = newGroupName;
            this.handler.legend.addLegendItem(seriesItem);
        }
        /**
         * Removes a LegendSeries from its group, making it standalone.
         * @param seriesItem The LegendSeries to ungroup.
         */
        ungroupSeriesFromGroup(seriesItem) {
            const currentGroupName = this.handler.legend.getGroupOfSeries(seriesItem.series);
            if (currentGroupName) {
                this.handler.legend.deleteLegendEntry(seriesItem);
                seriesItem.group = undefined;
                this.handler.legend.addLegendItem(seriesItem);
            }
            console.log(`Series "${seriesItem.name}" removed from its group and is now standalone.`);
        }
        /**
         * Removes all primitives associated with a LegendSeries.
         * @param seriesItem The LegendSeries to remove primitives from.
         */
        removePrimitivesFromSeries(seriesItem) {
            if (seriesItem.series.primitives) {
                Object.values(seriesItem.series.primitives).forEach(primitive => {
                    seriesItem.series.detachPrimitive(primitive); // Assuming a remove method exists
                    console.log(`Primitive removed from series "${seriesItem.name}".`);
                });
                seriesItem.primitives = undefined; // Reset primitives
            }
            console.log(`All primitives removed from series "${seriesItem.name}".`);
        }
        /**
         * Ungroups all series within a LegendGroup, making them standalone.
         * @param group The LegendGroup to ungroup.
         */
        ungroupSeries(group) {
            group.seriesList.forEach(seriesItem => {
                this.handler.legend.deleteLegendEntry(seriesItem);
                seriesItem.group = undefined;
                this.handler.legend.addLegendItem(seriesItem);
                // Add to the main legend container as standalone
            });
            // Remove the group
            this.removeGroup(group);
            console.log(`All series in group "${group.name}" have been ungrouped and are now standalone.`);
        }
    }

    function getLastData(series) {
        return series.data()[series.data().length - 1];
    }
    class Legend {
        handler;
        div;
        seriesContainer;
        legendMenu;
        ohlcEnabled = false;
        percentEnabled = false;
        linesEnabled = false;
        colorBasedOnCandle = false;
        contextMenu;
        text;
        _items = [];
        _lines = [];
        _groups = [];
        constructor(handler) {
            this.handler = handler;
            this.div = document.createElement('div');
            this.div.classList.add("legend");
            this.seriesContainer = document.createElement("div");
            this.text = document.createElement('span');
            this.contextMenu = this.handler.ContextMenu;
            // Initialize LegendMenu
            this.legendMenu = new LegendMenu({
                contextMenu: this.contextMenu,
                handler: handler
            });
            this.setupLegend();
            this.legendHandler = this.legendHandler.bind(this);
            handler.chart.subscribeCrosshairMove(this.legendHandler);
        }
        setupLegend() {
            this.div.style.maxWidth = `${(this.handler.scale.width * 100) - 8}vw`;
            this.div.style.display = 'none';
            const seriesWrapper = document.createElement('div');
            seriesWrapper.style.display = 'flex';
            seriesWrapper.style.flexDirection = 'row';
            this.seriesContainer.classList.add("series-container");
            this.text.style.lineHeight = '1.8';
            seriesWrapper.appendChild(this.seriesContainer);
            this.div.appendChild(this.text);
            this.div.appendChild(seriesWrapper);
            this.handler.div.appendChild(this.div);
        }
        legendItemFormat(num, decimal) {
            if (typeof num !== 'number' || isNaN(num)) {
                return '-'; // Default display when data is missing
            }
            return num.toFixed(decimal).toString().padStart(8, ' ');
        }
        shorthandFormat(num) {
            const absNum = Math.abs(num);
            return absNum >= 1000000 ? (num / 1000000).toFixed(1) + 'M' :
                absNum >= 1000 ? (num / 1000).toFixed(1) + 'K' :
                    num.toString().padStart(8, ' ');
        }
        createSvgIcon(svgContent) {
            const tempContainer = document.createElement('div');
            tempContainer.innerHTML = svgContent.trim();
            const svgElement = tempContainer.querySelector('svg');
            return svgElement;
        }
        /**
         * Adds a LegendItem to the legend, either as a standalone series or within a group.
         * @param item The LegendItem to add.
         * @returns The HTMLDivElement representing the legend entry.
         */
        addLegendItem(item) {
            // Ensure `item` is a series and map it to the `LegendSeries` type
            const seriesItem = this.mapToSeries(item);
            if (seriesItem.group) {
                // If the series belongs to a group, add it to the group
                return this.addItemToGroup(seriesItem, seriesItem.group);
            }
            else {
                // If standalone, create a series row and add it to the container
                const seriesRow = this.makeSeriesRow(seriesItem, this.seriesContainer);
                // Add the series to `_lines` for tracking
                this._lines.push(seriesItem);
                // Add to `_items` for general legend tracking
                this._items.push(seriesItem);
                return seriesRow;
            }
        }
        addLegendPrimitive(series, primitive, name) {
            const primitiveName = name || primitive.constructor.name;
            // Check if the parent series row exists
            const seriesEntry = this._lines.find(line => line.series === series);
            if (!seriesEntry) {
                console.warn(`Parent series not found in legend for primitive: ${primitiveName}`);
                return;
            }
            // Ensure the seriesEntry has a `primitives` array
            if (!seriesEntry.primitives) {
                seriesEntry.primitives = [];
            }
            // Ensure the primitives container exists
            let primitivesContainer = this.seriesContainer.querySelector(`[data-series-id="${seriesEntry.name}"] .primitives-container`);
            if (!primitivesContainer) {
                primitivesContainer = document.createElement('div');
                primitivesContainer.classList.add('primitives-container');
                primitivesContainer.style.display = 'none';
                primitivesContainer.style.marginLeft = '20px';
                primitivesContainer.style.flexDirection = 'column';
                // Insert the container below the series row
                seriesEntry.row.insertAdjacentElement('afterend', primitivesContainer);
            }
            // Check if the primitive already exists in the legend
            const existingPrimitiveRow = Array.from(primitivesContainer.children).find(row => row.getAttribute('data-primitive-type') === primitiveName);
            if (existingPrimitiveRow) {
                console.warn(`Primitive "${primitiveName}" already exists under the parent series.`);
                return existingPrimitiveRow;
            }
            // Create a new row for the primitive
            const primitiveRow = document.createElement('div');
            primitiveRow.classList.add('legend-primitive-row');
            primitiveRow.setAttribute('data-primitive-type', primitiveName);
            primitiveRow.style.display = 'flex';
            primitiveRow.style.justifyContent = 'space-between';
            primitiveRow.style.marginTop = '4px';
            const primitiveLabel = document.createElement('span');
            primitiveLabel.innerText = primitiveName;
            // Add a visibility toggle for the primitive
            const toggle = document.createElement('div');
            toggle.style.cursor = 'pointer';
            toggle.style.display = 'flex';
            toggle.style.alignItems = 'center';
            const onIcon = this.createSvgIcon(openEye);
            const offIcon = this.createSvgIcon(closedEye);
            toggle.appendChild(onIcon.cloneNode(true)); // Start with visible icon
            let visible = true;
            toggle.addEventListener('click', () => {
                visible = !visible;
                toggle.innerHTML = ''; // Clear existing content
                toggle.appendChild(visible ? onIcon.cloneNode(true) : offIcon.cloneNode(true));
                this.togglePrimitive(primitive, visible);
            });
            // Append elements to the primitive row
            primitiveRow.appendChild(primitiveLabel);
            primitiveRow.appendChild(toggle);
            primitivesContainer.appendChild(primitiveRow);
            // Ensure the primitives container is visible
            if (primitivesContainer.children.length > 0) {
                primitivesContainer.style.display = 'block';
            }
            // ✅ Store the primitive in `_items`
            const legendPrimitive = {
                name: primitiveName,
                primitive,
                row: primitiveRow
            };
            this._items.push(legendPrimitive);
            seriesEntry.primitives.push(legendPrimitive); // Track it in the series
            return primitiveRow;
        }
        togglePrimitive(primitive, visible) {
            // Check for options in either "options" or "_options"
            const options = primitive.options || primitive._options;
            if (!options) {
                console.warn("Primitive has no options to update.");
                return;
            }
            const updatedOptions = {};
            // Check if the primitive explicitly exposes a "visible" option.
            if ("visible" in options) {
                updatedOptions["visible"] = visible;
                console.log(`Toggling visible option for primitive: ${primitive.constructor.name} to ${visible}`);
                primitive.applyOptions(updatedOptions);
                // Return early since we have applied the simple visible toggle.
                return;
            }
            // Fallback: using color transparency for toggling visibility.
            const transparentColor = "rgba(0,0,0,0)";
            const originalColorsKey = "_originalColors";
            // Initialize storage for original colors if it doesn't exist,
            // checking again on both possible properties.
            if (!primitive[originalColorsKey]) {
                primitive[originalColorsKey] = {};
            }
            const originalColors = primitive[originalColorsKey];
            for (const key of Object.keys(options)) {
                if (key.toLowerCase().includes("color")) {
                    if (!visible) {
                        // Store the original color if we're toggling visibility off.
                        if (!originalColors[key]) {
                            originalColors[key] = options[key];
                        }
                        updatedOptions[key] = transparentColor;
                    }
                    else {
                        // Restore the original color if we're toggling visibility on.
                        updatedOptions[key] = originalColors[key] || options[key];
                    }
                }
            }
            // Apply the updated options if any changes exist.
            if (Object.keys(updatedOptions).length > 0) {
                console.log(`Updating visibility for primitive: ${primitive.constructor.name}`);
                primitive.applyOptions(updatedOptions);
                // Clear the original colors when visibility is restored.
                if (visible) {
                    delete primitive[originalColorsKey];
                }
            }
        }
        findLegendPrimitive(series, primitive) {
            // Find the parent series
            const seriesEntry = this._lines.find(line => line.series === series);
            if (!seriesEntry || !seriesEntry.primitives) {
                return null; // No associated series or no primitives exist
            }
            // Locate the exact primitive inside the series' `primitives` array
            const legendPrimitive = seriesEntry.primitives.find((p) => p.primitive === primitive);
            return legendPrimitive || null;
        }
        /**
        * Converts a LegendItem into a LegendSeries.
        * @param item The LegendItem to map.
        * @returns The mapped LegendSeries object.
        */
        mapToSeries(item) {
            return {
                name: item.name,
                series: item.series,
                group: item.group || undefined,
                legendSymbol: item.legendSymbol || [],
                colors: item.colors || ['#000'],
                seriesType: item.seriesType || 'Line',
                div: document.createElement('div'), // Default element
                row: document.createElement('div'), // Default element
                toggle: document.createElement('div'), // Default element
                extraData: item.extraData || null
            };
        }
        /**
         * Adds a LegendItem to a specified group, creating the group if it doesn't exist.
         * @param item The LegendItem to add.
         * @param groupName The name of the group to add the item to.
         * @returns The HTMLDivElement representing the group's row.
        */
        addItemToGroup(item, groupName) {
            let group = this._groups.find(g => g.name === groupName);
            if (!group) {
                // Create the group and append the series row to the group's container
                return this.makeSeriesGroup(groupName, [item]);
            }
            else {
                group.seriesList.push(item);
                // Create and append the new series row to the group's container
                this.makeSeriesRow(item, group.div);
                return group.row;
            }
        }
        /**
         * Creates a group in the legend with the provided items.
         * @param groupName The name of the group.
         * @param items The LegendItems to include in the group.
         * @returns The HTMLDivElement representing the group's row.
         */
        makeSeriesGroup(groupName, items) {
            let group = this._groups.find(g => g.name === groupName);
            if (group) {
                group.seriesList.push(...items);
                // Append new series to the existing group div
                items.forEach(item => this.makeSeriesRow(item, group.div));
                return group.row;
            }
            else {
                const newGroup = {
                    name: groupName,
                    seriesList: items,
                    subGroups: [],
                    div: document.createElement('div'),
                    row: document.createElement('div'),
                    toggle: document.createElement('div'),
                };
                this._groups.push(newGroup);
                this.renderGroup(newGroup, this.seriesContainer);
                return newGroup.row;
            }
        }
        // legend.ts
        makeSeriesRow(line, container) {
            const row = document.createElement('div');
            row.classList.add('legend-series-row'); // Add CSS class for styling
            // Use flexbox for layout
            row.style.display = 'flex';
            row.style.alignItems = 'center'; // Vertically center items
            row.style.justifyContent = 'space-between'; // Add space between items
            row.style.marginBottom = '4px'; // Optional spacing between rows
            // **Create Action Button for Series**
            const actionButton = document.createElement('button');
            actionButton.classList.add('legend-action-button');
            actionButton.innerHTML = '◇'; // Default Icon
            actionButton.title = 'Series Actions'; // Tooltip for accessibility
            actionButton.style.marginRight = '0px'; // Space between button and info
            actionButton.style.fontSize = '1em'; // Adjust size as needed
            actionButton.style.border = 'none'; // Remove default border
            actionButton.style.background = 'none'; // Remove default background
            actionButton.style.cursor = 'pointer'; // Indicate it's clickable
            // **Set Action Button Color to Match Series Color**
            line.colors[0] || '#000'; // Default to black if no color specified
            actionButton.style.color = '#ffffff';
            // **Attach Click Listener to Action Button**
            actionButton.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent triggering row click events
                event.preventDefault(); // Prevent default button behavior
                // **Toggle Icon Between ◇ and ◈**
                if (actionButton.innerHTML === '◇') {
                    actionButton.innerHTML = '◈'; // Menu is open
                }
                else {
                    actionButton.innerHTML = '◇'; // Menu is closed
                }
                // **Populate and Show LegendMenu**
                this.legendMenu.populateLegendMenu(line, event);
            });
            // **Create Series Info Div**
            const div = document.createElement('div');
            div.classList.add('series-info'); // Add CSS class for styling
            div.style.flex = '1'; // Allow the text to take up available space
            const displayOCvalues = ['Bar', 'Candlestick', 'Ohlc'].includes(line.seriesType || '');
            if (displayOCvalues) {
                const openPrice = '-';
                const closePrice = '-';
                const upSymbol = line.legendSymbol[0] || '▨';
                const downSymbol = line.legendSymbol[1] || upSymbol;
                const upColor = line.colors[0] || '#00FF00';
                const downColor = line.colors[1] || '#FF0000';
                div.innerHTML = `
            <span style="color: ${upColor};">${upSymbol}</span>
            <span style="color: ${downColor};">${downSymbol}</span>
            ${line.name}: <span style="color: ${downColor};">O ${openPrice}</span>, 
            <span style="color: ${upColor};">C ${closePrice}</span>
        `;
            }
            else {
                div.innerHTML = line.legendSymbol
                    .map((symbol, index) => `<span style="color: ${line.colors[index] || line.colors[0]};">${symbol}</span>`)
                    .join(' ') + ` ${line.name}`;
            }
            // **Toggle Visibility Icon**
            const toggle = document.createElement('div');
            toggle.classList.add('legend-toggle-switch');
            toggle.style.cursor = 'pointer'; // Indicate that this is clickable
            // Use flex styling to keep the toggle inline
            toggle.style.display = 'flex';
            toggle.style.alignItems = 'center';
            const onIcon = this.createSvgIcon(openEye);
            const offIcon = this.createSvgIcon(closedEye);
            toggle.appendChild(onIcon.cloneNode(true));
            let visible = true;
            // Add click listener for toggling visibility
            toggle.addEventListener('click', (event) => {
                visible = !visible;
                line.series.applyOptions({ visible });
                toggle.innerHTML = '';
                toggle.appendChild(visible ? onIcon.cloneNode(true) : offIcon.cloneNode(true));
                // Update ARIA attribute
                toggle.setAttribute('aria-pressed', visible.toString());
                // Update toggle state class
                toggle.classList.toggle('inactive', !visible);
                event.stopPropagation();
            });
            // Set initial ARIA attributes
            toggle.setAttribute('role', 'button');
            toggle.setAttribute('aria-label', `Toggle visibility for ${line.name}`);
            toggle.setAttribute('aria-pressed', visible.toString());
            // **Append Elements to the Row**
            row.appendChild(actionButton); // Add Action Button
            row.appendChild(div); // Add text/info div
            row.appendChild(toggle); // Add visibility toggle
            container.appendChild(row); // Append to the provided container
            // **Attach the contextmenu (right-click) listener**
            row.addEventListener("contextmenu", (event) => {
                event.preventDefault(); // Prevent the default browser context menu
                this.legendMenu.populateLegendMenu(line, event); // Populate and show the legend menu
            });
            // Create LegendSeries and store it
            const legendSeries = {
                ...line,
                div, // Assign the created div
                row, // Assign the created row
                toggle, // Assign the created toggle
            };
            this._lines.push(legendSeries);
            this._items.push(legendSeries);
            return row;
        }
        /** Type guard to detect a LegendGroup. */
        isLegendGroup(entry) {
            return entry.seriesList !== undefined;
        }
        /** Type guard to detect a LegendSeries. */
        isLegendSeries(entry) {
            return entry.series !== undefined
                || entry.primitives !== undefined;
        }
        /** Type guard to detect a LegendPrimitive. */
        isLegendPrimitive(entry) {
            return entry.primitive !== undefined
                && entry.row !== undefined;
        }
        /**
     * Deletes a legend entry, either a standalone series or an entire group.
     * @param seriesName The name of the series to delete.
     * @param groupName The name of the group to delete or from which to delete the series.
     */
        deleteLegendEntry(seriesName, groupName) {
            if (groupName && !seriesName) {
                // Remove entire group
                const groupIndex = this._groups.findIndex(group => group.name === groupName);
                if (groupIndex !== -1) {
                    const legendGroup = this._groups[groupIndex];
                    // Remove the group's DOM elements
                    this.seriesContainer.removeChild(legendGroup.row);
                    // Optionally, remove all series in the group from the chart
                    // legendGroup.seriesList.forEach(item => item.series.remove());
                    // Remove from the _groups array
                    this._groups.splice(groupIndex, 1);
                    // Also remove from _items array
                    this._items = this._items.filter(entry => entry !== legendGroup);
                    console.log(`Group "${groupName}" removed.`);
                }
                else {
                    console.warn(`Legend group with name "${groupName}" not found.`);
                }
            }
            else if (seriesName) {
                // Remove individual series
                let removed = false;
                if (groupName) {
                    // Remove from specific group
                    const group = this._groups.find(g => g.name === groupName);
                    if (group) {
                        const itemIndex = group.seriesList.findIndex(item => item.name === seriesName);
                        if (itemIndex !== -1) {
                            // Remove from the group's seriesList
                            group.seriesList.splice(itemIndex, 1);
                            // If the group is now empty, remove it
                            if (group.seriesList.length === 0) {
                                this.seriesContainer.removeChild(group.row);
                                this._groups = this._groups.filter(g => g !== group);
                                this._items = this._items.filter(entry => entry !== group);
                                console.log(`Group "${groupName}" is empty and has been removed.`);
                            }
                            else {
                                // Re-render the group to update its display
                                this.renderGroup(group, this.seriesContainer);
                            }
                            // Optionally, remove the series from the chart
                            // seriesItem.series.remove();
                            removed = true;
                            console.log(`Series "${seriesName}" removed from group "${groupName}".`);
                        }
                    }
                    else {
                        console.warn(`Legend group with name "${groupName}" not found.`);
                    }
                }
                if (!removed) {
                    // Remove from _lines (individual legend items)
                    const seriesIndex = this._lines.findIndex(series => series.name === seriesName);
                    if (seriesIndex !== -1) {
                        const legendSeries = this._lines[seriesIndex];
                        // Remove the DOM elements
                        this.seriesContainer.removeChild(legendSeries.row);
                        // Remove from the _lines array
                        this._lines.splice(seriesIndex, 1);
                        // Also remove from _items array
                        this._items = this._items.filter(entry => entry !== legendSeries);
                        // Optionally, remove the series from the chart
                        // legendSeries.series.remove();
                        removed = true;
                        console.log(`Series "${seriesName}" removed.`);
                    }
                }
                if (!removed) {
                    console.warn(`Legend item with name "${seriesName}" not found.`);
                }
            }
            else {
                console.warn(`No seriesName or groupName provided for deletion.`);
            }
        }
        /** Removes an entire LegendGroup from the legend. */
        removeLegendGroup(group) {
            // Remove from DOM
            if (this.seriesContainer.contains(group.row)) {
                this.seriesContainer.removeChild(group.row);
            }
            // Remove from _groups
            const gIndex = this._groups.indexOf(group);
            if (gIndex !== -1) {
                this._groups.splice(gIndex, 1);
            }
            // Also remove from _items if needed
            this._items = this._items.filter(item => item !== group);
            // Potentially remove each series from the group if you want
            // group.seriesList.forEach( series => { ... } );
            console.log(`Group "${group.name}" removed from legend.`);
        }
        // Helper method to search all possible locations for a series
        findSeriesAnywhere(series) {
            // Check standalone series first
            const standalone = this._lines.find(s => s.series === series);
            if (standalone)
                return standalone;
            // Search through all groups and subgroups
            for (const group of this._groups) {
                const found = this.findSeriesInGroup(group, series);
                if (found)
                    return found;
            }
            return undefined;
        }
        findSeriesInGroup(group, series) {
            // Check current group's series
            const inCurrentGroup = group.seriesList.find(s => s.series === series);
            if (inCurrentGroup)
                return inCurrentGroup;
            // Recursively check subgroups
            for (const subgroup of group.subGroups) {
                const found = this.findSeriesInGroup(subgroup, series);
                if (found)
                    return found;
            }
            return undefined;
        }
        removeSeriesFromGroupDOM(group, series) {
            if (!group.div || !series.row) {
                console.warn(`⚠️ Cannot remove series "${series.name}" – missing group div or series row.`);
                return false;
            }
            // 🚀 1️⃣ Check if the series exists inside the group div
            if (group.div.contains(series.row)) {
                try {
                    group.div.removeChild(series.row);
                    console.log(`✅ Removed series "${series.name}" from group "${group.name}".`);
                    return true; // Successfully removed from this group
                }
                catch (error) {
                    console.warn(`⚠️ Error removing series "${series.name}" from group "${group.name}":`, error);
                    return false;
                }
            }
            // 🚀 2️⃣ Recursively check subgroups
            return group.subGroups.some(subgroup => this.removeSeriesFromGroupDOM(subgroup, series));
        }
        removeLegendSeries(seriesOrLegend) {
            let legendSeries;
            // 🚀 1️⃣ Identify if it's an ISeriesApi or LegendSeries
            if (!isISeriesApi(seriesOrLegend)) {
                legendSeries = seriesOrLegend;
            }
            else {
                legendSeries = this.findSeriesAnywhere(seriesOrLegend);
            }
            if (!legendSeries) {
                console.warn("⚠️ LegendSeries not found in legend.");
                return;
            }
            // 🚀 2️⃣ Remove from tracking arrays
            this._lines = this._lines.filter(s => s !== legendSeries);
            this._items = this._items.filter(item => item !== legendSeries);
            // 🚀 3️⃣ Handle removal from a group OR standalone series
            if (legendSeries.group) {
                const group = this.findGroup(legendSeries.group);
                if (group) {
                    // 🔥 Remove from the group's series list
                    group.seriesList = group.seriesList.filter(item => item !== legendSeries);
                    // ✅ Remove from group's `div` container in the DOM
                    if (legendSeries.row && group.div.contains(legendSeries.row)) {
                        try {
                            group.div.removeChild(legendSeries.row);
                            console.log(`✅ Removed "${legendSeries.name}" from group "${group.name}".`);
                        }
                        catch (error) {
                            console.warn(`⚠️ Error removing "${legendSeries.name}" from group "${group.name}":`, error);
                        }
                    }
                    // ✅ If the group is now empty, remove it
                    if (group.seriesList.length === 0) {
                        this.removeGroupCompletely(group);
                    }
                }
            }
            else {
                // 🚀 4️⃣ Remove Standalone Series from DOM
                if (legendSeries.row?.parentElement) {
                    try {
                        legendSeries.row.parentElement.removeChild(legendSeries.row);
                        console.log(`✅ Removed row for standalone series: ${legendSeries.name}`);
                    }
                    catch (error) {
                        console.warn(`⚠️ Error removing standalone series row:`, error);
                    }
                }
            }
        }
        removeGroupCompletely(group) {
            // Remove group from DOM only if it exists
            if (group.row.parentElement) {
                try {
                    group.row.parentElement.removeChild(group.row);
                }
                catch (error) {
                    console.warn(`Error removing group "${group.name}":`, error);
                }
            }
            // Clean up tracking arrays
            this._groups = this._groups.filter(g => g !== group);
            this._items = this._items.filter(item => item !== group);
            console.log(`Group "${group.name}" removed as it became empty.`);
        }
        removeLegendPrimitive(primitiveOrLegend) {
            let legendPrimitive;
            if (this.isLegendPrimitive(primitiveOrLegend)) {
                // Case 1: It's already a LegendPrimitive
                legendPrimitive = primitiveOrLegend;
            }
            else {
                // Case 2: It's an ISeriesPrimitive, find its corresponding LegendPrimitive
                legendPrimitive = this._items.find((item) => this.isLegendPrimitive(item) && item.primitive === primitiveOrLegend);
            }
            if (!legendPrimitive) {
                console.warn("❌ LegendPrimitive not found in legend.");
                return;
            }
            // ✅ Ensure the row exists before trying to remove it
            if (legendPrimitive.row && legendPrimitive.row.parentElement) {
                legendPrimitive.row.parentElement.removeChild(legendPrimitive.row);
            }
            else {
                console.warn("❌ LegendPrimitive row not found in the DOM.");
            }
            // ✅ Remove primitive from parent series if applicable
            const parentSeries = this._lines.find(s => s.primitives?.includes(legendPrimitive));
            if (parentSeries) {
                parentSeries.primitives = parentSeries.primitives.filter(p => p !== legendPrimitive);
                console.log(`✅ Removed primitive "${legendPrimitive.name}" from series "${parentSeries.name}".`);
            }
            // ✅ Remove from _items
            this._items = this._items.filter(item => item !== legendPrimitive);
            // ✅ Ensure the underlying chart primitive is detached
            if (legendPrimitive.primitive) {
                try {
                    console.log(`Detaching underlying chart primitive for "${legendPrimitive.name}".`);
                    parentSeries?.series.detachPrimitive(legendPrimitive.primitive);
                }
                catch (error) {
                    console.warn(`⚠️ Failed to detach primitive "${legendPrimitive.name}":`, error);
                }
            }
            console.log(`✅ LegendPrimitive "${legendPrimitive.name}" removed from legend.`);
        }
        /**
         * Retrieves the group name of a given series.
         * @param series The series to find the group for.
         * @returns The name of the group, or undefined if not found.
         */
        getGroupOfSeries(series) {
            for (const group of this._groups) {
                const foundGroupName = this.findGroupOfSeriesRecursive(group, series);
                if (foundGroupName) {
                    return foundGroupName;
                }
            }
            return undefined;
        }
        /**
         * Recursively searches for the group containing the target series.
         * @param group The current group to search within.
         * @param targetSeries The series to find.
         * @returns The group name if found, otherwise undefined.
         */
        findGroupOfSeriesRecursive(group, targetSeries) {
            for (const item of group.seriesList) {
                if (item.series === targetSeries) {
                    return group.name;
                }
            }
            for (const subGroup of group.subGroups) {
                const found = this.findGroupOfSeriesRecursive(subGroup, targetSeries);
                if (found) {
                    return found;
                }
            }
            return undefined;
        }
        /**
         * Moves a series from its current group (or standalone) to a target group.
         * If the series is already in a group, it will be moved from its current group to the new one.
         * If the series is standalone, its row is removed from the main container.
         * @param seriesName The name of the series to move.
         * @param targetGroupName The name of the group to move the series into.
         */
        moveSeriesToGroup(seriesName, targetGroupName) {
            // Find the series in _lines (standalone)
            let foundSeriesIndex = this._lines.findIndex(s => s.name === seriesName);
            let foundSeries = null;
            if (foundSeriesIndex !== -1) {
                foundSeries = this._lines[foundSeriesIndex];
            }
            else {
                // If not found in _lines, search within groups
                for (const group of this._groups) {
                    const idx = group.seriesList.findIndex(item => item.name === seriesName);
                    if (idx !== -1) {
                        foundSeries = group.seriesList[idx];
                        // Remove from current group
                        group.seriesList.splice(idx, 1);
                        // If group becomes empty, remove it
                        if (group.seriesList.length === 0) {
                            this.seriesContainer.removeChild(group.row);
                            this._groups = this._groups.filter(g => g !== group);
                            this._items = this._items.filter(entry => entry !== group);
                            console.log(`Group "${group.name}" is empty and has been removed.`);
                        }
                        else {
                            // Re-render the group to update its display
                            this.renderGroup(group, this.seriesContainer);
                        }
                        break;
                    }
                }
            }
            if (!foundSeries) {
                console.warn(`Series "${seriesName}" not found in legend.`);
                return;
            }
            // If found in _lines, remove it from there
            if (foundSeriesIndex !== -1) {
                // Remove from DOM
                this.seriesContainer.removeChild(foundSeries.row);
                this._lines.splice(foundSeriesIndex, 1);
                this._items = this._items.filter(entry => entry !== foundSeries);
            }
            else {
                // If found in a group, its removal was handled above
                this._items = this._items.filter(entry => entry !== foundSeries);
            }
            // Now add to the target group
            let targetGroup = this.findGroup(targetGroupName);
            if (!targetGroup) {
                // Create the target group if it doesn't exist
                targetGroup = {
                    name: targetGroupName,
                    seriesList: [foundSeries],
                    subGroups: [],
                    div: document.createElement('div'),
                    row: document.createElement('div'),
                    toggle: document.createElement('div'),
                };
                this._groups.push(targetGroup);
                this.renderGroup(targetGroup, this.seriesContainer);
            }
            else {
                targetGroup.seriesList.push(foundSeries);
                // Append the series row to the group's div
                this.makeSeriesRow(foundSeries, targetGroup.div);
                // No need to re-render the entire group
            }
            this._items.push(foundSeries);
            console.log(`Series "${seriesName}" moved to group "${targetGroupName}".`);
        }
        // legend.ts
        renderGroup(group, container) {
            // Clear old row content
            group.row.innerHTML = '';
            group.row.style.display = 'flex';
            group.row.style.flexDirection = 'column';
            group.row.style.width = '100%';
            // **Group Header Setup**
            const header = document.createElement('div');
            header.classList.add('group-header'); // Add CSS class for styling
            header.style.display = 'flex'; // Set header layout to flex
            header.style.alignItems = 'center'; // Align items vertically
            header.style.justifyContent = 'space-between'; // Add space between items
            header.style.cursor = 'pointer'; // Make the header clickable
            // **Create Action Button for Group**
            const groupActionButton = document.createElement('button');
            groupActionButton.classList.add('legend-action-button');
            groupActionButton.innerHTML = '◇'; // Default Icon
            groupActionButton.title = 'Group Actions'; // Tooltip for accessibility
            groupActionButton.style.marginRight = '0px'; // Space between button and info
            groupActionButton.style.fontSize = '1em'; // Adjust size as needed
            groupActionButton.style.border = 'none'; // Remove default border
            groupActionButton.style.background = 'none'; // Remove default background
            groupActionButton.style.cursor = 'pointer'; // Indicate it's clickable
            // **Set Group Action Button Color to Match Group Color**
            // Use the first series' primary color or default to black
            group.seriesList[0]?.colors[0] || '#000';
            groupActionButton.style.color = '#ffffff';
            // **Attach Click Listener to Group Action Button**
            groupActionButton.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent triggering header click events
                event.preventDefault(); // Prevent default button behavior
                // **Toggle Icon Between ◇ and ◈**
                if (groupActionButton.innerHTML === '◇') {
                    groupActionButton.innerHTML = '◈'; // Menu is open
                }
                else {
                    groupActionButton.innerHTML = '◇'; // Menu is closed
                }
                // **Populate and Show LegendMenu**
                this.legendMenu.populateLegendMenu(group, event);
            });
            // **Group Name and Aggregated Symbols**
            const groupNameSpan = document.createElement('span');
            groupNameSpan.style.fontWeight = 'bold';
            groupNameSpan.innerHTML = group.seriesList
                .map(series => series.legendSymbol.map((symbol, index) => `<span style="color: ${series.colors[index] || series.colors[0]};">${symbol}</span>`).join(' '))
                .join(' ') + ` ${group.name}`;
            // **Custom Toggle Button (next to the group name)**
            const toggleButton = document.createElement('span');
            toggleButton.classList.add('toggle-button'); // Add CSS class for styling
            toggleButton.style.marginLeft = 'auto'; // Push button to the far right
            toggleButton.style.fontSize = '1.2em'; // Make the icon size consistent
            toggleButton.style.cursor = 'pointer'; // Indicate it’s clickable
            toggleButton.innerHTML = '⌲'; // Default expanded state
            toggleButton.setAttribute('aria-expanded', 'true'); // Accessibility
            toggleButton.addEventListener('click', (event) => {
                event.stopPropagation();
                if (group.div.style.display === 'none') {
                    group.div.style.display = 'block';
                    toggleButton.innerHTML = '⌲'; // Expanded icon
                    toggleButton.setAttribute('aria-expanded', 'true');
                }
                else {
                    group.div.style.display = 'none';
                    toggleButton.innerHTML = '☰'; // Collapsed icon
                    toggleButton.setAttribute('aria-expanded', 'false');
                }
            });
            // **Append Group Action Button and Group Name to Header**
            header.appendChild(groupActionButton); // Add Action Button
            header.appendChild(groupNameSpan);
            header.appendChild(toggleButton);
            // **Attach context menu listener to the group header**
            header.addEventListener("contextmenu", (event) => {
                event.preventDefault(); // Prevent the default browser context menu
                this.legendMenu.populateLegendMenu(group, event); // Populate and show the legend menu
            });
            // **Append Header to the Group Row**
            group.row.appendChild(header);
            // **Container for the Group's Items (Series Rows)**
            group.div = document.createElement('div');
            group.div.style.display = 'block';
            group.div.style.marginLeft = '10px'; // Indent for group items
            // **Render Each Series within the Group**
            for (const s of group.seriesList) {
                this.makeSeriesRow(s, group.div);
            }
            // **Render Subgroups Recursively**
            for (const subG of group.subGroups) {
                const subContainer = document.createElement('div');
                subContainer.style.display = 'flex';
                subContainer.style.flexDirection = 'column';
                subContainer.style.paddingLeft = '5px'; // Indent for nested groups
                this.renderGroup(subG, subContainer);
                group.div.appendChild(subContainer);
            }
            // **Append the Group's Items Container to the Group Row**
            group.row.appendChild(group.div);
            // **Append the Group Row to the Container if Not Already Present**
            if (!container.contains(group.row)) {
                container.appendChild(group.row);
            }
            // **Prevent Default Context Menu on the Group Row**
            group.row.oncontextmenu = (event) => {
                event.preventDefault();
            };
        }
        /**
         * Handles crosshair movement events to update the legend display.
         * @param param The mouse event parameters.
         * @param usingPoint Determines whether to use logical indexing.
         */
        legendHandler(param, usingPoint = false) {
            let logical = null;
            //
            //if (usingPoint) {
            //    const timeScale = this.handler.chart.timeScale();
            //    let coordinate = timeScale.timeToCoordinate(param.time)
            //    if (coordinate)
            //        logical = timeScale.coordinateToLogical(coordinate.valueOf())
            //    if (logical)
            //        data = this.handler.series.dataByIndex(logical.valueOf())
            //}
            //else {
            //    data = param.seriesData.get(this.handler.series);
            //}
            //
            //this.candle.style.color = ''
            //let str = '<span style="line-height: 1.8;">'
            //if (data) {
            //    if (this.ohlcEnabled) {
            //        str += `O ${this.legendItemFormat(data.open, this.handler.precision)} `;
            //        str += `| H ${this.legendItemFormat(data.high, this.handler.precision)} `;
            //        str += `| L ${this.legendItemFormat(data.low, this.handler.precision)} `;
            //        str += `| C ${this.legendItemFormat(data.close, this.handler.precision)} `;
            //    }
            //
            //    // Display percentage move if enabled
            //    if (this.percentEnabled) {
            //        const percentMove = ((data.close - data.open) / data.open) * 100;
            //        const color = percentMove > 0 ? options['upColor'] : options['downColor'];
            //        const percentStr = `${percentMove >= 0 ? '+' : ''}${percentMove.toFixed(2)} %`;
            //        str += this.colorBasedOnCandle ? `| <span style="color: ${color};">${percentStr}</span>` : `| ${percentStr}`;
            //    }
            //}
            //
            //this.candle.innerHTML = str + '</span>';
            // Update group legend and series legend
            this.updateGroupDisplay(param, logical, usingPoint);
            this.updateSeriesDisplay(param, logical, usingPoint);
        }
        updateSeriesDisplay(param, logical, usingPoint) {
            if (!this._lines || !this._lines.length) {
                console.error("No lines available to update legend.");
                return;
            }
            this._lines.forEach((e) => {
                const data = param.seriesData.get(e.series) || getLastData(e.series);
                if (!data) {
                    return;
                }
                const seriesType = e.seriesType || 'Line';
                const priceFormat = e.series.options().priceFormat;
                if (seriesType === 'Line' || seriesType === 'Area') {
                    const valueData = data;
                    if (valueData.value == null) {
                        return;
                    }
                    const value = this.legendItemFormat(valueData.value, priceFormat.precision);
                    e.div.innerHTML = `
                    <span style="color: ${e.colors[0]};">${e.legendSymbol[0] || '▨'}</span> 
                    ${e.name}: ${value}`;
                }
                else if (seriesType === 'Bar' || seriesType === 'Candlestick' || seriesType === 'Ohlc') {
                    const { open, close } = data;
                    if (open == null || close == null) {
                        return;
                    }
                    const openPrice = this.legendItemFormat(open, priceFormat.precision);
                    const closePrice = this.legendItemFormat(close, priceFormat.precision);
                    const isUp = close > open;
                    const color = isUp ? e.colors[0] : e.colors[1];
                    const symbol = isUp ? e.legendSymbol[0] : e.legendSymbol[1];
                    e.div.innerHTML = `
                    <span style="color: ${color};">${symbol || '▨'}</span>
                    ${e.name}: 
                    <span style="color: ${color};">O ${openPrice}</span>, 
                    <span style="color: ${color};">C ${closePrice}</span>`;
                }
            });
        }
        /**
         * Updates the display for grouped series based on the crosshair position.
         * @param param The mouse event parameters.
         * @param logical The logical index of the data point.
         * @param usingPoint Determines whether to use logical indexing.
         */
        updateGroupDisplay(param, logical, usingPoint) {
            this._groups.forEach((group) => {
                if (!this.linesEnabled) {
                    group.row.style.display = 'none';
                    return;
                }
                group.row.style.display = 'flex';
                // Iterate through each series in the group and update its display
                group.seriesList.forEach((seriesItem) => {
                    const data = param.seriesData.get(seriesItem.series) || getLastData(seriesItem.series);
                    if (!data) {
                        return;
                    }
                    const seriesType = seriesItem.seriesType || 'Line';
                    const name = seriesItem.name;
                    const priceFormat = seriesItem.series.options().priceFormat;
                    // Check if the series type supports OHLC values
                    const isOHLC = ['Bar', 'Candlestick', 'Ohlc'].includes(seriesType);
                    if (isOHLC) {
                        const { open, close, high, low } = data;
                        if (open == null || close == null || high == null || low == null) {
                            return;
                        }
                        const openPrice = this.legendItemFormat(open, priceFormat.precision);
                        const closePrice = this.legendItemFormat(close, priceFormat.precision);
                        const isUp = close > open;
                        const color = isUp ? seriesItem.colors[0] : seriesItem.colors[1];
                        const symbol = isUp ? seriesItem.legendSymbol[0] : seriesItem.legendSymbol[1];
                        seriesItem.div.innerHTML = `
                        <span style="color: ${color};">${symbol || '▨'}</span>
                        ${name}: 
                        <span style="color: ${color};">O ${openPrice}</span>, 
                        <span style="color: ${color};">C ${closePrice}</span>
                    `;
                    }
                    else {
                        // Handle series types with a single 'value' property
                        const valueData = data;
                        const value = 'value' in valueData ? valueData.value : undefined;
                        if (value == null) {
                            return;
                        }
                        const formattedValue = this.legendItemFormat(value, priceFormat.precision);
                        const color = seriesItem.colors[0];
                        const symbol = seriesItem.legendSymbol[0] || '▨';
                        seriesItem.div.innerHTML = `
                        <span style="color: ${color};">${symbol}</span>
                        ${name}: ${formattedValue}
                    `;
                    }
                });
            });
        }
        /**
         * Finds a group by name within the legend hierarchy.
         * @param groupName The name of the group to find.
         * @param groups The current group list to search within.
         * @returns The LegendGroup if found, undefined otherwise.
         */
        findGroup(groupName, groups = this._groups) {
            for (const group of groups) {
                if (group.name === groupName) {
                    return group;
                }
                const foundInSub = this.findGroup(groupName, group.subGroups);
                if (foundInSub) {
                    return foundInSub;
                }
            }
            return undefined;
        }
    }

    const defaultOptions$3 = {
        lineColor: '#1E80F0',
        lineStyle: lightweightCharts.LineStyle.Solid,
        width: 4,
    };

    var InteractionState;
    (function (InteractionState) {
        InteractionState[InteractionState["NONE"] = 0] = "NONE";
        InteractionState[InteractionState["HOVERING"] = 1] = "HOVERING";
        InteractionState[InteractionState["DRAGGING"] = 2] = "DRAGGING";
        InteractionState[InteractionState["DRAGGINGP1"] = 3] = "DRAGGINGP1";
        InteractionState[InteractionState["DRAGGINGP2"] = 4] = "DRAGGINGP2";
        InteractionState[InteractionState["DRAGGINGP3"] = 5] = "DRAGGINGP3";
        InteractionState[InteractionState["DRAGGINGP4"] = 6] = "DRAGGINGP4";
    })(InteractionState || (InteractionState = {}));
    class Drawing extends PluginBase {
        _paneViews = [];
        _options;
        _points = [];
        _state = InteractionState.NONE;
        _startDragPoint = null;
        _latestHoverPoint = null;
        static _mouseIsDown = false;
        static hoveredObject = null;
        static lastHoveredObject = null;
        _listeners = [];
        constructor(options) {
            super();
            this._options = {
                ...defaultOptions$3,
                ...options,
            };
        }
        updateAllViews() {
            this._paneViews.forEach(pw => pw.update());
        }
        paneViews() {
            return this._paneViews;
        }
        applyOptions(options) {
            this._options = {
                ...this._options,
                ...options,
            };
            this.requestUpdate();
        }
        updatePoints(...points) {
            for (let i = 0; i < this.points.length; i++) {
                if (points[i] == null)
                    continue;
                this.points[i] = points[i];
            }
            this.requestUpdate();
        }
        detach() {
            this._options.lineColor = 'transparent';
            this.requestUpdate();
            this.series.detachPrimitive(this);
            for (const s of this._listeners) {
                document.body.removeEventListener(s.name, s.listener);
            }
        }
        get points() {
            return this._points;
        }
        _subscribe(name, listener) {
            document.body.addEventListener(name, listener);
            this._listeners.push({ name: name, listener: listener });
        }
        _unsubscribe(name, callback) {
            document.body.removeEventListener(name, callback);
            const toRemove = this._listeners.find((x) => x.name === name && x.listener === callback);
            this._listeners.splice(this._listeners.indexOf(toRemove), 1);
        }
        _handleHoverInteraction(param) {
            this._latestHoverPoint = param.point;
            if (Drawing._mouseIsDown) {
                this._handleDragInteraction(param);
            }
            else {
                if (this._mouseIsOverDrawing(param)) {
                    if (this._state != InteractionState.NONE)
                        return;
                    this._moveToState(InteractionState.HOVERING);
                    Drawing.hoveredObject = Drawing.lastHoveredObject = this;
                }
                else {
                    if (this._state == InteractionState.NONE)
                        return;
                    this._moveToState(InteractionState.NONE);
                    if (Drawing.hoveredObject === this)
                        Drawing.hoveredObject = null;
                }
            }
        }
        static _eventToPoint(param, series) {
            if (!series || !param.point || !param.logical)
                return null;
            const barPrice = series.coordinateToPrice(param.point.y);
            if (barPrice == null)
                return null;
            return {
                time: param.time || null,
                logical: param.logical,
                price: barPrice.valueOf(),
            };
        }
        static _getDiff(p1, p2) {
            const diff = {
                logical: p1.logical - p2.logical,
                price: p1.price - p2.price,
            };
            return diff;
        }
        _addDiffToPoint(point, logicalDiff, priceDiff) {
            if (!point)
                return;
            point.logical = point.logical + logicalDiff;
            point.price = point.price + priceDiff;
            point.time = this.series.dataByIndex(point.logical)?.time || null;
        }
        _handleMouseDownInteraction = () => {
            // if (Drawing._mouseIsDown) return;
            Drawing._mouseIsDown = true;
            this._onMouseDown();
        };
        _handleMouseUpInteraction = () => {
            // if (!Drawing._mouseIsDown) return;
            Drawing._mouseIsDown = false;
            this._moveToState(InteractionState.HOVERING);
        };
        _handleDragInteraction(param) {
            if (this._state != InteractionState.DRAGGING &&
                this._state != InteractionState.DRAGGINGP1 &&
                this._state != InteractionState.DRAGGINGP2 &&
                this._state != InteractionState.DRAGGINGP3 &&
                this._state != InteractionState.DRAGGINGP4) {
                return;
            }
            const mousePoint = Drawing._eventToPoint(param, this.series);
            if (!mousePoint)
                return;
            this._startDragPoint = this._startDragPoint || mousePoint;
            const diff = Drawing._getDiff(mousePoint, this._startDragPoint);
            this._onDrag(diff);
            this.requestUpdate();
            this._startDragPoint = mousePoint;
        }
    }

    function buildOptions(optionPath, value) {
        const keys = optionPath.split(".");
        const options = {};
        let current = options;
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (i === keys.length - 1) {
                current[key] = value;
            }
            else {
                current[key] = {};
                current = current[key];
            }
        }
        return options;
    }
    /**
     * Utility function to convert camelCase to Title Case
     * @param inputString The camelCase string.
     * @returns The Title Case string.
     */
    function camelToTitle(inputString) {
        return inputString
            .replace(/([A-Z])/g, " $1")
            .replace(/^./, (str) => str.toUpperCase());
    }
    /**
     * Converts points between DrawingPoint (logical/price coordinates)
     * and CanvasPoint (pixel coordinates).
     *
     * @param point - A DrawingPoint or a CanvasPoint.
     * @param chart - The chart API providing time scale conversions.
     * @param series - The series API for y-axis conversions (price ↔ canvas coordinates).
     * @returns The converted point or null if conversion fails.
     */
    function convertPoint(point, chart, series) {
        const timeScale = chart.timeScale();
        const targetSeries = series ?? chart.addSeries(lightweightCharts.LineSeries); // Fallback to adding a new series if one wasn't provided
        if (!targetSeries) {
            console.warn('No series found. Cannot perform y-axis conversions.');
            return null;
        }
        // Determine if the input point is a DrawingPoint by checking for the "logical" property.
        const isDrawingPoint = 'logical' in point;
        if (isDrawingPoint) {
            // Convert DrawingPoint to CanvasPoint:
            const drawingPoint = point;
            const canvasX = timeScale.logicalToCoordinate(drawingPoint.logical);
            const canvasY = targetSeries.priceToCoordinate(drawingPoint.price);
            if (canvasX === null || canvasY === null)
                return null;
            return { x: canvasX, y: canvasY };
        }
        else {
            // Convert CanvasPoint to DrawingPoint:
            const canvasPoint = point;
            const logical = timeScale.coordinateToLogical(canvasPoint.x);
            const time = timeScale.coordinateToTime(canvasPoint.x);
            const price = targetSeries.coordinateToPrice(canvasPoint.y);
            if (logical === null || price === null)
                return null;
            // Note: Since the original DrawingPoint interface optionally includes a time property,
            // we are returning an object with just logical and price.
            return { time, logical, price };
        }
    } /**
     * Converts an object to JSON while filtering out circular references.
     * This helper uses a WeakSet to track seen objects.
     *
     * @param obj The object to stringify.
     * @returns A JSON string.
     */

    /**
     * Draws a rectangle-shaped candle.
     * @param ctx - The canvas rendering context.
     * @param leftSide - The X-coordinate of the left edge of the candle.
     * @param rightSide - The X-coordinate of the right edge of the candle.
     * @param yCenter - The Y-coordinate of the center of the candle.
     * @param candleHeight - The height of the candle in pixels.
     */
    function ohlcRectangle(ctx, leftSide, rightSide, yCenter, candleHeight) {
        const topEdge = yCenter - candleHeight / 2;
        const bottomEdge = yCenter + candleHeight / 2;
        // Begin drawing the candle rectangle.
        ctx.beginPath();
        ctx.moveTo(leftSide, topEdge);
        ctx.lineTo(leftSide, bottomEdge);
        ctx.lineTo(rightSide, bottomEdge);
        ctx.lineTo(rightSide, topEdge);
        ctx.closePath();
        // Fill and stroke the rectangle.
        ctx.fill();
        ctx.stroke();
    }
    /**
     * Draws a rounded rectangle-shaped candle with clamped corner radius.
     * @param ctx - The canvas rendering context.
     * @param leftSide - The X-coordinate of the left edge of the candle.
     * @param rightSide - The X-coordinate of the right edge of the candle.
     * @param yCenter - The Y-coordinate of the center of the candle.
     * @param candleHeight - The height of the candle in pixels.
     * @param radius - A float from 0..1 that we clamp to an appropriate max.
     */
    function ohlcRounded(ctx, leftSide, rightSide, yCenter, candleHeight, radius) {
        const width = rightSide - leftSide;
        // Optionally clamp radius if it's supposed to be 0..1
        const rawRadius = radius * Math.min(Math.abs(width), Math.abs(candleHeight));
        const effectiveRadius = Math.abs(Math.min(rawRadius, width / 2, candleHeight / 2));
        const topEdge = yCenter - candleHeight / 2;
        ctx.beginPath();
        if (typeof ctx.roundRect === 'function') {
            ctx.roundRect(leftSide, topEdge, width, candleHeight, effectiveRadius);
        }
        else {
            // Fallback: manually draw arcs or just do rect
            ctx.moveTo(leftSide + effectiveRadius, topEdge);
            ctx.lineTo(rightSide - effectiveRadius, topEdge);
            ctx.quadraticCurveTo(rightSide, topEdge, rightSide, topEdge + effectiveRadius);
            ctx.lineTo(rightSide, topEdge + candleHeight - effectiveRadius);
            ctx.quadraticCurveTo(rightSide, topEdge + candleHeight, rightSide - effectiveRadius, topEdge + candleHeight);
            ctx.lineTo(leftSide + effectiveRadius, topEdge + candleHeight);
            ctx.quadraticCurveTo(leftSide, topEdge + candleHeight, leftSide, topEdge + candleHeight - effectiveRadius);
            ctx.lineTo(leftSide, topEdge + effectiveRadius);
            ctx.quadraticCurveTo(leftSide, topEdge, leftSide + effectiveRadius, topEdge);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }
    /**
     * Draws an ellipse-shaped candle.
     * @param ctx - The canvas rendering context.
     * @param xCenter - The X-coordinate of the center of the ellipse.
     * @param yCenter - The Y-coordinate of the center of the ellipse.
     * @param candleWidth - The width of the ellipse in pixels.
     * @param candleHeight - The height of the ellipse in pixels.
     */
    function ohlcEllipse(ctx, leftSide, rightSide, middle, yCenter, candleHeight) {
        const xCenter = leftSide + (rightSide - leftSide) / 2;
        const candleWidth = rightSide - leftSide;
        ctx.beginPath();
        ctx.ellipse(xCenter, // X-coordinate of the center.
        yCenter, // Y-coordinate of the center.
        Math.abs(candleWidth / 2), // Horizontal radius.
        Math.abs(candleHeight / 2), // Vertical radius.
        0, // Rotation angle.
        0, // Start angle.
        Math.PI * 2 // End angle.
        );
        ctx.fill();
        ctx.stroke();
    }
    /**
     * Draws a 3D-shaped candle, providing a depth effect.
     * @param ctx - The canvas rendering context.
     * @param xCenter - The X-coordinate of the candle's center.
     * @param yHigh - The Y-coordinate of the highest point of the candle.
     * @param yLow - The Y-coordinate of the lowest point of the candle.
     * @param yOpen - The Y-coordinate of the opening price.
     * @param yClose - The Y-coordinate of the closing price.
     * @param candleWidth - The width of the candle.
     * @param combinedWidth - The combined width for depth effect.
     * @param fillColor - The fill color of the candle.
     * @param borderColor - The border color of the candle.
     * @param isUp - Indicates if the candle is upward-moving.
     * @param barSpacing - The spacing factor between bars.
     */
    function ohlc3d(ctx, xCenter, yHigh, yLow, yOpen, yClose, candleWidth, combinedWidth, fillColor, borderColor, isUp, barSpacing) {
        const xOffset = -Math.max(combinedWidth, 1) * (1 - barSpacing);
        const insideColor = darkenColor(fillColor, 0.666); // Darker side color
        const sideColor = darkenColor(fillColor, 0.333);
        const topColor = darkenColor(fillColor, 0.2); // Slightly lighter top face
        // Calculate front face X coordinates using candleWidth
        const frontLeftX = xCenter - candleWidth / 2;
        const frontRightX = frontLeftX + combinedWidth + xOffset;
        // Calculate back face X coordinates with combined width for depth effect
        const backLeftX = frontLeftX - xOffset;
        const backRightX = frontRightX - xOffset;
        // Set Y coordinates for front and back faces based on candle direction
        let frontTop, frontBottom, backTop, backBottom;
        if (!isUp) {
            // Up candle: front face uses open/high, back face uses low/close
            frontTop = yOpen;
            frontBottom = yHigh;
            backTop = yLow;
            backBottom = yClose;
        }
        else {
            // Down candle: front face uses open/low, back face uses high/close
            frontTop = yOpen;
            frontBottom = yLow;
            backTop = yHigh;
            backBottom = yClose;
        }
        // Draw back (shadow) rectangle
        ctx.fillStyle = sideColor;
        ctx.strokeStyle = borderColor;
        ctx.beginPath();
        ctx.rect(backLeftX, backTop, combinedWidth + xOffset - candleWidth / 2, backBottom - backTop);
        ctx.fill();
        ctx.stroke();
        // Draw top face between front and back
        ctx.fillStyle = topColor;
        if (isUp) {
            // Draw bottom face first for up candles
            ctx.fillStyle = insideColor;
            ctx.beginPath();
            ctx.moveTo(frontLeftX, frontBottom); // Bottom-left corner at the front
            ctx.lineTo(backLeftX, backBottom); // Bottom-left corner at the back
            ctx.lineTo(backRightX, backBottom); // Bottom-right corner at the back
            ctx.lineTo(frontRightX, frontBottom); // Bottom-right corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Draw left side face for up candles
            ctx.fillStyle = insideColor;
            ctx.beginPath();
            ctx.moveTo(frontLeftX, frontTop); // Top-left corner at the front
            ctx.lineTo(backLeftX, backTop); // Top-left corner at the back
            ctx.lineTo(backLeftX, backBottom); // Bottom-left corner at the back
            ctx.lineTo(frontLeftX, frontBottom); // Bottom-left corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Draw right side face for up candles
            ctx.fillStyle = insideColor;
            ctx.beginPath();
            ctx.moveTo(frontRightX, frontTop); // Top-right corner at the front
            ctx.lineTo(backRightX, backTop); // Top-right corner at the back
            ctx.lineTo(backRightX, backBottom); // Bottom-right corner at the back
            ctx.lineTo(frontRightX, frontBottom); // Bottom-right corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Draw top face last for up candles
            ctx.fillStyle = topColor;
            ctx.beginPath();
            ctx.moveTo(frontLeftX, frontTop); // Top-left corner at the front
            ctx.lineTo(backLeftX, backTop); // Top-left corner at the back
            ctx.lineTo(backRightX, backTop); // Top-right corner at the back
            ctx.lineTo(frontRightX, frontTop); // Top-right corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        else {
            // Draw top face first for down candles
            ctx.fillStyle = topColor;
            ctx.beginPath();
            ctx.moveTo(frontLeftX, frontTop); // Top-left corner at the front
            ctx.lineTo(backLeftX, backTop); // Top-left corner at the back
            ctx.lineTo(backRightX, backTop); // Top-right corner at the back
            ctx.lineTo(frontRightX, frontTop); // Top-right corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Draw right side face for down candles
            ctx.fillStyle = sideColor;
            ctx.beginPath();
            ctx.moveTo(frontRightX, frontTop); // Top-right corner at the front
            ctx.lineTo(backRightX, backTop); // Top-right corner at the back
            ctx.lineTo(backRightX, backBottom); // Bottom-right corner at the back
            ctx.lineTo(frontRightX, frontBottom); // Bottom-right corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Draw left side face for down candles
            ctx.fillStyle = sideColor;
            ctx.beginPath();
            ctx.moveTo(frontLeftX, frontTop); // Top-left corner at the front
            ctx.lineTo(backLeftX, backTop); // Top-left corner at the back
            ctx.lineTo(backLeftX, backBottom); // Bottom-left corner at the back
            ctx.lineTo(frontLeftX, frontBottom); // Bottom-left corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Draw bottom face last for down candles
            ctx.fillStyle = sideColor;
            ctx.beginPath();
            ctx.moveTo(frontLeftX, frontBottom); // Bottom-left corner at the front
            ctx.lineTo(backLeftX, backBottom); // Bottom-left corner at the back
            ctx.lineTo(backRightX, backBottom); // Bottom-right corner at the back
            ctx.lineTo(frontRightX, frontBottom); // Bottom-right corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
    }
    /**
     * Draws a polygon-shaped candle.
     * @param ctx - The canvas rendering context.
     * @param leftSide - The X-coordinate of the left edge of the polygon.
     * @param rightSide - The X-coordinate of the right edge of the polygon.
     * @param yCenter - The Y-coordinate of the center of the polygon.
     * @param candleHeight - The height of the polygon in pixels.
     * @param highY - The Y-coordinate of the highest point of the polygon.
     * @param lowY - The Y-coordinate of the lowest point of the polygon.
     * @param isUp - Indicates if the polygon points upwards.
     */
    function ohlcPolygon(ctx, leftSide, rightSide, yCenter, candleHeight, highY, lowY, isUp) {
        const openCloseTop = yCenter + candleHeight / 2;
        const openCloseBottom = yCenter - candleHeight / 2;
        // Save the current canvas state before drawing.
        ctx.save();
        ctx.beginPath();
        if (isUp) {
            // Define the path for an upward-pointing polygon.
            ctx.moveTo(leftSide, openCloseTop);
            ctx.lineTo(rightSide, highY);
            ctx.lineTo(rightSide, openCloseBottom);
            ctx.lineTo(leftSide, lowY);
        }
        else {
            // Define the path for a downward-pointing polygon.
            ctx.moveTo(leftSide, highY);
            ctx.lineTo(rightSide, openCloseTop);
            ctx.lineTo(rightSide, lowY);
            ctx.lineTo(leftSide, openCloseBottom);
        }
        // Complete the path and apply styles.
        ctx.closePath();
        ctx.stroke();
        ctx.fill();
        // Restore the canvas state after drawing.
        ctx.restore();
    }
    /**
     * Draws an arrow-shaped candle.
     * @param ctx - The canvas rendering context.
     * @param leftSide - The X-coordinate of the left edge of the arrow.
     * @param rightSide - The X-coordinate of the right edge of the arrow.
     * @param middle - The X-coordinate of the tip of the arrow.
     * @param yCenter - The Y-coordinate of the center of the arrow.
     * @param candleHeight - The height of the arrow in pixels.
     * @param highY - The Y-coordinate of the highest point of the arrow.
     * @param lowY - The Y-coordinate of the lowest point of the arrow.
     * @param isUp - Indicates if the arrow points upwards.
     */
    function ohlcArrow(ctx, leftSide, rightSide, middle, yCenter, candleHeight, highY, lowY, isUp) {
        // Save the current canvas state before drawing.
        ctx.save();
        ctx.beginPath();
        if (isUp) {
            // Define the path for an upward-pointing arrow.
            ctx.moveTo(leftSide, lowY);
            ctx.lineTo(leftSide, yCenter + candleHeight / 2);
            ctx.lineTo(middle, highY);
            ctx.lineTo(rightSide, yCenter + candleHeight / 2);
            ctx.lineTo(rightSide, lowY);
            ctx.lineTo(middle, yCenter - candleHeight / 2);
            ctx.lineTo(leftSide, lowY);
        }
        else {
            // Define the path for a downward-pointing arrow.
            ctx.moveTo(leftSide, highY);
            ctx.lineTo(leftSide, yCenter - candleHeight / 2);
            ctx.lineTo(middle, lowY);
            ctx.lineTo(rightSide, yCenter - candleHeight / 2);
            ctx.lineTo(rightSide, highY);
            ctx.lineTo(middle, yCenter + candleHeight / 2);
            ctx.lineTo(leftSide, highY);
        }
        // Complete the path and apply styles.
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        // Restore the canvas state after drawing.
        ctx.restore();
    }
    /**
     * Draws a traditional OHLC bar using leftSide and rightSide coordinates.
     *
     * The vertical line is drawn at the midpoint between leftSide and rightSide,
     * spanning from the high to the low. An open tick is drawn from leftSide to the center
     * at the open price, and a close tick is drawn from the center to rightSide at the close price.
     *
     * @param ctx - The canvas rendering context.
     * @param leftSide - The X-coordinate for the left edge of the bar.
     * @param rightSide - The X-coordinate for the right edge of the bar.
     * @param high - The Y-coordinate for the high price.
     * @param low - The Y-coordinate for the low price.
     * @param open - The Y-coordinate for the open price.
     * @param close - The Y-coordinate for the close price.
     */
    function ohlcBar(ctx, leftSide, rightSide, high, low, open, close) {
        // Compute the center X coordinate of the bar.
        const centerX = (leftSide + rightSide) / 2;
        // Draw the vertical line (from high to low) at the center.
        ctx.beginPath();
        ctx.moveTo(centerX, high);
        ctx.lineTo(centerX, low);
        ctx.stroke();
        // Draw the open tick from leftSide to center at the open price.
        ctx.beginPath();
        ctx.moveTo(leftSide, open);
        ctx.lineTo(centerX, open);
        ctx.stroke();
        // Draw the close tick from center to rightSide at the close price.
        ctx.beginPath();
        ctx.moveTo(centerX, close);
        ctx.lineTo(rightSide, close);
        ctx.stroke();
    }
    function ohlcSlanted(ctx, leftSide, rightSide, yCenter, candleHeight, isUp) {
        // Calculate the top and bottom edges of the candle.
        const topY = yCenter - candleHeight / 2;
        const bottomY = yCenter + candleHeight / 2;
        // Optional: You can tweak the slantOffset to control how "tilted" the parallelogram is.
        const slantOffset = Math.abs(rightSide - leftSide) * 0.9;
        // Save the current canvas state before drawing.
        ctx.save();
        ctx.beginPath();
        if (isUp) {
            // Forward slash (/): top-left to top-right is left-aligned,
            // bottom-left to bottom-right is right-aligned.
            ctx.moveTo(leftSide, topY);
            ctx.lineTo(leftSide + slantOffset, topY);
            ctx.lineTo(rightSide, bottomY);
            ctx.lineTo(rightSide - slantOffset, bottomY);
        }
        else {
            // Backslash (\): top-left to top-right is right-aligned,
            // bottom-left to bottom-right is left-aligned.
            ctx.moveTo(rightSide - slantOffset, topY);
            ctx.lineTo(rightSide, topY);
            ctx.lineTo(leftSide + slantOffset, bottomY);
            ctx.lineTo(leftSide, bottomY);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }

    class DrawingPaneRenderer {
        _options;
        constructor(options) {
            this._options = options;
        }
    }
    class TwoPointDrawingPaneRenderer extends DrawingPaneRenderer {
        _p1;
        _p2;
        _hovered;
        constructor(p1, p2, options, hovered) {
            super(options);
            this._p1 = p1;
            this._p2 = p2;
            this._hovered = hovered;
        }
        _getScaledCoordinates(scope) {
            if (this._p1.x === null || this._p1.y === null ||
                this._p2.x === null || this._p2.y === null)
                return null;
            return {
                x1: Math.round(this._p1.x * scope.horizontalPixelRatio),
                y1: Math.round(this._p1.y * scope.verticalPixelRatio),
                x2: Math.round(this._p2.x * scope.horizontalPixelRatio),
                y2: Math.round(this._p2.y * scope.verticalPixelRatio),
            };
        }
        // _drawTextLabel(scope: BitmapCoordinatesRenderingScope, text: string, x: number, y: number, left: boolean) {
        //  scope.context.font = '24px Arial';
        //  scope.context.beginPath();
        //  const offset = 5 * scope.horizontalPixelRatio;
        //  const textWidth = scope.context.measureText(text);
        //  const leftAdjustment = left ? textWidth.width + offset * 4 : 0;
        //  scope.context.fillStyle = this._options.labelBackgroundColor;
        //  scope.context.roundRect(x + offset - leftAdjustment, y - 24, textWidth.width + offset * 2,  24 + offset, 5);
        //  scope.context.fill();
        //  scope.context.beginPath();
        //  scope.context.fillStyle = this._options.labelTextColor;
        //  scope.context.fillText(text, x + offset * 2 - leftAdjustment, y);
        // }
        _drawEndCircle(scope, x, y) {
            const radius = 9;
            scope.context.fillStyle = '#000';
            scope.context.beginPath();
            scope.context.arc(x, y, radius, 0, 2 * Math.PI);
            scope.context.stroke();
            scope.context.fill();
            // scope.context.strokeStyle = this._options.lineColor;
        }
    }
    class ThreePointDrawingPaneRenderer extends DrawingPaneRenderer {
        _p1;
        _p2;
        _p3;
        _hovered;
        constructor(p1, p2, p3, options, hovered) {
            super(options);
            this._p1 = p1;
            this._p2 = p2;
            this._p3 = p3;
            this._hovered = hovered;
        }
        _getScaledCoordinates(scope) {
            if (this._p1.x === null || this._p1.y === null ||
                this._p2.x === null || this._p2.y === null ||
                this._p3.x === null || this._p3.y === null)
                return null;
            return {
                x1: Math.round(this._p1.x * scope.horizontalPixelRatio),
                y1: Math.round(this._p1.y * scope.verticalPixelRatio),
                x2: Math.round(this._p2.x * scope.horizontalPixelRatio),
                y2: Math.round(this._p2.y * scope.verticalPixelRatio),
                x3: Math.round(this._p3.x * scope.horizontalPixelRatio),
                y3: Math.round(this._p3.y * scope.verticalPixelRatio),
            };
        }
        _drawEndCircle(scope, x, y) {
            const radius = 9;
            scope.context.fillStyle = '#000';
            scope.context.beginPath();
            scope.context.arc(x, y, radius, 0, 2 * Math.PI);
            scope.context.stroke();
            scope.context.fill();
        }
    }

    const tradeDefaultOptions = {
        ...lightweightCharts.customSeriesDefaultOptions,
        side: 'long',
        mode: 'relative',
        auto: false,
        entryColor: '#FFFF00',
        stopColor: '#FF0000',
        targetColor: '#00FF00',
        backgroundColorStop: 'rgba(255,0,0,0.25)',
        backgroundColorTarget: 'rgba(0,255,0,0.25)',
        lineWidth: 1,
        lineStyle: 3, // Default to solid
        partialClosureLineColor: '#FFFFFF',
        partialClosureLineWidth: 1,
        partialClosureLineDash: [4, 2],
        infoTextColor: '#FFFFFF',
        infoFont: '12px Arial',
        positionChangeColor: '#FFFFFF'
    };

    function decorateSeries(original, legend // Optional Legend instance to handle primitives
    ) {
        // Check if the series is already decorated
        if (original._isDecorated) {
            console.warn("Series is already decorated. Skipping decoration.");
            return original;
        }
        // Mark the series as decorated
        original._isDecorated = true;
        const decorated = true;
        const originalSetData = original.setData.bind(original);
        // Array to store attached primitives
        const primitives = [];
        // Reference to the most recently attached primitive
        let lastAttachedPrimitive = null;
        // Hook into the original `detachPrimitive` if it exists
        const originalDetachPrimitive = original.detachPrimitive?.bind(original);
        const originalAttachPrimitive = original.attachPrimitive?.bind(original);
        const originalData = original.data?.bind(original);
        /**
         * Helper function to convert data items.
         *
         * @param sourceItem - The raw source item (must contain a `time` property).
         * @param keys - Optional list of property names to copy. Defaults to ['time'].
         * @param copy - If true, copies all properties from sourceItem, overriding `keys`.
         * @returns A partial data item or null if `time` is missing.
         */
        const _type = original.seriesType();
        const title = original.options().title;
        function sync(series) {
            // 1) Determine the type from the series’ own options
            //    (Ensure "seriesType" is indeed on the options, otherwise provide fallback)
            const options = series.options();
            const targetType = options.seriesType ?? "Line"; // fallback to "Line" if undefined
            // 2) Perform initial synchronization from "originalData"
            const sourceData = originalData();
            if (!sourceData) {
                console.warn("Source data is missing for synchronization.");
                return;
            }
            const targetData = [...series.data()];
            for (let i = targetData.length; i < sourceData.length; i++) {
                // Now call your convertDataItem with the discovered type:
                const newItem = convertDataItem(series, targetType, i);
                if (newItem) {
                    if (newItem && 'time' in newItem && 'value' in newItem) {
                        targetData.push(newItem);
                    }
                    else {
                        console.warn('Invalid data item:', newItem);
                    }
                }
            }
            series.setData(targetData);
            console.log(`Synchronized series of type ${series.seriesType}`);
            // 3) Subscribe for future changes
            series.subscribeDataChanged(() => {
                const updatedSourceData = [...originalData()];
                if (!updatedSourceData || updatedSourceData.length === 0) {
                    console.warn("Source data is missing for synchronization.");
                    return;
                }
                // Get the last bar from the target series
                const lastTargetBar = series.data().slice(-1)[0];
                // The last index from updatedSourceData
                const lastSourceIndex = updatedSourceData.length - 1;
                // If the new item has a time >= last target bar’s time, we update/append
                if (!lastTargetBar ||
                    updatedSourceData[lastSourceIndex].time >= lastTargetBar.time) {
                    const newItem = convertDataItem(series, targetType, lastSourceIndex);
                    if (newItem) {
                        series.update(newItem);
                        console.log(`Updated/added bar via "update()" for series type ${series.seriesType}`);
                    }
                }
            });
        }
        function attachPrimitive(primitive, name, replace = true, addToLegend = false) {
            const primitiveType = primitive.constructor.type || primitive.constructor.name;
            // Detach existing primitives if `replace` is true
            if (replace) {
                detachPrimitives();
            }
            else {
                // Check if a primitive of the same type is already attached
                const existingIndex = primitives.findIndex((p) => p.constructor.type === primitiveType);
                if (existingIndex !== -1) {
                    detachPrimitive(primitives[existingIndex]);
                }
            }
            // Attach the primitive to the series
            if (originalAttachPrimitive) {
                originalAttachPrimitive(primitive);
            }
            // Add the new primitive to the list
            primitives.push(primitive);
            lastAttachedPrimitive = primitive;
            console.log(`Primitive of type "${primitiveType}" attached.`);
            // Add the primitive to the legend if required
            if (legend && addToLegend) {
                legend.addLegendPrimitive(original, primitive, name);
            }
        }
        function detachPrimitive(primitive) {
            const index = primitives.indexOf(primitive);
            if (index === -1) {
                return;
            }
            // Remove the primitive from the array
            primitives.splice(index, 1);
            if (lastAttachedPrimitive === primitive) {
                lastAttachedPrimitive = null;
            }
            // Detach the primitive using the original method
            if (originalDetachPrimitive) {
                originalDetachPrimitive(primitive);
            }
            // Remove the primitive from the legend if it exists
            if (legend) {
                legend.removeLegendPrimitive(primitive);
                console.log(`Removed primitive of type "${primitive.constructor.name}" from legend.`);
            }
        }
        function detachPrimitives() {
            console.log("Detaching all primitives.");
            while (primitives.length > 0) {
                const primitive = primitives.pop();
                detachPrimitive(primitive);
            }
            console.log("All primitives detached.");
        }
        function setData(data) {
            originalSetData(data);
        }
        return Object.assign(original, {
            setData,
            primitives,
            sync,
            attachPrimitive,
            detachPrimitive,
            detachPrimitives,
            decorated,
            _type,
            title,
            get primitive() {
                return lastAttachedPrimitive;
            },
            toJSON() {
                return {
                    options: original.options(),
                    data: originalData(),
                };
            },
            fromJSON(json) {
                // If data is provided, update the series' data.
                if (json.data) {
                    originalSetData(json.data);
                }
                // If options are provided, iterate over each property and apply it.
                if (json.options) {
                    // Cast json.options to a plain record.
                    const opts = json.options;
                    for (const key in opts) {
                        if (Object.prototype.hasOwnProperty.call(opts, key)) {
                            // Cast key to string (since TS sometimes infers symbol too).
                            const typedKey = key;
                            original.applyOptions({ [typedKey]: opts[typedKey] });
                        }
                    }
                }
            },
        });
    }
    function getDefaultSeriesOptions(type //| "Ohlc" | "Trade"
    ) {
        const common = {
        // Define any common default options that apply to all series types here
        };
        switch (type) {
            case "Line":
                return {
                    ...common,
                    title: type,
                    color: "#195200",
                    lineWidth: 2,
                    crosshairMarkerVisible: true,
                };
            case "Histogram":
                return {
                    ...common,
                    title: type,
                    color: "#9ACF01",
                    base: 0,
                };
            case "Area":
                return {
                    ...common,
                    title: type,
                    lineColor: "#021698",
                    topColor: "rgba(9, 32, 210, 0.4)",
                    bottomColor: "rgba(0, 0, 0, 0.5)",
                };
            case "Bar":
                return {
                    ...common,
                    title: type,
                    upColor: "#006721",
                    downColor: "#6E0000",
                    borderUpColor: "#006721",
                    borderDownColor: "#6E0000",
                };
            case "Candlestick":
                return {
                    ...common,
                    title: type,
                    upColor: "rgba(0, 103, 33, 0.33)",
                    downColor: "rgba(110, 0, 0, 0.33)",
                    borderUpColor: "#006721",
                    borderDownColor: "#6E0000",
                    wickUpColor: "#006721",
                    wickDownColor: "#6E0000",
                };
            case "Ohlc":
                return {
                    ...common,
                    title: type,
                    upColor: "rgba(0, 103, 33, 0.33)",
                    downColor: "rgba(110, 0, 0, 0.33)",
                    borderUpColor: "#006721",
                    borderDownColor: "#6E0000",
                    wickUpColor: "#006721",
                    wickDownColor: "#6E0000",
                    shape: "Rounded",
                    chandelierSize: 1,
                    barSpacing: 0.777,
                    lineStyle: 0,
                    lineWidth: 1,
                };
            case "Trade":
                return {
                    ...common,
                    ...tradeDefaultOptions,
                };
            default:
                throw new Error(`Unsupported series type: ${type}`);
        }
    }
    /**
     * Converts one specific data item (by `index`) to the target series type.
     */
    function convertDataItem(series, targetType, index) {
        // 1) get the data array
        const data = series.data();
        if (!data || data.length === 0) {
            console.warn("No data available in the source series.");
            return null;
        }
        // 2) pick the individual item
        const item = data[index];
        // 3) switch on targetType, then use type guards on `item`
        switch (targetType) {
            // Single-value shapes: "Line", "Histogram", "Area"
            case "Line": {
                // line expects { time, value }
                if (isOHLCData(item)) {
                    // Use item.close for value
                    return {
                        time: item.time,
                        value: item.close,
                    };
                }
                else if (isSingleValueData(item)) {
                    // Already has { time, value }
                    return {
                        time: item.time,
                        value: item.value,
                    };
                }
                else if (isWhitespaceData(item)) {
                    // It's valid whitespace data => return as-is
                    return {
                        time: item.time,
                    };
                }
                // else it's something else => can't convert
                break;
            }
            case "Histogram": {
                // histogram expects { time, value }, possibly color
                if (isOHLCData(item)) {
                    return {
                        time: item.time,
                        value: item.close,
                    };
                }
                else if (isSingleValueData(item)) {
                    return {
                        time: item.time,
                        value: item.value,
                    };
                }
                else if (isWhitespaceData(item)) {
                    return {
                        time: item.time,
                    };
                }
                break;
            }
            case "Area": {
                // area expects { time, value }
                if (isOHLCData(item)) {
                    return {
                        time: item.time,
                        value: item.close,
                    };
                }
                else if (isSingleValueData(item)) {
                    return {
                        time: item.time,
                        value: item.value,
                    };
                }
                else if (isWhitespaceData(item)) {
                    return {
                        time: item.time,
                    };
                }
                break;
            }
            // OHLC shapes: "Bar", "Candlestick", "Ohlc"
            case "Bar": {
                // { time, open, high, low, close }
                if (isOHLCData(item)) {
                    return {
                        time: item.time,
                        open: item.open,
                        high: item.high,
                        low: item.low,
                        close: item.close,
                    };
                }
                else if (isWhitespaceData(item)) {
                    return {
                        time: item.time,
                    };
                }
                break;
            }
            case "Candlestick": {
                // shape = { time, open, high, low, close }
                if (isOHLCData(item)) {
                    return {
                        time: item.time,
                        open: item.open,
                        high: item.high,
                        low: item.low,
                        close: item.close,
                    };
                }
                else if (isWhitespaceData(item)) {
                    return {
                        time: item.time,
                    };
                }
                break;
            }
            case "Ohlc": {
                // your custom type or just treat it as BarData
                if (isOHLCData(item)) {
                    return {
                        time: item.time,
                        open: item.open,
                        high: item.high,
                        low: item.low,
                        close: item.close,
                    };
                }
                else if (isWhitespaceData(item)) {
                    return {
                        time: item.time,
                    };
                }
                break;
            }
            case "Trade": {
                return {
                    time: item.time,
                    action: item.action ?? undefined,
                };
            }
            default:
                console.error(`Unsupported target type: ${targetType}`);
                return null;
        }
        // If we reach here, no conversion was possible
        console.warn("Could not convert data to the target type.");
        return null;
    }
    /**
     * Clones an existing series into a new series of a specified type.
     *
     * @param series - The series to clone.
     * @param type - The target type for the cloned series.
     * @param options - Additional options to merge with default options.
     * @returns The cloned series, or null if cloning fails.
     */
    function cloneSeriesAsType(series, handler, type, options) {
        try {
            const defaultOptions = getDefaultSeriesOptions(type);
            const mergedOptions = { ...defaultOptions, ...options };
            let clonedSeries;
            console.log(`Cloning ${series.seriesType()} as ${type}...`);
            // Create the new series using a handler pattern you already have
            switch (type) {
                case 'Line':
                    clonedSeries = handler.createLineSeries(type, mergedOptions);
                    break;
                case 'Histogram':
                    clonedSeries = handler.createHistogramSeries(type, mergedOptions);
                    break;
                case 'Area':
                    clonedSeries = handler.createAreaSeries(type, mergedOptions);
                    break;
                case 'Bar':
                    clonedSeries = handler.createBarSeries(type, mergedOptions);
                    break;
                case 'Candlestick':
                    clonedSeries = {
                        name: options.name,
                        series: handler.createCandlestickSeries(),
                    };
                    break;
                case 'Ohlc':
                    clonedSeries = handler.createCustomOHLCSeries(type, mergedOptions);
                    break;
                default:
                    console.error(`Unsupported series type: ${type}`);
                    return null;
            }
            // ---------------------------
            // Use convertDataItem() to transform the existing data
            // ---------------------------
            const originalData = series.data();
            // Convert each bar in the original series
            let transformedData = originalData
                .map((_, i) => convertDataItem(series, type, i))
                .filter((item) => item !== null);
            // Apply the transformed data to the newly created series
            clonedSeries.series.setData(transformedData);
            // Hide the original series
            series.applyOptions({ visible: false });
            // ---------------------------
            // Subscribe to data changes on the original to keep the clone updated
            // ---------------------------
            series.subscribeDataChanged(() => {
                const updatedData = series.data();
                const newTransformed = updatedData
                    .map((_, i) => convertDataItem(series, type, i))
                    .filter((item) => item !== null);
                clonedSeries.series.setData(newTransformed);
                console.log(`Updated synced series of type ${type}`);
            });
            return clonedSeries.series;
        }
        catch (error) {
            console.error('Error cloning series:', error);
            return null;
        }
    }
    // series-types.ts
    var SeriesTypeEnum;
    (function (SeriesTypeEnum) {
        SeriesTypeEnum["Line"] = "Line";
        SeriesTypeEnum["Histogram"] = "Histogram";
        SeriesTypeEnum["Area"] = "Area";
        SeriesTypeEnum["Bar"] = "Bar";
        SeriesTypeEnum["Candlestick"] = "Candlestick";
        SeriesTypeEnum["Ohlc"] = "Ohlc";
        SeriesTypeEnum["Trade"] = "Trade";
    })(SeriesTypeEnum || (SeriesTypeEnum = {}));
    // A helper that, given a “default” object, picks only those keys 
    // from an incoming options object that are present in the default.
    function pickCommonOptions(defaults, opts) {
        const result = {};
        for (const key in defaults) {
            if (Object.prototype.hasOwnProperty.call(opts, key)) {
                result[key] = opts[key];
            }
        }
        return result;
    }
    function ensureExtendedSeries(series, legend // Assuming `Legend` is the type of the legend instance
    ) {
        // Type guard to check if the series is already extended
        const isExtendedSeries = (series) => {
            return series.primitives !== undefined;
        };
        // If the series is already extended, return it
        if (isExtendedSeries(series)) {
            return series;
        }
        // Otherwise, decorate the series dynamically
        console.log("Decorating the series dynamically.");
        return decorateSeries(series, legend);
    }
    function decorateSeriesAsIndicator(series, sourceSeries, ind, figures, figureCount, paramMap, recalculateIndicator) {
        const indicatorSeries = Object.assign(series, {
            sourceSeries,
            indicator: ind,
            figures,
            paramMap,
            figureCount, // NEW: stores the global figure count
            recalculate: function (overrides) {
                recalculateIndicator(this, overrides);
            },
        });
        // Subscribe to data changes on the source series to trigger automatic recalculation.
        if (typeof sourceSeries.subscribeDataChanged === "function") {
            sourceSeries.subscribeDataChanged(() => {
                if (sourceSeries.data()[sourceSeries.data().length - 1].time > series.data()[series.data().length - 1].time) {
                    recalculateIndicator(indicatorSeries);
                }
            });
        }
        return indicatorSeries;
    }
    function recalculateIndicator(indicatorSeries, overrides) {
        // Merge new overrides into the stored parameters to get the current parameters.
        const updatedParams = { ...indicatorSeries.paramMap, ...overrides };
        // Retrieve the source series data.
        const rawData = [...indicatorSeries.sourceSeries.data()];
        if (!rawData || !Array.isArray(rawData) || rawData.length === 0) {
            return;
        }
        // If the raw data is already in OHLC format, use it;
        // otherwise, convert each data point using singleToOhlcData.
        let data;
        if (rawData.every(isOHLCData)) {
            data = rawData;
        }
        else {
            data = rawData.map(singleToOhlcData);
        }
        // Run the indicator's calculation with the updated parameters.
        const newFigures = indicatorSeries.indicator.calc(data, updatedParams);
        // For each calculated figure, update the corresponding series if it exists.
        newFigures.forEach((newFigure) => {
            const existingSeries = indicatorSeries.figures.get(newFigure.key);
            if (existingSeries) {
                existingSeries.setData(newFigure.data);
                existingSeries.applyOptions({ title: newFigure.title });
                if (newFigure.pane) {
                    // Check if the current pane of the series is the same as the source series' pane.
                    if (existingSeries.getPane() === indicatorSeries.sourceSeries.getPane()) {
                        const currentPane = existingSeries.getPane();
                        const paneIndex = currentPane.paneIndex(); // Call the function to get a number
                        existingSeries.moveToPane(paneIndex + newFigure.pane);
                    }
                }
            }
        });
        // Store the current (merged) parameters for future recalculations.
        indicatorSeries.paramMap = updatedParams;
    }
    /**
     * Converts a SingleValueData object to an OhlcData object by assigning
     * the `value` property to the open, high, low, and close prices.
     *
     * @param data - The single value data point.
     * @returns An OhlcData object with open, high, low, and close set to data.value.
     */
    function singleToOhlcData(data) {
        return {
            time: data.time,
            open: data.value,
            high: data.value,
            low: data.value,
            close: data.value,
        };
    }

    function setLineStyle(ctx, style) {
        const dashPatterns = {
            [lightweightCharts.LineStyle.Solid]: [],
            [lightweightCharts.LineStyle.Dotted]: [ctx.lineWidth, ctx.lineWidth],
            [lightweightCharts.LineStyle.Dashed]: [2 * ctx.lineWidth, 2 * ctx.lineWidth],
            [lightweightCharts.LineStyle.LargeDashed]: [6 * ctx.lineWidth, 6 * ctx.lineWidth],
            [lightweightCharts.LineStyle.SparseDotted]: [ctx.lineWidth, 4 * ctx.lineWidth],
        };
        const dashPattern = dashPatterns[style];
        ctx.setLineDash(dashPattern);
    }

    const defaultSequenceOptions = {
        visible: true,
        autoScale: false,
        xScaleLock: false,
        yScaleLock: false,
        color: '#737375',
        lineWidth: 1,
        upColor: 'rgba(0,255,0,.25)',
        downColor: 'rgba(255,0,0,.25)',
        wickVisible: true,
        borderVisible: true,
        borderColor: '#737375',
        borderUpColor: '#1c9d1c',
        borderDownColor: '#d5160c',
        wickColor: '#737375',
        wickUpColor: '#1c9d1c',
        wickDownColor: '#d5160c',
        radius: 100,
        shape: 'Rounded',
        chandelierSize: 1,
        barSpacing: 0.7,
        lineStyle: 0,
        lineColor: '#ffffff',
        width: 1,
    };
    /* ============================================================================
      HELPER CLASS: Sequence
    ============================================================================ */
    /**
     * The Sequence class now slices the data ONLY ONCE in the constructor
     * (using _originalP1, _originalP2). Then it applies scale/shift to that
     * already-sliced data whenever p1 or p2 changes.
     */
    class Sequence {
        handler;
        get data() {
            return this.convertAndAggregateDataPoints();
        }
        get sourceData() {
            return this._originalData;
        }
        _originalP1;
        _originalP2;
        _barWidth = 0.8;
        p1;
        p2;
        _options;
        series;
        _originalData = [];
        _originalSlice = [];
        offset;
        /**
         * This array holds only the slice from _originalP1 to _originalP2,
         * so we never repeatedly slice the entire series data again.
         */
        onComplete;
        get spatial() {
            return this.recalculateSpatial();
        }
        transform = {
            scale: { x: 1, y: 1 },
            shift: { x: 0, y: 0 }
        };
        constructor(handler, series, p1, p2, options, pOffset) {
            this.handler = handler;
            this._options = { ...options, ...defaultSequenceOptions };
            let left, right;
            if (Math.min(p1.logical, p2.logical) === p1.logical) {
                left = p1;
                right = p2;
            }
            else {
                left = p2;
                right = p1;
            }
            this._originalP1 = { ...left };
            this._originalP2 = { ...right };
            this.offset = pOffset ?? 0;
            this.p1 = p1;
            this.p2 = p2;
            if (isISeriesApi(series)) {
                this.series = series;
                this._originalData = this.series.data().map((data, index) => ({
                    ...data,
                    x1: index,
                    x2: index
                }));
            }
            else {
                this.series = this.handler.series || this.handler._seriesList[0];
                this._originalData = series._originalData;
            }
            /**
             * We find the min and max of the original points' logical indexes
             * and slice the data range. We store that in _originalData so subsequent
             * calls only transform, not re-slice.
             */
            const x1 = Math.min(this._originalP1.logical, this._originalP2.logical);
            const x2 = Math.max(this._originalP1.logical, this._originalP2.logical);
            if (pOffset && pOffset > 0) {
                this._originalSlice = this._originalData.slice(x2, Math.min(this.series.data().length - 1, x2 + 1 + pOffset));
                console.log("Data Sliced with Offset", x1, x2, pOffset, "Offset Point:", Math.min(this.series.data().length - 1, x2 + 1 + pOffset));
            }
            else {
                this._originalSlice = this._originalData.slice(x1, x2 + 1);
                console.log("Data Sliced:", x1, x2);
            }
            // If a pOffset is provided, adjust each bar in the slice by adding the offset to x1 and x2.
            if (pOffset && pOffset > 0) {
                this._originalSlice = this._originalSlice.map((bar) => ({
                    ...bar,
                    x1: bar.x1 + pOffset,
                    x2: bar.x2 + pOffset
                }));
                console.log("Adjusted originalSlice with pOffset:", pOffset);
            }
            // Adjust this once initially
            this.transform = this.recalculateSpatial();
            if (this.p1 && this.p2) {
                this.setPoints(this.p1, this.p2);
            }
        }
        setData(data) {
            this._originalSlice = data;
        }
        setPoints(p1, p2) {
            let left, right;
            if (Math.min(p1.logical, p2.logical) === p1.logical) {
                left = p1;
                right = p2;
            }
            else {
                left = p2;
                right = p1;
            }
            if (this._originalP1 === null) {
                this._originalP1 = { ...left };
                console.log('First point (p1) set:', this._originalP1);
            }
            else if (this._originalP2 === null) {
                this._originalP2 = { ...right };
                console.log('Second point (p2) set:', this._originalP2);
            }
            this.p1 = left;
            this.p2 = right;
            this.recalculateSpatial(); // Ensure we just recalc scale/shift
            this.processSequence();
        }
        updatePoint(pointIndex, newPoint) {
            if (pointIndex === 1) {
                this.p1 = newPoint;
            }
            else if (pointIndex === 2) {
                if (!this._originalP2) {
                    this._originalP2 = newPoint;
                }
                this.p2 = newPoint;
            }
            this.recalculateSpatial(); // Ensure we just recalc scale/shift
            this.processSequence();
        }
        recalculateSpatial() {
            if (!this.p1 || !this.p2 || !this._originalP1 || !this._originalP2) {
                console.warn('Cannot recalc spatial without valid p1/p2.');
                return {
                    scale: { x: 1, y: 1 },
                    shift: { x: 0, y: 0 }
                };
            }
            const dxOrig = Math.abs(this._originalP1.logical - this._originalP2.logical);
            const dyOrig = Math.abs(this._originalP1.price - this._originalP2.price);
            if (dxOrig === 0 || dyOrig === 0) {
                console.warn('Cannot recalc scale if original points are zero difference.');
                return {
                    scale: { x: 1, y: 1 },
                    shift: { x: 0, y: 0 }
                };
            }
            const dxNew = Math.abs(this.p1.logical - this.p2.logical);
            const dyNew = ((this._originalP2.price > this._originalP1.price ? this.p2.price : this.p1.price)
                - (this._originalP2.price > this._originalP1.price ? this.p1.price : this.p2.price));
            const scaleX = dxNew / dxOrig;
            const scaleY = dyNew / dyOrig;
            if (!this._options.xScaleLock) {
                this.transform.scale.x = scaleX;
            }
            if (!this._options.yScaleLock) {
                this.transform.scale.y = scaleY;
            }
            if (this._options.autoScale) {
                if (scaleX > -1 && scaleX < 1) {
                    this._options.chandelierSize = Math.abs(Math.ceil(1 / scaleX));
                }
            }
            const spatial = {
                scale: {
                    x: scaleX !== 0 ? Math.round(scaleX * 100) / 100 : 1,
                    y: scaleY !== 0 ? Math.round(scaleY * 100) / 100 : 1
                },
                shift: {
                    x: (this._originalP1.logical - this.p1.logical),
                    y: this._originalP1.price - this.p1.price
                }
            };
            this._barWidth = Math.abs(this.p1.logical - this.p2.logical) / this._originalData.length;
            console.log('Spatial recalculated:', 'scaleX=', spatial.scale.x, 'scaleY=', spatial.scale.y, 'shiftX=', spatial.shift.x, 'shiftY=', spatial.shift.y);
            if (spatial.scale.x === 0 || spatial.scale.y === 0) {
                console.warn('Scale factors cannot be zero.');
                return {
                    scale: { x: 1, y: 1 },
                    shift: { x: 0, y: 0 }
                };
            }
            return spatial;
        }
        processSequence() {
            if (!this.p1 || !this.p2) {
                console.warn('Cannot process sequence without valid p1/p2.');
                return;
            }
            this.convertAndAggregateDataPoints(); // Simply triggers the creation of data
            if (this.onComplete) {
                this.onComplete();
            }
        }
        convertAndAggregateDataPoints() {
            // 1) Find min/max among all relevant fields (open, high, etc.) in _originalSlice
            let dataMin = Number.POSITIVE_INFINITY;
            let dataMax = Number.NEGATIVE_INFINITY;
            const transform = { ...this.spatial };
            this._originalSlice.forEach(orig => {
                // We check whichever fields matter to you: open, high, low, close, value...
                const values = [];
                if (orig.open !== undefined) {
                    values.push(orig.open);
                }
                if (orig.high !== undefined) {
                    values.push(orig.high);
                }
                if (orig.low !== undefined) {
                    values.push(orig.low);
                }
                if (orig.close !== undefined) {
                    values.push(orig.close);
                }
                if (orig.value !== undefined) {
                    values.push(orig.value);
                }
                for (const v of values) {
                    if (v < dataMin)
                        dataMin = v;
                    if (v > dataMax)
                        dataMax = v;
                }
            });
            // If dataMin===dataMax, ensure dataRange is 1 so we avoid dividing by 0
            const dataRange = (dataMax === dataMin) ? 1 : (dataMax - dataMin);
            // 2) The base X origin is (originalP1.logical + shift.x)
            //    We rely on `index` for local indexing in the already-sliced data.
            const originX = this.p1.logical;
            // 3) Map each item, normalizing its Y fields into [0..1], then scaling
            const dataPoints = this._originalSlice.map((orig, index) => {
                // X dimension logic
                const barX = originX + index;
                // Y dimension logic with min–max normalization
                function normalizeY(val, spatial) {
                    if (val === undefined)
                        return undefined;
                    const rel = (val - dataMin) / dataRange; // yields 0..1
                    // Then we scale by (spatial.scale.y * dataRange) and add spatial.shift.y
                    return (dataMin - spatial.shift.y) + (rel * spatial.scale.y * dataRange);
                }
                // Apply normalization to each relevant field
                const openPrice = normalizeY(orig.open, transform);
                const closePrice = normalizeY(orig.close, transform);
                const highPrice = normalizeY(orig.high, transform);
                const lowPrice = normalizeY(orig.low, transform);
                const valuePrice = normalizeY(orig.value, transform);
                // Decide if we have OHLC or single-value
                if (openPrice !== undefined ||
                    closePrice !== undefined ||
                    highPrice !== undefined ||
                    lowPrice !== undefined) {
                    // This bar is OHLC data
                    const isUp = (closePrice ?? 0) > (openPrice ?? 0);
                    // Construct your color/border/wick logic
                    const color = isUp
                        ? (this._options.upColor || 'rgba(0,255,0,0.333)')
                        : (this._options.downColor || 'rgba(255,0,0,0.333)');
                    const borderColor = isUp
                        ? (this._options.borderUpColor || setOpacity(color, 1))
                        : (this._options.borderDownColor || setOpacity(color, 1));
                    const wickColor = isUp
                        ? (this._options.wickUpColor || borderColor)
                        : (this._options.wickDownColor || borderColor);
                    // You might compute lineStyle, lineWidth, shape, etc. for each bar if needed
                    // For now, let's keep it simpler and not mention "bucket" here.
                    // (bucket logic is in your aggregator below.)
                    return {
                        open: openPrice,
                        close: closePrice,
                        high: highPrice,
                        low: lowPrice,
                        isUp,
                        x1: barX + this.offset,
                        x2: barX + this.offset,
                        isInProgress: false,
                        originalData: { ...orig, x1: index },
                        barSpacing: this._barWidth,
                        // Optional style fields
                        color,
                        borderColor,
                        wickColor,
                        lineStyle: this._options.lineStyle,
                        lineWidth: this._options.lineWidth,
                        shape: this._options.shape ?? 'Rounded'
                    };
                }
                else {
                    // Single-value data
                    // If your single-value doesn't need normalization, you could skip that step,
                    // but here we use `valuePrice`.
                    return {
                        value: valuePrice,
                        isUp: undefined,
                        x1: barX + this.offset,
                        x2: barX + this.offset,
                        isInProgress: false,
                        originalData: orig,
                        barSpacing: this._options.barSpacing ?? 0.8
                    };
                }
            });
            // 4) Optional aggregator step (e.g., chandelier)
            const groupSize = this._options.chandelierSize ?? 1;
            if (groupSize <= 1) {
                return dataPoints;
            }
            const aggregatedBars = [];
            for (let i = 0; i < dataPoints.length; i += groupSize) {
                const bucket = dataPoints.slice(i, i + groupSize);
                if (bucket.length === 0)
                    continue;
                const isInProgress = bucket.length < groupSize && (i + bucket.length === dataPoints.length);
                const aggregatedBar = this._chandelier(bucket, isInProgress, groupSize);
                aggregatedBars.push(aggregatedBar);
            }
            return aggregatedBars;
        }
        _chandelier(bucket, isInProgress = false, chandelierSize) {
            if (bucket.length === 0) {
                throw new Error('Bucket cannot be empty in _chandelier method.');
            }
            const aggregatedx1 = bucket[0].x1;
            const aggregatedx2 = bucket[bucket.length - 1].x2;
            // If it's an OHLC bucket:
            if (bucket[0].originalData?.open !== undefined) {
                const openPrice = bucket[0].open ?? 0;
                const closePrice = bucket[bucket.length - 1].close ?? 0;
                const highPrice = bucket.reduce((acc, cur) => Math.max(acc, cur.high || 0), 0);
                const lowPrice = bucket.reduce((acc, cur) => Math.min(acc, cur.low || Infinity), Infinity);
                const isUp = closePrice > openPrice;
                const color = isUp
                    ? this._options.upColor || 'rgba(0,255,0,0.333)'
                    : this._options.downColor || 'rgba(255,0,0,0.333)';
                const borderColor = isUp
                    ? this._options.borderUpColor || setOpacity(color, 1)
                    : this._options.borderDownColor || setOpacity(color, 1);
                const wickColor = isUp
                    ? this._options.wickUpColor || borderColor
                    : this._options.wickDownColor || borderColor;
                const lineStyle = bucket.reduce((style, bar) => bar.lineStyle ?? bar.originalData?.lineStyle ?? style, this._options.lineStyle);
                const lineWidth = bucket.reduce((currentWidth, bar) => bar.lineWidth ?? bar.originalData?.lineWidth ?? currentWidth, this._options.lineWidth ?? 1);
                const shape = this._options.shape ?? "Rounded";
                return {
                    open: openPrice,
                    high: highPrice,
                    low: lowPrice,
                    close: closePrice,
                    isUp,
                    x1: aggregatedx1,
                    x2: aggregatedx2,
                    isInProgress,
                    color,
                    borderColor,
                    wickColor,
                    shape,
                    lineStyle,
                    lineWidth
                };
            }
            else {
                // Single-value version for aggregation.
                const openVal = bucket[0].value ?? 0;
                const closeVal = bucket[bucket.length - 1].value ?? 0;
                const isUp = closeVal > openVal;
                const color = isUp
                    ? this._options.upColor || 'rgba(0,255,0,0.333)'
                    : this._options.downColor || 'rgba(255,0,0,0.333)';
                const borderColor = isUp
                    ? this._options.borderUpColor || setOpacity(color, 1)
                    : this._options.borderDownColor || setOpacity(color, 1);
                isUp
                    ? this._options.wickUpColor || borderColor
                    : this._options.wickDownColor || borderColor;
                const lineStyle = bucket.reduce((style, bar) => bar.lineStyle ?? bar.originalData?.lineStyle ?? style, this._options.lineStyle);
                const lineWidth = bucket.reduce((currentWidth, bar) => bar.lineWidth ?? bar.originalData?.lineWidth ?? currentWidth, this._options.lineWidth ?? 1);
                this._options.shape ?? "Rounded";
                return {
                    value: openVal,
                    isUp,
                    x1: aggregatedx1,
                    x2: aggregatedx2,
                    color,
                    lineStyle,
                    lineWidth
                };
            }
        }
        applyOptions(options) {
            this._options = {
                ...this._options,
                ...options,
            };
            this.processSequence();
        }
    }

    /* ============================================================================
      TYPE & INTERFACE DEFINITIONS
    ============================================================================ */
    /* ============================================================================
      TRENDTRACE PLUGIN CLASS
    ============================================================================ */
    class TrendTrace extends PluginBase {
        _type = "TrendTrace";
        _paneViews;
        _sequence;
        _options;
        _state = InteractionState.NONE;
        _handler;
        _source;
        _originalP1 = null;
        _originalP2 = null;
        p1 = null;
        p2 = null;
        _points = [];
        title = "";
        static _type = "Trend-Trace";
        _startDragPoint = null;
        _latestHoverPoint = null;
        static _mouseIsDown = false;
        static hoveredObject = null;
        static lastHoveredObject = null;
        _listeners = [];
        _hovered = false;
        constructor(handler, source, p1, p2, options, pOffset) {
            super();
            this._handler = handler;
            this._source = source;
            // Initialize original points
            this._originalP1 = { ...p1 };
            this._originalP2 = { ...p2 };
            const sourceOptions = this._source.options();
            // Step 2. Filter both seriesOpts and the explicit options to include only keys
            // that exist in our default options.
            const filteredSeriesOpts = pickCommonOptions(defaultSequenceOptions, sourceOptions);
            // Merge in order: defaults < series options < explicit options.
            this._options = {
                ...filteredSeriesOpts,
                ...options,
            };
            // Create and store the sequence
            this._sequence = this._createSequence({ p1, p2 }, this._options, pOffset);
            this.p1 = this._sequence.p1;
            this.p2 = this._sequence.p2;
            // Initialize pane views
            // this._hovered = false
            // Subscribe to chart or global events
            this._subscribeEvents();
            this._paneViews = [new TrendTracePaneView(this)];
        }
        /**
         * Serializes the Sequence instance to a JSON object.
         *
         * @returns An object representing the Sequence data and options.
         */
        toJSON() {
            return {
                data: this._sequence.data,
                p1: this._sequence._originalP1,
                p2: this._sequence._originalP2,
                options: this._sequence._options,
            };
        }
        /**
         * Deserializes a JSON object to update the current Sequence instance.
         *
         * @param json - The JSON object containing optional Sequence data and options.
         */
        fromJSON(json) {
            // If data is provided, update the sequence's data.
            if (json.data) {
                this._sequence.setData(json.data);
            }
            if (json.options) {
                // Cast json.options as a generic record to satisfy the index signature.
                const options = json.options;
                for (const key in options) {
                    if (Object.prototype.hasOwnProperty.call(options, key)) {
                        // Cast key to keyof SequenceOptions.
                        const typedKey = key;
                        this.applyOptions({ [typedKey]: options[typedKey] });
                    }
                }
            }
            // Optionally update the logical points if provided.
            if (json.p1) {
                this.p1 = json.p1;
            }
            if (json.p2) {
                this.p2 = json.p2;
            }
        }
        // ...existing code...
        attached(params) {
            super.attached(params);
            if (this._originalP1 && this._originalP2) {
                this._createSequence({ p1: this._originalP1, p2: this._originalP2 });
            }
            this._source = ensureExtendedSeries(params.series, this._handler.legend);
            this.title = params.series.options().title;
            // Call the function to get the class and then instantiate it
            const HorzScaleBehaviorClass = lightweightCharts.defaultHorzScaleBehavior();
            const horzScaleBehaviorInstance = new HorzScaleBehaviorClass();
            return {
                chart: params.chart,
                series: params.series,
                requestUpdate: params.requestUpdate,
                horzScaleBehavior: horzScaleBehaviorInstance
            };
        }
        // ...existing code...
        paneViews() {
            return this._paneViews;
        }
        detached() {
            super.detached();
            // Clear all event listeners
            this._listeners.forEach(({ name, listener }) => {
                document.body.removeEventListener(name, listener);
            });
            // Reset the listeners array
            this._listeners = [];
            // Unsubscribe from chart events
            if (this._handler?.chart) {
                this._handler.chart.unsubscribeCrosshairMove(this._handleMouseMove);
                this._handler.chart.unsubscribeClick(this._handleMouseDownOrUp);
            }
            // Clear references
            this._paneViews = [];
            this._sequence = null;
            this._options = null;
            this._source = null;
            this._originalP1 = null;
            this._originalP2 = null;
            this.p1 = null;
            this.p2 = null;
            console.log("✅ All listeners and references successfully detached.");
        }
        _createSequence(source, options, offset) {
            let sequence;
            if ('p1' in source && 'p2' in source) {
                sequence = new Sequence(this._handler, this._source, source.p1, source.p2, options ?? this._options, offset);
                sequence.onComplete = () => this.updateViewFromSequence();
                this.updateViewFromSequence();
                return sequence;
            }
            else {
                sequence = new Sequence(this._handler, source.data, source.data._originalP1, source.data._originalP2, options ?? this._options, offset);
                sequence.onComplete = () => this.updateViewFromSequence();
                this.updateViewFromSequence();
                return sequence;
            }
        }
        applyOptions(options) {
            // Destructure to separate spatial properties from all other options.
            // We assume that the spatial properties (if any) are provided under the keys "scale" and "shift".
            // The rest of the properties are our sequence options.
            // Update our options: only the explicitly provided fields are merged.
            this._options = {
                ...this._options,
                ...options,
            };
            // Relay the changes to our underlying sequence.
            if (this._sequence) {
                this._sequence.applyOptions(this._options);
            }
            // Finally, trigger an update (or reprocess the sequence).
            this.requestUpdate();
        }
        _pendingUpdate = false;
        updateViewFromSequence() {
            if (!this._pendingUpdate) {
                this._pendingUpdate = true;
                requestAnimationFrame(() => {
                    super.requestUpdate();
                    console.log("Updating view with sequence data:", this._sequence?.data);
                    this._pendingUpdate = false;
                });
            }
        }
        getOptions() {
            return this._options;
        }
        /**
         * Subscribe to relevant events, e.g. crosshair move, chart click.
         * If your framework differs, adapt accordingly.
         */
        _subscribeEvents() {
            this._handler.chart.subscribeCrosshairMove(this._handleMouseMove);
            this._handler.chart.subscribeClick(this._handleMouseDownOrUp);
        }
        /** Use the local methods to subscribe/unsubscribe from DOM events if needed. */
        _subscribe(name, listener) {
            document.body.addEventListener(name, listener);
            this._listeners.push({ name, listener });
        }
        _unsubscribe(name, callback) {
            document.body.removeEventListener(name, callback);
            const toRemove = this._listeners.find((x) => x.name === name && x.listener === callback);
            this._listeners.splice(this._listeners.indexOf(toRemove), 1);
        }
        _handleHoverInteraction(param) {
            this._latestHoverPoint = param.point;
            if (TrendTrace._mouseIsDown) {
                this._handleDragInteraction(param);
            }
            else {
                if (this._mouseIsOverSequence(param)) {
                    if (this._state != InteractionState.NONE)
                        return;
                    this._moveToState(InteractionState.HOVERING);
                    TrendTrace.hoveredObject = TrendTrace.lastHoveredObject = this;
                }
                else {
                    if (this._state == InteractionState.NONE)
                        return;
                    this._moveToState(InteractionState.NONE);
                    if (TrendTrace.hoveredObject === this)
                        TrendTrace.hoveredObject = null;
                }
            }
        }
        /**
         * A pseudo-click handler that toggles mouseDown state
         * If user is already down, we finalize a mouse up, etc.
         */
        _handleMouseDownOrUp = () => {
            // If we're not "over" anything, do nothing
            if (!this._latestHoverPoint) {
                return;
            }
            TrendTrace._mouseIsDown = !TrendTrace._mouseIsDown;
            if (TrendTrace._mouseIsDown) {
                // Mouse just went down => set DRAGGING or DRAGGING_P1 or DRAGGING_P2
                this._onMouseDown();
            }
            else {
                // Mouse just went up => finalize the drag
                this._onMouseUp();
            }
        };
        /**
         * A pseudo-mouse-move/crosshair-move handler
         * We do hover detection or if mouse is down, do drag.
         */
        _handleMouseMove = (param) => {
            const mousePoint = this._eventToPoint(param, this._source);
            this._latestHoverPoint = mousePoint;
            if (TrendTrace._mouseIsDown) {
                // If user is dragging
                this._handleDragInteraction(param);
            }
            else {
                // Check if user is near p1/p2 or inside the "body"
                if (this._mouseIsOverPoint(param, 1) ||
                    this._mouseIsOverPoint(param, 2)) {
                    if (this._state === InteractionState.NONE) {
                        this._moveToState(InteractionState.HOVERING);
                    }
                }
                else if (this._mouseIsOverSequence(param)) {
                    if (this._state === InteractionState.NONE) {
                        this._moveToState(InteractionState.HOVERING);
                    }
                }
                else {
                    // Not over anything
                    if (this._state !== InteractionState.NONE) {
                        this._moveToState(InteractionState.NONE);
                    }
                }
            }
        };
        _onMouseUp() {
            TrendTrace._mouseIsDown = false;
            this.chart.applyOptions({ handleScroll: true });
            this._moveToState(InteractionState.HOVERING);
            this._startDragPoint = null;
        }
        _handleDragInteraction(param) {
            if (this._state !== InteractionState.DRAGGING &&
                this._state !== InteractionState.DRAGGINGP1 &&
                this._state !== InteractionState.DRAGGINGP2) {
                return;
            }
            const mousePoint = this._eventToPoint(param, this.series);
            if (!mousePoint || !this._startDragPoint)
                return;
            // Compute difference
            const diff = this._getDiff(mousePoint, this._startDragPoint);
            // Apply the difference to p1 or p2 or entire shape
            this._onDrag(diff);
            this._startDragPoint = mousePoint; // update reference
            this.requestUpdate();
        }
        _mouseIsOverPoint(param, which) {
            // Define a tolerance factor (e.g., 5% of the pane width/height)
            const toleranceFactor = 0.05;
            // Determine which target canvas point to check (p1 or p2)
            const targetCanvasPoint = which === 1
                ? { x: this._paneViews[0]._p1.x, y: this._paneViews[0]._p1.y }
                : { x: this._paneViews[0]._p2.x, y: this._paneViews[0]._p2.y };
            // Ensure chart is defined.
            if (!this.chart)
                return false;
            // Use the isPointCloseCanvas function
            return isPointCloseCanvas(param, targetCanvasPoint, toleranceFactor, this.chart);
        }
        _mouseIsOverSequence(param) {
            // Validate the presence of necessary properties in param
            if (!param.logical || !param.point) {
                console.warn('Invalid MouseEventParams: Missing logical or point.');
                return false;
            }
            // Convert the Y-coordinate of the mouse point to a price
            const mousePrice = this._source.coordinateToPrice?.(param.point.y);
            if (mousePrice == null) {
                console.warn('Mouse price could not be determined.');
                return false;
            }
            // Attempt to find the corresponding bar by time
            let bar = param.time
                ? this._sequence.data.find((d) => d.time === param.time)
                : undefined;
            // If no bar is found by time, attempt to find by logical
            if (!bar) {
                bar = this._sequence.data.find((d) => Math.round(d.x1) === Math.round(param.logical));
            }
            // If no matching bar is found, return false
            if (!bar) {
                console.warn('No matching bar found for the given parameters.');
                return false;
            }
            // Check if the mouse price is within the bar's price range
            if (bar.low != null && bar.high != null) {
                // Apply a small tolerance to account for minor discrepancies
                const tolerance = (bar.high - bar.low) * 0.05;
                return mousePrice >= bar.low - tolerance && mousePrice <= bar.high + tolerance;
            }
            // For single-value data, apply a 5% tolerance
            if (bar.value != null) {
                const tolerance = bar.value * 0.05;
                return mousePrice >= bar.value - tolerance && mousePrice <= bar.value + tolerance;
            }
            // If bar lacks necessary price information, return false
            console.warn('Bar lacks price information.');
            return false;
        }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._hovered = false;
                    this.requestUpdate();
                    this._unsubscribe("mousedown", this._handleMouseDownInteraction);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._hovered = true;
                    this.requestUpdate();
                    this._subscribe("mousedown", this._handleMouseDownInteraction);
                    this._unsubscribe("mouseup", this._handleMouseDownInteraction);
                    this.chart.applyOptions({ handleScroll: true });
                    break;
                case InteractionState.DRAGGINGP1:
                case InteractionState.DRAGGINGP2:
                case InteractionState.DRAGGING:
                    document.body.style.cursor = "grabbing";
                    this._subscribe("mouseup", this._handleMouseUpInteraction);
                    this.chart.applyOptions({ handleScroll: false });
                    break;
            }
            this._state = state;
        }
        _addDiffToPoint(point, logicalDiff, priceDiff) {
            if (!point)
                return;
            point.logical = (point.logical + logicalDiff);
            point.price = point.price + priceDiff;
            point.time = this.series.dataByIndex(point.logical)?.time || null;
        }
        _onDrag(diff) {
            if (this._state == InteractionState.DRAGGING ||
                this._state == InteractionState.DRAGGINGP1) {
                this._addDiffToPoint(this._sequence.p1, this._options.xScaleLock && this._state == InteractionState.DRAGGINGP1
                    ? 0
                    : diff.logical, this._options.yScaleLock && this._state == InteractionState.DRAGGINGP1
                    ? 0
                    : diff.price);
            }
            if (this._state == InteractionState.DRAGGING ||
                this._state == InteractionState.DRAGGINGP2) {
                this._addDiffToPoint(this._sequence.p2, this._options.xScaleLock && this._state == InteractionState.DRAGGINGP2
                    ? 0
                    : diff.logical, this._options.yScaleLock && this._state == InteractionState.DRAGGINGP2
                    ? 0
                    : diff.price);
            }
        }
        _onMouseDown() {
            this._startDragPoint = null;
            const hoverPoint = this._latestHoverPoint;
            if (!hoverPoint)
                return;
            const p1 = this._paneViews[0]._p1;
            const p2 = this._paneViews[0]._p2;
            if (!p1.x || !p2.x || !p1.y || !p2.y)
                return this._moveToState(InteractionState.DRAGGING);
            const tolerance = 20;
            if (Math.abs(hoverPoint.x - p1.x) < tolerance &&
                Math.abs(hoverPoint.y - p1.y) < tolerance) {
                this.chart.applyOptions({ handleScroll: false });
                this._moveToState(InteractionState.DRAGGINGP1);
            }
            else if (Math.abs(hoverPoint.x - p2.x) < tolerance &&
                Math.abs(hoverPoint.y - p2.y) < tolerance) {
                this.chart.applyOptions({ handleScroll: false });
                this._moveToState(InteractionState.DRAGGINGP2);
            }
            else {
                this.chart.applyOptions({ handleScroll: false });
                this._moveToState(InteractionState.DRAGGING);
            }
        }
        _handleMouseDownInteraction = () => {
            this._onMouseDown();
        };
        _handleMouseUpInteraction = () => {
            this._onMouseUp();
        };
        /**
         * Utility: diff in logical & price between two points
         */
        _getDiff(p1, p2) {
            return {
                logical: p1.logical - p2.logical,
                price: p1.price - p2.price,
            };
        }
        /**
         * Convert the mouse event to a LogicalPoint (with price).
         */
        _eventToPoint(param, series) {
            if (!series || !param.point || !param.logical)
                return null;
            const barPrice = series.coordinateToPrice(param.point.y);
            if (barPrice == null)
                return null;
            return {
                time: param.time || null,
                logical: param.logical,
                price: barPrice.valueOf(),
            };
        }
    }
    /* ============================================================================
      TRENDTRACE PANE VIEW
    ============================================================================ */
    class TrendTracePaneView {
        _p1 = { x: null, y: null };
        _p2 = { x: null, y: null };
        _plugin;
        constructor(plugin) {
            this._plugin = plugin;
        }
        renderer() {
            if (!this._plugin._sequence) {
                throw new Error("No sequence available for rendering.");
            }
            return new TrendTracePaneRenderer(this._plugin, this._plugin._options, false);
        }
    }
    class TrendTracePaneRenderer extends TwoPointDrawingPaneRenderer {
        _source;
        _options;
        constructor(source, options, hovered) {
            super(convertPoint(source._sequence.p1, source.chart, source._source), convertPoint(source._sequence.p2, source.chart, source._source), options, hovered);
            this._source = source;
            this._options = options;
        }
        draw(target) {
            target.useBitmapCoordinateSpace((scope) => {
                const ctx = scope.context;
                const { chart } = this._source;
                ctx.save();
                const { horizontalPixelRatio } = scope;
                const data = this._source._sequence.data;
                const timeScale = this._source.chart.timeScale();
                const series = this._source._source;
                const visibleRange = chart.timeScale().getVisibleLogicalRange();
                const barSpace = chart.options().width /
                    ((visibleRange?.to ?? data.length) - (visibleRange?.from ?? 0));
                console.log("barSpace:", barSpace);
                if (!series || !timeScale || data.length === 0) {
                    ctx.restore();
                    return;
                }
                const firstX = data[0].x1;
                const lastX = data[data.length - 1].x1;
                const canvasX1 = chart.timeScale().logicalToCoordinate(firstX) ?? 0;
                const canvasX2 = chart.timeScale().logicalToCoordinate(lastX) ?? canvasX1;
                const _firstX = canvasX1 * horizontalPixelRatio;
                const _lastX = canvasX2 * horizontalPixelRatio;
                const inverted = (this._source._sequence._originalP2.logical >
                    this._source._sequence._originalP1.logical &&
                    this._source._sequence.p2.logical >
                        this._source._sequence.p1.logical) ||
                    (this._source._sequence._originalP2.logical <
                        this._source._sequence._originalP1.logical &&
                        this._source._sequence.p2.logical <
                            this._source._sequence.p1.logical);
                const scaledBars = data
                    .map((bar, index) => {
                    const scaledX1 = _firstX +
                        (inverted ? 1 : -1) *
                            (index *
                                ((_lastX - _firstX) / data.length) *
                                this._source._sequence.spatial.scale.x);
                    const scaledX2 = _firstX +
                        (inverted ? 1 : -1) *
                            ((index + 1) *
                                ((_lastX - _firstX) / data.length) *
                                this._source._sequence.spatial.scale.x);
                    const color = !bar.isUp
                        ? inverted
                            ? this._options.downColor
                            : this._options.upColor
                        : inverted
                            ? this._options.upColor
                            : this._options.downColor;
                    const borderColor = !bar.isUp
                        ? inverted
                            ? this._options.borderDownColor
                            : this._options.borderUpColor
                        : inverted
                            ? this._options.borderUpColor
                            : this._options.borderDownColor;
                    const wickColor = !bar.isUp
                        ? inverted
                            ? this._options.wickDownColor
                            : this._options.wickUpColor
                        : inverted
                            ? this._options.wickUpColor
                            : this._options.wickDownColor;
                    // Include all required properties in the returned object
                    return {
                        ...bar,
                        scaledX1: inverted ? scaledX1 : scaledX2,
                        scaledX2: inverted ? scaledX2 : scaledX1,
                        color,
                        borderColor,
                        wickColor,
                    };
                })
                    .filter((bar) => bar !== null);
                console.log("Scaled bars:", scaledBars);
                // Continue with drawing logic using `scaledBars`...
                //const firstPoint = scaledBars[0];
                //const lastPoint = scaledBars[scaledBars.length - 1];
                if (this.isOHLCData(data)) {
                    if (this._options.wickVisible) {
                        this._drawWicks(scope, scaledBars, barSpace);
                    }
                    this._drawCandles(scope, scaledBars, barSpace);
                    //// Draw end circles
                    //this._drawEndCircle(
                    //	scope,
                    //	firstPoint.scaledX1,
                    //	series.priceToCoordinate(lastPoint.open??lastPoint.close??lastPoint.value??0) ??0 * verticalPixelRatio				);
                    //this._drawEndCircle(
                    //	scope,
                    //	lastPoint.scaledX2,
                    //	series.priceToCoordinate(lastPoint.close??lastPoint.open??lastPoint.value??0) ??0 * verticalPixelRatio
                    //);
                }
                else if (this.isSingleValueData(data)) {
                    this._drawSingleValueData(scope, scaledBars);
                    //// Draw end circles
                    //this._drawEndCircle(
                    //	scope,
                    //	firstPoint.scaledX1,
                    //	series.priceToCoordinate(firstPoint.value!) ?? 0 * verticalPixelRatio
                    //);
                    //this._drawEndCircle(
                    //	scope,
                    //	lastPoint.scaledX2,
                    //	series.priceToCoordinate(lastPoint.value!) ?? 0 * verticalPixelRatio
                    //);
                }
                ctx.restore();
            });
        }
        /**
         * Draws data points and connecting lines on the bitmap canvas.
         * Each point is drawn at its scaledX1 coordinate and the lines connect consecutive
         * points directly from scaledX1 to scaledX1.
         *
         * @param scope - Contains the canvas context and pixel ratios.
         * @param data - Array of data points with pre-calculated scaled coordinates.
         */
        _drawSingleValueData(scope, data) {
            const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = scope;
            // Set the line appearance once, before drawing
            ctx.lineWidth = this._options.lineWidth ?? 1;
            setLineStyle(ctx, (this._options.lineStyle ?? 1));
            ctx.strokeStyle = this._options.visible
                ? this._options.lineColor ?? "#ffffff"
                : "rgba(0,0,0,0)";
            ctx.beginPath();
            data.forEach((point) => {
                // Skip point if there's no valid logical x value.
                if (point.x1 === null || point.x1 === undefined)
                    return;
                // Calculate the current point's coordinates using scaledX1.
                const scaledX1 = point.scaledX1 * horizontalPixelRatio;
                const scaledValue = (this._source._source?.priceToCoordinate(point.value ?? 0) ?? 0) *
                    verticalPixelRatio;
                ctx.lineTo(scaledX1, scaledValue);
                ctx.stroke();
            });
        }
        _drawWicks(scope, bars, barSpace) {
            const { context: ctx, verticalPixelRatio } = scope;
            const inverted = (this._source._sequence._originalP2.price >
                this._source._sequence._originalP1.price &&
                this._source._sequence.p2.price > this._source._sequence.p1.price) ||
                (this._source._sequence._originalP2.price <
                    this._source._sequence._originalP1.price &&
                    this._source._sequence.p2.price < this._source._sequence.p1.price);
            bars.forEach((bar) => {
                const candleBodyWidth = (this._options.barSpacing ?? 0.8) * (bar.scaledX2 - bar.scaledX1);
                const leftSide = bar.scaledX1; //-  Math.abs((( candleWidth) * ((this._options.barSpacing ?? 0.8)))/2);
                const rightSide = leftSide + candleBodyWidth;
                const middle = (leftSide + rightSide) / 2; //const scaledHigh =
                //  (this._source.series.priceToCoordinate( (inverted? bar.high??0:bar.low??0)) ?? 0) *
                //  verticalPixelRatio;
                //const scaledLow =
                //  (this._source.series.priceToCoordinate((inverted?bar.low??0:bar.high??0)) ?? 0) *
                //  verticalPixelRatio;
                const scaledHigh = (this._source.series.priceToCoordinate(bar.high ?? 0) ?? 0) *
                    verticalPixelRatio;
                const scaledLow = (this._source.series.priceToCoordinate(bar.low ?? 0) ?? 0) *
                    verticalPixelRatio;
                // Calculate the top and bottom parts of the wick based on max(open, close) and min(open, close)
                const scaledOpen = (this._source.series.priceToCoordinate(bar.open ?? 0) ?? 0) *
                    verticalPixelRatio;
                const scaledClose = (this._source.series.priceToCoordinate(bar.close ?? 0) ?? 0) *
                    verticalPixelRatio;
                //const topWick = inverted
                //  ? Math.min(scaledOpen, scaledClose)
                //  : Math.max(scaledOpen, scaledClose);
                //const bottomWick = inverted
                //  ? Math.max(scaledOpen, scaledClose)
                //  : Math.min(scaledOpen, scaledClose);
                const topWick = inverted ? Math.min(scaledOpen, scaledClose) : Math.max(scaledOpen, scaledClose);
                const bottomWick = inverted ? Math.max(scaledOpen, scaledClose) : Math.min(scaledOpen, scaledClose);
                ctx.strokeStyle = this._options.visible
                    ? bar.wickColor ?? "#ffffff"
                    : "rgba(0,0,0,0)";
                // Draw the top wick (high to max(open, close))
                ctx.beginPath();
                ctx.moveTo(middle, scaledHigh);
                ctx.lineTo(middle, topWick);
                ctx.stroke();
                // Draw the bottom wick (min(open, close) to low)
                ctx.beginPath();
                ctx.moveTo(middle, bottomWick);
                ctx.lineTo(middle, scaledLow);
                ctx.stroke();
            });
        }
        _drawCandles(scope, bars, barSpace) {
            const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = scope;
            ctx.save();
            bars.forEach((bar) => {
                const candleBodyWidth = (this._options.barSpacing ?? 0.8) * (bar.scaledX2 - bar.scaledX1);
                if (!bar) {
                    return;
                }
                const scaledOpen = (this._source.series.priceToCoordinate(bar.open) ?? 0) *
                    verticalPixelRatio;
                const scaledClose = (this._source.series.priceToCoordinate(bar.close) ?? 0) *
                    verticalPixelRatio;
                const scaledHigh = (this._source.series.priceToCoordinate(bar.high) ?? 0) *
                    verticalPixelRatio;
                const scaledLow = (this._source.series.priceToCoordinate(bar.low) ?? 0) *
                    verticalPixelRatio;
                const isUp = scaledClose >= scaledOpen;
                const barVerticalMax = Math.min(scaledOpen, scaledClose);
                const barVerticalMin = Math.max(scaledOpen, scaledClose);
                const barVerticalSpan = barVerticalMax - barVerticalMin;
                const barY = (barVerticalMax + barVerticalMin) / 2;
                const leftSide = bar.scaledX1; //-  Math.abs((( candleWidth) * ((this._options.barSpacing ?? 0.8)))/2);
                const rightSide = leftSide + candleBodyWidth; // this._options.chandelierSize??1  > 1? 
                //leftSide +   (candleWidth*(this._options.chandelierSize??1 )) - Math.abs((((this._options.barSpacing ?? 0.8))*(candleWidth)))  : leftSide +  Math.abs(1-((this._options.barSpacing??0.8 * candleWidth)/2));
                const middle = (leftSide + rightSide) / 2; //const scaledHigh =
                ctx.fillStyle = this._options.visible
                    ? bar.color ?? "#ffffff"
                    : "rgba(0,0,0,0)";
                ctx.strokeStyle = this._options.visible
                    ? (this._options.borderVisible ? bar.borderColor : bar.color) ??
                        "#ffffff"
                    : "rgba(0,0,0,0)";
                ctx.lineWidth = bar.lineWidth ?? 1;
                setLineStyle(ctx, bar.lineStyle);
                const shape = this._options?.shape
                    || CandleShape.Rounded; // Use the enum value for defaults
                console.log("Selected candle shape:", shape);
                switch (shape) {
                    case CandleShape.Rectangle:
                        ohlcRectangle(ctx, leftSide, rightSide, barY, barVerticalSpan);
                        break;
                    case CandleShape.Rounded:
                        ohlcRounded(ctx, leftSide, rightSide, barY, barVerticalSpan, 5);
                        break;
                    case CandleShape.Ellipse:
                        ohlcEllipse(ctx, leftSide, rightSide, middle, barY, barVerticalSpan);
                        break;
                    case CandleShape.Arrow:
                        ohlcArrow(ctx, leftSide, rightSide, middle, barY, barVerticalSpan, scaledHigh, scaledLow, isUp);
                        break;
                    case CandleShape.Polygon:
                        ohlcPolygon(ctx, leftSide, rightSide, barY, barVerticalSpan, scaledHigh, scaledLow, isUp);
                        break;
                    case CandleShape.Bar:
                        ohlcBar(ctx, leftSide, rightSide, scaledHigh, scaledLow, scaledOpen, scaledClose);
                        break;
                    case 'Slanted':
                        // Add your newly created slanted candle.
                        ohlcSlantedCandle(ctx, leftSide, rightSide, barY, barVerticalSpan, bar.isUp);
                        break;
                    default:
                        console.warn(`Unknown shape '${shape}', using default Rectangle`);
                        ohlcRectangle(ctx, leftSide, rightSide, barY, barVerticalSpan);
                        break;
                }
                ctx.restore();
            });
        }
        _drawEndCircle(scope, x, y) {
            const ctx = scope.context;
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = this._options.visible
                ? this._options?.color ?? "#FF0000"
                : "rgba(0,0,0,0)";
            ctx.fill();
            ctx.strokeStyle = this._source._sequence._options.lineColor ?? "#000";
            ctx.stroke();
            ctx.restore();
        }
        isOHLCData(data) {
            return data.every((point) => point.open !== undefined &&
                point.high !== undefined &&
                point.low !== undefined &&
                point.close !== undefined);
        }
        isSingleValueData(data) {
            return data.every((point) => point.value !== undefined);
        }
    }

    /**
     * Given a target LogicalPoint, a tolerance factor (for example, 0.05 means 5%),
     * the chart, the series, and the current MouseEventParams, this function checks
     * whether the current mouse event is “close” to the target. The idea is to compute
     * the visible logical and price spans and then use the tolerance factor to derive a
     * threshold for each.
     *
     * @param target The LogicalPoint (for example, an endpoint) to test.
     * @param toleranceFactor A fraction (e.g. 0.05 for 5%) of the visible span.
     * @param chart The chart API.
     * @param series The series API used for the price conversion.
     * @param param The MouseEventParams from the chart.
     * @returns True if the mouse event’s logical and price are within the tolerance thresholds.
     */
    /**
     * Measures the visible pane size from the chart.
     */
    function _measurePaneSize(chart) {
        if (!chart)
            return null;
        const paneSize = chart.paneSize();
        return {
            width: paneSize.width,
            height: paneSize.height,
        };
    }
    /**
    * Converts MouseEventParams to canvas coordinates.
    */
    function eventToCanvasPoint(event, chart) {
        if (!event)
            return null;
        return {
            x: event.x,
            y: event.y,
        };
    }
    // Helper: convert the input (which may be MouseEventParams or a native MouseEvent)
    // to a CanvasPoint. If the input has a 'point' property already, we use that;
    // otherwise, if it’s a MouseEvent, we convert it.
    function getCanvasCoordinates(input, chart) {
        // Check if input is a native MouseEvent by testing for the existence
        // of the "target" property from the DOM event
        if (input instanceof MouseEvent) {
            return eventToCanvasPoint(input);
        }
        // Else, if it’s MouseEventParams and has a "point" property, assume that’s in canvas space.
        if ("point" in input && input.point) {
            return input.point;
        }
        return null;
    }
    /**
     * Determines if the target CanvasPoint is close to the mouse position within the tolerance factor.
     *
     * @param input - A MouseEvent or MouseEventParams object.
     * @param target - The CanvasPoint (or ViewPoint) to compare against.
     * @param toleranceFactor - Fraction of the visible spans (for example, 0.05 for 5%).
     * @param chart - The chart instance.
     * @returns True if within tolerance; otherwise, false.
     */
    function isPointCloseCanvas(input, target, toleranceFactor, chart) {
        const paneSize = _measurePaneSize(chart);
        if (!paneSize)
            return false;
        // Compute visible spans from the pane
        const visibleWidth = paneSize.width;
        const visibleHeight = paneSize.height;
        // Set tolerance thresholds (in canvas coordinate units)
        const xTolerance = visibleWidth * toleranceFactor;
        const yTolerance = visibleHeight * toleranceFactor;
        // Get the canvas point from the input
        const mousePoint = getCanvasCoordinates(input);
        if (!mousePoint || mousePoint.x == null || mousePoint.y == null ||
            target.x == null || target.y == null) {
            return false;
        }
        // Compute the differences in canvas space
        const dx = Math.abs(target.x - mousePoint.x);
        const dy = Math.abs(target.y - mousePoint.y);
        return dx <= xTolerance && dy <= yTolerance;
    }
    const PluginRegistry = {
        "TrendTrace": TrendTrace,
        // Add other plugin types as needed...
    };

    class TwoPointDrawing extends Drawing {
        _paneViews = [];
        _hovered = false;
        linkedObjects = [];
        constructor(p1, p2, options) {
            super();
            this.points.push(p1);
            this.points.push(p2);
            this._options = {
                ...defaultOptions$3,
                ...options,
            };
        }
        setFirstPoint(point) {
            this.updatePoints(point);
        }
        setSecondPoint(point) {
            this.updatePoints(null, point);
        }
        detach() {
            this.linkedObjects.forEach((primitive) => {
                const series = primitive.series;
                if (series) {
                    series.detachPrimitive(primitive);
                }
            });
            this.linkedObjects = []; // Clear linked objects after detaching
            super.detach();
        }
        get p1() { return this.points[0]; }
        get p2() { return this.points[1]; }
        get hovered() { return this._hovered; }
        /**
          * Serializes the drawing’s configuration.
          * Exports points, options, and the linked objects’ state.
          */
        toJSON() {
            return {
                points: this.points,
                _options: this._options,
                linkedObjects: this.linkedObjects.map(obj => typeof obj.toJSON === 'function' ? obj.toJSON() : {}),
            };
        }
        /**
         * Restores the drawing’s configuration from JSON.
         * This updates the drawing’s points, options, and rebuilds linked objects.
         *
         * @param json - The JSON object representing the state.
         */
        fromJSON(json) {
            if (!json)
                return;
            // Restore points.
            if (json.points && Array.isArray(json.points) && json.points.length >= 2) {
                this.updatePoints(json.points[0], json.points[1]);
            }
            // Restore options.
            if (json._options) {
                this._options = { ...this._options, ...json._options };
            }
            // Rebuild linked objects from the JSON array.
            if (json.linkedObjects && Array.isArray(json.linkedObjects)) {
                this.linkedObjects = json.linkedObjects.map((objJson) => {
                    // Determine the plugin type. We assume the JSON object contains a _type property.
                    const type = objJson._type;
                    if (!type) {
                        console.warn("Linked object JSON missing _type property.");
                        return null;
                    }
                    const PluginConstructor = PluginRegistry[type];
                    if (!PluginConstructor) {
                        console.warn(`No constructor found in registry for type: ${type}`);
                        return null;
                    }
                    // Create a new instance and restore its state.
                    const instance = new PluginConstructor();
                    if (typeof instance.fromJSON === "function") {
                        instance.fromJSON(objJson);
                    }
                    return instance;
                }).filter((obj) => obj !== null);
            }
            // Trigger a re-render/update.
            this.requestUpdate();
        }
    }

    class ThreePointDrawing extends Drawing {
        _paneViews = [];
        _hovered = false;
        linkedObjects = [];
        detach() {
            this.linkedObjects.forEach((primitive) => {
                const series = primitive.series;
                if (series) {
                    series.detachPrimitive(primitive);
                }
            });
            this.linkedObjects = []; // Clear linked objects after detaching
            super.detach();
        }
        constructor(p1, p2, p3, options) {
            super();
            this.points.push(p1);
            this.points.push(p2);
            this.points.push(p3);
            this._options = {
                ...defaultOptions$3,
                ...options,
            };
        }
        setFirstPoint(point) {
            this.updatePoints(point);
        }
        setSecondPoint(point) {
            this.updatePoints(null, point);
        }
        setThirdPoint(point) {
            this.updatePoints(null, null, point);
        }
        get p1() { return this.points[0]; }
        get p2() { return this.points[1]; }
        get p3() { return this.points[2]; }
        get hovered() { return this._hovered; }
        /**
          * Serializes the drawing’s configuration.
          * Exports points, options, and the linked objects’ state.
          */
        toJSON() {
            return {
                points: this.points,
                _options: this._options,
                linkedObjects: this.linkedObjects.map(obj => typeof obj.toJSON === 'function' ? obj.toJSON() : {}),
            };
        }
        /**
         * Restores the drawing’s configuration from JSON.
         * This updates the drawing’s points, options, and rebuilds linked objects.
         *
         * @param json - The JSON object representing the state.
         */
        fromJSON(json) {
            if (!json)
                return;
            // Restore points.
            if (json.points && Array.isArray(json.points) && json.points.length >= 2) {
                this.updatePoints(json.points[0], json.points[1]);
            }
            // Restore options.
            if (json._options) {
                this._options = { ...this._options, ...json._options };
            }
            // Rebuild linked objects from the JSON array.
            if (json.linkedObjects && Array.isArray(json.linkedObjects)) {
                this.linkedObjects = json.linkedObjects.map((objJson) => {
                    // Determine the plugin type. We assume the JSON object contains a _type property.
                    const type = objJson._type;
                    if (!type) {
                        console.warn("Linked object JSON missing _type property.");
                        return null;
                    }
                    const PluginConstructor = PluginRegistry[type];
                    if (!PluginConstructor) {
                        console.warn(`No constructor found in registry for type: ${type}`);
                        return null;
                    }
                    // Create a new instance and restore its state.
                    const instance = new PluginConstructor();
                    if (typeof instance.fromJSON === "function") {
                        instance.fromJSON(objJson);
                    }
                    return instance;
                }).filter((obj) => obj !== null);
            }
            // Trigger a re-render/update.
            this.requestUpdate();
        }
    }

    class FourPointDrawing extends Drawing {
        _paneViews = [];
        _hovered = false;
        linkedObjects = [];
        detach() {
            this.linkedObjects.forEach((primitive) => {
                const series = primitive.series;
                if (series) {
                    series.detachPrimitive(primitive);
                }
            });
            this.linkedObjects = []; // Clear linked objects after detaching
            super.detach();
        }
        constructor(p1, p2, p3, p4, options) {
            super();
            this.points.push(p1);
            this.points.push(p2);
            this.points.push(p3);
            this.points.push(p4);
            this._options = {
                ...defaultOptions$3,
                ...options,
            };
        }
        setFirstPoint(point) {
            this.updatePoints(point);
        }
        setSecondPoint(point) {
            this.updatePoints(null, point);
        }
        setThirdPoint(point) {
            this.updatePoints(null, null, point);
        }
        setFourthPoint(point) {
            this.updatePoints(null, null, null, point);
        }
        get p1() { return this.points[0]; }
        get p2() { return this.points[1]; }
        get p3() { return this.points[2]; }
        get p4() { return this.points[3]; }
        get hovered() { return this._hovered; }
    }

    class DrawingTool {
        _chart;
        _series;
        _finishDrawingCallback = null;
        _drawings = [];
        _activeDrawing = null;
        _isDrawing = false;
        _drawingType = null;
        // Temporary storage for multi-click drawings.
        // For three-point drawings we only need the first point.
        // For four-point drawings we need both the first and second temporary points.
        _tempStartPoint = null;
        _tempSecondPoint = null;
        // Track the number of clicks for the active drawing.
        _clickCount = 0;
        constructor(chart, series, finishDrawingCallback = null) {
            this._chart = chart;
            this._series = series;
            this._finishDrawingCallback = finishDrawingCallback;
            this._chart.subscribeClick(this._clickHandler);
            this._chart.subscribeCrosshairMove(this._moveHandler);
        }
        _clickHandler = (param) => this._onClick(param);
        _moveHandler = (param) => this._onMouseMove(param);
        beginDrawing(DrawingType) {
            this._drawingType = DrawingType;
            this._isDrawing = true;
            this._tempStartPoint = null;
            this._tempSecondPoint = null;
            this._clickCount = 0;
        }
        stopDrawing() {
            this._isDrawing = false;
            this._activeDrawing = null;
            this._tempStartPoint = null;
            this._tempSecondPoint = null;
            this._clickCount = 0;
        }
        get drawings() {
            return this._drawings;
        }
        addNewDrawing(drawing) {
            this._series.attachPrimitive(drawing);
            this._drawings.push(drawing);
        }
        delete(d) {
            if (d == null)
                return;
            const idx = this._drawings.indexOf(d);
            if (idx == -1)
                return;
            this._drawings.splice(idx, 1);
            d.detach();
        }
        clearDrawings() {
            for (const d of this._drawings)
                d.detach();
            this._drawings = [];
        }
        repositionOnTime() {
            for (const drawing of this.drawings) {
                const newPoints = [];
                for (const point of drawing.points) {
                    if (!point) {
                        newPoints.push(point);
                        continue;
                    }
                    const logical = point.time
                        ? this._chart.timeScale().coordinateToLogical(this._chart.timeScale().timeToCoordinate(point.time) || 0)
                        : point.logical;
                    newPoints.push({
                        time: point.time,
                        logical: logical,
                        price: point.price,
                    });
                }
                drawing.updatePoints(...newPoints);
            }
        }
        _onClick(param) {
            if (!this._isDrawing)
                return;
            const point = Drawing._eventToPoint(param, this._series);
            if (!point)
                return;
            // 1) Determine the required number of points based on the drawing type.
            let requiredPoints;
            if (this._drawingType) {
                if (this._drawingType.prototype instanceof FourPointDrawing) {
                    requiredPoints = 4;
                }
                else if (this._drawingType.prototype instanceof ThreePointDrawing) {
                    requiredPoints = 3;
                }
                else if (this._drawingType.prototype instanceof TwoPointDrawing) {
                    requiredPoints = 2;
                }
                else {
                    // default to 2 if unknown
                    requiredPoints = 2;
                }
            }
            else {
                return;
            }
            // 2) Handle drawing creation based on the required points.
            if (requiredPoints === 3) {
                // --- Three-point drawing logic ---
                if (this._activeDrawing == null) {
                    // First click: store temporary starting point.
                    if (this._tempStartPoint == null) {
                        this._tempStartPoint = point;
                        this._clickCount = 1;
                        return;
                    }
                    else {
                        // Second click: create the drawing with p1 and p2.
                        this._activeDrawing = new this._drawingType(this._tempStartPoint, point, null);
                        this._series.attachPrimitive(this._activeDrawing);
                        this._clickCount = 2;
                        // Clear temporary storage so that we can set the third point next.
                        this._tempStartPoint = null;
                        return;
                    }
                }
                else {
                    // Third click: set p3 and finalize.
                    if (this._clickCount === 2) {
                        this._activeDrawing.setThirdPoint(point);
                        this._clickCount = 3;
                        this._drawings.push(this._activeDrawing);
                        this.stopDrawing();
                        if (this._finishDrawingCallback) {
                            this._finishDrawingCallback();
                        }
                    }
                }
            }
            else if (requiredPoints === 4) {
                // --- Four-point drawing logic (initialize on click 3) ---
                if (this._activeDrawing == null) {
                    // No active drawing yet.
                    if (this._tempStartPoint == null) {
                        // Click 1: store first point.
                        this._tempStartPoint = point;
                        this._clickCount = 1;
                        return;
                    }
                    else if (this._tempSecondPoint == null) {
                        // Click 2: store second point.
                        this._tempSecondPoint = point;
                        this._clickCount = 2;
                        return;
                    }
                    else {
                        // Click 3: initialize the active drawing using the stored first two points
                        // and the current point as the third point. p4 remains null.
                        this._activeDrawing = new this._drawingType(this._tempStartPoint, this._tempSecondPoint, point, null);
                        this._series.attachPrimitive(this._activeDrawing);
                        this._clickCount = 3;
                        // Clear temporary storage.
                        this._tempStartPoint = null;
                        this._tempSecondPoint = null;
                        return;
                    }
                }
                else {
                    // Active drawing is already initialized.
                    // Click 4: set p4 and finalize.
                    if (this._clickCount === 3) {
                        this._activeDrawing.setFourthPoint(point);
                        this._clickCount = 4;
                        this._drawings.push(this._activeDrawing);
                        this.stopDrawing();
                        if (this._finishDrawingCallback) {
                            this._finishDrawingCallback();
                        }
                    }
                }
            }
            else {
                // --- Two-point drawing logic ---
                if (this._activeDrawing == null) {
                    // First click: create drawing with (p1, p2 = same).
                    this._activeDrawing = new this._drawingType(point, point);
                    this._series.attachPrimitive(this._activeDrawing);
                    this._clickCount = 1;
                }
                else {
                    // Second click: finalize p2.
                    this._activeDrawing.setSecondPoint(point);
                    this._clickCount = 2;
                    this._drawings.push(this._activeDrawing);
                    this.stopDrawing();
                    if (this._finishDrawingCallback) {
                        this._finishDrawingCallback();
                    }
                }
            }
        }
        /**
         * Called whenever the user moves the mouse on the chart (crosshair).
         * Used for real-time preview of the current drawing.
         */
        _onMouseMove(param) {
            if (!param)
                return;
            // 1) Hover logic for all existing drawings.
            for (const d of this._drawings) {
                d._handleHoverInteraction(param);
            }
            // 2) If we are in the middle of drawing, update the last "live" point.
            if (!this._isDrawing || !this._activeDrawing)
                return;
            const point = Drawing._eventToPoint(param, this._series);
            if (!point)
                return;
            // Determine if the drawing is two-, three-, or four-point.
            const isThreePoint = this._drawingType && (this._drawingType.prototype instanceof ThreePointDrawing);
            const isFourPoint = this._drawingType && (this._drawingType.prototype instanceof FourPointDrawing);
            if (isFourPoint) {
                // For four-point drawing:
                // - If click count is 2 (waiting for the third click), preview the third point.
                // - If click count is 3 (active drawing created and waiting for p4), preview the fourth point.
                if (this._clickCount === 2) {
                    this._activeDrawing.updatePoints(null, null, point, null);
                }
                else if (this._clickCount === 3) {
                    this._activeDrawing.updatePoints(null, null, null, point);
                }
            }
            else if (isThreePoint) {
                // For three-point drawing: preview the third point if click count is 2.
                if (this._clickCount === 2) {
                    this._activeDrawing.updatePoints(null, null, point);
                }
            }
            else {
                // For two-point drawing: preview the second point.
                this._activeDrawing.setSecondPoint(point);
            }
        }
    }

    class TrendLinePaneRenderer extends TwoPointDrawingPaneRenderer {
        constructor(p1, p2, options, hovered) {
            super(p1, p2, options, hovered);
        }
        draw(target) {
            target.useBitmapCoordinateSpace(scope => {
                if (this._p1.x === null ||
                    this._p1.y === null ||
                    this._p2.x === null ||
                    this._p2.y === null)
                    return;
                const ctx = scope.context;
                const scaled = this._getScaledCoordinates(scope);
                if (!scaled)
                    return;
                ctx.lineWidth = this._options.width;
                ctx.strokeStyle = this._options.lineColor;
                setLineStyle(ctx, this._options.lineStyle);
                ctx.beginPath();
                ctx.moveTo(scaled.x1, scaled.y1);
                ctx.lineTo(scaled.x2, scaled.y2);
                ctx.stroke();
                // this._drawTextLabel(scope, this._text1, x1Scaled, y1Scaled, true);
                // this._drawTextLabel(scope, this._text2, x2Scaled, y2Scaled, false);
                if (!this._hovered)
                    return;
                this._drawEndCircle(scope, scaled.x1, scaled.y1);
                this._drawEndCircle(scope, scaled.x2, scaled.y2);
            });
        }
    }

    class DrawingPaneView {
        _source;
        constructor(source) {
            this._source = source;
        }
    }
    class TwoPointDrawingPaneView extends DrawingPaneView {
        _p1 = { x: null, y: null };
        _p2 = { x: null, y: null };
        _source;
        constructor(source) {
            super(source);
            this._source = source;
        }
        update() {
            if (!this._source.p1 || !this._source.p2)
                return;
            const series = this._source.series;
            const y1 = series.priceToCoordinate(this._source.p1.price);
            const y2 = series.priceToCoordinate(this._source.p2.price);
            const x1 = this._getX(this._source.p1);
            const x2 = this._getX(this._source.p2);
            this._p1 = { x: x1, y: y1 };
            this._p2 = { x: x2, y: y2 };
            if (!x1 || !x2 || !y1 || !y2)
                return;
        }
        _getX(p) {
            const timeScale = this._source.chart.timeScale();
            return timeScale.logicalToCoordinate(p.logical);
        }
    }
    class ThreePointDrawingPaneView extends DrawingPaneView {
        _p1 = { x: null, y: null };
        _p2 = { x: null, y: null };
        _p3 = { x: null, y: null };
        _source;
        constructor(source) {
            super(source);
            this._source = source;
        }
        update() {
            if (!this._source.p1 || !this._source.p2 || !this._source.p3)
                return;
            const series = this._source.series;
            const y1 = series.priceToCoordinate(this._source.p1.price);
            const y2 = series.priceToCoordinate(this._source.p2.price);
            const y3 = series.priceToCoordinate(this._source.p3.price);
            const x1 = this._getX(this._source.p1);
            const x2 = this._getX(this._source.p2);
            const x3 = this._getX(this._source.p3);
            this._p1 = { x: x1, y: y1 };
            this._p2 = { x: x2, y: y2 };
            this._p3 = { x: x3, y: y3 };
            if (!x1 || !x2 || !x3 || !y1 || !y2 || !y3)
                return;
        }
        _getX(p) {
            const timeScale = this._source.chart.timeScale();
            return timeScale.logicalToCoordinate(p.logical);
        }
    }

    class TrendLinePaneView extends TwoPointDrawingPaneView {
        constructor(source) {
            super(source);
        }
        renderer() {
            return new TrendLinePaneRenderer(this._p1, this._p2, this._source._options, this._source.hovered);
        }
    }

    class TrendLine extends TwoPointDrawing {
        _type = "TrendLine";
        constructor(p1, p2, options) {
            super(p1, p2, options);
            this._paneViews = [new TrendLinePaneView(this)];
        }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._hovered = false;
                    this.requestUpdate();
                    this._unsubscribe("mousedown", this._handleMouseDownInteraction);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._hovered = true;
                    this.requestUpdate();
                    this._subscribe("mousedown", this._handleMouseDownInteraction);
                    this._unsubscribe("mouseup", this._handleMouseDownInteraction);
                    this.chart.applyOptions({ handleScroll: true });
                    break;
                case InteractionState.DRAGGINGP1:
                case InteractionState.DRAGGINGP2:
                case InteractionState.DRAGGING:
                    document.body.style.cursor = "grabbing";
                    this._subscribe("mouseup", this._handleMouseUpInteraction);
                    this.chart.applyOptions({ handleScroll: false });
                    break;
            }
            this._state = state;
        }
        _onDrag(diff) {
            if (this._state == InteractionState.DRAGGING || this._state == InteractionState.DRAGGINGP1) {
                this._addDiffToPoint(this.p1, diff.logical, diff.price);
            }
            if (this._state == InteractionState.DRAGGING || this._state == InteractionState.DRAGGINGP2) {
                this._addDiffToPoint(this.p2, diff.logical, diff.price);
            }
        }
        _onMouseDown() {
            this._startDragPoint = null;
            const hoverPoint = this._latestHoverPoint;
            if (!hoverPoint)
                return;
            const p1 = this._paneViews[0]._p1;
            const p2 = this._paneViews[0]._p2;
            if (!p1.x || !p2.x || !p1.y || !p2.y)
                return this._moveToState(InteractionState.DRAGGING);
            const tolerance = 10;
            if (Math.abs(hoverPoint.x - p1.x) < tolerance && Math.abs(hoverPoint.y - p1.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP1);
            }
            else if (Math.abs(hoverPoint.x - p2.x) < tolerance && Math.abs(hoverPoint.y - p2.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP2);
            }
            else {
                this._moveToState(InteractionState.DRAGGING);
            }
        }
        _mouseIsOverDrawing(param, tolerance = 4) {
            if (!param.point)
                return false;
            const x1 = this._paneViews[0]._p1.x;
            const y1 = this._paneViews[0]._p1.y;
            const x2 = this._paneViews[0]._p2.x;
            const y2 = this._paneViews[0]._p2.y;
            if (!x1 || !x2 || !y1 || !y2)
                return false;
            const mouseX = param.point.x;
            const mouseY = param.point.y;
            if (mouseX <= Math.min(x1, x2) - tolerance ||
                mouseX >= Math.max(x1, x2) + tolerance) {
                return false;
            }
            const distance = Math.abs((y2 - y1) * mouseX - (x2 - x1) * mouseY + x2 * y1 - y2 * x1) / Math.sqrt((y2 - y1) ** 2 + (x2 - x1) ** 2);
            return distance <= tolerance;
        }
    }

    class BoxPaneRenderer extends TwoPointDrawingPaneRenderer {
        constructor(p1, p2, options, showCircles) {
            super(p1, p2, options, showCircles);
        }
        draw(target) {
            target.useBitmapCoordinateSpace(scope => {
                const ctx = scope.context;
                const scaled = this._getScaledCoordinates(scope);
                if (!scaled)
                    return;
                ctx.lineWidth = this._options.width;
                ctx.strokeStyle = this._options.lineColor;
                setLineStyle(ctx, this._options.lineStyle);
                ctx.fillStyle = this._options.fillColor;
                const mainX = Math.min(scaled.x1, scaled.x2);
                const mainY = Math.min(scaled.y1, scaled.y2);
                const width = Math.abs(scaled.x1 - scaled.x2);
                const height = Math.abs(scaled.y1 - scaled.y2);
                ctx.strokeRect(mainX, mainY, width, height);
                ctx.fillRect(mainX, mainY, width, height);
                if (!this._hovered)
                    return;
                this._drawEndCircle(scope, mainX, mainY);
                this._drawEndCircle(scope, mainX + width, mainY);
                this._drawEndCircle(scope, mainX + width, mainY + height);
                this._drawEndCircle(scope, mainX, mainY + height);
            });
        }
    }

    class BoxPaneView extends TwoPointDrawingPaneView {
        constructor(source) {
            super(source);
        }
        renderer() {
            return new BoxPaneRenderer(this._p1, this._p2, this._source._options, this._source.hovered);
        }
    }

    const defaultBoxOptions = {
        fillEnabled: true,
        fillColor: 'rgba(255, 255, 255, 0.2)',
        ...defaultOptions$3
    };
    class Box extends TwoPointDrawing {
        _type = "Box";
        constructor(p1, p2, options) {
            super(p1, p2, options);
            this._options = {
                ...defaultBoxOptions,
                ...options,
            };
            this._paneViews = [new BoxPaneView(this)];
        }
        // autoscaleInfo(startTimePoint: Logical, endTimePoint: Logical): AutoscaleInfo | null {
        // const p1Index = this._pointIndex(this._p1);
        // const p2Index = this._pointIndex(this._p2);
        // if (p1Index === null || p2Index === null) return null;
        // if (endTimePoint < p1Index || startTimePoint > p2Index) return null;
        // return {
        //  priceRange: {
        //      minValue: this._minPrice,
        //      maxValue: this._maxPrice,
        //  },
        // };
        // }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._hovered = false;
                    this._unsubscribe("mousedown", this._handleMouseDownInteraction);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._hovered = true;
                    this._unsubscribe("mouseup", this._handleMouseUpInteraction);
                    this._subscribe("mousedown", this._handleMouseDownInteraction);
                    this.chart.applyOptions({ handleScroll: true });
                    break;
                case InteractionState.DRAGGINGP1:
                case InteractionState.DRAGGINGP2:
                case InteractionState.DRAGGINGP3:
                case InteractionState.DRAGGINGP4:
                case InteractionState.DRAGGING:
                    document.body.style.cursor = "grabbing";
                    document.body.addEventListener("mouseup", this._handleMouseUpInteraction);
                    this._subscribe("mouseup", this._handleMouseUpInteraction);
                    this.chart.applyOptions({ handleScroll: false });
                    break;
            }
            this._state = state;
        }
        _onDrag(diff) {
            if (this._state == InteractionState.DRAGGING || this._state == InteractionState.DRAGGINGP1) {
                this._addDiffToPoint(this.p1, diff.logical, diff.price);
            }
            if (this._state == InteractionState.DRAGGING || this._state == InteractionState.DRAGGINGP2) {
                this._addDiffToPoint(this.p2, diff.logical, diff.price);
            }
            if (this._state != InteractionState.DRAGGING) {
                if (this._state == InteractionState.DRAGGINGP3) {
                    this._addDiffToPoint(this.p1, diff.logical, 0);
                    this._addDiffToPoint(this.p2, 0, diff.price);
                }
                if (this._state == InteractionState.DRAGGINGP4) {
                    this._addDiffToPoint(this.p1, 0, diff.price);
                    this._addDiffToPoint(this.p2, diff.logical, 0);
                }
            }
        }
        _onMouseDown() {
            this._startDragPoint = null;
            const hoverPoint = this._latestHoverPoint;
            const p1 = this._paneViews[0]._p1;
            const p2 = this._paneViews[0]._p2;
            if (!p1.x || !p2.x || !p1.y || !p2.y)
                return this._moveToState(InteractionState.DRAGGING);
            const tolerance = 10;
            if (Math.abs(hoverPoint.x - p1.x) < tolerance && Math.abs(hoverPoint.y - p1.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP1);
            }
            else if (Math.abs(hoverPoint.x - p2.x) < tolerance && Math.abs(hoverPoint.y - p2.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP2);
            }
            else if (Math.abs(hoverPoint.x - p1.x) < tolerance && Math.abs(hoverPoint.y - p2.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP3);
            }
            else if (Math.abs(hoverPoint.x - p2.x) < tolerance && Math.abs(hoverPoint.y - p1.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP4);
            }
            else {
                this._moveToState(InteractionState.DRAGGING);
            }
        }
        _mouseIsOverDrawing(param, tolerance = 4) {
            if (!param.point)
                return false;
            const x1 = this._paneViews[0]._p1.x;
            const y1 = this._paneViews[0]._p1.y;
            const x2 = this._paneViews[0]._p2.x;
            const y2 = this._paneViews[0]._p2.y;
            if (!x1 || !x2 || !y1 || !y2)
                return false;
            const mouseX = param.point.x;
            const mouseY = param.point.y;
            const mainX = Math.min(x1, x2);
            const mainY = Math.min(y1, y2);
            const width = Math.abs(x1 - x2);
            const height = Math.abs(y1 - y2);
            const halfTolerance = tolerance / 2;
            return mouseX > mainX - halfTolerance && mouseX < mainX + width + halfTolerance &&
                mouseY > mainY - halfTolerance && mouseY < mainY + height + halfTolerance;
        }
    }

    class HorizontalLinePaneRenderer extends DrawingPaneRenderer {
        _point = { x: null, y: null };
        constructor(point, options) {
            super(options);
            this._point = point;
        }
        draw(target) {
            target.useBitmapCoordinateSpace(scope => {
                if (this._point.y == null)
                    return;
                const ctx = scope.context;
                const scaledY = Math.round(this._point.y * scope.verticalPixelRatio);
                const scaledX = this._point.x ? this._point.x * scope.horizontalPixelRatio : 0;
                ctx.lineWidth = this._options.width;
                ctx.strokeStyle = this._options.lineColor;
                setLineStyle(ctx, this._options.lineStyle);
                ctx.beginPath();
                ctx.moveTo(scaledX, scaledY);
                ctx.lineTo(scope.bitmapSize.width, scaledY);
                ctx.stroke();
            });
        }
    }

    class HorizontalLinePaneView extends DrawingPaneView {
        _source;
        _point = { x: null, y: null };
        constructor(source) {
            super(source);
            this._source = source;
        }
        update() {
            const point = this._source._point;
            const timeScale = this._source.chart.timeScale();
            const series = this._source.series;
            if (this._source._type == "RayLine") {
                this._point.x = point.time ? timeScale.timeToCoordinate(point.time) : timeScale.logicalToCoordinate(point.logical);
            }
            this._point.y = series.priceToCoordinate(point.price);
        }
        renderer() {
            return new HorizontalLinePaneRenderer(this._point, this._source._options);
        }
    }

    class HorizontalLineAxisView {
        _source;
        _y = null;
        _price = null;
        constructor(source) {
            this._source = source;
        }
        update() {
            if (!this._source.series || !this._source._point)
                return;
            this._y = this._source.series.priceToCoordinate(this._source._point.price);
            const priceFormat = this._source.series.options().priceFormat;
            const precision = priceFormat.precision;
            this._price = this._source._point.price.toFixed(precision).toString();
        }
        visible() {
            return true;
        }
        tickVisible() {
            return true;
        }
        coordinate() {
            return this._y ?? 0;
        }
        text() {
            return this._source._options.text || this._price || '';
        }
        textColor() {
            return 'white';
        }
        backColor() {
            return this._source._options.lineColor;
        }
    }

    class HorizontalLine extends Drawing {
        _type = 'HorizontalLine';
        _paneViews;
        _point;
        _callbackName;
        _priceAxisViews;
        _startDragPoint = null;
        constructor(point, options, callbackName = null) {
            super(options);
            this._point = point;
            this._point.time = null; // time is null for horizontal lines
            this._paneViews = [new HorizontalLinePaneView(this)];
            this._priceAxisViews = [new HorizontalLineAxisView(this)];
            this._callbackName = callbackName;
        }
        get points() {
            return [this._point];
        }
        updatePoints(...points) {
            for (const p of points)
                if (p)
                    this._point.price = p.price;
            this.requestUpdate();
        }
        updateAllViews() {
            this._paneViews.forEach((pw) => pw.update());
            this._priceAxisViews.forEach((tw) => tw.update());
        }
        priceAxisViews() {
            return this._priceAxisViews;
        }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._unsubscribe("mousedown", this._handleMouseDownInteraction);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._unsubscribe("mouseup", this._childHandleMouseUpInteraction);
                    this._subscribe("mousedown", this._handleMouseDownInteraction);
                    this.chart.applyOptions({ handleScroll: true });
                    break;
                case InteractionState.DRAGGING:
                    document.body.style.cursor = "grabbing";
                    this._subscribe("mouseup", this._childHandleMouseUpInteraction);
                    this.chart.applyOptions({ handleScroll: false });
                    break;
            }
            this._state = state;
        }
        _onDrag(diff) {
            this._addDiffToPoint(this._point, 0, diff.price);
            this.requestUpdate();
        }
        _mouseIsOverDrawing(param, tolerance = 4) {
            if (!param.point)
                return false;
            const y = this.series.priceToCoordinate(this._point.price);
            if (!y)
                return false;
            return (Math.abs(y - param.point.y) < tolerance);
        }
        _onMouseDown() {
            this._startDragPoint = null;
            const hoverPoint = this._latestHoverPoint;
            if (!hoverPoint)
                return;
            return this._moveToState(InteractionState.DRAGGING);
        }
        _childHandleMouseUpInteraction = () => {
            this._handleMouseUpInteraction();
            if (!this._callbackName)
                return;
            window.callbackFunction(`${this._callbackName}_~_${this._point.price.toFixed(8)}`);
        };
    }

    class RayLine extends HorizontalLine {
        _type = 'RayLine';
        constructor(point, options) {
            super({ ...point }, options);
            this._point.time = point.time;
        }
        updatePoints(...points) {
            for (const p of points)
                if (p)
                    this._point = p;
            this.requestUpdate();
        }
        _onDrag(diff) {
            this._addDiffToPoint(this._point, diff.logical, diff.price);
            this.requestUpdate();
        }
        _mouseIsOverDrawing(param, tolerance = 4) {
            if (!param.point)
                return false;
            const y = this.series.priceToCoordinate(this._point.price);
            const x = this._point.time ? this.chart.timeScale().timeToCoordinate(this._point.time) : null;
            if (!y || !x)
                return false;
            return (Math.abs(y - param.point.y) < tolerance && param.point.x > x - tolerance);
        }
    }

    class VerticalLinePaneRenderer extends DrawingPaneRenderer {
        _point = { x: null, y: null };
        constructor(point, options) {
            super(options);
            this._point = point;
        }
        draw(target) {
            target.useBitmapCoordinateSpace(scope => {
                if (this._point.x == null)
                    return;
                const ctx = scope.context;
                const scaledX = this._point.x * scope.horizontalPixelRatio;
                ctx.lineWidth = this._options.width;
                ctx.strokeStyle = this._options.lineColor;
                setLineStyle(ctx, this._options.lineStyle);
                ctx.beginPath();
                ctx.moveTo(scaledX, 0);
                ctx.lineTo(scaledX, scope.bitmapSize.height);
                ctx.stroke();
            });
        }
    }

    class VerticalLinePaneView extends DrawingPaneView {
        _source;
        _point = { x: null, y: null };
        constructor(source) {
            super(source);
            this._source = source;
        }
        update() {
            const point = this._source._point;
            const timeScale = this._source.chart.timeScale();
            const series = this._source.series;
            this._point.x = point.time ? timeScale.timeToCoordinate(point.time) : timeScale.logicalToCoordinate(point.logical);
            this._point.y = series.priceToCoordinate(point.price);
        }
        renderer() {
            return new VerticalLinePaneRenderer(this._point, this._source._options);
        }
    }

    class VerticalLineTimeAxisView {
        _source;
        _x = null;
        constructor(source) {
            this._source = source;
        }
        update() {
            if (!this._source.chart || !this._source._point)
                return;
            const point = this._source._point;
            const timeScale = this._source.chart.timeScale();
            this._x = point.time ? timeScale.timeToCoordinate(point.time) : timeScale.logicalToCoordinate(point.logical);
        }
        visible() {
            return !!this._source._options.text;
        }
        tickVisible() {
            return true;
        }
        coordinate() {
            return this._x ?? 0;
        }
        text() {
            return this._source._options.text || '';
        }
        textColor() {
            return "white";
        }
        backColor() {
            return this._source._options.lineColor;
        }
    }

    class VerticalLine extends Drawing {
        _type = 'VerticalLine';
        _paneViews;
        _timeAxisViews;
        _point;
        _callbackName;
        _startDragPoint = null;
        constructor(point, options, callbackName = null) {
            super(options);
            this._point = point;
            this._paneViews = [new VerticalLinePaneView(this)];
            this._callbackName = callbackName;
            this._timeAxisViews = [new VerticalLineTimeAxisView(this)];
        }
        updateAllViews() {
            this._paneViews.forEach(pw => pw.update());
            this._timeAxisViews.forEach(tw => tw.update());
        }
        timeAxisViews() {
            return this._timeAxisViews;
        }
        updatePoints(...points) {
            for (const p of points) {
                if (!p)
                    continue;
                if (!p.time && p.logical) {
                    p.time = this.series.dataByIndex(p.logical)?.time || null;
                }
                this._point = p;
            }
            this.requestUpdate();
        }
        get points() {
            return [this._point];
        }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._unsubscribe("mousedown", this._handleMouseDownInteraction);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._unsubscribe("mouseup", this._childHandleMouseUpInteraction);
                    this._subscribe("mousedown", this._handleMouseDownInteraction);
                    this.chart.applyOptions({ handleScroll: true });
                    break;
                case InteractionState.DRAGGING:
                    document.body.style.cursor = "grabbing";
                    this._subscribe("mouseup", this._childHandleMouseUpInteraction);
                    this.chart.applyOptions({ handleScroll: false });
                    break;
            }
            this._state = state;
        }
        _onDrag(diff) {
            this._addDiffToPoint(this._point, diff.logical, 0);
            this.requestUpdate();
        }
        _mouseIsOverDrawing(param, tolerance = 4) {
            if (!param.point)
                return false;
            const timeScale = this.chart.timeScale();
            let x;
            if (this._point.time) {
                x = timeScale.timeToCoordinate(this._point.time);
            }
            else {
                x = timeScale.logicalToCoordinate(this._point.logical);
            }
            if (!x)
                return false;
            return (Math.abs(x - param.point.x) < tolerance);
        }
        _onMouseDown() {
            this._startDragPoint = null;
            const hoverPoint = this._latestHoverPoint;
            if (!hoverPoint)
                return;
            return this._moveToState(InteractionState.DRAGGING);
        }
        _childHandleMouseUpInteraction = () => {
            this._handleMouseUpInteraction();
            if (!this._callbackName)
                return;
            window.callbackFunction(`${this._callbackName}_~_${this._point.price.toFixed(8)}`);
        };
    }

    /**
     * Renderer class for drawing Pitch Forks.
     *
     * Responsibilities:
     * - Compute geometric positions based on input view points.
     * - Render all parts of the pitchfork including the baseline, median, and fork-lines.
     *
     * SOLID Considerations:
     * - Single Responsibility: Each helper (e.g. computing anchor point, intersection) has one task.
     * - Open/Closed: New drawing variants can be added by extending without modifying existing logic.
     * - Liskov Substitution: Derived classes can be substituted without altering behavior.
     * - Interface Segregation: The public API remains minimal.
     * - Dependency Inversion: Drawing relies on abstract canvas operations.
     */
    class PitchForkPaneRenderer extends ThreePointDrawingPaneRenderer {
        options;
        variant;
        /**
         * Constructs a new PitchForkPaneRenderer instance.
         *
         * @param p1 - The first view point.
         * @param p2 - The second view point.
         * @param p3 - The third view point.
         * @param options - Options for drawing the pitchfork.
         * @param hovered - Indicates whether the pitchfork is hovered.
         */
        constructor(p1, p2, p3, options, hovered) {
            super(p1, p2, p3, options, hovered);
            this.options = options;
            this.variant = options.variant ?? "standard";
        }
        /**
         * Draws the pitchfork on the provided canvas rendering target.
         *
         * The method computes key geometric points and draws the baseline, median, fork-lines,
         * and optionally fills the area and draws hover circles.
         *
         * @param target - The canvas rendering target.
         */
        draw(target) {
            target.useBitmapCoordinateSpace((scope) => {
                if (this._p1.x === null || this._p1.y === null ||
                    this._p2.x === null || this._p2.y === null ||
                    this._p3.x === null || this._p3.y === null) {
                    return;
                }
                const ctx = scope.context;
                const scaled = this._getScaledCoordinates(scope);
                if (!scaled)
                    return;
                const { x1, y1, x2, y2, x3, y3 } = scaled;
                // 1) Compute the midpoint of p2→p3.
                const midP2P3X = (x2 + x3) / 2;
                const midP2P3Y = (y2 + y3) / 2;
                let medianStartX, medianStartY;
                let medianEndX, medianEndY;
                let vx, vy; // median vector
                // The horizontal extension is 2× the difference between p2.x and p1.x.
                const dxExtension = (this._options.length ?? 1) * (x2 - x1);
                if (this.variant === "inside") {
                    // For the "inside" variant:
                    // - The median starts at the midpoint of p2 and p3.
                    // - Its direction is defined by the vector from p3 to the midpoint of p1 and p2.
                    medianStartX = midP2P3X;
                    medianStartY = midP2P3Y;
                    const midP1P2X = (x1 + x2) / 2;
                    const midP1P2Y = (y1 + y2) / 2;
                    // Compute the direction from p3 to the midpoint of p1 and p2.
                    const deltaX = midP1P2X - x3;
                    const deltaY = midP1P2Y - y3;
                    let angle = Math.atan2(deltaY, deltaX);
                    // Ensure the extension goes rightwards: if the horizontal component is negative, flip the angle.
                    if (Math.cos(angle) < 0) {
                        angle += Math.PI;
                    }
                    medianEndX = medianStartX + dxExtension * Math.cos(angle);
                    medianEndY = medianStartY + dxExtension * Math.sin(angle);
                }
                else {
                    // For other variants:
                    // 2) Compute the variant-based anchor point from p1 and p2.
                    const { anchorX, anchorY } = this._computeAnchorPoint(this.variant, x1, y1, x2, y2);
                    // 3) Compute the intersection of L1 (p1→p2) and L2 (from midpoint of p2→p3 towards the anchor).
                    const intersect = this._lineIntersection(x1, y1, x2, y2, midP2P3X, midP2P3Y, anchorX, anchorY);
                    if (intersect) {
                        [medianStartX, medianStartY] = intersect;
                    }
                    else {
                        // Fallback: if no intersection, use p1.
                        medianStartX = x1;
                        medianStartY = y1;
                    }
                    // 4) Compute the slope from the median start to the midpoint of p2 and p3.
                    const dxForSlope = midP2P3X - medianStartX;
                    const slope = Math.abs(dxForSlope) > 1e-9 ? (midP2P3Y - medianStartY) / dxForSlope : 0;
                    medianEndX = medianStartX + dxExtension;
                    medianEndY = medianStartY + slope * dxExtension;
                }
                // Compute the median vector.
                vx = medianEndX - medianStartX;
                vy = medianEndY - medianStartY;
                // 5) Optional fill: draw a quadrilateral from the baseline (p2→p3) offset by the median vector.
                //if (this.options.fillColor) {
                //  ctx.save();
                //  ctx.fillStyle = this.options.fillColor;
                //  ctx.beginPath();
                //  ctx.moveTo(x2, y2);
                //  ctx.lineTo(x3, y3);
                //  ctx.lineTo(x3 + vx, y3 + vy);
                //  ctx.lineTo(x2 + vx, y2 + vy);
                //  ctx.closePath();
                //  ctx.fill();
                //  ctx.restore();
                //}
                // 6) Set line style and draw the primary lines.
                ctx.lineWidth = this.options.width;
                ctx.strokeStyle = this.options.lineColor;
                setLineStyle(ctx, this.options.lineStyle);
                // 7) Draw the primary lines.
                // (a) Baseline: p2→p3.
                setLineStyle(ctx, lightweightCharts.LineStyle.Solid);
                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x3, y3);
                ctx.stroke();
                setLineStyle(ctx, this.options.lineStyle);
                // (b) p1→p2 (always drawn).
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                // (c) Median line.
                ctx.beginPath();
                ctx.moveTo(medianStartX, medianStartY);
                ctx.lineTo(medianEndX, medianEndY);
                ctx.stroke();
                // (d) Parallels: lines through p2 and p3 using the median vector.
                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 + vx, y2 + vy);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x3, y3);
                ctx.lineTo(x3 + vx, y3 + vy);
                ctx.stroke();
                // 8) Draw additional fork-lines parallel to the median and fill between them if fillColor is set.
                if (this.options.forkLines && this.options.forkLines.length > 0) {
                    const forkLines = this.options.forkLines;
                    for (let i = 0; i < forkLines.length; i++) {
                        const fork = forkLines[i];
                        // Compute the current fork's starting point: p3 offset by fork.value * (p2 - p3)
                        const forkStartX = x3 + fork.value * (x2 - x3);
                        const forkStartY = y3 + fork.value * (y2 - y3);
                        // Extend the fork-line using the same median vector.
                        const forkEndX = forkStartX + vx;
                        const forkEndY = forkStartY + vy;
                        // Draw the current fork line.
                        ctx.lineWidth = fork.width;
                        ctx.strokeStyle = fork.color;
                        setLineStyle(ctx, fork.style);
                        ctx.beginPath();
                        ctx.moveTo(forkStartX, forkStartY);
                        ctx.lineTo(forkEndX, forkEndY);
                        ctx.stroke();
                        // If the current fork line has a fillColor and there's a fork line below it, fill the area.
                        if (fork.fillColor && i < forkLines.length - 1) {
                            const nextFork = forkLines[i + 1];
                            const nextForkStartX = x3 + nextFork.value * (x2 - x3);
                            const nextForkStartY = y3 + nextFork.value * (y2 - y3);
                            const nextForkEndX = nextForkStartX + vx;
                            const nextForkEndY = nextForkStartY + vy;
                            ctx.save();
                            ctx.fillStyle = fork.fillColor;
                            ctx.beginPath();
                            ctx.moveTo(forkStartX, forkStartY);
                            ctx.lineTo(forkEndX, forkEndY);
                            ctx.lineTo(nextForkEndX, nextForkEndY);
                            ctx.lineTo(nextForkStartX, nextForkStartY);
                            ctx.closePath();
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                }
                // 9) If hovered, draw circles at the pivot points.
                if (this._hovered) {
                    ctx.lineWidth = this.options.width + 1;
                    ctx.strokeStyle = this.options.lineColor;
                    setLineStyle(ctx, lightweightCharts.LineStyle.Solid);
                    this._drawEndCircle(scope, x1, y1);
                    this._drawEndCircle(scope, x2, y2);
                    this._drawEndCircle(scope, x3, y3);
                }
            });
        }
        /**
         * Computes the anchor point based on the pitchfork variant.
         *
         * @param variant - The pitchfork variant.
         * @param x1 - x-coordinate of p1.
         * @param y1 - y-coordinate of p1.
         * @param x2 - x-coordinate of p2.
         * @param y2 - y-coordinate of p2.
         * @returns The computed anchor point.
         */
        _computeAnchorPoint(variant, x1, y1, x2, y2) {
            switch (variant) {
                case "standard":
                    return { anchorX: x1, anchorY: y1 };
                case "schiff":
                    return { anchorX: x1, anchorY: (y1 + y2) / 2 };
                case "modifiedSchiff":
                    return { anchorX: (x1 + x2) / 2, anchorY: (y1 + y2) / 2 };
                case "inside":
                    // Although the "inside" variant computes its median differently,
                    // we still provide an anchor for consistency.
                    return { anchorX: x1 + 0.5 * (x2 - x1), anchorY: y1 + 0.5 * (y2 - y1) };
            }
        }
        /**
         * Calculates the intersection point of two infinite lines:
         * - Line 1: from (x1, y1) to (x2, y2)
         * - Line 2: from (x3, y3) to (x4, y4)
         *
         * @returns A tuple [xi, yi] representing the intersection point, or null if the lines are parallel.
         */
        _lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (Math.abs(denom) < 1e-9)
                return null;
            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            const ix = x1 + ua * (x2 - x1);
            const iy = y1 + ua * (y2 - y1);
            return [ix, iy];
        }
    }

    class PitchForkPaneView extends ThreePointDrawingPaneView {
        constructor(source) {
            super(source);
        }
        renderer() {
            return new PitchForkPaneRenderer(this._p1, this._p2, this._p3, this._source._options, this._source.hovered);
        }
    }

    const defaultPitchForkOptions = {
        lineColor: "#ffffff",
        lineStyle: lightweightCharts.LineStyle.LargeDashed,
        width: 1,
        variant: "standard",
        forkLines: [
            {
                value: 1.0,
                width: 2,
                style: lightweightCharts.LineStyle.Solid,
                color: "#ff0000",
                fillColor: undefined,
            },
            {
                value: 0.786,
                width: 1,
                style: lightweightCharts.LineStyle.SparseDotted,
                color: "#000fff",
                fillColor: undefined,
            },
            {
                value: 0.618,
                width: 1,
                style: lightweightCharts.LineStyle.LargeDashed,
                color: "#ffffff",
                fillColor: undefined,
            },
            {
                value: 0.5,
                width: 2,
                style: lightweightCharts.LineStyle.Solid,
                color: "#ff0000",
                fillColor: undefined,
            },
            {
                value: 0.382,
                width: 1,
                style: lightweightCharts.LineStyle.LargeDashed,
                color: "#ffffff",
                fillColor: undefined,
            },
            {
                value: 0.236,
                width: 1,
                style: lightweightCharts.LineStyle.SparseDotted,
                color: "#000fff",
                fillColor: undefined,
            },
            {
                value: 0,
                width: 2,
                style: lightweightCharts.LineStyle.Solid,
                color: "#ff0000",
                fillColor: undefined,
            },
        ],
        length: 1.0, // default logical length for extensions
    };
    class PitchFork extends ThreePointDrawing {
        _type = "PitchFork";
        variant;
        constructor(p1, p2, p3, options) {
            super(p1, p2, p3, { ...defaultPitchForkOptions, ...options });
            this.variant = options?.variant || "standard";
            this._paneViews = [new PitchForkPaneView(this)];
        }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._hovered = false;
                    this.requestUpdate();
                    this._unsubscribe("mousedown", this._handleMouseDownInteraction);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._hovered = true;
                    this.requestUpdate();
                    this._subscribe("mousedown", this._handleMouseDownInteraction);
                    this._unsubscribe("mouseup", this._handleMouseDownInteraction);
                    this.chart.applyOptions({ handleScroll: true });
                    break;
                case InteractionState.DRAGGINGP1:
                case InteractionState.DRAGGINGP2:
                case InteractionState.DRAGGINGP3:
                case InteractionState.DRAGGING:
                    document.body.style.cursor = "grabbing";
                    this._subscribe("mouseup", this._handleMouseUpInteraction);
                    this.chart.applyOptions({ handleScroll: false });
                    break;
            }
            this._state = state;
        }
        _onDrag(diff) {
            if (this._state == InteractionState.DRAGGING ||
                this._state == InteractionState.DRAGGINGP1) {
                this._addDiffToPoint(this.p1, diff.logical, diff.price);
            }
            if (this._state == InteractionState.DRAGGING ||
                this._state == InteractionState.DRAGGINGP2) {
                this._addDiffToPoint(this.p2, diff.logical, diff.price);
            }
            if (this._state == InteractionState.DRAGGING ||
                this._state == InteractionState.DRAGGINGP3) {
                this._addDiffToPoint(this.p3, diff.logical, diff.price);
            }
        }
        _onMouseDown() {
            this._startDragPoint = null;
            const hoverPoint = this._latestHoverPoint;
            if (!hoverPoint)
                return;
            const p1 = this._paneViews[0]._p1;
            const p2 = this._paneViews[0]._p2;
            const p3 = this._paneViews[0]._p3;
            if (!p1.x || !p2.x || !p3.x || !p1.y || !p2.y || !p3.y)
                return this._moveToState(InteractionState.DRAGGING);
            const tolerance = 10;
            if (Math.abs(hoverPoint.x - p1.x) < tolerance &&
                Math.abs(hoverPoint.y - p1.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP1);
            }
            else if (Math.abs(hoverPoint.x - p2.x) < tolerance &&
                Math.abs(hoverPoint.y - p2.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP2);
            }
            else if (Math.abs(hoverPoint.x - p3.x) < tolerance &&
                Math.abs(hoverPoint.y - p3.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP3);
            }
            else {
                this._moveToState(InteractionState.DRAGGING);
            }
        }
        _mouseIsOverDrawing(param, tolerance = 4) {
            if (!param.point)
                return false;
            const x1 = this._paneViews[0]._p1.x;
            const y1 = this._paneViews[0]._p1.y;
            const x2 = this._paneViews[0]._p2.x;
            const y2 = this._paneViews[0]._p2.y;
            const x3 = this._paneViews[0]._p3.x;
            const y3 = this._paneViews[0]._p3.y;
            if (x1 == null ||
                y1 == null ||
                x2 == null ||
                y2 == null ||
                x3 == null ||
                y3 == null)
                return false;
            const mouseX = param.point.x;
            const mouseY = param.point.y;
            // Check bounding box of the three points
            if (mouseX < Math.min(x1, x2, x3) - tolerance ||
                mouseX > Math.max(x1, x2, x3) + tolerance) {
                return false;
            }
            // Check distance to each segment: p1->p2, p2->p3, and p1->p3
            const d1 = this._distanceFromSegment(x1, y1, x2, y2, mouseX, mouseY);
            const d2 = this._distanceFromSegment(x2, y2, x3, y3, mouseX, mouseY);
            const d3 = this._distanceFromSegment(x1, y1, x3, y3, mouseX, mouseY);
            return d1 <= tolerance || d2 <= tolerance || d3 <= tolerance;
        }
        _distanceFromSegment(xA, yA, xB, yB, x, y) {
            const A = x - xA, B = y - yA, C = xB - xA, D = yB - yA;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = lenSq !== 0 ? dot / lenSq : -1;
            let xx, yy;
            if (param < 0) {
                xx = xA;
                yy = yA;
            }
            else if (param > 1) {
                xx = xB;
                yy = yB;
            }
            else {
                xx = xA + param * C;
                yy = yA + param * D;
            }
            const dx = x - xx, dy = y - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        /**
         * Deserializes a JSON object to update the current Sequence instance.
         *
         * @param json - The JSON object containing optional Sequence data and options.
         */
        fromJSON(json) {
            if (json.options) {
                // Cast json.options as a generic record to satisfy the index signature.
                const options = json.options;
                for (const key in options) {
                    if (Object.prototype.hasOwnProperty.call(options, key)) {
                        // Cast key to keyof SequenceOptions.
                        const typedKey = key;
                        this.applyOptions({ [typedKey]: options[typedKey] });
                    }
                }
            }
        }
        toJSON() {
            return {
                options: this._options,
            };
        }
        title = "PitchFork";
    }

    class ToolBox {
        static TREND_SVG = '<rect x="3.84" y="13.67" transform="matrix(0.7071 -0.7071 0.7071 0.7071 -5.9847 14.4482)" width="21.21" height="1.56"/><path d="M23,3.17L20.17,6L23,8.83L25.83,6L23,3.17z M23,7.41L21.59,6L23,4.59L24.41,6L23,7.41z"/><path d="M6,20.17L3.17,23L6,25.83L8.83,23L6,20.17z M6,24.41L4.59,23L6,21.59L7.41,23L6,24.41z"/>';
        static HORZ_SVG = '<rect x="4" y="14" width="9" height="1"/><rect x="16" y="14" width="9" height="1"/><path d="M11.67,14.5l2.83,2.83l2.83-2.83l-2.83-2.83L11.67,14.5z M15.91,14.5l-1.41,1.41l-1.41-1.41l1.41-1.41L15.91,14.5z"/>';
        static RAY_SVG = '<rect x="8" y="14" width="17" height="1"/><path d="M3.67,14.5l2.83,2.83l2.83-2.83L6.5,11.67L3.67,14.5z M7.91,14.5L6.5,15.91L5.09,14.5l1.41-1.41L7.91,14.5z"/>';
        static BOX_SVG = '<rect x="8" y="6" width="12" height="1"/><rect x="9" y="22" width="11" height="1"/><path d="M3.67,6.5L6.5,9.33L9.33,6.5L6.5,3.67L3.67,6.5z M7.91,6.5L6.5,7.91L5.09,6.5L6.5,5.09L7.91,6.5z"/><path d="M19.67,6.5l2.83,2.83l2.83-2.83L22.5,3.67L19.67,6.5z M23.91,6.5L22.5,7.91L21.09,6.5l1.41-1.41L23.91,6.5z"/><path d="M19.67,22.5l2.83,2.83l2.83-2.83l-2.83-2.83L19.67,22.5z M23.91,22.5l-1.41,1.41l-1.41-1.41l1.41-1.41L23.91,22.5z"/><path d="M3.67,22.5l2.83,2.83l2.83-2.83L6.5,19.67L3.67,22.5z M7.91,22.5L6.5,23.91L5.09,22.5l1.41-1.41L7.91,22.5z"/><rect x="22" y="9" width="1" height="11"/><rect x="6" y="9" width="1" height="11"/>';
        static VERT_SVG = ToolBox.RAY_SVG;
        // Add new static SVG icons for pitchfork tools:
        static PITCHFORK_SVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><g fill="#ffffff" fill-rule="nonzero"><path d="M7.275 21.432l12.579-12.579-.707-.707-12.579 12.579z"/><path d="M6.69 13.397l7.913 7.913.707-.707-7.913-7.913z"/><path d="M7.149 10.558l7.058-7.058-.707-.707-7.058 7.058z" id="Line"/><path d="M20.149 21.558l7.058-7.058-.707-.707-7.058 7.558z"/><path d="M5.5 23h11v-1h-11z"/><path d="M4.5 24c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm0 1c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5z"/></g></svg>';
        //sprivate static readonly SCHIFF_PITCHFORK_SVG: string = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><g fill="#ffffff" fill-rule="nonzero"><path d="M7.354 21.354l14-14-.707-.707-14 14z"/><path d="M8.336 13.043l8.621 8.621.707-.707-8.621-8.621z"/><path d="M9.149 10.558l7.058-7.058-.707-.707-7.058 7.058z" id="Line"/><path d="M20.149 21.558l7.058-7.058-.707-.707-7.058 7.558z"/><path d="M5.5 23h10v-1h-10z"/><path d="M4.5 24c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm0 1c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5z"/></g></svg>';
        //sprivate static readonly MODIFIED_SCHIFF_PITCHFORK_SVG: string = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><g fill="#ffffff" fill-rule="nonzero"><path d="M10.275 20.432l11.579-11.579-.707-.707-11.579 11.579z"/><path d="M6.69 13.397l7.913 7.913.707-.707-7.913-7.913z"/><path d="M7.149 10.558l7.058-7.058-.707-.707-7.058 7.058z" id="Line"/><path d="M20.149 21.558l7.058-7.058-.707-.707-7.058 7.558z"/><path d="M5.5 23h11v-1h-11z"/><path d="M4.5 24c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm0 1c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5z"/></g></svg>';
        //sprivate static readonly INSIDE_PITCHFORK_SVG: string = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><g fill="#ffffff" fill-rule="nonzero"><path d="M6.5 23h12v-1h-12z" id="Line"/><path d="M21.596 20.715l3.091-9.66-.952-.305-3.091 9.66z"/><path d="M8.413 22.664l1.95-6.094-.952-.305-1.95 6.094z"/><path d="M11.602 12.695l3.085-9.641-.952-.305-3.085 9.641z"/><path d="M11.783 16.167l6.817 5.454.625-.781-6.817-5.454z"/><path d="M15.976 18.652l3.711-11.598-.952-.305-3.711 11.598z"/><path d="M4.5 24c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm0 1c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5z"/></g></svg>';
        //sprivate static readonly SEGMENT_SVG: string = '<line x1="5" y1="10" x2="25" y2="10" stroke="black" stroke-width="1"/>';
        //sprivate static readonly EXTENSION_SVG: string = '<line x1="5" y1="10" x2="25" y2="10" stroke="black" stroke-width="1" stroke-dasharray="4,2"/>';
        //sprivate static readonly CIRCLE_SVG: string = '<circle cx="15" cy="15" r="10" stroke="black" stroke-width="1" fill="none"/>';
        //sprivate static readonly SPIRAL_SVG: string = '<path d="M15 15 m -10,0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0" fill="none" stroke="black" stroke-width="1"/>';
        //sprivate static readonly GANN_SVG: string = '<rect x="8" y="8" width="12" height="12" stroke="black" fill="none" stroke-width="1"/><line x1="8" y1="8" x2="20" y2="20" stroke="black" stroke-width="1"/><line x1="20" y1="8" x2="8" y2="20" stroke="black" stroke-width="1"/>';
        div;
        activeIcon = null;
        buttons = [];
        _commandFunctions;
        _handlerID;
        _drawingTool;
        handler;
        constructor(handler, handlerID, chart, series, commandFunctions) {
            this._handlerID = handlerID;
            this._commandFunctions = commandFunctions;
            this._drawingTool = new DrawingTool(chart, series, () => this.removeActiveAndSave());
            this.div = this._makeToggleToolBox();
            this.handler = handler;
            this.handler.ContextMenu.setupDrawingTools(this.saveDrawings, this._drawingTool);
            commandFunctions.push((event) => {
                if ((event.metaKey || event.ctrlKey) && event.code === 'KeyZ') {
                    const drawingToDelete = this._drawingTool.drawings.pop();
                    if (drawingToDelete)
                        this._drawingTool.delete(drawingToDelete);
                    return true;
                }
                return false;
            });
        }
        toJSON() {
            // Exclude the chart attribute from serialization
            const { ...serialized } = this;
            return serialized;
        }
        _makeToggleToolBox() {
            const outerDiv = document.createElement('div');
            outerDiv.classList.add('flyout-toolbox');
            // Position the container absolutely at the top center.
            outerDiv.style.position = 'absolute';
            outerDiv.style.top = '0';
            outerDiv.style.left = '50%';
            outerDiv.style.transform = 'translateX(-50%)';
            outerDiv.style.zIndex = '1000';
            outerDiv.style.overflow = 'hidden';
            outerDiv.style.transition = 'height 0.3s ease';
            // Create the container for the toolbox content (the buttons).
            const contentDiv = document.createElement('div');
            contentDiv.classList.add('toolbox-content');
            // Use inline-flex so its width is determined by its content.
            contentDiv.style.display = 'inline-flex';
            contentDiv.style.flexDirection = 'row';
            contentDiv.style.justifyContent = 'center';
            contentDiv.style.alignItems = 'center';
            contentDiv.style.padding = '5px';
            contentDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            // Initially, content is hidden.
            contentDiv.style.display = 'none';
            // Create toolbox buttons using your existing method.
            this.buttons = [];
            this.buttons.push(this._makeToolBoxElement(TrendLine, 'KeyT', ToolBox.TREND_SVG));
            this.buttons.push(this._makeToolBoxElement(HorizontalLine, 'KeyH', ToolBox.HORZ_SVG));
            this.buttons.push(this._makeToolBoxElement(RayLine, 'KeyR', ToolBox.RAY_SVG));
            this.buttons.push(this._makeToolBoxElement(Box, 'KeyB', ToolBox.BOX_SVG));
            this.buttons.push(this._makeToolBoxElement(VerticalLine, 'KeyV', ToolBox.VERT_SVG, true));
            this.buttons.push(this._makeToolBoxElement(PitchFork, 'KeyP', ToolBox.PITCHFORK_SVG));
            // Append each button to the content container.
            for (const button of this.buttons) {
                contentDiv.appendChild(button);
            }
            // Create the toggle tab that will always be visible and is attached to the bottom.
            const toggleTab = document.createElement('div');
            toggleTab.textContent = '▼'; // Down arrow for collapsed state.
            toggleTab.style.width = '15px';
            toggleTab.style.height = '10px';
            toggleTab.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            toggleTab.style.color = '#fff';
            toggleTab.style.textAlign = 'center';
            toggleTab.style.lineHeight = '15px';
            toggleTab.style.cursor = 'pointer';
            // No extra margin needed since we want it attached.
            // Append both content and toggle tab to the outer container.
            outerDiv.appendChild(contentDiv);
            outerDiv.appendChild(toggleTab);
            // Define heights.
            const tabHeight = 15; // Height of the toggle tab.
            let expanded = false;
            // When collapsed, outerDiv's height is exactly the toggle tab's height.
            outerDiv.style.height = `${tabHeight}px`;
            // Toggle behavior: clicking the tab shows or hides the content.
            toggleTab.onclick = () => {
                expanded = !expanded;
                if (expanded) {
                    // Show content.
                    contentDiv.style.display = 'inline-flex';
                    // Force reflow to measure the content height.
                    const contentHeight = contentDiv.scrollHeight;
                    // Set the outer container's height to content + tab height.
                    outerDiv.style.height = `${tabHeight + contentHeight}px`;
                    toggleTab.textContent = '▲'; // Up arrow indicates expanded.
                }
                else {
                    // Hide content.
                    contentDiv.style.display = 'none';
                    outerDiv.style.height = `${tabHeight}px`;
                    toggleTab.textContent = '▼'; // Down arrow indicates collapsed.
                }
            };
            return outerDiv;
        }
        _makeToolBoxElement(DrawingType, keyCmd, paths, rotate = false) {
            const elem = document.createElement('div');
            elem.classList.add("toolbox-button");
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("width", "29");
            svg.setAttribute("height", "29");
            const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
            group.innerHTML = paths;
            group.setAttribute("fill", window.pane.color);
            svg.appendChild(group);
            elem.appendChild(svg);
            const icon = { div: elem, group: group, type: DrawingType };
            elem.addEventListener('click', () => this._onIconClick(icon));
            this._commandFunctions.push((event) => {
                if (this._handlerID !== window.handlerInFocus)
                    return false;
                if (event.altKey && event.code === keyCmd) {
                    event.preventDefault();
                    this._onIconClick(icon);
                    return true;
                }
                return false;
            });
            if (rotate == true) {
                svg.style.transform = 'rotate(90deg)';
                svg.style.transformBox = 'fill-box';
                svg.style.transformOrigin = 'center';
            }
            return elem;
        }
        _onIconClick(icon) {
            if (this.activeIcon) {
                this.activeIcon.div.classList.remove('active-toolbox-button');
                window.setCursor('crosshair');
                this._drawingTool?.stopDrawing();
                if (this.activeIcon === icon) {
                    this.activeIcon = null;
                    return;
                }
            }
            this.activeIcon = icon;
            this.activeIcon.div.classList.add('active-toolbox-button');
            window.setCursor('crosshair');
            this._drawingTool?.beginDrawing(this.activeIcon.type);
        }
        removeActiveAndSave = () => {
            window.setCursor('default');
            if (this.activeIcon)
                this.activeIcon.div.classList.remove('active-toolbox-button');
            this.activeIcon = null;
            this.saveDrawings();
        };
        addNewDrawing(d) {
            this._drawingTool.addNewDrawing(d);
        }
        clearDrawings() {
            this._drawingTool.clearDrawings();
        }
        saveDrawings = () => {
            const drawingMeta = [];
            for (const d of this._drawingTool.drawings) {
                drawingMeta.push({
                    type: d._type,
                    points: d.points,
                    options: d._options
                });
            }
            const string = JSON.stringify(drawingMeta);
            window.callbackFunction(`save_drawings${this._handlerID}_~_${string}`);
        };
        loadDrawings(drawings) {
            drawings.forEach((d) => {
                switch (d.type) {
                    case "Box":
                        this._drawingTool.addNewDrawing(new Box(d.points[0], d.points[1], d.options));
                        break;
                    case "TrendLine":
                        this._drawingTool.addNewDrawing(new TrendLine(d.points[0], d.points[1], d.options));
                        break;
                    case "HorizontalLine":
                        this._drawingTool.addNewDrawing(new HorizontalLine(d.points[0], d.options));
                        break;
                    case "RayLine":
                        this._drawingTool.addNewDrawing(new RayLine(d.points[0], d.options));
                        break;
                    case "VerticalLine":
                        this._drawingTool.addNewDrawing(new VerticalLine(d.points[0], d.options));
                        break;
                    // Add cases for pitchfork types if needed:
                    case "PitchFork":
                        this._drawingTool.addNewDrawing(new PitchFork(d.points[0], d.points[1], d.points[2], d.options));
                        break;
                    //case "SchiffPitchfork":
                    //    this._drawingTool.addNewDrawing(new PitchFork(d.points[0], d.points[1], d.points[2], {...d.options, variant: "schiff"}));
                    //    break;
                    //case "ModifiedSchiffPitchfork":
                    //    this._drawingTool.addNewDrawing(new PitchFork(d.points[0], d.points[1], d.points[2], {...d.options, variant: "modifiedSchiff"}));
                    //    break;
                    //case "InsidePitchfork":
                    //    this._drawingTool.addNewDrawing(new PitchFork(d.points[0], d.points[1], d.points[2], {...d.options, variant: "inside"}));
                    //    break;
                    //case "FibonacciSegment":
                    //    this._drawingTool.addNewDrawing(new FibonacciSegmentDrawing(d.points[0], d.points[1], d.options));
                    //    break;
                    //case "FibonacciExtension":
                    //    this._drawingTool.addNewDrawing(new FibonacciExtensionDrawing(d.points[0], d.points[1], d.options));
                    //    break;
                    //case "FibonacciCircle":
                    //    this._drawingTool.addNewDrawing(new FibonacciCircleDrawing(d.points[0], d.points[1], d.options));
                    //    break;
                    //case "FibonacciSpiral":
                    //    this._drawingTool.addNewDrawing(new FibonacciSpiralDrawing(d.points[0], d.points[1], d.options));
                    //    break;
                    //case "GannBox":
                    //    this._drawingTool.addNewDrawing(new GannBoxDrawing(d.points[0], d.points[1], d.points[2], d.points[3], d.options));
                    //    break;
                }
            });
        }
    }

    // This file was generated. Do not modify manually!
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

    // This file was generated. Do not modify manually!
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];

    // This file was generated. Do not modify manually!
    var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";

    // This file was generated. Do not modify manually!
    var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7cd\ua7d0\ua7d1\ua7d3\ua7d5-\ua7dc\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

    // These are a run-length and offset encoded representation of the
    // >0xffff code points that are a valid part of identifiers. The
    // offset starts at 0x10000, and each pair of numbers represents an
    // offset to the next range, and then a size of the range.

    // Reserved word lists for various dialects of the language

    var reservedWords = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };

    // And the keywords

    var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

    var keywords$1 = {
      5: ecma5AndLessKeywords,
      "5module": ecma5AndLessKeywords + " export import",
      6: ecma5AndLessKeywords + " const class extends export import super"
    };

    var keywordRelationalOperator = /^in(stanceof)?$/;

    // ## Character categories

    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

    // This has a complexity linear to the value of the code. The
    // assumption is that looking up astral identifier characters is
    // rare.
    function isInAstralSet(code, set) {
      var pos = 0x10000;
      for (var i = 0; i < set.length; i += 2) {
        pos += set[i];
        if (pos > code) { return false }
        pos += set[i + 1];
        if (pos >= code) { return true }
      }
      return false
    }

    // Test whether a given character code starts an identifier.

    function isIdentifierStart(code, astral) {
      if (code < 65) { return code === 36 }
      if (code < 91) { return true }
      if (code < 97) { return code === 95 }
      if (code < 123) { return true }
      if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
      if (astral === false) { return false }
      return isInAstralSet(code, astralIdentifierStartCodes)
    }

    // Test whether a given character is part of an identifier.

    function isIdentifierChar(code, astral) {
      if (code < 48) { return code === 36 }
      if (code < 58) { return true }
      if (code < 65) { return false }
      if (code < 91) { return true }
      if (code < 97) { return code === 95 }
      if (code < 123) { return true }
      if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
      if (astral === false) { return false }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
    }

    // ## Token types

    // The assignment of fine-grained, information-carrying type objects
    // allows the tokenizer to store the information it has about a
    // token in a way that is very cheap for the parser to look up.

    // All token type variables start with an underscore, to make them
    // easy to recognize.

    // The `beforeExpr` property is used to disambiguate between regular
    // expressions and divisions. It is set on all token types that can
    // be followed by an expression (thus, a slash after them would be a
    // regular expression).
    //
    // The `startsExpr` property is used to check if the token ends a
    // `yield` expression. It is set on all token types that either can
    // directly start an expression (like a quotation mark) or can
    // continue an expression (like the body of a string).
    //
    // `isLoop` marks a keyword as starting a loop, which is important
    // to know when parsing a label, in order to allow or disallow
    // continue jumps to that label.

    var TokenType = function TokenType(label, conf) {
      if ( conf === void 0 ) conf = {};

      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };

    function binop(name, prec) {
      return new TokenType(name, {beforeExpr: true, binop: prec})
    }
    var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

    // Map keyword names to token types.

    var keywords = {};

    // Succinct definitions of keyword token types
    function kw(name, options) {
      if ( options === void 0 ) options = {};

      options.keyword = name;
      return keywords[name] = new TokenType(name, options)
    }

    var types$1 = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      privateId: new TokenType("privateId", startsExpr),
      eof: new TokenType("eof"),

      // Punctuation token types.
      bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      questionDot: new TokenType("?."),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      invalidTemplate: new TokenType("invalidTemplate"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

      // Operators. These carry several kinds of properties to help the
      // parser use them properly (the presence of these properties is
      // what categorizes them as operators).
      //
      // `binop`, when present, specifies that this operator is a binary
      // operator, and will refer to its precedence.
      //
      // `prefix` and `postfix` mark the operator as a prefix or postfix
      // unary operator.
      //
      // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
      // binary operators with a very low precedence, that should result
      // in AssignmentExpression nodes.

      eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
      assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
      incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
      prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=/===/!==", 6),
      relational: binop("</>/<=/>=", 7),
      bitShift: binop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10),
      starstar: new TokenType("**", {beforeExpr: true}),
      coalesce: binop("??", 1),

      // Keyword token types.
      _break: kw("break"),
      _case: kw("case", beforeExpr),
      _catch: kw("catch"),
      _continue: kw("continue"),
      _debugger: kw("debugger"),
      _default: kw("default", beforeExpr),
      _do: kw("do", {isLoop: true, beforeExpr: true}),
      _else: kw("else", beforeExpr),
      _finally: kw("finally"),
      _for: kw("for", {isLoop: true}),
      _function: kw("function", startsExpr),
      _if: kw("if"),
      _return: kw("return", beforeExpr),
      _switch: kw("switch"),
      _throw: kw("throw", beforeExpr),
      _try: kw("try"),
      _var: kw("var"),
      _const: kw("const"),
      _while: kw("while", {isLoop: true}),
      _with: kw("with"),
      _new: kw("new", {beforeExpr: true, startsExpr: true}),
      _this: kw("this", startsExpr),
      _super: kw("super", startsExpr),
      _class: kw("class", startsExpr),
      _extends: kw("extends", beforeExpr),
      _export: kw("export"),
      _import: kw("import", startsExpr),
      _null: kw("null", startsExpr),
      _true: kw("true", startsExpr),
      _false: kw("false", startsExpr),
      _in: kw("in", {beforeExpr: true, binop: 7}),
      _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
      _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
      _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
      _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
    };

    // Matches a whole line break (where CRLF is considered a single
    // line break). Used to count lines.

    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    var lineBreakG = new RegExp(lineBreak.source, "g");

    function isNewLine(code) {
      return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
    }

    function nextLineBreak(code, from, end) {
      if ( end === void 0 ) end = code.length;

      for (var i = from; i < end; i++) {
        var next = code.charCodeAt(i);
        if (isNewLine(next))
          { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
      }
      return -1
    }

    var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

    var ref = Object.prototype;
    var hasOwnProperty = ref.hasOwnProperty;
    var toString = ref.toString;

    var hasOwn = Object.hasOwn || (function (obj, propName) { return (
      hasOwnProperty.call(obj, propName)
    ); });

    var isArray = Array.isArray || (function (obj) { return (
      toString.call(obj) === "[object Array]"
    ); });

    var regexpCache = Object.create(null);

    function wordsRegexp(words) {
      return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"))
    }

    function codePointToString(code) {
      // UTF-16 Decoding
      if (code <= 0xFFFF) { return String.fromCharCode(code) }
      code -= 0x10000;
      return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
    }

    var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

    // These are used when `options.locations` is on, for the
    // `startLoc` and `endLoc` properties.

    var Position = function Position(line, col) {
      this.line = line;
      this.column = col;
    };

    Position.prototype.offset = function offset (n) {
      return new Position(this.line, this.column + n)
    };

    var SourceLocation = function SourceLocation(p, start, end) {
      this.start = start;
      this.end = end;
      if (p.sourceFile !== null) { this.source = p.sourceFile; }
    };

    // The `getLineInfo` function is mostly useful when the
    // `locations` option is off (for performance reasons) and you
    // want to find the line/column position for a given character
    // offset. `input` should be the code string that the offset refers
    // into.

    function getLineInfo(input, offset) {
      for (var line = 1, cur = 0;;) {
        var nextBreak = nextLineBreak(input, cur, offset);
        if (nextBreak < 0) { return new Position(line, offset - cur) }
        ++line;
        cur = nextBreak;
      }
    }

    // A second argument must be given to configure the parser process.
    // These options are recognized (only `ecmaVersion` is required):

    var defaultOptions$2 = {
      // `ecmaVersion` indicates the ECMAScript version to parse. Must be
      // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
      // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
      // (the latest version the library supports). This influences
      // support for strict mode, the set of reserved words, and support
      // for new syntax features.
      ecmaVersion: null,
      // `sourceType` indicates the mode the code should be parsed in.
      // Can be either `"script"` or `"module"`. This influences global
      // strict mode and parsing of `import` and `export` declarations.
      sourceType: "script",
      // `onInsertedSemicolon` can be a callback that will be called when
      // a semicolon is automatically inserted. It will be passed the
      // position of the inserted semicolon as an offset, and if
      // `locations` is enabled, it is given the location as a `{line,
      // column}` object as second argument.
      onInsertedSemicolon: null,
      // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
      // trailing commas.
      onTrailingComma: null,
      // By default, reserved words are only enforced if ecmaVersion >= 5.
      // Set `allowReserved` to a boolean value to explicitly turn this on
      // an off. When this option has the value "never", reserved words
      // and keywords can also not be used as property names.
      allowReserved: null,
      // When enabled, a return at the top level is not considered an
      // error.
      allowReturnOutsideFunction: false,
      // When enabled, import/export statements are not constrained to
      // appearing at the top of the program, and an import.meta expression
      // in a script isn't considered an error.
      allowImportExportEverywhere: false,
      // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
      // When enabled, await identifiers are allowed to appear at the top-level scope,
      // but they are still not allowed in non-async functions.
      allowAwaitOutsideFunction: null,
      // When enabled, super identifiers are not constrained to
      // appearing in methods and do not raise an error when they appear elsewhere.
      allowSuperOutsideMethod: null,
      // When enabled, hashbang directive in the beginning of file is
      // allowed and treated as a line comment. Enabled by default when
      // `ecmaVersion` >= 2023.
      allowHashBang: false,
      // By default, the parser will verify that private properties are
      // only used in places where they are valid and have been declared.
      // Set this to false to turn such checks off.
      checkPrivateFields: true,
      // When `locations` is on, `loc` properties holding objects with
      // `start` and `end` properties in `{line, column}` form (with
      // line being 1-based and column 0-based) will be attached to the
      // nodes.
      locations: false,
      // A function can be passed as `onToken` option, which will
      // cause Acorn to call that function with object in the same
      // format as tokens returned from `tokenizer().getToken()`. Note
      // that you are not allowed to call the parser from the
      // callback—that will corrupt its internal state.
      onToken: null,
      // A function can be passed as `onComment` option, which will
      // cause Acorn to call that function with `(block, text, start,
      // end)` parameters whenever a comment is skipped. `block` is a
      // boolean indicating whether this is a block (`/* */`) comment,
      // `text` is the content of the comment, and `start` and `end` are
      // character offsets that denote the start and end of the comment.
      // When the `locations` option is on, two more parameters are
      // passed, the full `{line, column}` locations of the start and
      // end of the comments. Note that you are not allowed to call the
      // parser from the callback—that will corrupt its internal state.
      // When this option has an array as value, objects representing the
      // comments are pushed to it.
      onComment: null,
      // Nodes have their start and end characters offsets recorded in
      // `start` and `end` properties (directly on the node, rather than
      // the `loc` object, which holds line/column data. To also add a
      // [semi-standardized][range] `range` property holding a `[start,
      // end]` array with the same numbers, set the `ranges` option to
      // `true`.
      //
      // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
      ranges: false,
      // It is possible to parse multiple files into a single AST by
      // passing the tree produced by parsing the first file as
      // `program` option in subsequent parses. This will add the
      // toplevel forms of the parsed file to the `Program` (top) node
      // of an existing parse tree.
      program: null,
      // When `locations` is on, you can pass this to record the source
      // file in every node's `loc` object.
      sourceFile: null,
      // This value, if given, is stored in every node, whether
      // `locations` is on or off.
      directSourceFile: null,
      // When enabled, parenthesized expressions are represented by
      // (non-standard) ParenthesizedExpression nodes
      preserveParens: false
    };

    // Interpret and default an options object

    var warnedAboutEcmaVersion = false;

    function getOptions(opts) {
      var options = {};

      for (var opt in defaultOptions$2)
        { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions$2[opt]; }

      if (options.ecmaVersion === "latest") {
        options.ecmaVersion = 1e8;
      } else if (options.ecmaVersion == null) {
        if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
          warnedAboutEcmaVersion = true;
          console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
        }
        options.ecmaVersion = 11;
      } else if (options.ecmaVersion >= 2015) {
        options.ecmaVersion -= 2009;
      }

      if (options.allowReserved == null)
        { options.allowReserved = options.ecmaVersion < 5; }

      if (!opts || opts.allowHashBang == null)
        { options.allowHashBang = options.ecmaVersion >= 14; }

      if (isArray(options.onToken)) {
        var tokens = options.onToken;
        options.onToken = function (token) { return tokens.push(token); };
      }
      if (isArray(options.onComment))
        { options.onComment = pushComment(options, options.onComment); }

      return options
    }

    function pushComment(options, array) {
      return function(block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? "Block" : "Line",
          value: text,
          start: start,
          end: end
        };
        if (options.locations)
          { comment.loc = new SourceLocation(this, startLoc, endLoc); }
        if (options.ranges)
          { comment.range = [start, end]; }
        array.push(comment);
      }
    }

    // Each scope gets a bitset that may contain these flags
    var
        SCOPE_TOP = 1,
        SCOPE_FUNCTION = 2,
        SCOPE_ASYNC = 4,
        SCOPE_GENERATOR = 8,
        SCOPE_ARROW = 16,
        SCOPE_SIMPLE_CATCH = 32,
        SCOPE_SUPER = 64,
        SCOPE_DIRECT_SUPER = 128,
        SCOPE_CLASS_STATIC_BLOCK = 256,
        SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

    function functionFlags(async, generator) {
      return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
    }

    // Used in checkLVal* and declareName to determine the type of a binding
    var
        BIND_NONE = 0, // Not a binding
        BIND_VAR = 1, // Var-style binding
        BIND_LEXICAL = 2, // Let- or const-style binding
        BIND_FUNCTION = 3, // Function declaration
        BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
        BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

    var Parser = function Parser(options, input, startPos) {
      this.options = options = getOptions(options);
      this.sourceFile = options.sourceFile;
      this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
      var reserved = "";
      if (options.allowReserved !== true) {
        reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
        if (options.sourceType === "module") { reserved += " await"; }
      }
      this.reservedWords = wordsRegexp(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
      this.reservedWordsStrict = wordsRegexp(reservedStrict);
      this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
      this.input = String(input);

      // Used to signal to callers of `readWord1` whether the word
      // contained any escape sequences. This is needed because words with
      // escape sequences must not be interpreted as keywords.
      this.containsEsc = false;

      // Set up token state

      // The current position of the tokenizer in the input.
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }

      // Properties of the current token:
      // Its type
      this.type = types$1.eof;
      // For tokens that include more information than their type, the value
      this.value = null;
      // Its start and end offset
      this.start = this.end = this.pos;
      // And, if locations are used, the {line, column} object
      // corresponding to those offsets
      this.startLoc = this.endLoc = this.curPosition();

      // Position information for the previous token
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;

      // The context stack is used to superficially track syntactic
      // context to predict whether a regular expression is allowed in a
      // given position.
      this.context = this.initialContext();
      this.exprAllowed = true;

      // Figure out if it's a module code.
      this.inModule = options.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);

      // Used to signify the start of a potential arrow function
      this.potentialArrowAt = -1;
      this.potentialArrowInForAwait = false;

      // Positions to delayed-check that yield/await does not exist in default parameters.
      this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
      // Labels in scope.
      this.labels = [];
      // Thus-far undefined exports.
      this.undefinedExports = Object.create(null);

      // If enabled, skip leading hashbang line.
      if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
        { this.skipLineComment(2); }

      // Scope tracking for duplicate variable names (see scope.js)
      this.scopeStack = [];
      this.enterScope(SCOPE_TOP);

      // For RegExp validation
      this.regexpState = null;

      // The stack of private names.
      // Each element has two properties: 'declared' and 'used'.
      // When it exited from the outermost class definition, all used private names must be declared.
      this.privateNameStack = [];
    };

    var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

    Parser.prototype.parse = function parse () {
      var node = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node)
    };

    prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

    prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };

    prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };

    prototypeAccessors.canAwait.get = function () {
      for (var i = this.scopeStack.length - 1; i >= 0; i--) {
        var scope = this.scopeStack[i];
        if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }
        if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }
      }
      return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
    };

    prototypeAccessors.allowSuper.get = function () {
      var ref = this.currentThisScope();
        var flags = ref.flags;
        var inClassFieldInit = ref.inClassFieldInit;
      return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
    };

    prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

    prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

    prototypeAccessors.allowNewDotTarget.get = function () {
      var ref = this.currentThisScope();
        var flags = ref.flags;
        var inClassFieldInit = ref.inClassFieldInit;
      return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
    };

    prototypeAccessors.inClassStaticBlock.get = function () {
      return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
    };

    Parser.extend = function extend () {
        var plugins = [], len = arguments.length;
        while ( len-- ) plugins[ len ] = arguments[ len ];

      var cls = this;
      for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
      return cls
    };

    Parser.parse = function parse (input, options) {
      return new this(options, input).parse()
    };

    Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
      var parser = new this(options, input, pos);
      parser.nextToken();
      return parser.parseExpression()
    };

    Parser.tokenizer = function tokenizer (input, options) {
      return new this(options, input)
    };

    Object.defineProperties( Parser.prototype, prototypeAccessors );

    var pp$9 = Parser.prototype;

    // ## Parser utilities

    var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
    pp$9.strictDirective = function(start) {
      if (this.options.ecmaVersion < 5) { return false }
      for (;;) {
        // Try to find string literal.
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match = literal.exec(this.input.slice(start));
        if (!match) { return false }
        if ((match[1] || match[2]) === "use strict") {
          skipWhiteSpace.lastIndex = start + match[0].length;
          var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
          var next = this.input.charAt(end);
          return next === ";" || next === "}" ||
            (lineBreak.test(spaceAfter[0]) &&
             !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
        }
        start += match[0].length;

        // Skip semicolon, if any.
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        if (this.input[start] === ";")
          { start++; }
      }
    };

    // Predicate that tests whether the next token is of the given
    // type, and if yes, consumes it as a side effect.

    pp$9.eat = function(type) {
      if (this.type === type) {
        this.next();
        return true
      } else {
        return false
      }
    };

    // Tests whether parsed token is a contextual keyword.

    pp$9.isContextual = function(name) {
      return this.type === types$1.name && this.value === name && !this.containsEsc
    };

    // Consumes contextual keyword if possible.

    pp$9.eatContextual = function(name) {
      if (!this.isContextual(name)) { return false }
      this.next();
      return true
    };

    // Asserts that following token is given contextual keyword.

    pp$9.expectContextual = function(name) {
      if (!this.eatContextual(name)) { this.unexpected(); }
    };

    // Test whether a semicolon can be inserted at the current position.

    pp$9.canInsertSemicolon = function() {
      return this.type === types$1.eof ||
        this.type === types$1.braceR ||
        lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
    };

    pp$9.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon)
          { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
        return true
      }
    };

    // Consume a semicolon, or, failing that, see if we are allowed to
    // pretend that there is a semicolon at this position.

    pp$9.semicolon = function() {
      if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
    };

    pp$9.afterTrailingComma = function(tokType, notNext) {
      if (this.type === tokType) {
        if (this.options.onTrailingComma)
          { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
        if (!notNext)
          { this.next(); }
        return true
      }
    };

    // Expect a token of a given type. If found, consume it, otherwise,
    // raise an unexpected token error.

    pp$9.expect = function(type) {
      this.eat(type) || this.unexpected();
    };

    // Raise an unexpected token error.

    pp$9.unexpected = function(pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };

    var DestructuringErrors = function DestructuringErrors() {
      this.shorthandAssign =
      this.trailingComma =
      this.parenthesizedAssign =
      this.parenthesizedBind =
      this.doubleProto =
        -1;
    };

    pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) { return }
      if (refDestructuringErrors.trailingComma > -1)
        { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
    };

    pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      if (!refDestructuringErrors) { return false }
      var shorthandAssign = refDestructuringErrors.shorthandAssign;
      var doubleProto = refDestructuringErrors.doubleProto;
      if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
      if (shorthandAssign >= 0)
        { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
      if (doubleProto >= 0)
        { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
    };

    pp$9.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
        { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
      if (this.awaitPos)
        { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
    };

    pp$9.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression")
        { return this.isSimpleAssignTarget(expr.expression) }
      return expr.type === "Identifier" || expr.type === "MemberExpression"
    };

    var pp$8 = Parser.prototype;

    // ### Statement parsing

    // Parse a program. Initializes the parser, reads any number of
    // statements, and wraps them in a Program node.  Optionally takes a
    // `program` argument.  If present, the statements will be appended
    // to its body instead of creating a new node.

    pp$8.parseTopLevel = function(node) {
      var exports = Object.create(null);
      if (!node.body) { node.body = []; }
      while (this.type !== types$1.eof) {
        var stmt = this.parseStatement(null, true, exports);
        node.body.push(stmt);
      }
      if (this.inModule)
        { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
          {
            var name = list[i];

            this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
          } }
      this.adaptDirectivePrologue(node.body);
      this.next();
      node.sourceType = this.options.sourceType;
      return this.finishNode(node, "Program")
    };

    var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

    pp$8.isLet = function(context) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      // For ambiguous cases, determine if a LexicalDeclaration (or only a
      // Statement) is allowed here. If context is not empty then only a Statement
      // is allowed. However, `let [` is an explicit negative lookahead for
      // ExpressionStatement, so special-case it first.
      if (nextCh === 91 || nextCh === 92) { return true } // '[', '\'
      if (context) { return false }

      if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral
      if (isIdentifierStart(nextCh, true)) {
        var pos = next + 1;
        while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
        if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) { return true }
      }
      return false
    };

    // check 'async [no LineTerminator here] function'
    // - 'async /*foo*/ function' is OK.
    // - 'async /*\n*/ function' is invalid.
    pp$8.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
        { return false }

      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, after;
      return !lineBreak.test(this.input.slice(this.pos, next)) &&
        this.input.slice(next, next + 8) === "function" &&
        (next + 8 === this.input.length ||
         !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
    };

    // Parse a single statement.
    //
    // If expecting a statement and finding a slash operator, parse a
    // regular expression literal. This is to handle cases like
    // `if (foo) /blah/.exec(foo)`, where looking at the previous token
    // does not help.

    pp$8.parseStatement = function(context, topLevel, exports) {
      var starttype = this.type, node = this.startNode(), kind;

      if (this.isLet(context)) {
        starttype = types$1._var;
        kind = "let";
      }

      // Most types of statements are recognized by the keyword they
      // start with. Many are trivial to parse, some require a bit of
      // complexity.

      switch (starttype) {
      case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
      case types$1._debugger: return this.parseDebuggerStatement(node)
      case types$1._do: return this.parseDoStatement(node)
      case types$1._for: return this.parseForStatement(node)
      case types$1._function:
        // Function as sole body of either an if statement or a labeled statement
        // works, but not when it is part of a labeled statement that is the sole
        // body of an if statement.
        if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
        return this.parseFunctionStatement(node, false, !context)
      case types$1._class:
        if (context) { this.unexpected(); }
        return this.parseClass(node, true)
      case types$1._if: return this.parseIfStatement(node)
      case types$1._return: return this.parseReturnStatement(node)
      case types$1._switch: return this.parseSwitchStatement(node)
      case types$1._throw: return this.parseThrowStatement(node)
      case types$1._try: return this.parseTryStatement(node)
      case types$1._const: case types$1._var:
        kind = kind || this.value;
        if (context && kind !== "var") { this.unexpected(); }
        return this.parseVarStatement(node, kind)
      case types$1._while: return this.parseWhileStatement(node)
      case types$1._with: return this.parseWithStatement(node)
      case types$1.braceL: return this.parseBlock(true, node)
      case types$1.semi: return this.parseEmptyStatement(node)
      case types$1._export:
      case types$1._import:
        if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
          if (nextCh === 40 || nextCh === 46) // '(' or '.'
            { return this.parseExpressionStatement(node, this.parseExpression()) }
        }

        if (!this.options.allowImportExportEverywhere) {
          if (!topLevel)
            { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
          if (!this.inModule)
            { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
        }
        return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)

        // If the statement does not start with a statement keyword or a
        // brace, it's an ExpressionStatement or LabeledStatement. We
        // simply start parsing an expression, and afterwards, if the
        // next token is a colon and the expression was a simple
        // Identifier node, we switch to interpreting it as a label.
      default:
        if (this.isAsyncFunction()) {
          if (context) { this.unexpected(); }
          this.next();
          return this.parseFunctionStatement(node, true, !context)
        }

        var maybeName = this.value, expr = this.parseExpression();
        if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
          { return this.parseLabeledStatement(node, maybeName, expr, context) }
        else { return this.parseExpressionStatement(node, expr) }
      }
    };

    pp$8.parseBreakContinueStatement = function(node, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
      else if (this.type !== types$1.name) { this.unexpected(); }
      else {
        node.label = this.parseIdent();
        this.semicolon();
      }

      // Verify that there is an actual destination to break or
      // continue to.
      var i = 0;
      for (; i < this.labels.length; ++i) {
        var lab = this.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
          if (node.label && isBreak) { break }
        }
      }
      if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
    };

    pp$8.parseDebuggerStatement = function(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement")
    };

    pp$8.parseDoStatement = function(node) {
      this.next();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("do");
      this.labels.pop();
      this.expect(types$1._while);
      node.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6)
        { this.eat(types$1.semi); }
      else
        { this.semicolon(); }
      return this.finishNode(node, "DoWhileStatement")
    };

    // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
    // loop is non-trivial. Basically, we have to parse the init `var`
    // statement or expression, disallowing the `in` operator (see
    // the second parameter to `parseExpression`), and then check
    // whether the next token is `in` or `of`. When there is no init
    // part (semicolon immediately after the opening parenthesis), it
    // is a regular `for` loop.

    pp$8.parseForStatement = function(node) {
      this.next();
      var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
      this.labels.push(loopLabel);
      this.enterScope(0);
      this.expect(types$1.parenL);
      if (this.type === types$1.semi) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
        return this.parseFor(node, null)
      }
      var isLet = this.isLet();
      if (this.type === types$1._var || this.type === types$1._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) { this.unexpected(awaitAt); }
            } else { node.await = awaitAt > -1; }
          }
          return this.parseForIn(node, init$1)
        }
        if (awaitAt > -1) { this.unexpected(awaitAt); }
        return this.parseFor(node, init$1)
      }
      var startsWithLet = this.isContextual("let"), isForOf = false;
      var containsEsc = this.containsEsc;
      var refDestructuringErrors = new DestructuringErrors;
      var initPos = this.start;
      var init = awaitAt > -1
        ? this.parseExprSubscripts(refDestructuringErrors, "await")
        : this.parseExpression(true, refDestructuringErrors);
      if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        if (awaitAt > -1) { // implies `ecmaVersion >= 9` (see declaration of awaitAt)
          if (this.type === types$1._in) { this.unexpected(awaitAt); }
          node.await = true;
        } else if (isForOf && this.options.ecmaVersion >= 8) {
          if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") { this.unexpected(); }
          else if (this.options.ecmaVersion >= 9) { node.await = false; }
        }
        if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
        this.toAssignable(init, false, refDestructuringErrors);
        this.checkLValPattern(init);
        return this.parseForIn(node, init)
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init)
    };

    pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
    };

    pp$8.parseIfStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      // allow function declarations in branches, but only in non-strict mode
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement")
    };

    pp$8.parseReturnStatement = function(node) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction)
        { this.raise(this.start, "'return' outside of function"); }
      this.next();

      // In `return` (and `break`/`continue`), the keywords with
      // optional arguments, we eagerly look for a semicolon or the
      // possibility to insert one.

      if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
      else { node.argument = this.parseExpression(); this.semicolon(); }
      return this.finishNode(node, "ReturnStatement")
    };

    pp$8.parseSwitchStatement = function(node) {
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.expect(types$1.braceL);
      this.labels.push(switchLabel);
      this.enterScope(0);

      // Statements under must be grouped (by label) in SwitchCase
      // nodes. `cur` is used to keep the node that we are currently
      // adding statements to.

      var cur;
      for (var sawDefault = false; this.type !== types$1.braceR;) {
        if (this.type === types$1._case || this.type === types$1._default) {
          var isCase = this.type === types$1._case;
          if (cur) { this.finishNode(cur, "SwitchCase"); }
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types$1.colon);
        } else {
          if (!cur) { this.unexpected(); }
          cur.consequent.push(this.parseStatement(null));
        }
      }
      this.exitScope();
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      this.next(); // Closing brace
      this.labels.pop();
      return this.finishNode(node, "SwitchStatement")
    };

    pp$8.parseThrowStatement = function(node) {
      this.next();
      if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
        { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement")
    };

    // Reused empty array added for node fields that are always empty.

    var empty$1 = [];

    pp$8.parseCatchClauseParam = function() {
      var param = this.parseBindingAtom();
      var simple = param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types$1.parenR);

      return param
    };

    pp$8.parseTryStatement = function(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.type === types$1._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types$1.parenL)) {
          clause.param = this.parseCatchClauseParam();
        } else {
          if (this.options.ecmaVersion < 10) { this.unexpected(); }
          clause.param = null;
          this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer)
        { this.raise(node.start, "Missing catch or finally clause"); }
      return this.finishNode(node, "TryStatement")
    };

    pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
      this.next();
      this.parseVar(node, false, kind, allowMissingInitializer);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration")
    };

    pp$8.parseWhileStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("while");
      this.labels.pop();
      return this.finishNode(node, "WhileStatement")
    };

    pp$8.parseWithStatement = function(node) {
      if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement("with");
      return this.finishNode(node, "WithStatement")
    };

    pp$8.parseEmptyStatement = function(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement")
    };

    pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
      for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
        {
        var label = list[i$1];

        if (label.name === maybeName)
          { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
      } }
      var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
      for (var i = this.labels.length - 1; i >= 0; i--) {
        var label$1 = this.labels[i];
        if (label$1.statementStart === node.start) {
          // Update information about previous labels on this node
          label$1.statementStart = this.start;
          label$1.kind = kind;
        } else { break }
      }
      this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement")
    };

    pp$8.parseExpressionStatement = function(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement")
    };

    // Parse a semicolon-enclosed block of statements, handling `"use
    // strict"` declarations when `allowStrict` is true (used for
    // function bodies).

    pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
      if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
      if ( node === void 0 ) node = this.startNode();

      node.body = [];
      this.expect(types$1.braceL);
      if (createNewLexicalScope) { this.enterScope(0); }
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
      }
      if (exitStrict) { this.strict = false; }
      this.next();
      if (createNewLexicalScope) { this.exitScope(); }
      return this.finishNode(node, "BlockStatement")
    };

    // Parse a regular `for` loop. The disambiguation code in
    // `parseStatement` will already have parsed the init statement or
    // expression.

    pp$8.parseFor = function(node, init) {
      node.init = init;
      this.expect(types$1.semi);
      node.test = this.type === types$1.semi ? null : this.parseExpression();
      this.expect(types$1.semi);
      node.update = this.type === types$1.parenR ? null : this.parseExpression();
      this.expect(types$1.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, "ForStatement")
    };

    // Parse a `for`/`in` and `for`/`of` loop, which are almost
    // same from parser's perspective.

    pp$8.parseForIn = function(node, init) {
      var isForIn = this.type === types$1._in;
      this.next();

      if (
        init.type === "VariableDeclaration" &&
        init.declarations[0].init != null &&
        (
          !isForIn ||
          this.options.ecmaVersion < 8 ||
          this.strict ||
          init.kind !== "var" ||
          init.declarations[0].id.type !== "Identifier"
        )
      ) {
        this.raise(
          init.start,
          ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
        );
      }
      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types$1.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
    };

    // Parse a list of variable declarations.

    pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
      node.declarations = [];
      node.kind = kind;
      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types$1.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
          this.unexpected();
        } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types$1.comma)) { break }
      }
      return node
    };

    pp$8.parseVarId = function(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };

    var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

    // Parse a function declaration or literal (depending on the
    // `statement & FUNC_STATEMENT`).

    // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
    pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
      this.initFunction(node);
      if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
          { this.unexpected(); }
        node.generator = this.eat(types$1.star);
      }
      if (this.options.ecmaVersion >= 8)
        { node.async = !!isAsync; }

      if (statement & FUNC_STATEMENT) {
        node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();
        if (node.id && !(statement & FUNC_HANGING_STATEMENT))
          // If it is a regular function declaration in sloppy mode, then it is
          // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
          // mode depends on properties of the current scope (see
          // treatFunctionsAsVar).
          { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
      }

      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(node.async, node.generator));

      if (!(statement & FUNC_STATEMENT))
        { node.id = this.type === types$1.name ? this.parseIdent() : null; }

      this.parseFunctionParams(node);
      this.parseFunctionBody(node, allowExpressionBody, false, forInit);

      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
    };

    pp$8.parseFunctionParams = function(node) {
      this.expect(types$1.parenL);
      node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };

    // Parse a class declaration or literal (depending on the
    // `isStatement` parameter).

    pp$8.parseClass = function(node, isStatement) {
      this.next();

      // ecma-262 14.6 Class Definitions
      // A class definition is always strict mode code.
      var oldStrict = this.strict;
      this.strict = true;

      this.parseClassId(node, isStatement);
      this.parseClassSuper(node);
      var privateNameMap = this.enterClassBody();
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types$1.braceL);
      while (this.type !== types$1.braceR) {
        var element = this.parseClassElement(node.superClass !== null);
        if (element) {
          classBody.body.push(element);
          if (element.type === "MethodDefinition" && element.kind === "constructor") {
            if (hadConstructor) { this.raiseRecoverable(element.start, "Duplicate constructor in the same class"); }
            hadConstructor = true;
          } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
            this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
          }
        }
      }
      this.strict = oldStrict;
      this.next();
      node.body = this.finishNode(classBody, "ClassBody");
      this.exitClassBody();
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
    };

    pp$8.parseClassElement = function(constructorAllowsSuper) {
      if (this.eat(types$1.semi)) { return null }

      var ecmaVersion = this.options.ecmaVersion;
      var node = this.startNode();
      var keyName = "";
      var isGenerator = false;
      var isAsync = false;
      var kind = "method";
      var isStatic = false;

      if (this.eatContextual("static")) {
        // Parse static init block
        if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
          this.parseClassStaticBlock(node);
          return node
        }
        if (this.isClassElementNameStart() || this.type === types$1.star) {
          isStatic = true;
        } else {
          keyName = "static";
        }
      }
      node.static = isStatic;
      if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
        if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
          isAsync = true;
        } else {
          keyName = "async";
        }
      }
      if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
        isGenerator = true;
      }
      if (!keyName && !isAsync && !isGenerator) {
        var lastValue = this.value;
        if (this.eatContextual("get") || this.eatContextual("set")) {
          if (this.isClassElementNameStart()) {
            kind = lastValue;
          } else {
            keyName = lastValue;
          }
        }
      }

      // Parse element name
      if (keyName) {
        // 'async', 'get', 'set', or 'static' were not a keyword contextually.
        // The last token is any of those. Make it the element name.
        node.computed = false;
        node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
        node.key.name = keyName;
        this.finishNode(node.key, "Identifier");
      } else {
        this.parseClassElementName(node);
      }

      // Parse element value
      if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
        var isConstructor = !node.static && checkKeyName(node, "constructor");
        var allowsDirectSuper = isConstructor && constructorAllowsSuper;
        // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
        if (isConstructor && kind !== "method") { this.raise(node.key.start, "Constructor can't have get/set modifier"); }
        node.kind = isConstructor ? "constructor" : kind;
        this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
      } else {
        this.parseClassField(node);
      }

      return node
    };

    pp$8.isClassElementNameStart = function() {
      return (
        this.type === types$1.name ||
        this.type === types$1.privateId ||
        this.type === types$1.num ||
        this.type === types$1.string ||
        this.type === types$1.bracketL ||
        this.type.keyword
      )
    };

    pp$8.parseClassElementName = function(element) {
      if (this.type === types$1.privateId) {
        if (this.value === "constructor") {
          this.raise(this.start, "Classes can't have an element named '#constructor'");
        }
        element.computed = false;
        element.key = this.parsePrivateIdent();
      } else {
        this.parsePropertyName(element);
      }
    };

    pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
      // Check key and flags
      var key = method.key;
      if (method.kind === "constructor") {
        if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
        if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
      } else if (method.static && checkKeyName(method, "prototype")) {
        this.raise(key.start, "Classes may not have a static property named prototype");
      }

      // Parse value
      var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);

      // Check value
      if (method.kind === "get" && value.params.length !== 0)
        { this.raiseRecoverable(value.start, "getter should have no params"); }
      if (method.kind === "set" && value.params.length !== 1)
        { this.raiseRecoverable(value.start, "setter should have exactly one param"); }
      if (method.kind === "set" && value.params[0].type === "RestElement")
        { this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"); }

      return this.finishNode(method, "MethodDefinition")
    };

    pp$8.parseClassField = function(field) {
      if (checkKeyName(field, "constructor")) {
        this.raise(field.key.start, "Classes can't have a field named 'constructor'");
      } else if (field.static && checkKeyName(field, "prototype")) {
        this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
      }

      if (this.eat(types$1.eq)) {
        // To raise SyntaxError if 'arguments' exists in the initializer.
        var scope = this.currentThisScope();
        var inClassFieldInit = scope.inClassFieldInit;
        scope.inClassFieldInit = true;
        field.value = this.parseMaybeAssign();
        scope.inClassFieldInit = inClassFieldInit;
      } else {
        field.value = null;
      }
      this.semicolon();

      return this.finishNode(field, "PropertyDefinition")
    };

    pp$8.parseClassStaticBlock = function(node) {
      node.body = [];

      var oldLabels = this.labels;
      this.labels = [];
      this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
      }
      this.next();
      this.exitScope();
      this.labels = oldLabels;

      return this.finishNode(node, "StaticBlock")
    };

    pp$8.parseClassId = function(node, isStatement) {
      if (this.type === types$1.name) {
        node.id = this.parseIdent();
        if (isStatement)
          { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
      } else {
        if (isStatement === true)
          { this.unexpected(); }
        node.id = null;
      }
    };

    pp$8.parseClassSuper = function(node) {
      node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
    };

    pp$8.enterClassBody = function() {
      var element = {declared: Object.create(null), used: []};
      this.privateNameStack.push(element);
      return element.declared
    };

    pp$8.exitClassBody = function() {
      var ref = this.privateNameStack.pop();
      var declared = ref.declared;
      var used = ref.used;
      if (!this.options.checkPrivateFields) { return }
      var len = this.privateNameStack.length;
      var parent = len === 0 ? null : this.privateNameStack[len - 1];
      for (var i = 0; i < used.length; ++i) {
        var id = used[i];
        if (!hasOwn(declared, id.name)) {
          if (parent) {
            parent.used.push(id);
          } else {
            this.raiseRecoverable(id.start, ("Private field '#" + (id.name) + "' must be declared in an enclosing class"));
          }
        }
      }
    };

    function isPrivateNameConflicted(privateNameMap, element) {
      var name = element.key.name;
      var curr = privateNameMap[name];

      var next = "true";
      if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
        next = (element.static ? "s" : "i") + element.kind;
      }

      // `class { get #a(){}; static set #a(_){} }` is also conflict.
      if (
        curr === "iget" && next === "iset" ||
        curr === "iset" && next === "iget" ||
        curr === "sget" && next === "sset" ||
        curr === "sset" && next === "sget"
      ) {
        privateNameMap[name] = "true";
        return false
      } else if (!curr) {
        privateNameMap[name] = next;
        return false
      } else {
        return true
      }
    }

    function checkKeyName(node, name) {
      var computed = node.computed;
      var key = node.key;
      return !computed && (
        key.type === "Identifier" && key.name === name ||
        key.type === "Literal" && key.value === name
      )
    }

    // Parses module export declaration.

    pp$8.parseExportAllDeclaration = function(node, exports) {
      if (this.options.ecmaVersion >= 11) {
        if (this.eatContextual("as")) {
          node.exported = this.parseModuleExportName();
          this.checkExport(exports, node.exported, this.lastTokStart);
        } else {
          node.exported = null;
        }
      }
      this.expectContextual("from");
      if (this.type !== types$1.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16)
        { node.attributes = this.parseWithClause(); }
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration")
    };

    pp$8.parseExport = function(node, exports) {
      this.next();
      // export * from '...'
      if (this.eat(types$1.star)) {
        return this.parseExportAllDeclaration(node, exports)
      }
      if (this.eat(types$1._default)) { // export default ...
        this.checkExport(exports, "default", this.lastTokStart);
        node.declaration = this.parseExportDefaultDeclaration();
        return this.finishNode(node, "ExportDefaultDeclaration")
      }
      // export var|const|let|function|class ...
      if (this.shouldParseExportStatement()) {
        node.declaration = this.parseExportDeclaration(node);
        if (node.declaration.type === "VariableDeclaration")
          { this.checkVariableExport(exports, node.declaration.declarations); }
        else
          { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
        node.specifiers = [];
        node.source = null;
      } else { // export { x, y as z } [from '...']
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers(exports);
        if (this.eatContextual("from")) {
          if (this.type !== types$1.string) { this.unexpected(); }
          node.source = this.parseExprAtom();
          if (this.options.ecmaVersion >= 16)
            { node.attributes = this.parseWithClause(); }
        } else {
          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
            // check for keywords used as local names
            var spec = list[i];

            this.checkUnreserved(spec.local);
            // check if export is defined
            this.checkLocalExport(spec.local);

            if (spec.local.type === "Literal") {
              this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
          }

          node.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node, "ExportNamedDeclaration")
    };

    pp$8.parseExportDeclaration = function(node) {
      return this.parseStatement(null)
    };

    pp$8.parseExportDefaultDeclaration = function() {
      var isAsync;
      if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) { this.next(); }
        return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync)
      } else if (this.type === types$1._class) {
        var cNode = this.startNode();
        return this.parseClass(cNode, "nullableID")
      } else {
        var declaration = this.parseMaybeAssign();
        this.semicolon();
        return declaration
      }
    };

    pp$8.checkExport = function(exports, name, pos) {
      if (!exports) { return }
      if (typeof name !== "string")
        { name = name.type === "Identifier" ? name.name : name.value; }
      if (hasOwn(exports, name))
        { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
      exports[name] = true;
    };

    pp$8.checkPatternExport = function(exports, pat) {
      var type = pat.type;
      if (type === "Identifier")
        { this.checkExport(exports, pat, pat.start); }
      else if (type === "ObjectPattern")
        { for (var i = 0, list = pat.properties; i < list.length; i += 1)
          {
            var prop = list[i];

            this.checkPatternExport(exports, prop);
          } }
      else if (type === "ArrayPattern")
        { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
          var elt = list$1[i$1];

            if (elt) { this.checkPatternExport(exports, elt); }
        } }
      else if (type === "Property")
        { this.checkPatternExport(exports, pat.value); }
      else if (type === "AssignmentPattern")
        { this.checkPatternExport(exports, pat.left); }
      else if (type === "RestElement")
        { this.checkPatternExport(exports, pat.argument); }
    };

    pp$8.checkVariableExport = function(exports, decls) {
      if (!exports) { return }
      for (var i = 0, list = decls; i < list.length; i += 1)
        {
        var decl = list[i];

        this.checkPatternExport(exports, decl.id);
      }
    };

    pp$8.shouldParseExportStatement = function() {
      return this.type.keyword === "var" ||
        this.type.keyword === "const" ||
        this.type.keyword === "class" ||
        this.type.keyword === "function" ||
        this.isLet() ||
        this.isAsyncFunction()
    };

    // Parses a comma-separated list of module exports.

    pp$8.parseExportSpecifier = function(exports) {
      var node = this.startNode();
      node.local = this.parseModuleExportName();

      node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
      this.checkExport(
        exports,
        node.exported,
        node.exported.start
      );

      return this.finishNode(node, "ExportSpecifier")
    };

    pp$8.parseExportSpecifiers = function(exports) {
      var nodes = [], first = true;
      // export { x, y as z } [from '...']
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) { break }
        } else { first = false; }

        nodes.push(this.parseExportSpecifier(exports));
      }
      return nodes
    };

    // Parses import declaration.

    pp$8.parseImport = function(node) {
      this.next();

      // import '...'
      if (this.type === types$1.string) {
        node.specifiers = empty$1;
        node.source = this.parseExprAtom();
      } else {
        node.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
      }
      if (this.options.ecmaVersion >= 16)
        { node.attributes = this.parseWithClause(); }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration")
    };

    // Parses a comma-separated list of module imports.

    pp$8.parseImportSpecifier = function() {
      var node = this.startNode();
      node.imported = this.parseModuleExportName();

      if (this.eatContextual("as")) {
        node.local = this.parseIdent();
      } else {
        this.checkUnreserved(node.imported);
        node.local = node.imported;
      }
      this.checkLValSimple(node.local, BIND_LEXICAL);

      return this.finishNode(node, "ImportSpecifier")
    };

    pp$8.parseImportDefaultSpecifier = function() {
      // import defaultObj, { x, y as z } from '...'
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLValSimple(node.local, BIND_LEXICAL);
      return this.finishNode(node, "ImportDefaultSpecifier")
    };

    pp$8.parseImportNamespaceSpecifier = function() {
      var node = this.startNode();
      this.next();
      this.expectContextual("as");
      node.local = this.parseIdent();
      this.checkLValSimple(node.local, BIND_LEXICAL);
      return this.finishNode(node, "ImportNamespaceSpecifier")
    };

    pp$8.parseImportSpecifiers = function() {
      var nodes = [], first = true;
      if (this.type === types$1.name) {
        nodes.push(this.parseImportDefaultSpecifier());
        if (!this.eat(types$1.comma)) { return nodes }
      }
      if (this.type === types$1.star) {
        nodes.push(this.parseImportNamespaceSpecifier());
        return nodes
      }
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) { break }
        } else { first = false; }

        nodes.push(this.parseImportSpecifier());
      }
      return nodes
    };

    pp$8.parseWithClause = function() {
      var nodes = [];
      if (!this.eat(types$1._with)) {
        return nodes
      }
      this.expect(types$1.braceL);
      var attributeKeys = {};
      var first = true;
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) { break }
        } else { first = false; }

        var attr = this.parseImportAttribute();
        var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
        if (hasOwn(attributeKeys, keyName))
          { this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'"); }
        attributeKeys[keyName] = true;
        nodes.push(attr);
      }
      return nodes
    };

    pp$8.parseImportAttribute = function() {
      var node = this.startNode();
      node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      this.expect(types$1.colon);
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.value = this.parseExprAtom();
      return this.finishNode(node, "ImportAttribute")
    };

    pp$8.parseModuleExportName = function() {
      if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
        var stringLiteral = this.parseLiteral(this.value);
        if (loneSurrogate.test(stringLiteral.value)) {
          this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
        }
        return stringLiteral
      }
      return this.parseIdent(true)
    };

    // Set `ExpressionStatement#directive` property for directive prologues.
    pp$8.adaptDirectivePrologue = function(statements) {
      for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
        statements[i].directive = statements[i].expression.raw.slice(1, -1);
      }
    };
    pp$8.isDirectiveCandidate = function(statement) {
      return (
        this.options.ecmaVersion >= 5 &&
        statement.type === "ExpressionStatement" &&
        statement.expression.type === "Literal" &&
        typeof statement.expression.value === "string" &&
        // Reject parenthesized strings.
        (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
      )
    };

    var pp$7 = Parser.prototype;

    // Convert existing expression atom to assignable pattern
    // if possible.

    pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 6 && node) {
        switch (node.type) {
        case "Identifier":
          if (this.inAsync && node.name === "await")
            { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
          break

        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break

        case "ObjectExpression":
          node.type = "ObjectPattern";
          if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
          for (var i = 0, list = node.properties; i < list.length; i += 1) {
            var prop = list[i];

          this.toAssignable(prop, isBinding);
            // Early error:
            //   AssignmentRestProperty[Yield, Await] :
            //     `...` DestructuringAssignmentTarget[Yield, Await]
            //
            //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
            if (
              prop.type === "RestElement" &&
              (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
            ) {
              this.raise(prop.argument.start, "Unexpected token");
            }
          }
          break

        case "Property":
          // AssignmentProperty has type === "Property"
          if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
          this.toAssignable(node.value, isBinding);
          break

        case "ArrayExpression":
          node.type = "ArrayPattern";
          if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
          this.toAssignableList(node.elements, isBinding);
          break

        case "SpreadElement":
          node.type = "RestElement";
          this.toAssignable(node.argument, isBinding);
          if (node.argument.type === "AssignmentPattern")
            { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
          break

        case "AssignmentExpression":
          if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left, isBinding);
          break

        case "ParenthesizedExpression":
          this.toAssignable(node.expression, isBinding, refDestructuringErrors);
          break

        case "ChainExpression":
          this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
          break

        case "MemberExpression":
          if (!isBinding) { break }

        default:
          this.raise(node.start, "Assigning to rvalue");
        }
      } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      return node
    };

    // Convert list of expression atoms to binding list.

    pp$7.toAssignableList = function(exprList, isBinding) {
      var end = exprList.length;
      for (var i = 0; i < end; i++) {
        var elt = exprList[i];
        if (elt) { this.toAssignable(elt, isBinding); }
      }
      if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
          { this.unexpected(last.argument.start); }
      }
      return exprList
    };

    // Parses spread element.

    pp$7.parseSpread = function(refDestructuringErrors) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node, "SpreadElement")
    };

    pp$7.parseRestBinding = function() {
      var node = this.startNode();
      this.next();

      // RestElement inside of a function parameter must be an identifier
      if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
        { this.unexpected(); }

      node.argument = this.parseBindingAtom();

      return this.finishNode(node, "RestElement")
    };

    // Parses lvalue (assignable) atom.

    pp$7.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) {
        switch (this.type) {
        case types$1.bracketL:
          var node = this.startNode();
          this.next();
          node.elements = this.parseBindingList(types$1.bracketR, true, true);
          return this.finishNode(node, "ArrayPattern")

        case types$1.braceL:
          return this.parseObj(true)
        }
      }
      return this.parseIdent()
    };

    pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (first) { first = false; }
        else { this.expect(types$1.comma); }
        if (allowEmpty && this.type === types$1.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close)) {
          break
        } else if (this.type === types$1.ellipsis) {
          var rest = this.parseRestBinding();
          this.parseBindingListItem(rest);
          elts.push(rest);
          if (this.type === types$1.comma) { this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"); }
          this.expect(close);
          break
        } else {
          elts.push(this.parseAssignableListItem(allowModifiers));
        }
      }
      return elts
    };

    pp$7.parseAssignableListItem = function(allowModifiers) {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      return elem
    };

    pp$7.parseBindingListItem = function(param) {
      return param
    };

    // Parses assignment pattern around given atom if possible.

    pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern")
    };

    // The following three functions all verify that a node is an lvalue —
    // something that can be bound, or assigned to. In order to do so, they perform
    // a variety of checks:
    //
    // - Check that none of the bound/assigned-to identifiers are reserved words.
    // - Record name declarations for bindings in the appropriate scope.
    // - Check duplicate argument names, if checkClashes is set.
    //
    // If a complex binding pattern is encountered (e.g., object and array
    // destructuring), the entire pattern is recursively checked.
    //
    // There are three versions of checkLVal*() appropriate for different
    // circumstances:
    //
    // - checkLValSimple() shall be used if the syntactic construct supports
    //   nothing other than identifiers and member expressions. Parenthesized
    //   expressions are also correctly handled. This is generally appropriate for
    //   constructs for which the spec says
    //
    //   > It is a Syntax Error if AssignmentTargetType of [the production] is not
    //   > simple.
    //
    //   It is also appropriate for checking if an identifier is valid and not
    //   defined elsewhere, like import declarations or function/class identifiers.
    //
    //   Examples where this is used include:
    //     a += …;
    //     import a from '…';
    //   where a is the node to be checked.
    //
    // - checkLValPattern() shall be used if the syntactic construct supports
    //   anything checkLValSimple() supports, as well as object and array
    //   destructuring patterns. This is generally appropriate for constructs for
    //   which the spec says
    //
    //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
    //   > an ArrayLiteral and AssignmentTargetType of [the production] is not
    //   > simple.
    //
    //   Examples where this is used include:
    //     (a = …);
    //     const a = …;
    //     try { … } catch (a) { … }
    //   where a is the node to be checked.
    //
    // - checkLValInnerPattern() shall be used if the syntactic construct supports
    //   anything checkLValPattern() supports, as well as default assignment
    //   patterns, rest elements, and other constructs that may appear within an
    //   object or array destructuring pattern.
    //
    //   As a special case, function parameters also use checkLValInnerPattern(),
    //   as they also support defaults and rest constructs.
    //
    // These functions deliberately support both assignment and binding constructs,
    // as the logic for both is exceedingly similar. If the node is the target of
    // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
    // should be set to the appropriate BIND_* constant, like BIND_VAR or
    // BIND_LEXICAL.
    //
    // If the function is called with a non-BIND_NONE bindingType, then
    // additionally a checkClashes object may be specified to allow checking for
    // duplicate argument names. checkClashes is ignored if the provided construct
    // is an assignment (i.e., bindingType is BIND_NONE).

    pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
      if ( bindingType === void 0 ) bindingType = BIND_NONE;

      var isBind = bindingType !== BIND_NONE;

      switch (expr.type) {
      case "Identifier":
        if (this.strict && this.reservedWordsStrictBind.test(expr.name))
          { this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
        if (isBind) {
          if (bindingType === BIND_LEXICAL && expr.name === "let")
            { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
          if (checkClashes) {
            if (hasOwn(checkClashes, expr.name))
              { this.raiseRecoverable(expr.start, "Argument name clash"); }
            checkClashes[expr.name] = true;
          }
          if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
        }
        break

      case "ChainExpression":
        this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
        break

      case "MemberExpression":
        if (isBind) { this.raiseRecoverable(expr.start, "Binding member expression"); }
        break

      case "ParenthesizedExpression":
        if (isBind) { this.raiseRecoverable(expr.start, "Binding parenthesized expression"); }
        return this.checkLValSimple(expr.expression, bindingType, checkClashes)

      default:
        this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
      }
    };

    pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
      if ( bindingType === void 0 ) bindingType = BIND_NONE;

      switch (expr.type) {
      case "ObjectPattern":
        for (var i = 0, list = expr.properties; i < list.length; i += 1) {
          var prop = list[i];

        this.checkLValInnerPattern(prop, bindingType, checkClashes);
        }
        break

      case "ArrayPattern":
        for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
          var elem = list$1[i$1];

        if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }
        }
        break

      default:
        this.checkLValSimple(expr, bindingType, checkClashes);
      }
    };

    pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
      if ( bindingType === void 0 ) bindingType = BIND_NONE;

      switch (expr.type) {
      case "Property":
        // AssignmentProperty has type === "Property"
        this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
        break

      case "AssignmentPattern":
        this.checkLValPattern(expr.left, bindingType, checkClashes);
        break

      case "RestElement":
        this.checkLValPattern(expr.argument, bindingType, checkClashes);
        break

      default:
        this.checkLValPattern(expr, bindingType, checkClashes);
      }
    };

    // The algorithm used to determine whether a regexp can appear at a
    // given point in the program is loosely based on sweet.js' approach.
    // See https://github.com/mozilla/sweet.js/wiki/design


    var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };

    var types = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", false),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
      f_stat: new TokContext("function", false),
      f_expr: new TokContext("function", true),
      f_expr_gen: new TokContext("function", true, false, null, true),
      f_gen: new TokContext("function", false, false, null, true)
    };

    var pp$6 = Parser.prototype;

    pp$6.initialContext = function() {
      return [types.b_stat]
    };

    pp$6.curContext = function() {
      return this.context[this.context.length - 1]
    };

    pp$6.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types.f_expr || parent === types.f_stat)
        { return true }
      if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
        { return !parent.isExpr }

      // The check for `tt.name && exprAllowed` detects whether we are
      // after a `yield` or `of` construct. See the `updateContext` for
      // `tt.name`.
      if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
        { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
      if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
        { return true }
      if (prevType === types$1.braceL)
        { return parent === types.b_stat }
      if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
        { return false }
      return !this.exprAllowed
    };

    pp$6.inGeneratorContext = function() {
      for (var i = this.context.length - 1; i >= 1; i--) {
        var context = this.context[i];
        if (context.token === "function")
          { return context.generator }
      }
      return false
    };

    pp$6.updateContext = function(prevType) {
      var update, type = this.type;
      if (type.keyword && prevType === types$1.dot)
        { this.exprAllowed = false; }
      else if (update = type.updateContext)
        { update.call(this, prevType); }
      else
        { this.exprAllowed = type.beforeExpr; }
    };

    // Used to handle edge cases when token context could not be inferred correctly during tokenization phase

    pp$6.overrideContext = function(tokenCtx) {
      if (this.curContext() !== tokenCtx) {
        this.context[this.context.length - 1] = tokenCtx;
      }
    };

    // Token-specific context update code

    types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return
      }
      var out = this.context.pop();
      if (out === types.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      this.exprAllowed = !out.isExpr;
    };

    types$1.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
      this.exprAllowed = true;
    };

    types$1.dollarBraceL.updateContext = function() {
      this.context.push(types.b_tmpl);
      this.exprAllowed = true;
    };

    types$1.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
      this.context.push(statementParens ? types.p_stat : types.p_expr);
      this.exprAllowed = true;
    };

    types$1.incDec.updateContext = function() {
      // tokExprAllowed stays unchanged
    };

    types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types$1._else &&
          !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
          !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
          !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
        { this.context.push(types.f_expr); }
      else
        { this.context.push(types.f_stat); }
      this.exprAllowed = false;
    };

    types$1.colon.updateContext = function() {
      if (this.curContext().token === "function") { this.context.pop(); }
      this.exprAllowed = true;
    };

    types$1.backQuote.updateContext = function() {
      if (this.curContext() === types.q_tmpl)
        { this.context.pop(); }
      else
        { this.context.push(types.q_tmpl); }
      this.exprAllowed = false;
    };

    types$1.star.updateContext = function(prevType) {
      if (prevType === types$1._function) {
        var index = this.context.length - 1;
        if (this.context[index] === types.f_expr)
          { this.context[index] = types.f_expr_gen; }
        else
          { this.context[index] = types.f_gen; }
      }
      this.exprAllowed = true;
    };

    types$1.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
        if (this.value === "of" && !this.exprAllowed ||
            this.value === "yield" && this.inGeneratorContext())
          { allowed = true; }
      }
      this.exprAllowed = allowed;
    };

    // A recursive descent parser operates by defining functions for all
    // syntactic elements, and recursively calling those, each function
    // advancing the input stream and returning an AST node. Precedence
    // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
    // instead of `(!x)[1]` is handled by the fact that the parser
    // function that parses unary prefix operators is called first, and
    // in turn calls the function that parses `[]` subscripts — that
    // way, it'll receive the node for `x[1]` already parsed, and wraps
    // *that* in the unary operator node.
    //
    // Acorn uses an [operator precedence parser][opp] to handle binary
    // operator precedence, because it is much more compact than using
    // the technique outlined above, which uses different, nesting
    // functions to specify precedence, for all of the ten binary
    // precedence levels that JavaScript defines.
    //
    // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser


    var pp$5 = Parser.prototype;

    // Check if property name clashes with already added.
    // Object/class getters and setters are not allowed to clash —
    // either with each other or with an init property — and in
    // strict mode, init properties are also not allowed to be repeated.

    pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
        { return }
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
        { return }
      var key = prop.key;
      var name;
      switch (key.type) {
      case "Identifier": name = key.name; break
      case "Literal": name = String(key.value); break
      default: return
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
          if (propHash.proto) {
            if (refDestructuringErrors) {
              if (refDestructuringErrors.doubleProto < 0) {
                refDestructuringErrors.doubleProto = key.start;
              }
            } else {
              this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
            }
          }
          propHash.proto = true;
        }
        return
      }
      name = "$" + name;
      var other = propHash[name];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition)
          { this.raiseRecoverable(key.start, "Redefinition of property"); }
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };

    // ### Expression parsing

    // These nest, from the most general expression type at the top to
    // 'atomic', nondivisible expression types at the bottom. Most of
    // the functions will simply let the function(s) below them parse,
    // and, *if* the syntactic construct they handle is present, wrap
    // the AST node that the inner parser gave them in another node.

    // Parse a full expression. The optional arguments are used to
    // forbid the `in` operator (in for loops initalization expressions)
    // and provide reference for storing '=' operator inside shorthand
    // property assignment in contexts where both object expression
    // and object pattern might appear (so it's possible to raise
    // delayed syntax error at correct position).

    pp$5.parseExpression = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
      if (this.type === types$1.comma) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];
        while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
        return this.finishNode(node, "SequenceExpression")
      }
      return expr
    };

    // Parse an assignment expression. This includes applications of
    // operators like `+=`.

    pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) { return this.parseYield(forInit) }
        // The tokenizer will assume an expression is allowed after
        // `yield`, but this isn't that kind of yield
        else { this.exprAllowed = false; }
      }

      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        oldDoubleProto = refDestructuringErrors.doubleProto;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors;
        ownDestructuringErrors = true;
      }

      var startPos = this.start, startLoc = this.startLoc;
      if (this.type === types$1.parenL || this.type === types$1.name) {
        this.potentialArrowAt = this.start;
        this.potentialArrowInForAwait = forInit === "await";
      }
      var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
      if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
      if (this.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        if (this.type === types$1.eq)
          { left = this.toAssignable(left, false, refDestructuringErrors); }
        if (!ownDestructuringErrors) {
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
        }
        if (refDestructuringErrors.shorthandAssign >= left.start)
          { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
        if (this.type === types$1.eq)
          { this.checkLValPattern(left); }
        else
          { this.checkLValSimple(left); }
        node.left = left;
        this.next();
        node.right = this.parseMaybeAssign(forInit);
        if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
        return this.finishNode(node, "AssignmentExpression")
      } else {
        if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
      }
      if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
      if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
      return left
    };

    // Parse a ternary conditional (`?:`) operator.

    pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(forInit, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      if (this.eat(types$1.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types$1.colon);
        node.alternate = this.parseMaybeAssign(forInit);
        return this.finishNode(node, "ConditionalExpression")
      }
      return expr
    };

    // Start the precedence parser.

    pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)
    };

    // Parse binary operators with the operator precedence parsing
    // algorithm. `left` is the left-hand side of the operator.
    // `minPrec` provides context that allows the function to stop and
    // defer further parser to one of its callers when it encounters an
    // operator that has a lower precedence than the set it is parsing.

    pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
      var prec = this.type.binop;
      if (prec != null && (!forInit || this.type !== types$1._in)) {
        if (prec > minPrec) {
          var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
          var coalesce = this.type === types$1.coalesce;
          if (coalesce) {
            // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
            // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
            prec = types$1.logicalAND.binop;
          }
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
          var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
          if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
            this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
          }
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
        }
      }
      return left
    };

    pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.operator = op;
      node.right = right;
      return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
    };

    // Parse unary operators, both prefix and postfix.

    pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.isContextual("await") && this.canAwait) {
        expr = this.parseAwait(forInit);
        sawUnary = true;
      } else if (this.type.prefix) {
        var node = this.startNode(), update = this.type === types$1.incDec;
        node.operator = this.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary(null, true, update, forInit);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) { this.checkLValSimple(node.argument); }
        else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument))
          { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
        else if (node.operator === "delete" && isPrivateFieldAccess(node.argument))
          { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
        else { sawUnary = true; }
        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      } else if (!sawUnary && this.type === types$1.privateId) {
        if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) { this.unexpected(); }
        expr = this.parsePrivateIdent();
        // only could be private fields in 'in', such as #x in obj
        if (this.type !== types$1._in) { this.unexpected(); }
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.operator = this.value;
          node$1.prefix = false;
          node$1.argument = expr;
          this.checkLValSimple(expr);
          this.next();
          expr = this.finishNode(node$1, "UpdateExpression");
        }
      }

      if (!incDec && this.eat(types$1.starstar)) {
        if (sawUnary)
          { this.unexpected(this.lastTokStart); }
        else
          { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false) }
      } else {
        return expr
      }
    };

    function isLocalVariableAccess(node) {
      return (
        node.type === "Identifier" ||
        node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression)
      )
    }

    function isPrivateFieldAccess(node) {
      return (
        node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" ||
        node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) ||
        node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression)
      )
    }

    // Parse call, dot, and `[]`-subscript expressions.

    pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors, forInit);
      if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
        { return expr }
      var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
      if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
        if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
        if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }
      }
      return result
    };

    pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
          this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
          this.potentialArrowAt === base.start;
      var optionalChained = false;

      while (true) {
        var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);

        if (element.optional) { optionalChained = true; }
        if (element === base || element.type === "ArrowFunctionExpression") {
          if (optionalChained) {
            var chainNode = this.startNodeAt(startPos, startLoc);
            chainNode.expression = element;
            element = this.finishNode(chainNode, "ChainExpression");
          }
          return element
        }

        base = element;
      }
    };

    pp$5.shouldParseAsyncArrow = function() {
      return !this.canInsertSemicolon() && this.eat(types$1.arrow)
    };

    pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)
    };

    pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
      var optionalSupported = this.options.ecmaVersion >= 11;
      var optional = optionalSupported && this.eat(types$1.questionDot);
      if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

      var computed = this.eat(types$1.bracketL);
      if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        if (computed) {
          node.property = this.parseExpression();
          this.expect(types$1.bracketR);
        } else if (this.type === types$1.privateId && base.type !== "Super") {
          node.property = this.parsePrivateIdent();
        } else {
          node.property = this.parseIdent(this.options.allowReserved !== "never");
        }
        node.computed = !!computed;
        if (optionalSupported) {
          node.optional = optional;
        }
        base = this.finishNode(node, "MemberExpression");
      } else if (!noCalls && this.eat(types$1.parenL)) {
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (this.awaitIdentPos > 0)
            { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit)
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.callee = base;
        node$1.arguments = exprList;
        if (optionalSupported) {
          node$1.optional = optional;
        }
        base = this.finishNode(node$1, "CallExpression");
      } else if (this.type === types$1.backQuote) {
        if (optional || optionalChained) {
          this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        }
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base;
        node$2.quasi = this.parseTemplate({isTagged: true});
        base = this.finishNode(node$2, "TaggedTemplateExpression");
      }
      return base
    };

    // Parse an atomic expression — either a single token that is an
    // expression, an expression started by a keyword like `function` or
    // `new`, or an expression wrapped in punctuation like `()`, `[]`,
    // or `{}`.

    pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
      // If a division operator appears in an expression position, the
      // tokenizer got confused, and we force it to read a regexp instead.
      if (this.type === types$1.slash) { this.readRegexp(); }

      var node, canBeArrow = this.potentialArrowAt === this.start;
      switch (this.type) {
      case types$1._super:
        if (!this.allowSuper)
          { this.raise(this.start, "'super' keyword outside a method"); }
        node = this.startNode();
        this.next();
        if (this.type === types$1.parenL && !this.allowDirectSuper)
          { this.raise(node.start, "super() call outside constructor of a subclass"); }
        // The `super` keyword can appear at below:
        // SuperProperty:
        //     super [ Expression ]
        //     super . IdentifierName
        // SuperCall:
        //     super ( Arguments )
        if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
          { this.unexpected(); }
        return this.finishNode(node, "Super")

      case types$1._this:
        node = this.startNode();
        this.next();
        return this.finishNode(node, "ThisExpression")

      case types$1.name:
        var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
        var id = this.parseIdent(false);
        if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
          this.overrideContext(types.f_expr);
          return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
        }
        if (canBeArrow && !this.canInsertSemicolon()) {
          if (this.eat(types$1.arrow))
            { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
          if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
              (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
            id = this.parseIdent(false);
            if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
              { this.unexpected(); }
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
          }
        }
        return id

      case types$1.regexp:
        var value = this.value;
        node = this.parseLiteral(value.value);
        node.regex = {pattern: value.pattern, flags: value.flags};
        return node

      case types$1.num: case types$1.string:
        return this.parseLiteral(this.value)

      case types$1._null: case types$1._true: case types$1._false:
        node = this.startNode();
        node.value = this.type === types$1._null ? null : this.type === types$1._true;
        node.raw = this.type.keyword;
        this.next();
        return this.finishNode(node, "Literal")

      case types$1.parenL:
        var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
        if (refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
            { refDestructuringErrors.parenthesizedAssign = start; }
          if (refDestructuringErrors.parenthesizedBind < 0)
            { refDestructuringErrors.parenthesizedBind = start; }
        }
        return expr

      case types$1.bracketL:
        node = this.startNode();
        this.next();
        node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
        return this.finishNode(node, "ArrayExpression")

      case types$1.braceL:
        this.overrideContext(types.b_expr);
        return this.parseObj(false, refDestructuringErrors)

      case types$1._function:
        node = this.startNode();
        this.next();
        return this.parseFunction(node, 0)

      case types$1._class:
        return this.parseClass(this.startNode(), false)

      case types$1._new:
        return this.parseNew()

      case types$1.backQuote:
        return this.parseTemplate()

      case types$1._import:
        if (this.options.ecmaVersion >= 11) {
          return this.parseExprImport(forNew)
        } else {
          return this.unexpected()
        }

      default:
        return this.parseExprAtomDefault()
      }
    };

    pp$5.parseExprAtomDefault = function() {
      this.unexpected();
    };

    pp$5.parseExprImport = function(forNew) {
      var node = this.startNode();

      // Consume `import` as an identifier for `import.meta`.
      // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
      if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
      this.next();

      if (this.type === types$1.parenL && !forNew) {
        return this.parseDynamicImport(node)
      } else if (this.type === types$1.dot) {
        var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
        meta.name = "import";
        node.meta = this.finishNode(meta, "Identifier");
        return this.parseImportMeta(node)
      } else {
        this.unexpected();
      }
    };

    pp$5.parseDynamicImport = function(node) {
      this.next(); // skip `(`

      // Parse node.source.
      node.source = this.parseMaybeAssign();

      if (this.options.ecmaVersion >= 16) {
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            node.options = this.parseMaybeAssign();
            if (!this.eat(types$1.parenR)) {
              this.expect(types$1.comma);
              if (!this.afterTrailingComma(types$1.parenR)) {
                this.unexpected();
              }
            }
          } else {
            node.options = null;
          }
        } else {
          node.options = null;
        }
      } else {
        // Verify ending.
        if (!this.eat(types$1.parenR)) {
          var errorPos = this.start;
          if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
      }

      return this.finishNode(node, "ImportExpression")
    };

    pp$5.parseImportMeta = function(node) {
      this.next(); // skip `.`

      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);

      if (node.property.name !== "meta")
        { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
      if (containsEsc)
        { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
      if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
        { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

      return this.finishNode(node, "MetaProperty")
    };

    pp$5.parseLiteral = function(value) {
      var node = this.startNode();
      node.value = value;
      node.raw = this.input.slice(this.start, this.end);
      if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
      this.next();
      return this.finishNode(node, "Literal")
    };

    pp$5.parseParenExpression = function() {
      this.expect(types$1.parenL);
      var val = this.parseExpression();
      this.expect(types$1.parenR);
      return val
    };

    pp$5.shouldParseArrow = function(exprList) {
      return !this.canInsertSemicolon()
    };

    pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();

        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        // Do not save awaitIdentPos to allow checking awaits nested in parameters
        while (this.type !== types$1.parenR) {
          first ? first = false : this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
            lastIsComma = true;
            break
          } else if (this.type === types$1.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRestBinding()));
            if (this.type === types$1.comma) {
              this.raiseRecoverable(
                this.start,
                "Comma is not permitted after the rest element"
              );
            }
            break
          } else {
            exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          }
        }
        var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
        this.expect(types$1.parenR);

        if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList, forInit)
        }

        if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
        if (spreadStart) { this.unexpected(spreadStart); }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;

        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }

      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression")
      } else {
        return val
      }
    };

    pp$5.parseParenItem = function(item) {
      return item
    };

    pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
    };

    // New's precedence is slightly tricky. It must allow its argument to
    // be a `[]` or dot subscript expression, but not a call — at least,
    // not without wrapping it in parentheses. Thus, it uses the noCalls
    // argument to parseSubscripts to prevent it from consuming the
    // argument list.

    var empty = [];

    pp$5.parseNew = function() {
      if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
      var node = this.startNode();
      this.next();
      if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
        var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
        meta.name = "new";
        node.meta = this.finishNode(meta, "Identifier");
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "target")
          { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
        if (containsEsc)
          { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
        if (!this.allowNewDotTarget)
          { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
        return this.finishNode(node, "MetaProperty")
      }
      var startPos = this.start, startLoc = this.startLoc;
      node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
      if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
      else { node.arguments = empty; }
      return this.finishNode(node, "NewExpression")
    };

    // Parse template expression.

    pp$5.parseTemplateElement = function(ref) {
      var isTagged = ref.isTagged;

      var elem = this.startNode();
      if (this.type === types$1.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value.replace(/\r\n?/g, "\n"),
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types$1.backQuote;
      return this.finishNode(elem, "TemplateElement")
    };

    pp$5.parseTemplate = function(ref) {
      if ( ref === void 0 ) ref = {};
      var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement({isTagged: isTagged});
      node.quasis = [curElt];
      while (!curElt.tail) {
        if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
        this.expect(types$1.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types$1.braceR);
        node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
      }
      this.next();
      return this.finishNode(node, "TemplateLiteral")
    };

    pp$5.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
        (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
        !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
    };

    // Parse an object literal or binding pattern.

    pp$5.parseObj = function(isPattern, refDestructuringErrors) {
      var node = this.startNode(), first = true, propHash = {};
      node.properties = [];
      this.next();
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
        } else { first = false; }

        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
        node.properties.push(prop);
      }
      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
    };

    pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
      var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
      if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
        if (isPattern) {
          prop.argument = this.parseIdent(false);
          if (this.type === types$1.comma) {
            this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
          }
          return this.finishNode(prop, "RestElement")
        }
        // Parse argument.
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        // To disallow trailing comma via `this.toAssignable()`.
        if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
        // Finish
        return this.finishNode(prop, "SpreadElement")
      }
      if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
          startPos = this.start;
          startLoc = this.startLoc;
        }
        if (!isPattern)
          { isGenerator = this.eat(types$1.star); }
      }
      var containsEsc = this.containsEsc;
      this.parsePropertyName(prop);
      if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
        this.parsePropertyName(prop);
      } else {
        isAsync = false;
      }
      this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
      return this.finishNode(prop, "Property")
    };

    pp$5.parseGetterSetter = function(prop) {
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get")
          { this.raiseRecoverable(start, "getter should have no params"); }
        else
          { this.raiseRecoverable(start, "setter should have exactly one param"); }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
          { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
      }
    };

    pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
      if ((isGenerator || isAsync) && this.type === types$1.colon)
        { this.unexpected(); }

      if (this.eat(types$1.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
        if (isPattern) { this.unexpected(); }
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
      } else if (!isPattern && !containsEsc &&
                 this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
                 (prop.key.name === "get" || prop.key.name === "set") &&
                 (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
        if (isGenerator || isAsync) { this.unexpected(); }
        this.parseGetterSetter(prop);
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) { this.unexpected(); }
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos)
          { this.awaitIdentPos = startPos; }
        prop.kind = "init";
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else if (this.type === types$1.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0)
            { refDestructuringErrors.shorthandAssign = this.start; }
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else {
          prop.value = this.copyNode(prop.key);
        }
        prop.shorthand = true;
      } else { this.unexpected(); }
    };

    pp$5.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types$1.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types$1.bracketR);
          return prop.key
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
    };

    // Initialize empty function node.

    pp$5.initFunction = function(node) {
      node.id = null;
      if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
      if (this.options.ecmaVersion >= 8) { node.async = false; }
    };

    // Parse object or class method.

    pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
      var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

      this.initFunction(node);
      if (this.options.ecmaVersion >= 6)
        { node.generator = isGenerator; }
      if (this.options.ecmaVersion >= 8)
        { node.async = !!isAsync; }

      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

      this.expect(types$1.parenL);
      node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node, false, true, false);

      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "FunctionExpression")
    };

    // Parse arrow function expression with given parameters.

    pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

      this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
      this.initFunction(node);
      if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;

      node.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node, true, false, forInit);

      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "ArrowFunctionExpression")
    };

    // Parse function body and check parameters.

    pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
      var isExpression = isArrowFunction && this.type !== types$1.braceL;
      var oldStrict = this.strict, useStrict = false;

      if (isExpression) {
        node.body = this.parseMaybeAssign(forInit);
        node.expression = true;
        this.checkParams(node, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          // If this is a strict mode function, verify that argument names
          // are not repeated, and it does not try to bind the words `eval`
          // or `arguments`.
          if (useStrict && nonSimple)
            { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
        }
        // Start a new scope with regard to labels and the `inFunction`
        // flag (restore them to their old value afterwards).
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) { this.strict = true; }

        // Add the params to varDeclaredNames to ensure that an error is thrown
        // if a let/const declaration in the function clashes with one of the params.
        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
        // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
        if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }
        node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
        node.expression = false;
        this.adaptDirectivePrologue(node.body.body);
        this.labels = oldLabels;
      }
      this.exitScope();
    };

    pp$5.isSimpleParamList = function(params) {
      for (var i = 0, list = params; i < list.length; i += 1)
        {
        var param = list[i];

        if (param.type !== "Identifier") { return false
      } }
      return true
    };

    // Checks function params for various disallowed patterns such as using "eval"
    // or "arguments" and duplicate parameters.

    pp$5.checkParams = function(node, allowDuplicates) {
      var nameHash = Object.create(null);
      for (var i = 0, list = node.params; i < list.length; i += 1)
        {
        var param = list[i];

        this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
      }
    };

    // Parses a comma-separated list of expressions, and returns them as
    // an array. `close` is the token type that ends the list, and
    // `allowEmpty` can be turned on to allow subsequent commas with
    // nothing in between them to be parsed as `null` (which is needed
    // for array literals).

    pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (!first) {
          this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(close)) { break }
        } else { first = false; }

        var elt = (void 0);
        if (allowEmpty && this.type === types$1.comma)
          { elt = null; }
        else if (this.type === types$1.ellipsis) {
          elt = this.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
            { refDestructuringErrors.trailingComma = this.start; }
        } else {
          elt = this.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts
    };

    pp$5.checkUnreserved = function(ref) {
      var start = ref.start;
      var end = ref.end;
      var name = ref.name;

      if (this.inGenerator && name === "yield")
        { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
      if (this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
      if (this.currentThisScope().inClassFieldInit && name === "arguments")
        { this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"); }
      if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
        { this.raise(start, ("Cannot use " + name + " in class static initialization block")); }
      if (this.keywords.test(name))
        { this.raise(start, ("Unexpected keyword '" + name + "'")); }
      if (this.options.ecmaVersion < 6 &&
        this.input.slice(start, end).indexOf("\\") !== -1) { return }
      var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re.test(name)) {
        if (!this.inAsync && name === "await")
          { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
        this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
      }
    };

    // Parse the next token as an identifier. If `liberal` is true (used
    // when parsing properties), it will also convert keywords into
    // identifiers.

    pp$5.parseIdent = function(liberal) {
      var node = this.parseIdentNode();
      this.next(!!liberal);
      this.finishNode(node, "Identifier");
      if (!liberal) {
        this.checkUnreserved(node);
        if (node.name === "await" && !this.awaitIdentPos)
          { this.awaitIdentPos = node.start; }
      }
      return node
    };

    pp$5.parseIdentNode = function() {
      var node = this.startNode();
      if (this.type === types$1.name) {
        node.name = this.value;
      } else if (this.type.keyword) {
        node.name = this.type.keyword;

        // To fix https://github.com/acornjs/acorn/issues/575
        // `class` and `function` keywords push new context into this.context.
        // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
        // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
        if ((node.name === "class" || node.name === "function") &&
          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
          this.context.pop();
        }
        this.type = types$1.name;
      } else {
        this.unexpected();
      }
      return node
    };

    pp$5.parsePrivateIdent = function() {
      var node = this.startNode();
      if (this.type === types$1.privateId) {
        node.name = this.value;
      } else {
        this.unexpected();
      }
      this.next();
      this.finishNode(node, "PrivateIdentifier");

      // For validating existence
      if (this.options.checkPrivateFields) {
        if (this.privateNameStack.length === 0) {
          this.raise(node.start, ("Private field '#" + (node.name) + "' must be declared in an enclosing class"));
        } else {
          this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
        }
      }

      return node
    };

    // Parses yield expression inside generator.

    pp$5.parseYield = function(forInit) {
      if (!this.yieldPos) { this.yieldPos = this.start; }

      var node = this.startNode();
      this.next();
      if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types$1.star);
        node.argument = this.parseMaybeAssign(forInit);
      }
      return this.finishNode(node, "YieldExpression")
    };

    pp$5.parseAwait = function(forInit) {
      if (!this.awaitPos) { this.awaitPos = this.start; }

      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeUnary(null, true, false, forInit);
      return this.finishNode(node, "AwaitExpression")
    };

    var pp$4 = Parser.prototype;

    // This function is used to raise exceptions on parse errors. It
    // takes an offset integer (into the current `input`) to indicate
    // the location of the error, attaches the position to the end
    // of the error message, and then raises a `SyntaxError` with that
    // message.

    pp$4.raise = function(pos, message) {
      var loc = getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
      throw err
    };

    pp$4.raiseRecoverable = pp$4.raise;

    pp$4.curPosition = function() {
      if (this.options.locations) {
        return new Position(this.curLine, this.pos - this.lineStart)
      }
    };

    var pp$3 = Parser.prototype;

    var Scope = function Scope(flags) {
      this.flags = flags;
      // A list of var-declared names in the current lexical scope
      this.var = [];
      // A list of lexically-declared names in the current lexical scope
      this.lexical = [];
      // A list of lexically-declared FunctionDeclaration names in the current lexical scope
      this.functions = [];
      // A switch to disallow the identifier reference 'arguments'
      this.inClassFieldInit = false;
    };

    // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

    pp$3.enterScope = function(flags) {
      this.scopeStack.push(new Scope(flags));
    };

    pp$3.exitScope = function() {
      this.scopeStack.pop();
    };

    // The spec says:
    // > At the top level of a function, or script, function declarations are
    // > treated like var declarations rather than like lexical declarations.
    pp$3.treatFunctionsAsVarInScope = function(scope) {
      return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
    };

    pp$3.declareName = function(name, bindingType, pos) {
      var redeclared = false;
      if (bindingType === BIND_LEXICAL) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
        scope.lexical.push(name);
        if (this.inModule && (scope.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
      } else if (bindingType === BIND_SIMPLE_CATCH) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name);
      } else if (bindingType === BIND_FUNCTION) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar)
          { redeclared = scope$2.lexical.indexOf(name) > -1; }
        else
          { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
        scope$2.functions.push(name);
      } else {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          var scope$3 = this.scopeStack[i];
          if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
              !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
            redeclared = true;
            break
          }
          scope$3.var.push(name);
          if (this.inModule && (scope$3.flags & SCOPE_TOP))
            { delete this.undefinedExports[name]; }
          if (scope$3.flags & SCOPE_VAR) { break }
        }
      }
      if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
    };

    pp$3.checkLocalExport = function(id) {
      // scope.functions must be empty as Module code is always strict.
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
          this.scopeStack[0].var.indexOf(id.name) === -1) {
        this.undefinedExports[id.name] = id;
      }
    };

    pp$3.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1]
    };

    pp$3.currentVarScope = function() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR) { return scope }
      }
    };

    // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
    pp$3.currentThisScope = function() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
      }
    };

    var Node = function Node(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser.options.locations)
        { this.loc = new SourceLocation(parser, loc); }
      if (parser.options.directSourceFile)
        { this.sourceFile = parser.options.directSourceFile; }
      if (parser.options.ranges)
        { this.range = [pos, 0]; }
    };

    // Start an AST node, attaching a start offset.

    var pp$2 = Parser.prototype;

    pp$2.startNode = function() {
      return new Node(this, this.start, this.startLoc)
    };

    pp$2.startNodeAt = function(pos, loc) {
      return new Node(this, pos, loc)
    };

    // Finish an AST node, adding `type` and `end` properties.

    function finishNodeAt(node, type, pos, loc) {
      node.type = type;
      node.end = pos;
      if (this.options.locations)
        { node.loc.end = loc; }
      if (this.options.ranges)
        { node.range[1] = pos; }
      return node
    }

    pp$2.finishNode = function(node, type) {
      return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
    };

    // Finish node at given position

    pp$2.finishNodeAt = function(node, type, pos, loc) {
      return finishNodeAt.call(this, node, type, pos, loc)
    };

    pp$2.copyNode = function(node) {
      var newNode = new Node(this, node.start, this.startLoc);
      for (var prop in node) { newNode[prop] = node[prop]; }
      return newNode
    };

    // This file was generated by "bin/generate-unicode-script-values.js". Do not modify manually!
    var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";

    // This file contains Unicode properties extracted from the ECMAScript specification.
    // The lists are extracted like so:
    // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

    // #table-binary-unicode-properties
    var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    var ecma11BinaryProperties = ecma10BinaryProperties;
    var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
    var ecma13BinaryProperties = ecma12BinaryProperties;
    var ecma14BinaryProperties = ecma13BinaryProperties;

    var unicodeBinaryProperties = {
      9: ecma9BinaryProperties,
      10: ecma10BinaryProperties,
      11: ecma11BinaryProperties,
      12: ecma12BinaryProperties,
      13: ecma13BinaryProperties,
      14: ecma14BinaryProperties
    };

    // #table-binary-unicode-properties-of-strings
    var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";

    var unicodeBinaryPropertiesOfStrings = {
      9: "",
      10: "",
      11: "",
      12: "",
      13: "",
      14: ecma14BinaryPropertiesOfStrings
    };

    // #table-unicode-general-category-values
    var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

    // #table-unicode-script-values
    var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
    var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
    var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;

    var unicodeScriptValues = {
      9: ecma9ScriptValues,
      10: ecma10ScriptValues,
      11: ecma11ScriptValues,
      12: ecma12ScriptValues,
      13: ecma13ScriptValues,
      14: ecma14ScriptValues
    };

    var data = {};
    function buildUnicodeData(ecmaVersion) {
      var d = data[ecmaVersion] = {
        binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
        binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
        nonBinary: {
          General_Category: wordsRegexp(unicodeGeneralCategoryValues),
          Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
        }
      };
      d.nonBinary.Script_Extensions = d.nonBinary.Script;

      d.nonBinary.gc = d.nonBinary.General_Category;
      d.nonBinary.sc = d.nonBinary.Script;
      d.nonBinary.scx = d.nonBinary.Script_Extensions;
    }

    for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
      var ecmaVersion = list[i];

      buildUnicodeData(ecmaVersion);
    }

    var pp$1 = Parser.prototype;

    // Track disjunction structure to determine whether a duplicate
    // capture group name is allowed because it is in a separate branch.
    var BranchID = function BranchID(parent, base) {
      // Parent disjunction branch
      this.parent = parent;
      // Identifies this set of sibling branches
      this.base = base || this;
    };

    BranchID.prototype.separatedFrom = function separatedFrom (alt) {
      // A branch is separate from another branch if they or any of
      // their parents are siblings in a given disjunction
      for (var self = this; self; self = self.parent) {
        for (var other = alt; other; other = other.parent) {
          if (self.base === other.base && self !== other) { return true }
        }
      }
      return false
    };

    BranchID.prototype.sibling = function sibling () {
      return new BranchID(this.parent, this.base)
    };

    var RegExpValidationState = function RegExpValidationState(parser) {
      this.parser = parser;
      this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
      this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
      this.source = "";
      this.flags = "";
      this.start = 0;
      this.switchU = false;
      this.switchV = false;
      this.switchN = false;
      this.pos = 0;
      this.lastIntValue = 0;
      this.lastStringValue = "";
      this.lastAssertionIsQuantifiable = false;
      this.numCapturingParens = 0;
      this.maxBackReference = 0;
      this.groupNames = Object.create(null);
      this.backReferenceNames = [];
      this.branchID = null;
    };

    RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
      var unicodeSets = flags.indexOf("v") !== -1;
      var unicode = flags.indexOf("u") !== -1;
      this.start = start | 0;
      this.source = pattern + "";
      this.flags = flags;
      if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
        this.switchU = true;
        this.switchV = true;
        this.switchN = true;
      } else {
        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
        this.switchV = false;
        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
      }
    };

    RegExpValidationState.prototype.raise = function raise (message) {
      this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
    };

    // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
    // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
    RegExpValidationState.prototype.at = function at (i, forceU) {
        if ( forceU === void 0 ) forceU = false;

      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return -1
      }
      var c = s.charCodeAt(i);
      if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
        return c
      }
      var next = s.charCodeAt(i + 1);
      return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
    };

    RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
        if ( forceU === void 0 ) forceU = false;

      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return l
      }
      var c = s.charCodeAt(i), next;
      if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
          (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
        return i + 1
      }
      return i + 2
    };

    RegExpValidationState.prototype.current = function current (forceU) {
        if ( forceU === void 0 ) forceU = false;

      return this.at(this.pos, forceU)
    };

    RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
        if ( forceU === void 0 ) forceU = false;

      return this.at(this.nextIndex(this.pos, forceU), forceU)
    };

    RegExpValidationState.prototype.advance = function advance (forceU) {
        if ( forceU === void 0 ) forceU = false;

      this.pos = this.nextIndex(this.pos, forceU);
    };

    RegExpValidationState.prototype.eat = function eat (ch, forceU) {
        if ( forceU === void 0 ) forceU = false;

      if (this.current(forceU) === ch) {
        this.advance(forceU);
        return true
      }
      return false
    };

    RegExpValidationState.prototype.eatChars = function eatChars (chs, forceU) {
        if ( forceU === void 0 ) forceU = false;

      var pos = this.pos;
      for (var i = 0, list = chs; i < list.length; i += 1) {
        var ch = list[i];

          var current = this.at(pos, forceU);
        if (current === -1 || current !== ch) {
          return false
        }
        pos = this.nextIndex(pos, forceU);
      }
      this.pos = pos;
      return true
    };

    /**
     * Validate the flags part of a given RegExpLiteral.
     *
     * @param {RegExpValidationState} state The state to validate RegExp.
     * @returns {void}
     */
    pp$1.validateRegExpFlags = function(state) {
      var validFlags = state.validFlags;
      var flags = state.flags;

      var u = false;
      var v = false;

      for (var i = 0; i < flags.length; i++) {
        var flag = flags.charAt(i);
        if (validFlags.indexOf(flag) === -1) {
          this.raise(state.start, "Invalid regular expression flag");
        }
        if (flags.indexOf(flag, i + 1) > -1) {
          this.raise(state.start, "Duplicate regular expression flag");
        }
        if (flag === "u") { u = true; }
        if (flag === "v") { v = true; }
      }
      if (this.options.ecmaVersion >= 15 && u && v) {
        this.raise(state.start, "Invalid regular expression flag");
      }
    };

    function hasProp(obj) {
      for (var _ in obj) { return true }
      return false
    }

    /**
     * Validate the pattern part of a given RegExpLiteral.
     *
     * @param {RegExpValidationState} state The state to validate RegExp.
     * @returns {void}
     */
    pp$1.validateRegExpPattern = function(state) {
      this.regexp_pattern(state);

      // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
      // parsing contains a |GroupName|, reparse with the goal symbol
      // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
      // exception if _P_ did not conform to the grammar, if any elements of _P_
      // were not matched by the parse, or if any Early Error conditions exist.
      if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
        state.switchN = true;
        this.regexp_pattern(state);
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
    pp$1.regexp_pattern = function(state) {
      state.pos = 0;
      state.lastIntValue = 0;
      state.lastStringValue = "";
      state.lastAssertionIsQuantifiable = false;
      state.numCapturingParens = 0;
      state.maxBackReference = 0;
      state.groupNames = Object.create(null);
      state.backReferenceNames.length = 0;
      state.branchID = null;

      this.regexp_disjunction(state);

      if (state.pos !== state.source.length) {
        // Make the same messages as V8.
        if (state.eat(0x29 /* ) */)) {
          state.raise("Unmatched ')'");
        }
        if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
          state.raise("Lone quantifier brackets");
        }
      }
      if (state.maxBackReference > state.numCapturingParens) {
        state.raise("Invalid escape");
      }
      for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
        var name = list[i];

        if (!state.groupNames[name]) {
          state.raise("Invalid named capture referenced");
        }
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
    pp$1.regexp_disjunction = function(state) {
      var trackDisjunction = this.options.ecmaVersion >= 16;
      if (trackDisjunction) { state.branchID = new BranchID(state.branchID, null); }
      this.regexp_alternative(state);
      while (state.eat(0x7C /* | */)) {
        if (trackDisjunction) { state.branchID = state.branchID.sibling(); }
        this.regexp_alternative(state);
      }
      if (trackDisjunction) { state.branchID = state.branchID.parent; }

      // Make the same message as V8.
      if (this.regexp_eatQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      if (state.eat(0x7B /* { */)) {
        state.raise("Lone quantifier brackets");
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
    pp$1.regexp_alternative = function(state) {
      while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
    pp$1.regexp_eatTerm = function(state) {
      if (this.regexp_eatAssertion(state)) {
        // Handle `QuantifiableAssertion Quantifier` alternative.
        // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
        // is a QuantifiableAssertion.
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
          // Make the same message as V8.
          if (state.switchU) {
            state.raise("Invalid quantifier");
          }
        }
        return true
      }

      if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true
      }

      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
    pp$1.regexp_eatAssertion = function(state) {
      var start = state.pos;
      state.lastAssertionIsQuantifiable = false;

      // ^, $
      if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
        return true
      }

      // \b \B
      if (state.eat(0x5C /* \ */)) {
        if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
          return true
        }
        state.pos = start;
      }

      // Lookahead / Lookbehind
      if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) {
          lookbehind = state.eat(0x3C /* < */);
        }
        if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
          this.regexp_disjunction(state);
          if (!state.eat(0x29 /* ) */)) {
            state.raise("Unterminated group");
          }
          state.lastAssertionIsQuantifiable = !lookbehind;
          return true
        }
      }

      state.pos = start;
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
    pp$1.regexp_eatQuantifier = function(state, noError) {
      if ( noError === void 0 ) noError = false;

      if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(0x3F /* ? */);
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
    pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
      return (
        state.eat(0x2A /* * */) ||
        state.eat(0x2B /* + */) ||
        state.eat(0x3F /* ? */) ||
        this.regexp_eatBracedQuantifier(state, noError)
      )
    };
    pp$1.regexp_eatBracedQuantifier = function(state, noError) {
      var start = state.pos;
      if (state.eat(0x7B /* { */)) {
        var min = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
          min = state.lastIntValue;
          if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
            max = state.lastIntValue;
          }
          if (state.eat(0x7D /* } */)) {
            // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
            if (max !== -1 && max < min && !noError) {
              state.raise("numbers out of order in {} quantifier");
            }
            return true
          }
        }
        if (state.switchU && !noError) {
          state.raise("Incomplete quantifier");
        }
        state.pos = start;
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
    pp$1.regexp_eatAtom = function(state) {
      return (
        this.regexp_eatPatternCharacters(state) ||
        state.eat(0x2E /* . */) ||
        this.regexp_eatReverseSolidusAtomEscape(state) ||
        this.regexp_eatCharacterClass(state) ||
        this.regexp_eatUncapturingGroup(state) ||
        this.regexp_eatCapturingGroup(state)
      )
    };
    pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
      var start = state.pos;
      if (state.eat(0x5C /* \ */)) {
        if (this.regexp_eatAtomEscape(state)) {
          return true
        }
        state.pos = start;
      }
      return false
    };
    pp$1.regexp_eatUncapturingGroup = function(state) {
      var start = state.pos;
      if (state.eat(0x28 /* ( */)) {
        if (state.eat(0x3F /* ? */)) {
          if (this.options.ecmaVersion >= 16) {
            var addModifiers = this.regexp_eatModifiers(state);
            var hasHyphen = state.eat(0x2D /* - */);
            if (addModifiers || hasHyphen) {
              for (var i = 0; i < addModifiers.length; i++) {
                var modifier = addModifiers.charAt(i);
                if (addModifiers.indexOf(modifier, i + 1) > -1) {
                  state.raise("Duplicate regular expression modifiers");
                }
              }
              if (hasHyphen) {
                var removeModifiers = this.regexp_eatModifiers(state);
                if (!addModifiers && !removeModifiers && state.current() === 0x3A /* : */) {
                  state.raise("Invalid regular expression modifiers");
                }
                for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
                  var modifier$1 = removeModifiers.charAt(i$1);
                  if (
                    removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 ||
                    addModifiers.indexOf(modifier$1) > -1
                  ) {
                    state.raise("Duplicate regular expression modifiers");
                  }
                }
              }
            }
          }
          if (state.eat(0x3A /* : */)) {
            this.regexp_disjunction(state);
            if (state.eat(0x29 /* ) */)) {
              return true
            }
            state.raise("Unterminated group");
          }
        }
        state.pos = start;
      }
      return false
    };
    pp$1.regexp_eatCapturingGroup = function(state) {
      if (state.eat(0x28 /* ( */)) {
        if (this.options.ecmaVersion >= 9) {
          this.regexp_groupSpecifier(state);
        } else if (state.current() === 0x3F /* ? */) {
          state.raise("Invalid group");
        }
        this.regexp_disjunction(state);
        if (state.eat(0x29 /* ) */)) {
          state.numCapturingParens += 1;
          return true
        }
        state.raise("Unterminated group");
      }
      return false
    };
    // RegularExpressionModifiers ::
    //   [empty]
    //   RegularExpressionModifiers RegularExpressionModifier
    pp$1.regexp_eatModifiers = function(state) {
      var modifiers = "";
      var ch = 0;
      while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
        modifiers += codePointToString(ch);
        state.advance();
      }
      return modifiers
    };
    // RegularExpressionModifier :: one of
    //   `i` `m` `s`
    function isRegularExpressionModifier(ch) {
      return ch === 0x69 /* i */ || ch === 0x6d /* m */ || ch === 0x73 /* s */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
    pp$1.regexp_eatExtendedAtom = function(state) {
      return (
        state.eat(0x2E /* . */) ||
        this.regexp_eatReverseSolidusAtomEscape(state) ||
        this.regexp_eatCharacterClass(state) ||
        this.regexp_eatUncapturingGroup(state) ||
        this.regexp_eatCapturingGroup(state) ||
        this.regexp_eatInvalidBracedQuantifier(state) ||
        this.regexp_eatExtendedPatternCharacter(state)
      )
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
    pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
      if (this.regexp_eatBracedQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
    pp$1.regexp_eatSyntaxCharacter = function(state) {
      var ch = state.current();
      if (isSyntaxCharacter(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }
      return false
    };
    function isSyntaxCharacter(ch) {
      return (
        ch === 0x24 /* $ */ ||
        ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
        ch === 0x2E /* . */ ||
        ch === 0x3F /* ? */ ||
        ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
        ch >= 0x7B /* { */ && ch <= 0x7D /* } */
      )
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
    // But eat eager.
    pp$1.regexp_eatPatternCharacters = function(state) {
      var start = state.pos;
      var ch = 0;
      while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
        state.advance();
      }
      return state.pos !== start
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
    pp$1.regexp_eatExtendedPatternCharacter = function(state) {
      var ch = state.current();
      if (
        ch !== -1 &&
        ch !== 0x24 /* $ */ &&
        !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
        ch !== 0x2E /* . */ &&
        ch !== 0x3F /* ? */ &&
        ch !== 0x5B /* [ */ &&
        ch !== 0x5E /* ^ */ &&
        ch !== 0x7C /* | */
      ) {
        state.advance();
        return true
      }
      return false
    };

    // GroupSpecifier ::
    //   [empty]
    //   `?` GroupName
    pp$1.regexp_groupSpecifier = function(state) {
      if (state.eat(0x3F /* ? */)) {
        if (!this.regexp_eatGroupName(state)) { state.raise("Invalid group"); }
        var trackDisjunction = this.options.ecmaVersion >= 16;
        var known = state.groupNames[state.lastStringValue];
        if (known) {
          if (trackDisjunction) {
            for (var i = 0, list = known; i < list.length; i += 1) {
              var altID = list[i];

              if (!altID.separatedFrom(state.branchID))
                { state.raise("Duplicate capture group name"); }
            }
          } else {
            state.raise("Duplicate capture group name");
          }
        }
        if (trackDisjunction) {
          (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
        } else {
          state.groupNames[state.lastStringValue] = true;
        }
      }
    };

    // GroupName ::
    //   `<` RegExpIdentifierName `>`
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$1.regexp_eatGroupName = function(state) {
      state.lastStringValue = "";
      if (state.eat(0x3C /* < */)) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
          return true
        }
        state.raise("Invalid capture group name");
      }
      return false
    };

    // RegExpIdentifierName ::
    //   RegExpIdentifierStart
    //   RegExpIdentifierName RegExpIdentifierPart
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$1.regexp_eatRegExpIdentifierName = function(state) {
      state.lastStringValue = "";
      if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
        }
        return true
      }
      return false
    };

    // RegExpIdentifierStart ::
    //   UnicodeIDStart
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[+U]
    pp$1.regexp_eatRegExpIdentifierStart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);

      if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierStart(ch)) {
        state.lastIntValue = ch;
        return true
      }

      state.pos = start;
      return false
    };
    function isRegExpIdentifierStart(ch) {
      return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
    }

    // RegExpIdentifierPart ::
    //   UnicodeIDContinue
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[+U]
    //   <ZWNJ>
    //   <ZWJ>
    pp$1.regexp_eatRegExpIdentifierPart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);

      if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierPart(ch)) {
        state.lastIntValue = ch;
        return true
      }

      state.pos = start;
      return false
    };
    function isRegExpIdentifierPart(ch) {
      return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
    pp$1.regexp_eatAtomEscape = function(state) {
      if (
        this.regexp_eatBackReference(state) ||
        this.regexp_eatCharacterClassEscape(state) ||
        this.regexp_eatCharacterEscape(state) ||
        (state.switchN && this.regexp_eatKGroupName(state))
      ) {
        return true
      }
      if (state.switchU) {
        // Make the same message as V8.
        if (state.current() === 0x63 /* c */) {
          state.raise("Invalid unicode escape");
        }
        state.raise("Invalid escape");
      }
      return false
    };
    pp$1.regexp_eatBackReference = function(state) {
      var start = state.pos;
      if (this.regexp_eatDecimalEscape(state)) {
        var n = state.lastIntValue;
        if (state.switchU) {
          // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
          if (n > state.maxBackReference) {
            state.maxBackReference = n;
          }
          return true
        }
        if (n <= state.numCapturingParens) {
          return true
        }
        state.pos = start;
      }
      return false
    };
    pp$1.regexp_eatKGroupName = function(state) {
      if (state.eat(0x6B /* k */)) {
        if (this.regexp_eatGroupName(state)) {
          state.backReferenceNames.push(state.lastStringValue);
          return true
        }
        state.raise("Invalid named reference");
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
    pp$1.regexp_eatCharacterEscape = function(state) {
      return (
        this.regexp_eatControlEscape(state) ||
        this.regexp_eatCControlLetter(state) ||
        this.regexp_eatZero(state) ||
        this.regexp_eatHexEscapeSequence(state) ||
        this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
        (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
        this.regexp_eatIdentityEscape(state)
      )
    };
    pp$1.regexp_eatCControlLetter = function(state) {
      var start = state.pos;
      if (state.eat(0x63 /* c */)) {
        if (this.regexp_eatControlLetter(state)) {
          return true
        }
        state.pos = start;
      }
      return false
    };
    pp$1.regexp_eatZero = function(state) {
      if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
    pp$1.regexp_eatControlEscape = function(state) {
      var ch = state.current();
      if (ch === 0x74 /* t */) {
        state.lastIntValue = 0x09; /* \t */
        state.advance();
        return true
      }
      if (ch === 0x6E /* n */) {
        state.lastIntValue = 0x0A; /* \n */
        state.advance();
        return true
      }
      if (ch === 0x76 /* v */) {
        state.lastIntValue = 0x0B; /* \v */
        state.advance();
        return true
      }
      if (ch === 0x66 /* f */) {
        state.lastIntValue = 0x0C; /* \f */
        state.advance();
        return true
      }
      if (ch === 0x72 /* r */) {
        state.lastIntValue = 0x0D; /* \r */
        state.advance();
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
    pp$1.regexp_eatControlLetter = function(state) {
      var ch = state.current();
      if (isControlLetter(ch)) {
        state.lastIntValue = ch % 0x20;
        state.advance();
        return true
      }
      return false
    };
    function isControlLetter(ch) {
      return (
        (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
        (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
      )
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
    pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
      if ( forceU === void 0 ) forceU = false;

      var start = state.pos;
      var switchU = forceU || state.switchU;

      if (state.eat(0x75 /* u */)) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
          var lead = state.lastIntValue;
          if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
            var leadSurrogateEnd = state.pos;
            if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
              var trail = state.lastIntValue;
              if (trail >= 0xDC00 && trail <= 0xDFFF) {
                state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
                return true
              }
            }
            state.pos = leadSurrogateEnd;
            state.lastIntValue = lead;
          }
          return true
        }
        if (
          switchU &&
          state.eat(0x7B /* { */) &&
          this.regexp_eatHexDigits(state) &&
          state.eat(0x7D /* } */) &&
          isValidUnicode(state.lastIntValue)
        ) {
          return true
        }
        if (switchU) {
          state.raise("Invalid unicode escape");
        }
        state.pos = start;
      }

      return false
    };
    function isValidUnicode(ch) {
      return ch >= 0 && ch <= 0x10FFFF
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
    pp$1.regexp_eatIdentityEscape = function(state) {
      if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) {
          return true
        }
        if (state.eat(0x2F /* / */)) {
          state.lastIntValue = 0x2F; /* / */
          return true
        }
        return false
      }

      var ch = state.current();
      if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }

      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
    pp$1.regexp_eatDecimalEscape = function(state) {
      state.lastIntValue = 0;
      var ch = state.current();
      if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
        do {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
          state.advance();
        } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
        return true
      }
      return false
    };

    // Return values used by character set parsing methods, needed to
    // forbid negation of sets that can match strings.
    var CharSetNone = 0; // Nothing parsed
    var CharSetOk = 1; // Construct parsed, cannot contain strings
    var CharSetString = 2; // Construct parsed, can contain strings

    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
    pp$1.regexp_eatCharacterClassEscape = function(state) {
      var ch = state.current();

      if (isCharacterClassEscape(ch)) {
        state.lastIntValue = -1;
        state.advance();
        return CharSetOk
      }

      var negate = false;
      if (
        state.switchU &&
        this.options.ecmaVersion >= 9 &&
        ((negate = ch === 0x50 /* P */) || ch === 0x70 /* p */)
      ) {
        state.lastIntValue = -1;
        state.advance();
        var result;
        if (
          state.eat(0x7B /* { */) &&
          (result = this.regexp_eatUnicodePropertyValueExpression(state)) &&
          state.eat(0x7D /* } */)
        ) {
          if (negate && result === CharSetString) { state.raise("Invalid property name"); }
          return result
        }
        state.raise("Invalid property name");
      }

      return CharSetNone
    };

    function isCharacterClassEscape(ch) {
      return (
        ch === 0x64 /* d */ ||
        ch === 0x44 /* D */ ||
        ch === 0x73 /* s */ ||
        ch === 0x53 /* S */ ||
        ch === 0x77 /* w */ ||
        ch === 0x57 /* W */
      )
    }

    // UnicodePropertyValueExpression ::
    //   UnicodePropertyName `=` UnicodePropertyValue
    //   LoneUnicodePropertyNameOrValue
    pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
      var start = state.pos;

      // UnicodePropertyName `=` UnicodePropertyValue
      if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
        var name = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
          var value = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
          return CharSetOk
        }
      }
      state.pos = start;

      // LoneUnicodePropertyNameOrValue
      if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue)
      }
      return CharSetNone
    };

    pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
      if (!hasOwn(state.unicodeProperties.nonBinary, name))
        { state.raise("Invalid property name"); }
      if (!state.unicodeProperties.nonBinary[name].test(value))
        { state.raise("Invalid property value"); }
    };

    pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
      if (state.unicodeProperties.binary.test(nameOrValue)) { return CharSetOk }
      if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) { return CharSetString }
      state.raise("Invalid property name");
    };

    // UnicodePropertyName ::
    //   UnicodePropertyNameCharacters
    pp$1.regexp_eatUnicodePropertyName = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyNameCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== ""
    };

    function isUnicodePropertyNameCharacter(ch) {
      return isControlLetter(ch) || ch === 0x5F /* _ */
    }

    // UnicodePropertyValue ::
    //   UnicodePropertyValueCharacters
    pp$1.regexp_eatUnicodePropertyValue = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyValueCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== ""
    };
    function isUnicodePropertyValueCharacter(ch) {
      return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
    }

    // LoneUnicodePropertyNameOrValue ::
    //   UnicodePropertyValueCharacters
    pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
      return this.regexp_eatUnicodePropertyValue(state)
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
    pp$1.regexp_eatCharacterClass = function(state) {
      if (state.eat(0x5B /* [ */)) {
        var negate = state.eat(0x5E /* ^ */);
        var result = this.regexp_classContents(state);
        if (!state.eat(0x5D /* ] */))
          { state.raise("Unterminated character class"); }
        if (negate && result === CharSetString)
          { state.raise("Negated character class may contain strings"); }
        return true
      }
      return false
    };

    // https://tc39.es/ecma262/#prod-ClassContents
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
    pp$1.regexp_classContents = function(state) {
      if (state.current() === 0x5D /* ] */) { return CharSetOk }
      if (state.switchV) { return this.regexp_classSetExpression(state) }
      this.regexp_nonEmptyClassRanges(state);
      return CharSetOk
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
    pp$1.regexp_nonEmptyClassRanges = function(state) {
      while (this.regexp_eatClassAtom(state)) {
        var left = state.lastIntValue;
        if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
          var right = state.lastIntValue;
          if (state.switchU && (left === -1 || right === -1)) {
            state.raise("Invalid character class");
          }
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
        }
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
    pp$1.regexp_eatClassAtom = function(state) {
      var start = state.pos;

      if (state.eat(0x5C /* \ */)) {
        if (this.regexp_eatClassEscape(state)) {
          return true
        }
        if (state.switchU) {
          // Make the same message as V8.
          var ch$1 = state.current();
          if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
            state.raise("Invalid class escape");
          }
          state.raise("Invalid escape");
        }
        state.pos = start;
      }

      var ch = state.current();
      if (ch !== 0x5D /* ] */) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }

      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
    pp$1.regexp_eatClassEscape = function(state) {
      var start = state.pos;

      if (state.eat(0x62 /* b */)) {
        state.lastIntValue = 0x08; /* <BS> */
        return true
      }

      if (state.switchU && state.eat(0x2D /* - */)) {
        state.lastIntValue = 0x2D; /* - */
        return true
      }

      if (!state.switchU && state.eat(0x63 /* c */)) {
        if (this.regexp_eatClassControlLetter(state)) {
          return true
        }
        state.pos = start;
      }

      return (
        this.regexp_eatCharacterClassEscape(state) ||
        this.regexp_eatCharacterEscape(state)
      )
    };

    // https://tc39.es/ecma262/#prod-ClassSetExpression
    // https://tc39.es/ecma262/#prod-ClassUnion
    // https://tc39.es/ecma262/#prod-ClassIntersection
    // https://tc39.es/ecma262/#prod-ClassSubtraction
    pp$1.regexp_classSetExpression = function(state) {
      var result = CharSetOk, subResult;
      if (this.regexp_eatClassSetRange(state)) ; else if (subResult = this.regexp_eatClassSetOperand(state)) {
        if (subResult === CharSetString) { result = CharSetString; }
        // https://tc39.es/ecma262/#prod-ClassIntersection
        var start = state.pos;
        while (state.eatChars([0x26, 0x26] /* && */)) {
          if (
            state.current() !== 0x26 /* & */ &&
            (subResult = this.regexp_eatClassSetOperand(state))
          ) {
            if (subResult !== CharSetString) { result = CharSetOk; }
            continue
          }
          state.raise("Invalid character in character class");
        }
        if (start !== state.pos) { return result }
        // https://tc39.es/ecma262/#prod-ClassSubtraction
        while (state.eatChars([0x2D, 0x2D] /* -- */)) {
          if (this.regexp_eatClassSetOperand(state)) { continue }
          state.raise("Invalid character in character class");
        }
        if (start !== state.pos) { return result }
      } else {
        state.raise("Invalid character in character class");
      }
      // https://tc39.es/ecma262/#prod-ClassUnion
      for (;;) {
        if (this.regexp_eatClassSetRange(state)) { continue }
        subResult = this.regexp_eatClassSetOperand(state);
        if (!subResult) { return result }
        if (subResult === CharSetString) { result = CharSetString; }
      }
    };

    // https://tc39.es/ecma262/#prod-ClassSetRange
    pp$1.regexp_eatClassSetRange = function(state) {
      var start = state.pos;
      if (this.regexp_eatClassSetCharacter(state)) {
        var left = state.lastIntValue;
        if (state.eat(0x2D /* - */) && this.regexp_eatClassSetCharacter(state)) {
          var right = state.lastIntValue;
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
          return true
        }
        state.pos = start;
      }
      return false
    };

    // https://tc39.es/ecma262/#prod-ClassSetOperand
    pp$1.regexp_eatClassSetOperand = function(state) {
      if (this.regexp_eatClassSetCharacter(state)) { return CharSetOk }
      return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state)
    };

    // https://tc39.es/ecma262/#prod-NestedClass
    pp$1.regexp_eatNestedClass = function(state) {
      var start = state.pos;
      if (state.eat(0x5B /* [ */)) {
        var negate = state.eat(0x5E /* ^ */);
        var result = this.regexp_classContents(state);
        if (state.eat(0x5D /* ] */)) {
          if (negate && result === CharSetString) {
            state.raise("Negated character class may contain strings");
          }
          return result
        }
        state.pos = start;
      }
      if (state.eat(0x5C /* \ */)) {
        var result$1 = this.regexp_eatCharacterClassEscape(state);
        if (result$1) {
          return result$1
        }
        state.pos = start;
      }
      return null
    };

    // https://tc39.es/ecma262/#prod-ClassStringDisjunction
    pp$1.regexp_eatClassStringDisjunction = function(state) {
      var start = state.pos;
      if (state.eatChars([0x5C, 0x71] /* \q */)) {
        if (state.eat(0x7B /* { */)) {
          var result = this.regexp_classStringDisjunctionContents(state);
          if (state.eat(0x7D /* } */)) {
            return result
          }
        } else {
          // Make the same message as V8.
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return null
    };

    // https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents
    pp$1.regexp_classStringDisjunctionContents = function(state) {
      var result = this.regexp_classString(state);
      while (state.eat(0x7C /* | */)) {
        if (this.regexp_classString(state) === CharSetString) { result = CharSetString; }
      }
      return result
    };

    // https://tc39.es/ecma262/#prod-ClassString
    // https://tc39.es/ecma262/#prod-NonEmptyClassString
    pp$1.regexp_classString = function(state) {
      var count = 0;
      while (this.regexp_eatClassSetCharacter(state)) { count++; }
      return count === 1 ? CharSetOk : CharSetString
    };

    // https://tc39.es/ecma262/#prod-ClassSetCharacter
    pp$1.regexp_eatClassSetCharacter = function(state) {
      var start = state.pos;
      if (state.eat(0x5C /* \ */)) {
        if (
          this.regexp_eatCharacterEscape(state) ||
          this.regexp_eatClassSetReservedPunctuator(state)
        ) {
          return true
        }
        if (state.eat(0x62 /* b */)) {
          state.lastIntValue = 0x08; /* <BS> */
          return true
        }
        state.pos = start;
        return false
      }
      var ch = state.current();
      if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) { return false }
      if (isClassSetSyntaxCharacter(ch)) { return false }
      state.advance();
      state.lastIntValue = ch;
      return true
    };

    // https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator
    function isClassSetReservedDoublePunctuatorCharacter(ch) {
      return (
        ch === 0x21 /* ! */ ||
        ch >= 0x23 /* # */ && ch <= 0x26 /* & */ ||
        ch >= 0x2A /* * */ && ch <= 0x2C /* , */ ||
        ch === 0x2E /* . */ ||
        ch >= 0x3A /* : */ && ch <= 0x40 /* @ */ ||
        ch === 0x5E /* ^ */ ||
        ch === 0x60 /* ` */ ||
        ch === 0x7E /* ~ */
      )
    }

    // https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter
    function isClassSetSyntaxCharacter(ch) {
      return (
        ch === 0x28 /* ( */ ||
        ch === 0x29 /* ) */ ||
        ch === 0x2D /* - */ ||
        ch === 0x2F /* / */ ||
        ch >= 0x5B /* [ */ && ch <= 0x5D /* ] */ ||
        ch >= 0x7B /* { */ && ch <= 0x7D /* } */
      )
    }

    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
    pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
      var ch = state.current();
      if (isClassSetReservedPunctuator(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }
      return false
    };

    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
    function isClassSetReservedPunctuator(ch) {
      return (
        ch === 0x21 /* ! */ ||
        ch === 0x23 /* # */ ||
        ch === 0x25 /* % */ ||
        ch === 0x26 /* & */ ||
        ch === 0x2C /* , */ ||
        ch === 0x2D /* - */ ||
        ch >= 0x3A /* : */ && ch <= 0x3E /* > */ ||
        ch === 0x40 /* @ */ ||
        ch === 0x60 /* ` */ ||
        ch === 0x7E /* ~ */
      )
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
    pp$1.regexp_eatClassControlLetter = function(state) {
      var ch = state.current();
      if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
        state.lastIntValue = ch % 0x20;
        state.advance();
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$1.regexp_eatHexEscapeSequence = function(state) {
      var start = state.pos;
      if (state.eat(0x78 /* x */)) {
        if (this.regexp_eatFixedHexDigits(state, 2)) {
          return true
        }
        if (state.switchU) {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
    pp$1.regexp_eatDecimalDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isDecimalDigit(ch = state.current())) {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
        state.advance();
      }
      return state.pos !== start
    };
    function isDecimalDigit(ch) {
      return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
    pp$1.regexp_eatHexDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isHexDigit(ch = state.current())) {
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return state.pos !== start
    };
    function isHexDigit(ch) {
      return (
        (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
        (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
        (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
      )
    }
    function hexToInt(ch) {
      if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
        return 10 + (ch - 0x41 /* A */)
      }
      if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
        return 10 + (ch - 0x61 /* a */)
      }
      return ch - 0x30 /* 0 */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
    // Allows only 0-377(octal) i.e. 0-255(decimal).
    pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
      if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
          var n2 = state.lastIntValue;
          if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
            state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
          } else {
            state.lastIntValue = n1 * 8 + n2;
          }
        } else {
          state.lastIntValue = n1;
        }
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
    pp$1.regexp_eatOctalDigit = function(state) {
      var ch = state.current();
      if (isOctalDigit(ch)) {
        state.lastIntValue = ch - 0x30; /* 0 */
        state.advance();
        return true
      }
      state.lastIntValue = 0;
      return false
    };
    function isOctalDigit(ch) {
      return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
    // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$1.regexp_eatFixedHexDigits = function(state, length) {
      var start = state.pos;
      state.lastIntValue = 0;
      for (var i = 0; i < length; ++i) {
        var ch = state.current();
        if (!isHexDigit(ch)) {
          state.pos = start;
          return false
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return true
    };

    // Object type used to represent tokens. Note that normally, tokens
    // simply exist as properties on the parser object. This is only
    // used for the onToken callback and the external tokenizer.

    var Token = function Token(p) {
      this.type = p.type;
      this.value = p.value;
      this.start = p.start;
      this.end = p.end;
      if (p.options.locations)
        { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
      if (p.options.ranges)
        { this.range = [p.start, p.end]; }
    };

    // ## Tokenizer

    var pp = Parser.prototype;

    // Move to the next token

    pp.next = function(ignoreEscapeSequenceInKeyword) {
      if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
        { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
      if (this.options.onToken)
        { this.options.onToken(new Token(this)); }

      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };

    pp.getToken = function() {
      this.next();
      return new Token(this)
    };

    // If we're in an ES6 environment, make parsers iterable
    if (typeof Symbol !== "undefined")
      { pp[Symbol.iterator] = function() {
        var this$1$1 = this;

        return {
          next: function () {
            var token = this$1$1.getToken();
            return {
              done: token.type === types$1.eof,
              value: token
            }
          }
        }
      }; }

    // Toggle strict mode. Re-reads the next number or string to please
    // pedantic tests (`"use strict"; 010;` should fail).

    // Read a single token, updating the parser object's token-related
    // properties.

    pp.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

      this.start = this.pos;
      if (this.options.locations) { this.startLoc = this.curPosition(); }
      if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }

      if (curContext.override) { return curContext.override(this) }
      else { this.readToken(this.fullCharCodeAtPos()); }
    };

    pp.readToken = function(code) {
      // Identifier or keyword. '\uXXXX' sequences are allowed in
      // identifiers, so '\' also dispatches to that.
      if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
        { return this.readWord() }

      return this.getTokenFromCode(code)
    };

    pp.fullCharCodeAtPos = function() {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 0xd7ff || code >= 0xdc00) { return code }
      var next = this.input.charCodeAt(this.pos + 1);
      return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00
    };

    pp.skipBlockComment = function() {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
      this.pos = end + 2;
      if (this.options.locations) {
        for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
          ++this.curLine;
          pos = this.lineStart = nextBreak;
        }
      }
      if (this.options.onComment)
        { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                               startLoc, this.curPosition()); }
    };

    pp.skipLineComment = function(startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine(ch)) {
        ch = this.input.charCodeAt(++this.pos);
      }
      if (this.options.onComment)
        { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                               startLoc, this.curPosition()); }
    };

    // Called at the start of the parse and after every token. Skips
    // whitespace and comments, and.

    pp.skipSpace = function() {
      loop: while (this.pos < this.input.length) {
        var ch = this.input.charCodeAt(this.pos);
        switch (ch) {
        case 32: case 160: // ' '
          ++this.pos;
          break
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10: case 8232: case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break
        case 47: // '/'
          switch (this.input.charCodeAt(this.pos + 1)) {
          case 42: // '*'
            this.skipBlockComment();
            break
          case 47:
            this.skipLineComment(2);
            break
          default:
            break loop
          }
          break
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop
          }
        }
      }
    };

    // Called at the end of every token. Sets `end`, `val`, and
    // maintains `context` and `exprAllowed`, and skips the space after
    // the token, so that the next one's `start` will point at the
    // right position.

    pp.finishToken = function(type, val) {
      this.end = this.pos;
      if (this.options.locations) { this.endLoc = this.curPosition(); }
      var prevType = this.type;
      this.type = type;
      this.value = val;

      this.updateContext(prevType);
    };

    // ### Token reading

    // This is the function that is called to fetch the next token. It
    // is somewhat obscure, because it works in character codes rather
    // than characters, and because operator parsing has been inlined
    // into it.
    //
    // All in the name of speed.
    //
    pp.readToken_dot = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) { return this.readNumber(true) }
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
        this.pos += 3;
        return this.finishToken(types$1.ellipsis)
      } else {
        ++this.pos;
        return this.finishToken(types$1.dot)
      }
    };

    pp.readToken_slash = function() { // '/'
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
      if (next === 61) { return this.finishOp(types$1.assign, 2) }
      return this.finishOp(types$1.slash, 1)
    };

    pp.readToken_mult_modulo_exp = function(code) { // '%*'
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code === 42 ? types$1.star : types$1.modulo;

      // exponentiation operator ** and **=
      if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types$1.starstar;
        next = this.input.charCodeAt(this.pos + 2);
      }

      if (next === 61) { return this.finishOp(types$1.assign, size + 1) }
      return this.finishOp(tokentype, size)
    };

    pp.readToken_pipe_amp = function(code) { // '|&'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (this.options.ecmaVersion >= 12) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 === 61) { return this.finishOp(types$1.assign, 3) }
        }
        return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)
      }
      if (next === 61) { return this.finishOp(types$1.assign, 2) }
      return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)
    };

    pp.readToken_caret = function() { // '^'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) { return this.finishOp(types$1.assign, 2) }
      return this.finishOp(types$1.bitwiseXOR, 1)
    };

    pp.readToken_plus_min = function(code) { // '+-'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
            (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          // A `-->` line comment
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken()
        }
        return this.finishOp(types$1.incDec, 2)
      }
      if (next === 61) { return this.finishOp(types$1.assign, 2) }
      return this.finishOp(types$1.plusMin, 1)
    };

    pp.readToken_lt_gt = function(code) { // '<>'
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }
        return this.finishOp(types$1.bitShift, size)
      }
      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
          this.input.charCodeAt(this.pos + 3) === 45) {
        // `<!--`, an XML-style comment that should be interpreted as a line comment
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken()
      }
      if (next === 61) { size = 2; }
      return this.finishOp(types$1.relational, size)
    };

    pp.readToken_eq_excl = function(code) { // '=!'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
        this.pos += 2;
        return this.finishToken(types$1.arrow)
      }
      return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)
    };

    pp.readToken_question = function() { // '?'
      var ecmaVersion = this.options.ecmaVersion;
      if (ecmaVersion >= 11) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 46) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }
        }
        if (next === 63) {
          if (ecmaVersion >= 12) {
            var next2$1 = this.input.charCodeAt(this.pos + 2);
            if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }
          }
          return this.finishOp(types$1.coalesce, 2)
        }
      }
      return this.finishOp(types$1.question, 1)
    };

    pp.readToken_numberSign = function() { // '#'
      var ecmaVersion = this.options.ecmaVersion;
      var code = 35; // '#'
      if (ecmaVersion >= 13) {
        ++this.pos;
        code = this.fullCharCodeAtPos();
        if (isIdentifierStart(code, true) || code === 92 /* '\' */) {
          return this.finishToken(types$1.privateId, this.readWord1())
        }
      }

      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };

    pp.getTokenFromCode = function(code) {
      switch (code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
      case 46: // '.'
        return this.readToken_dot()

      // Punctuation tokens.
      case 40: ++this.pos; return this.finishToken(types$1.parenL)
      case 41: ++this.pos; return this.finishToken(types$1.parenR)
      case 59: ++this.pos; return this.finishToken(types$1.semi)
      case 44: ++this.pos; return this.finishToken(types$1.comma)
      case 91: ++this.pos; return this.finishToken(types$1.bracketL)
      case 93: ++this.pos; return this.finishToken(types$1.bracketR)
      case 123: ++this.pos; return this.finishToken(types$1.braceL)
      case 125: ++this.pos; return this.finishToken(types$1.braceR)
      case 58: ++this.pos; return this.finishToken(types$1.colon)

      case 96: // '`'
        if (this.options.ecmaVersion < 6) { break }
        ++this.pos;
        return this.finishToken(types$1.backQuote)

      case 48: // '0'
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
        if (this.options.ecmaVersion >= 6) {
          if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
          if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
        }

      // Anything else beginning with a digit is an integer, octal
      // number, or float.
      case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
        return this.readNumber(false)

      // Quotes produce strings.
      case 34: case 39: // '"', "'"
        return this.readString(code)

      // Operators are parsed inline in tiny state machines. '=' (61) is
      // often referred to. `finishOp` simply skips the amount of
      // characters it is given as second argument, and returns a token
      // of the type given by its first argument.
      case 47: // '/'
        return this.readToken_slash()

      case 37: case 42: // '%*'
        return this.readToken_mult_modulo_exp(code)

      case 124: case 38: // '|&'
        return this.readToken_pipe_amp(code)

      case 94: // '^'
        return this.readToken_caret()

      case 43: case 45: // '+-'
        return this.readToken_plus_min(code)

      case 60: case 62: // '<>'
        return this.readToken_lt_gt(code)

      case 61: case 33: // '=!'
        return this.readToken_eq_excl(code)

      case 63: // '?'
        return this.readToken_question()

      case 126: // '~'
        return this.finishOp(types$1.prefix, 1)

      case 35: // '#'
        return this.readToken_numberSign()
      }

      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };

    pp.finishOp = function(type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str)
    };

    pp.readRegexp = function() {
      var escaped, inClass, start = this.pos;
      for (;;) {
        if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
        var ch = this.input.charAt(this.pos);
        if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
        if (!escaped) {
          if (ch === "[") { inClass = true; }
          else if (ch === "]" && inClass) { inClass = false; }
          else if (ch === "/" && !inClass) { break }
          escaped = ch === "\\";
        } else { escaped = false; }
        ++this.pos;
      }
      var pattern = this.input.slice(start, this.pos);
      ++this.pos;
      var flagsStart = this.pos;
      var flags = this.readWord1();
      if (this.containsEsc) { this.unexpected(flagsStart); }

      // Validate pattern
      var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
      state.reset(start, pattern, flags);
      this.validateRegExpFlags(state);
      this.validateRegExpPattern(state);

      // Create Literal#value property value.
      var value = null;
      try {
        value = new RegExp(pattern, flags);
      } catch (e) {
        // ESTree requires null if it failed to instantiate RegExp object.
        // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
      }

      return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})
    };

    // Read an integer in the given radix. Return null if zero digits
    // were read, the integer value otherwise. When `len` is given, this
    // will return `null` unless the integer has exactly `len` digits.

    pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
      // `len` is used for character escape sequences. In that case, disallow separators.
      var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

      // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
      // and isn't fraction part nor exponent part. In that case, if the first digit
      // is zero then disallow separators.
      var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

      var start = this.pos, total = 0, lastCode = 0;
      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
        var code = this.input.charCodeAt(this.pos), val = (void 0);

        if (allowSeparators && code === 95) {
          if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
          if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
          if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
          lastCode = code;
          continue
        }

        if (code >= 97) { val = code - 97 + 10; } // a
        else if (code >= 65) { val = code - 65 + 10; } // A
        else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
        else { val = Infinity; }
        if (val >= radix) { break }
        lastCode = code;
        total = total * radix + val;
      }

      if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
      if (this.pos === start || len != null && this.pos - start !== len) { return null }

      return total
    };

    function stringToNumber(str, isLegacyOctalNumericLiteral) {
      if (isLegacyOctalNumericLiteral) {
        return parseInt(str, 8)
      }

      // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
      return parseFloat(str.replace(/_/g, ""))
    }

    function stringToBigInt(str) {
      if (typeof BigInt !== "function") {
        return null
      }

      // `BigInt(value)` throws syntax error if the string contains numeric separators.
      return BigInt(str.replace(/_/g, ""))
    }

    pp.readRadixNumber = function(radix) {
      var start = this.pos;
      this.pos += 2; // 0x
      var val = this.readInt(radix);
      if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
      } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types$1.num, val)
    };

    // Read an integer, octal integer, or floating-point number.

    pp.readNumber = function(startsWithDot) {
      var start = this.pos;
      if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
      var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (octal && this.strict) { this.raise(start, "Invalid number"); }
      var next = this.input.charCodeAt(this.pos);
      if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var val$1 = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
        if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
        return this.finishToken(types$1.num, val$1)
      }
      if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
      if (next === 46 && !octal) { // '.'
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
      }
      if ((next === 69 || next === 101) && !octal) { // 'eE'
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) { ++this.pos; } // '+-'
        if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
      }
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

      var val = stringToNumber(this.input.slice(start, this.pos), octal);
      return this.finishToken(types$1.num, val)
    };

    // Read a string value, interpreting backslash-escapes.

    pp.readCodePoint = function() {
      var ch = this.input.charCodeAt(this.pos), code;

      if (ch === 123) { // '{'
        if (this.options.ecmaVersion < 6) { this.unexpected(); }
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
      } else {
        code = this.readHexChar(4);
      }
      return code
    };

    pp.readString = function(quote) {
      var out = "", chunkStart = ++this.pos;
      for (;;) {
        if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) { break }
        if (ch === 92) { // '\'
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else if (ch === 0x2028 || ch === 0x2029) {
          if (this.options.ecmaVersion < 10) { this.raise(this.start, "Unterminated string constant"); }
          ++this.pos;
          if (this.options.locations) {
            this.curLine++;
            this.lineStart = this.pos;
          }
        } else {
          if (isNewLine(ch)) { this.raise(this.start, "Unterminated string constant"); }
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types$1.string, out)
    };

    // Reads template string tokens.

    var INVALID_TEMPLATE_ESCAPE_ERROR = {};

    pp.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
          this.readInvalidTemplateToken();
        } else {
          throw err
        }
      }

      this.inTemplateElement = false;
    };

    pp.invalidStringToken = function(position, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR
      } else {
        this.raise(position, message);
      }
    };

    pp.readTmplToken = function() {
      var out = "", chunkStart = this.pos;
      for (;;) {
        if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
          if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
            if (ch === 36) {
              this.pos += 2;
              return this.finishToken(types$1.dollarBraceL)
            } else {
              ++this.pos;
              return this.finishToken(types$1.backQuote)
            }
          }
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(types$1.template, out)
        }
        if (ch === 92) { // '\'
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
          case 10:
            out += "\n";
            break
          default:
            out += String.fromCharCode(ch);
            break
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };

    // Reads a template token to search for the end, without validating any escape sequences
    pp.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++) {
        switch (this.input[this.pos]) {
        case "\\":
          ++this.pos;
          break

        case "$":
          if (this.input[this.pos + 1] !== "{") { break }
          // fall through
        case "`":
          return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))

        case "\r":
          if (this.input[this.pos + 1] === "\n") { ++this.pos; }
          // fall through
        case "\n": case "\u2028": case "\u2029":
          ++this.curLine;
          this.lineStart = this.pos + 1;
          break
        }
      }
      this.raise(this.start, "Unterminated template");
    };

    // Used to read escaped characters

    pp.readEscapedChar = function(inTemplate) {
      var ch = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch) {
      case 110: return "\n" // 'n' -> '\n'
      case 114: return "\r" // 'r' -> '\r'
      case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
      case 117: return codePointToString(this.readCodePoint()) // 'u'
      case 116: return "\t" // 't' -> '\t'
      case 98: return "\b" // 'b' -> '\b'
      case 118: return "\u000b" // 'v' -> '\u000b'
      case 102: return "\f" // 'f' -> '\f'
      case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
      case 10: // ' \n'
        if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
        return ""
      case 56:
      case 57:
        if (this.strict) {
          this.invalidStringToken(
            this.pos - 1,
            "Invalid escape sequence"
          );
        }
        if (inTemplate) {
          var codePos = this.pos - 1;

          this.invalidStringToken(
            codePos,
            "Invalid escape sequence in template string"
          );
        }
      default:
        if (ch >= 48 && ch <= 55) {
          var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          this.pos += octalStr.length - 1;
          ch = this.input.charCodeAt(this.pos);
          if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
            this.invalidStringToken(
              this.pos - 1 - octalStr.length,
              inTemplate
                ? "Octal literal in template string"
                : "Octal literal in strict mode"
            );
          }
          return String.fromCharCode(octal)
        }
        if (isNewLine(ch)) {
          // Unicode new line characters after \ get removed from output in both
          // template literals and strings
          if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
          return ""
        }
        return String.fromCharCode(ch)
      }
    };

    // Used to read character escape sequences ('\x', '\u', '\U').

    pp.readHexChar = function(len) {
      var codePos = this.pos;
      var n = this.readInt(16, len);
      if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
      return n
    };

    // Read an identifier, and return it as a string. Sets `this.containsEsc`
    // to whether the word contained a '\u' escape.
    //
    // Incrementally adds only escaped chars, adding other chunks as-is
    // as a micro-optimization.

    pp.readWord1 = function() {
      this.containsEsc = false;
      var word = "", first = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch, astral)) {
          this.pos += ch <= 0xffff ? 1 : 2;
        } else if (ch === 92) { // "\"
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117) // "u"
            { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
            { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
          word += codePointToString(esc);
          chunkStart = this.pos;
        } else {
          break
        }
        first = false;
      }
      return word + this.input.slice(chunkStart, this.pos)
    };

    // Read an identifier or keyword token. Will check for reserved
    // words when necessary.

    pp.readWord = function() {
      var word = this.readWord1();
      var type = types$1.name;
      if (this.keywords.test(word)) {
        type = keywords[word];
      }
      return this.finishToken(type, word)
    };

    // Acorn is a tiny, fast JavaScript parser written in JavaScript.
    //
    // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
    // various contributors and released under an MIT license.
    //
    // Git repositories for Acorn are available at
    //
    //     http://marijnhaverbeke.nl/git/acorn
    //     https://github.com/acornjs/acorn.git
    //
    // Please use the [github bug tracker][ghbt] to report issues.
    //
    // [ghbt]: https://github.com/acornjs/acorn/issues
    //
    // [walk]: util/walk.js


    var version$2 = "8.14.0";

    Parser.acorn = {
      Parser: Parser,
      version: version$2,
      defaultOptions: defaultOptions$2,
      Position: Position,
      SourceLocation: SourceLocation,
      getLineInfo: getLineInfo,
      Node: Node,
      TokenType: TokenType,
      tokTypes: types$1,
      keywordTypes: keywords,
      TokContext: TokContext,
      tokContexts: types,
      isIdentifierChar: isIdentifierChar,
      isIdentifierStart: isIdentifierStart,
      Token: Token,
      isNewLine: isNewLine,
      lineBreak: lineBreak,
      lineBreakG: lineBreakG,
      nonASCIIwhitespace: nonASCIIwhitespace
    };

    // The main exported interface (under `self.acorn` when in the
    // browser) is a `parse` function that takes a code string and returns
    // an abstract syntax tree as specified by the [ESTree spec][estree].
    //
    // [estree]: https://github.com/estree/estree

    function parse(input, options) {
      return Parser.parse(input, options)
    }

    // AST walker module for ESTree compatible trees

    // A simple walk is one where you simply specify callbacks to be
    // called on specific nodes. The last two arguments are optional. A
    // simple use would be
    //
    //     walk.simple(myTree, {
    //         Expression: function(node) { ... }
    //     });
    //
    // to do something with all expressions. All ESTree node types
    // can be used to identify node types, as well as Expression and
    // Statement, which denote categories of nodes.
    //
    // The base argument can be used to pass a custom (recursive)
    // walker, and state can be used to give this walked an initial
    // state.

    function simple(node, visitors, baseVisitor, state, override) {
      if (!baseVisitor) { baseVisitor = base$1
      ; }(function c(node, st, override) {
        var type = override || node.type;
        baseVisitor[type](node, st, c);
        if (visitors[type]) { visitors[type](node, st); }
      })(node, state, override);
    }

    // A recursive walk is one where your functions override the default
    // walkers. They can modify and replace the state parameter that's
    // threaded through the walk, and can opt how and whether to walk
    // their child nodes (by calling their third argument on these
    // nodes).
    function recursive(node, state, funcs, baseVisitor, override) {
      var visitor = funcs ? make(funcs) : baseVisitor
      ;(function c(node, st, override) {
        visitor[override || node.type](node, st, c);
      })(node, state, override);
    }

    // Used to create a custom walker. Will fill in all missing node
    // type properties with the defaults.
    function make(funcs, baseVisitor) {
      var visitor = Object.create(base$1);
      for (var type in funcs) { visitor[type] = funcs[type]; }
      return visitor
    }

    function skipThrough(node, st, c) { c(node, st); }
    function ignore(_node, _st, _c) {}

    // Node walkers.

    var base$1 = {};

    base$1.Program = base$1.BlockStatement = base$1.StaticBlock = function (node, st, c) {
      for (var i = 0, list = node.body; i < list.length; i += 1)
        {
        var stmt = list[i];

        c(stmt, st, "Statement");
      }
    };
    base$1.Statement = skipThrough;
    base$1.EmptyStatement = ignore;
    base$1.ExpressionStatement = base$1.ParenthesizedExpression = base$1.ChainExpression =
      function (node, st, c) { return c(node.expression, st, "Expression"); };
    base$1.IfStatement = function (node, st, c) {
      c(node.test, st, "Expression");
      c(node.consequent, st, "Statement");
      if (node.alternate) { c(node.alternate, st, "Statement"); }
    };
    base$1.LabeledStatement = function (node, st, c) { return c(node.body, st, "Statement"); };
    base$1.BreakStatement = base$1.ContinueStatement = ignore;
    base$1.WithStatement = function (node, st, c) {
      c(node.object, st, "Expression");
      c(node.body, st, "Statement");
    };
    base$1.SwitchStatement = function (node, st, c) {
      c(node.discriminant, st, "Expression");
      for (var i = 0, list = node.cases; i < list.length; i += 1) {
        var cs = list[i];

        c(cs, st);
      }
    };
    base$1.SwitchCase = function (node, st, c) {
      if (node.test) { c(node.test, st, "Expression"); }
      for (var i = 0, list = node.consequent; i < list.length; i += 1)
        {
        var cons = list[i];

        c(cons, st, "Statement");
      }
    };
    base$1.ReturnStatement = base$1.YieldExpression = base$1.AwaitExpression = function (node, st, c) {
      if (node.argument) { c(node.argument, st, "Expression"); }
    };
    base$1.ThrowStatement = base$1.SpreadElement =
      function (node, st, c) { return c(node.argument, st, "Expression"); };
    base$1.TryStatement = function (node, st, c) {
      c(node.block, st, "Statement");
      if (node.handler) { c(node.handler, st); }
      if (node.finalizer) { c(node.finalizer, st, "Statement"); }
    };
    base$1.CatchClause = function (node, st, c) {
      if (node.param) { c(node.param, st, "Pattern"); }
      c(node.body, st, "Statement");
    };
    base$1.WhileStatement = base$1.DoWhileStatement = function (node, st, c) {
      c(node.test, st, "Expression");
      c(node.body, st, "Statement");
    };
    base$1.ForStatement = function (node, st, c) {
      if (node.init) { c(node.init, st, "ForInit"); }
      if (node.test) { c(node.test, st, "Expression"); }
      if (node.update) { c(node.update, st, "Expression"); }
      c(node.body, st, "Statement");
    };
    base$1.ForInStatement = base$1.ForOfStatement = function (node, st, c) {
      c(node.left, st, "ForInit");
      c(node.right, st, "Expression");
      c(node.body, st, "Statement");
    };
    base$1.ForInit = function (node, st, c) {
      if (node.type === "VariableDeclaration") { c(node, st); }
      else { c(node, st, "Expression"); }
    };
    base$1.DebuggerStatement = ignore;

    base$1.FunctionDeclaration = function (node, st, c) { return c(node, st, "Function"); };
    base$1.VariableDeclaration = function (node, st, c) {
      for (var i = 0, list = node.declarations; i < list.length; i += 1)
        {
        var decl = list[i];

        c(decl, st);
      }
    };
    base$1.VariableDeclarator = function (node, st, c) {
      c(node.id, st, "Pattern");
      if (node.init) { c(node.init, st, "Expression"); }
    };

    base$1.Function = function (node, st, c) {
      if (node.id) { c(node.id, st, "Pattern"); }
      for (var i = 0, list = node.params; i < list.length; i += 1)
        {
        var param = list[i];

        c(param, st, "Pattern");
      }
      c(node.body, st, node.expression ? "Expression" : "Statement");
    };

    base$1.Pattern = function (node, st, c) {
      if (node.type === "Identifier")
        { c(node, st, "VariablePattern"); }
      else if (node.type === "MemberExpression")
        { c(node, st, "MemberPattern"); }
      else
        { c(node, st); }
    };
    base$1.VariablePattern = ignore;
    base$1.MemberPattern = skipThrough;
    base$1.RestElement = function (node, st, c) { return c(node.argument, st, "Pattern"); };
    base$1.ArrayPattern = function (node, st, c) {
      for (var i = 0, list = node.elements; i < list.length; i += 1) {
        var elt = list[i];

        if (elt) { c(elt, st, "Pattern"); }
      }
    };
    base$1.ObjectPattern = function (node, st, c) {
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

        if (prop.type === "Property") {
          if (prop.computed) { c(prop.key, st, "Expression"); }
          c(prop.value, st, "Pattern");
        } else if (prop.type === "RestElement") {
          c(prop.argument, st, "Pattern");
        }
      }
    };

    base$1.Expression = skipThrough;
    base$1.ThisExpression = base$1.Super = base$1.MetaProperty = ignore;
    base$1.ArrayExpression = function (node, st, c) {
      for (var i = 0, list = node.elements; i < list.length; i += 1) {
        var elt = list[i];

        if (elt) { c(elt, st, "Expression"); }
      }
    };
    base$1.ObjectExpression = function (node, st, c) {
      for (var i = 0, list = node.properties; i < list.length; i += 1)
        {
        var prop = list[i];

        c(prop, st);
      }
    };
    base$1.FunctionExpression = base$1.ArrowFunctionExpression = base$1.FunctionDeclaration;
    base$1.SequenceExpression = function (node, st, c) {
      for (var i = 0, list = node.expressions; i < list.length; i += 1)
        {
        var expr = list[i];

        c(expr, st, "Expression");
      }
    };
    base$1.TemplateLiteral = function (node, st, c) {
      for (var i = 0, list = node.quasis; i < list.length; i += 1)
        {
        var quasi = list[i];

        c(quasi, st);
      }

      for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)
        {
        var expr = list$1[i$1];

        c(expr, st, "Expression");
      }
    };
    base$1.TemplateElement = ignore;
    base$1.UnaryExpression = base$1.UpdateExpression = function (node, st, c) {
      c(node.argument, st, "Expression");
    };
    base$1.BinaryExpression = base$1.LogicalExpression = function (node, st, c) {
      c(node.left, st, "Expression");
      c(node.right, st, "Expression");
    };
    base$1.AssignmentExpression = base$1.AssignmentPattern = function (node, st, c) {
      c(node.left, st, "Pattern");
      c(node.right, st, "Expression");
    };
    base$1.ConditionalExpression = function (node, st, c) {
      c(node.test, st, "Expression");
      c(node.consequent, st, "Expression");
      c(node.alternate, st, "Expression");
    };
    base$1.NewExpression = base$1.CallExpression = function (node, st, c) {
      c(node.callee, st, "Expression");
      if (node.arguments)
        { for (var i = 0, list = node.arguments; i < list.length; i += 1)
          {
            var arg = list[i];

            c(arg, st, "Expression");
          } }
    };
    base$1.MemberExpression = function (node, st, c) {
      c(node.object, st, "Expression");
      if (node.computed) { c(node.property, st, "Expression"); }
    };
    base$1.ExportNamedDeclaration = base$1.ExportDefaultDeclaration = function (node, st, c) {
      if (node.declaration)
        { c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression"); }
      if (node.source) { c(node.source, st, "Expression"); }
    };
    base$1.ExportAllDeclaration = function (node, st, c) {
      if (node.exported)
        { c(node.exported, st); }
      c(node.source, st, "Expression");
    };
    base$1.ImportDeclaration = function (node, st, c) {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1)
        {
        var spec = list[i];

        c(spec, st);
      }
      c(node.source, st, "Expression");
    };
    base$1.ImportExpression = function (node, st, c) {
      c(node.source, st, "Expression");
    };
    base$1.ImportSpecifier = base$1.ImportDefaultSpecifier = base$1.ImportNamespaceSpecifier = base$1.Identifier = base$1.PrivateIdentifier = base$1.Literal = ignore;

    base$1.TaggedTemplateExpression = function (node, st, c) {
      c(node.tag, st, "Expression");
      c(node.quasi, st, "Expression");
    };
    base$1.ClassDeclaration = base$1.ClassExpression = function (node, st, c) { return c(node, st, "Class"); };
    base$1.Class = function (node, st, c) {
      if (node.id) { c(node.id, st, "Pattern"); }
      if (node.superClass) { c(node.superClass, st, "Expression"); }
      c(node.body, st);
    };
    base$1.ClassBody = function (node, st, c) {
      for (var i = 0, list = node.body; i < list.length; i += 1)
        {
        var elt = list[i];

        c(elt, st);
      }
    };
    base$1.MethodDefinition = base$1.PropertyDefinition = base$1.Property = function (node, st, c) {
      if (node.computed) { c(node.key, st, "Expression"); }
      if (node.value) { c(node.value, st, "Expression"); }
    };

    // Astring is a tiny and fast JavaScript code generator from an ESTree-compliant AST.
    //
    // Astring was written by David Bonnet and released under an MIT license.
    //
    // The Git repository for Astring is available at:
    // https://github.com/davidbonnet/astring.git
    //
    // Please use the GitHub bug tracker to report issues:
    // https://github.com/davidbonnet/astring/issues

    const { stringify } = JSON;

    /* c8 ignore if */
    if (!String.prototype.repeat) {
      /* c8 ignore next */
      throw new Error(
        'String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation',
      )
    }

    /* c8 ignore if */
    if (!String.prototype.endsWith) {
      /* c8 ignore next */
      throw new Error(
        'String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation',
      )
    }

    const OPERATOR_PRECEDENCE = {
      '||': 2,
      '??': 3,
      '&&': 4,
      '|': 5,
      '^': 6,
      '&': 7,
      '==': 8,
      '!=': 8,
      '===': 8,
      '!==': 8,
      '<': 9,
      '>': 9,
      '<=': 9,
      '>=': 9,
      in: 9,
      instanceof: 9,
      '<<': 10,
      '>>': 10,
      '>>>': 10,
      '+': 11,
      '-': 11,
      '*': 12,
      '%': 12,
      '/': 12,
      '**': 13,
    };

    // Enables parenthesis regardless of precedence
    const NEEDS_PARENTHESES = 17;

    const EXPRESSIONS_PRECEDENCE = {
      // Definitions
      ArrayExpression: 20,
      TaggedTemplateExpression: 20,
      ThisExpression: 20,
      Identifier: 20,
      PrivateIdentifier: 20,
      Literal: 18,
      TemplateLiteral: 20,
      Super: 20,
      SequenceExpression: 20,
      // Operations
      MemberExpression: 19,
      ChainExpression: 19,
      CallExpression: 19,
      NewExpression: 19,
      // Other definitions
      ArrowFunctionExpression: NEEDS_PARENTHESES,
      ClassExpression: NEEDS_PARENTHESES,
      FunctionExpression: NEEDS_PARENTHESES,
      ObjectExpression: NEEDS_PARENTHESES,
      // Other operations
      UpdateExpression: 16,
      UnaryExpression: 15,
      AwaitExpression: 15,
      BinaryExpression: 14,
      LogicalExpression: 13,
      ConditionalExpression: 4,
      AssignmentExpression: 3,
      YieldExpression: 2,
      RestElement: 1,
    };

    function formatSequence(state, nodes) {
      /*
      Writes into `state` a sequence of `nodes`.
      */
      const { generator } = state;
      state.write('(');
      if (nodes != null && nodes.length > 0) {
        generator[nodes[0].type](nodes[0], state);
        const { length } = nodes;
        for (let i = 1; i < length; i++) {
          const param = nodes[i];
          state.write(', ');
          generator[param.type](param, state);
        }
      }
      state.write(')');
    }

    function expressionNeedsParenthesis(state, node, parentNode, isRightHand) {
      const nodePrecedence = state.expressionsPrecedence[node.type];
      if (nodePrecedence === NEEDS_PARENTHESES) {
        return true
      }
      const parentNodePrecedence = state.expressionsPrecedence[parentNode.type];
      if (nodePrecedence !== parentNodePrecedence) {
        // Different node types
        return (
          (!isRightHand &&
            nodePrecedence === 15 &&
            parentNodePrecedence === 14 &&
            parentNode.operator === '**') ||
          nodePrecedence < parentNodePrecedence
        )
      }
      if (nodePrecedence !== 13 && nodePrecedence !== 14) {
        // Not a `LogicalExpression` or `BinaryExpression`
        return false
      }
      if (node.operator === '**' && parentNode.operator === '**') {
        // Exponentiation operator has right-to-left associativity
        return !isRightHand
      }
      if (
        nodePrecedence === 13 &&
        parentNodePrecedence === 13 &&
        (node.operator === '??' || parentNode.operator === '??')
      ) {
        // Nullish coalescing and boolean operators cannot be combined
        return true
      }
      if (isRightHand) {
        // Parenthesis are used if both operators have the same precedence
        return (
          OPERATOR_PRECEDENCE[node.operator] <=
          OPERATOR_PRECEDENCE[parentNode.operator]
        )
      }
      return (
        OPERATOR_PRECEDENCE[node.operator] <
        OPERATOR_PRECEDENCE[parentNode.operator]
      )
    }

    function formatExpression(state, node, parentNode, isRightHand) {
      /*
      Writes into `state` the provided `node`, adding parenthesis around if the provided `parentNode` needs it. If `node` is a right-hand argument, the provided `isRightHand` parameter should be `true`.
      */
      const { generator } = state;
      if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {
        state.write('(');
        generator[node.type](node, state);
        state.write(')');
      } else {
        generator[node.type](node, state);
      }
    }

    function reindent(state, text, indent, lineEnd) {
      /*
      Writes into `state` the `text` string reindented with the provided `indent`.
      */
      const lines = text.split('\n');
      const end = lines.length - 1;
      state.write(lines[0].trim());
      if (end > 0) {
        state.write(lineEnd);
        for (let i = 1; i < end; i++) {
          state.write(indent + lines[i].trim() + lineEnd);
        }
        state.write(indent + lines[end].trim());
      }
    }

    function formatComments(state, comments, indent, lineEnd) {
      /*
      Writes into `state` the provided list of `comments`, with the given `indent` and `lineEnd` strings.
      Line comments will end with `"\n"` regardless of the value of `lineEnd`.
      Expects to start on a new unindented line.
      */
      const { length } = comments;
      for (let i = 0; i < length; i++) {
        const comment = comments[i];
        state.write(indent);
        if (comment.type[0] === 'L') {
          // Line comment
          state.write('// ' + comment.value.trim() + '\n', comment);
        } else {
          // Block comment
          state.write('/*');
          reindent(state, comment.value, indent, lineEnd);
          state.write('*/' + lineEnd);
        }
      }
    }

    function hasCallExpression(node) {
      /*
      Returns `true` if the provided `node` contains a call expression and `false` otherwise.
      */
      let currentNode = node;
      while (currentNode != null) {
        const { type } = currentNode;
        if (type[0] === 'C' && type[1] === 'a') {
          // Is CallExpression
          return true
        } else if (type[0] === 'M' && type[1] === 'e' && type[2] === 'm') {
          // Is MemberExpression
          currentNode = currentNode.object;
        } else {
          return false
        }
      }
    }

    function formatVariableDeclaration(state, node) {
      /*
      Writes into `state` a variable declaration.
      */
      const { generator } = state;
      const { declarations } = node;
      state.write(node.kind + ' ');
      const { length } = declarations;
      if (length > 0) {
        generator.VariableDeclarator(declarations[0], state);
        for (let i = 1; i < length; i++) {
          state.write(', ');
          generator.VariableDeclarator(declarations[i], state);
        }
      }
    }

    let ForInStatement,
      FunctionDeclaration,
      RestElement,
      BinaryExpression,
      ArrayExpression,
      BlockStatement;

    const GENERATOR = {
      /*
      Default generator.
      */
      Program(node, state) {
        const indent = state.indent.repeat(state.indentLevel);
        const { lineEnd, writeComments } = state;
        if (writeComments && node.comments != null) {
          formatComments(state, node.comments, indent, lineEnd);
        }
        const statements = node.body;
        const { length } = statements;
        for (let i = 0; i < length; i++) {
          const statement = statements[i];
          if (writeComments && statement.comments != null) {
            formatComments(state, statement.comments, indent, lineEnd);
          }
          state.write(indent);
          this[statement.type](statement, state);
          state.write(lineEnd);
        }
        if (writeComments && node.trailingComments != null) {
          formatComments(state, node.trailingComments, indent, lineEnd);
        }
      },
      BlockStatement: (BlockStatement = function (node, state) {
        const indent = state.indent.repeat(state.indentLevel++);
        const { lineEnd, writeComments } = state;
        const statementIndent = indent + state.indent;
        state.write('{');
        const statements = node.body;
        if (statements != null && statements.length > 0) {
          state.write(lineEnd);
          if (writeComments && node.comments != null) {
            formatComments(state, node.comments, statementIndent, lineEnd);
          }
          const { length } = statements;
          for (let i = 0; i < length; i++) {
            const statement = statements[i];
            if (writeComments && statement.comments != null) {
              formatComments(state, statement.comments, statementIndent, lineEnd);
            }
            state.write(statementIndent);
            this[statement.type](statement, state);
            state.write(lineEnd);
          }
          state.write(indent);
        } else {
          if (writeComments && node.comments != null) {
            state.write(lineEnd);
            formatComments(state, node.comments, statementIndent, lineEnd);
            state.write(indent);
          }
        }
        if (writeComments && node.trailingComments != null) {
          formatComments(state, node.trailingComments, statementIndent, lineEnd);
        }
        state.write('}');
        state.indentLevel--;
      }),
      ClassBody: BlockStatement,
      StaticBlock(node, state) {
        state.write('static ');
        this.BlockStatement(node, state);
      },
      EmptyStatement(node, state) {
        state.write(';');
      },
      ExpressionStatement(node, state) {
        const precedence = state.expressionsPrecedence[node.expression.type];
        if (
          precedence === NEEDS_PARENTHESES ||
          (precedence === 3 && node.expression.left.type[0] === 'O')
        ) {
          // Should always have parentheses or is an AssignmentExpression to an ObjectPattern
          state.write('(');
          this[node.expression.type](node.expression, state);
          state.write(')');
        } else {
          this[node.expression.type](node.expression, state);
        }
        state.write(';');
      },
      IfStatement(node, state) {
        state.write('if (');
        this[node.test.type](node.test, state);
        state.write(') ');
        this[node.consequent.type](node.consequent, state);
        if (node.alternate != null) {
          state.write(' else ');
          this[node.alternate.type](node.alternate, state);
        }
      },
      LabeledStatement(node, state) {
        this[node.label.type](node.label, state);
        state.write(': ');
        this[node.body.type](node.body, state);
      },
      BreakStatement(node, state) {
        state.write('break');
        if (node.label != null) {
          state.write(' ');
          this[node.label.type](node.label, state);
        }
        state.write(';');
      },
      ContinueStatement(node, state) {
        state.write('continue');
        if (node.label != null) {
          state.write(' ');
          this[node.label.type](node.label, state);
        }
        state.write(';');
      },
      WithStatement(node, state) {
        state.write('with (');
        this[node.object.type](node.object, state);
        state.write(') ');
        this[node.body.type](node.body, state);
      },
      SwitchStatement(node, state) {
        const indent = state.indent.repeat(state.indentLevel++);
        const { lineEnd, writeComments } = state;
        state.indentLevel++;
        const caseIndent = indent + state.indent;
        const statementIndent = caseIndent + state.indent;
        state.write('switch (');
        this[node.discriminant.type](node.discriminant, state);
        state.write(') {' + lineEnd);
        const { cases: occurences } = node;
        const { length: occurencesCount } = occurences;
        for (let i = 0; i < occurencesCount; i++) {
          const occurence = occurences[i];
          if (writeComments && occurence.comments != null) {
            formatComments(state, occurence.comments, caseIndent, lineEnd);
          }
          if (occurence.test) {
            state.write(caseIndent + 'case ');
            this[occurence.test.type](occurence.test, state);
            state.write(':' + lineEnd);
          } else {
            state.write(caseIndent + 'default:' + lineEnd);
          }
          const { consequent } = occurence;
          const { length: consequentCount } = consequent;
          for (let i = 0; i < consequentCount; i++) {
            const statement = consequent[i];
            if (writeComments && statement.comments != null) {
              formatComments(state, statement.comments, statementIndent, lineEnd);
            }
            state.write(statementIndent);
            this[statement.type](statement, state);
            state.write(lineEnd);
          }
        }
        state.indentLevel -= 2;
        state.write(indent + '}');
      },
      ReturnStatement(node, state) {
        state.write('return');
        if (node.argument) {
          state.write(' ');
          this[node.argument.type](node.argument, state);
        }
        state.write(';');
      },
      ThrowStatement(node, state) {
        state.write('throw ');
        this[node.argument.type](node.argument, state);
        state.write(';');
      },
      TryStatement(node, state) {
        state.write('try ');
        this[node.block.type](node.block, state);
        if (node.handler) {
          const { handler } = node;
          if (handler.param == null) {
            state.write(' catch ');
          } else {
            state.write(' catch (');
            this[handler.param.type](handler.param, state);
            state.write(') ');
          }
          this[handler.body.type](handler.body, state);
        }
        if (node.finalizer) {
          state.write(' finally ');
          this[node.finalizer.type](node.finalizer, state);
        }
      },
      WhileStatement(node, state) {
        state.write('while (');
        this[node.test.type](node.test, state);
        state.write(') ');
        this[node.body.type](node.body, state);
      },
      DoWhileStatement(node, state) {
        state.write('do ');
        this[node.body.type](node.body, state);
        state.write(' while (');
        this[node.test.type](node.test, state);
        state.write(');');
      },
      ForStatement(node, state) {
        state.write('for (');
        if (node.init != null) {
          const { init } = node;
          if (init.type[0] === 'V') {
            formatVariableDeclaration(state, init);
          } else {
            this[init.type](init, state);
          }
        }
        state.write('; ');
        if (node.test) {
          this[node.test.type](node.test, state);
        }
        state.write('; ');
        if (node.update) {
          this[node.update.type](node.update, state);
        }
        state.write(') ');
        this[node.body.type](node.body, state);
      },
      ForInStatement: (ForInStatement = function (node, state) {
        state.write(`for ${node.await ? 'await ' : ''}(`);
        const { left } = node;
        if (left.type[0] === 'V') {
          formatVariableDeclaration(state, left);
        } else {
          this[left.type](left, state);
        }
        // Identifying whether node.type is `ForInStatement` or `ForOfStatement`
        state.write(node.type[3] === 'I' ? ' in ' : ' of ');
        this[node.right.type](node.right, state);
        state.write(') ');
        this[node.body.type](node.body, state);
      }),
      ForOfStatement: ForInStatement,
      DebuggerStatement(node, state) {
        state.write('debugger;', node);
      },
      FunctionDeclaration: (FunctionDeclaration = function (node, state) {
        state.write(
          (node.async ? 'async ' : '') +
            (node.generator ? 'function* ' : 'function ') +
            (node.id ? node.id.name : ''),
          node,
        );
        formatSequence(state, node.params);
        state.write(' ');
        this[node.body.type](node.body, state);
      }),
      FunctionExpression: FunctionDeclaration,
      VariableDeclaration(node, state) {
        formatVariableDeclaration(state, node);
        state.write(';');
      },
      VariableDeclarator(node, state) {
        this[node.id.type](node.id, state);
        if (node.init != null) {
          state.write(' = ');
          this[node.init.type](node.init, state);
        }
      },
      ClassDeclaration(node, state) {
        state.write('class ' + (node.id ? `${node.id.name} ` : ''), node);
        if (node.superClass) {
          state.write('extends ');
          const { superClass } = node;
          const { type } = superClass;
          const precedence = state.expressionsPrecedence[type];
          if (
            (type[0] !== 'C' || type[1] !== 'l' || type[5] !== 'E') &&
            (precedence === NEEDS_PARENTHESES ||
              precedence < state.expressionsPrecedence.ClassExpression)
          ) {
            // Not a ClassExpression that needs parentheses
            state.write('(');
            this[node.superClass.type](superClass, state);
            state.write(')');
          } else {
            this[superClass.type](superClass, state);
          }
          state.write(' ');
        }
        this.ClassBody(node.body, state);
      },
      ImportDeclaration(node, state) {
        state.write('import ');
        const { specifiers, attributes } = node;
        const { length } = specifiers;
        // TODO: Once babili is fixed, put this after condition
        // https://github.com/babel/babili/issues/430
        let i = 0;
        if (length > 0) {
          for (; i < length; ) {
            if (i > 0) {
              state.write(', ');
            }
            const specifier = specifiers[i];
            const type = specifier.type[6];
            if (type === 'D') {
              // ImportDefaultSpecifier
              state.write(specifier.local.name, specifier);
              i++;
            } else if (type === 'N') {
              // ImportNamespaceSpecifier
              state.write('* as ' + specifier.local.name, specifier);
              i++;
            } else {
              // ImportSpecifier
              break
            }
          }
          if (i < length) {
            state.write('{');
            for (;;) {
              const specifier = specifiers[i];
              const { name } = specifier.imported;
              state.write(name, specifier);
              if (name !== specifier.local.name) {
                state.write(' as ' + specifier.local.name);
              }
              if (++i < length) {
                state.write(', ');
              } else {
                break
              }
            }
            state.write('}');
          }
          state.write(' from ');
        }
        this.Literal(node.source, state);

        if (attributes && attributes.length > 0) {
          state.write(' with { ');
          for (let i = 0; i < attributes.length; i++) {
            this.ImportAttribute(attributes[i], state);
            if (i < attributes.length - 1) state.write(', ');
          }

          state.write(' }');
        }
        state.write(';');
      },
      ImportAttribute(node, state) {
        this.Identifier(node.key, state);
        state.write(': ');
        this.Literal(node.value, state);
      },
      ImportExpression(node, state) {
        state.write('import(');
        this[node.source.type](node.source, state);
        state.write(')');
      },
      ExportDefaultDeclaration(node, state) {
        state.write('export default ');
        this[node.declaration.type](node.declaration, state);
        if (
          state.expressionsPrecedence[node.declaration.type] != null &&
          node.declaration.type[0] !== 'F'
        ) {
          // All expression nodes except `FunctionExpression`
          state.write(';');
        }
      },
      ExportNamedDeclaration(node, state) {
        state.write('export ');
        if (node.declaration) {
          this[node.declaration.type](node.declaration, state);
        } else {
          state.write('{');
          const { specifiers } = node,
            { length } = specifiers;
          if (length > 0) {
            for (let i = 0; ; ) {
              const specifier = specifiers[i];
              const { name } = specifier.local;
              state.write(name, specifier);
              if (name !== specifier.exported.name) {
                state.write(' as ' + specifier.exported.name);
              }
              if (++i < length) {
                state.write(', ');
              } else {
                break
              }
            }
          }
          state.write('}');
          if (node.source) {
            state.write(' from ');
            this.Literal(node.source, state);
          }

          if (node.attributes && node.attributes.length > 0) {
            state.write(' with { ');
            for (let i = 0; i < node.attributes.length; i++) {
              this.ImportAttribute(node.attributes[i], state);
              if (i < node.attributes.length - 1) state.write(', ');
            }

            state.write(' }');
          }

          state.write(';');
        }
      },
      ExportAllDeclaration(node, state) {
        if (node.exported != null) {
          state.write('export * as ' + node.exported.name + ' from ');
        } else {
          state.write('export * from ');
        }
        this.Literal(node.source, state);

        if (node.attributes && node.attributes.length > 0) {
          state.write(' with { ');
          for (let i = 0; i < node.attributes.length; i++) {
            this.ImportAttribute(node.attributes[i], state);
            if (i < node.attributes.length - 1) state.write(', ');
          }

          state.write(' }');
        }

        state.write(';');
      },
      MethodDefinition(node, state) {
        if (node.static) {
          state.write('static ');
        }
        const kind = node.kind[0];
        if (kind === 'g' || kind === 's') {
          // Getter or setter
          state.write(node.kind + ' ');
        }
        if (node.value.async) {
          state.write('async ');
        }
        if (node.value.generator) {
          state.write('*');
        }
        if (node.computed) {
          state.write('[');
          this[node.key.type](node.key, state);
          state.write(']');
        } else {
          this[node.key.type](node.key, state);
        }
        formatSequence(state, node.value.params);
        state.write(' ');
        this[node.value.body.type](node.value.body, state);
      },
      ClassExpression(node, state) {
        this.ClassDeclaration(node, state);
      },
      ArrowFunctionExpression(node, state) {
        state.write(node.async ? 'async ' : '', node);
        const { params } = node;
        if (params != null) {
          // Omit parenthesis if only one named parameter
          if (params.length === 1 && params[0].type[0] === 'I') {
            // If params[0].type[0] starts with 'I', it can't be `ImportDeclaration` nor `IfStatement` and thus is `Identifier`
            state.write(params[0].name, params[0]);
          } else {
            formatSequence(state, node.params);
          }
        }
        state.write(' => ');
        if (node.body.type[0] === 'O') {
          // Body is an object expression
          state.write('(');
          this.ObjectExpression(node.body, state);
          state.write(')');
        } else {
          this[node.body.type](node.body, state);
        }
      },
      ThisExpression(node, state) {
        state.write('this', node);
      },
      Super(node, state) {
        state.write('super', node);
      },
      RestElement: (RestElement = function (node, state) {
        state.write('...');
        this[node.argument.type](node.argument, state);
      }),
      SpreadElement: RestElement,
      YieldExpression(node, state) {
        state.write(node.delegate ? 'yield*' : 'yield');
        if (node.argument) {
          state.write(' ');
          this[node.argument.type](node.argument, state);
        }
      },
      AwaitExpression(node, state) {
        state.write('await ', node);
        formatExpression(state, node.argument, node);
      },
      TemplateLiteral(node, state) {
        const { quasis, expressions } = node;
        state.write('`');
        const { length } = expressions;
        for (let i = 0; i < length; i++) {
          const expression = expressions[i];
          const quasi = quasis[i];
          state.write(quasi.value.raw, quasi);
          state.write('${');
          this[expression.type](expression, state);
          state.write('}');
        }
        const quasi = quasis[quasis.length - 1];
        state.write(quasi.value.raw, quasi);
        state.write('`');
      },
      TemplateElement(node, state) {
        state.write(node.value.raw, node);
      },
      TaggedTemplateExpression(node, state) {
        formatExpression(state, node.tag, node);
        this[node.quasi.type](node.quasi, state);
      },
      ArrayExpression: (ArrayExpression = function (node, state) {
        state.write('[');
        if (node.elements.length > 0) {
          const { elements } = node,
            { length } = elements;
          for (let i = 0; ; ) {
            const element = elements[i];
            if (element != null) {
              this[element.type](element, state);
            }
            if (++i < length) {
              state.write(', ');
            } else {
              if (element == null) {
                state.write(', ');
              }
              break
            }
          }
        }
        state.write(']');
      }),
      ArrayPattern: ArrayExpression,
      ObjectExpression(node, state) {
        const indent = state.indent.repeat(state.indentLevel++);
        const { lineEnd, writeComments } = state;
        const propertyIndent = indent + state.indent;
        state.write('{');
        if (node.properties.length > 0) {
          state.write(lineEnd);
          if (writeComments && node.comments != null) {
            formatComments(state, node.comments, propertyIndent, lineEnd);
          }
          const comma = ',' + lineEnd;
          const { properties } = node,
            { length } = properties;
          for (let i = 0; ; ) {
            const property = properties[i];
            if (writeComments && property.comments != null) {
              formatComments(state, property.comments, propertyIndent, lineEnd);
            }
            state.write(propertyIndent);
            this[property.type](property, state);
            if (++i < length) {
              state.write(comma);
            } else {
              break
            }
          }
          state.write(lineEnd);
          if (writeComments && node.trailingComments != null) {
            formatComments(state, node.trailingComments, propertyIndent, lineEnd);
          }
          state.write(indent + '}');
        } else if (writeComments) {
          if (node.comments != null) {
            state.write(lineEnd);
            formatComments(state, node.comments, propertyIndent, lineEnd);
            if (node.trailingComments != null) {
              formatComments(state, node.trailingComments, propertyIndent, lineEnd);
            }
            state.write(indent + '}');
          } else if (node.trailingComments != null) {
            state.write(lineEnd);
            formatComments(state, node.trailingComments, propertyIndent, lineEnd);
            state.write(indent + '}');
          } else {
            state.write('}');
          }
        } else {
          state.write('}');
        }
        state.indentLevel--;
      },
      Property(node, state) {
        if (node.method || node.kind[0] !== 'i') {
          // Either a method or of kind `set` or `get` (not `init`)
          this.MethodDefinition(node, state);
        } else {
          if (!node.shorthand) {
            if (node.computed) {
              state.write('[');
              this[node.key.type](node.key, state);
              state.write(']');
            } else {
              this[node.key.type](node.key, state);
            }
            state.write(': ');
          }
          this[node.value.type](node.value, state);
        }
      },
      PropertyDefinition(node, state) {
        if (node.static) {
          state.write('static ');
        }
        if (node.computed) {
          state.write('[');
        }
        this[node.key.type](node.key, state);
        if (node.computed) {
          state.write(']');
        }
        if (node.value == null) {
          if (node.key.type[0] !== 'F') {
            state.write(';');
          }
          return
        }
        state.write(' = ');
        this[node.value.type](node.value, state);
        state.write(';');
      },
      ObjectPattern(node, state) {
        state.write('{');
        if (node.properties.length > 0) {
          const { properties } = node,
            { length } = properties;
          for (let i = 0; ; ) {
            this[properties[i].type](properties[i], state);
            if (++i < length) {
              state.write(', ');
            } else {
              break
            }
          }
        }
        state.write('}');
      },
      SequenceExpression(node, state) {
        formatSequence(state, node.expressions);
      },
      UnaryExpression(node, state) {
        if (node.prefix) {
          const {
            operator,
            argument,
            argument: { type },
          } = node;
          state.write(operator);
          const needsParentheses = expressionNeedsParenthesis(state, argument, node);
          if (
            !needsParentheses &&
            (operator.length > 1 ||
              (type[0] === 'U' &&
                (type[1] === 'n' || type[1] === 'p') &&
                argument.prefix &&
                argument.operator[0] === operator &&
                (operator === '+' || operator === '-')))
          ) {
            // Large operator or argument is UnaryExpression or UpdateExpression node
            state.write(' ');
          }
          if (needsParentheses) {
            state.write(operator.length > 1 ? ' (' : '(');
            this[type](argument, state);
            state.write(')');
          } else {
            this[type](argument, state);
          }
        } else {
          // FIXME: This case never occurs
          this[node.argument.type](node.argument, state);
          state.write(node.operator);
        }
      },
      UpdateExpression(node, state) {
        // Always applied to identifiers or members, no parenthesis check needed
        if (node.prefix) {
          state.write(node.operator);
          this[node.argument.type](node.argument, state);
        } else {
          this[node.argument.type](node.argument, state);
          state.write(node.operator);
        }
      },
      AssignmentExpression(node, state) {
        this[node.left.type](node.left, state);
        state.write(' ' + node.operator + ' ');
        this[node.right.type](node.right, state);
      },
      AssignmentPattern(node, state) {
        this[node.left.type](node.left, state);
        state.write(' = ');
        this[node.right.type](node.right, state);
      },
      BinaryExpression: (BinaryExpression = function (node, state) {
        const isIn = node.operator === 'in';
        if (isIn) {
          // Avoids confusion in `for` loops initializers
          state.write('(');
        }
        formatExpression(state, node.left, node, false);
        state.write(' ' + node.operator + ' ');
        formatExpression(state, node.right, node, true);
        if (isIn) {
          state.write(')');
        }
      }),
      LogicalExpression: BinaryExpression,
      ConditionalExpression(node, state) {
        const { test } = node;
        const precedence = state.expressionsPrecedence[test.type];
        if (
          precedence === NEEDS_PARENTHESES ||
          precedence <= state.expressionsPrecedence.ConditionalExpression
        ) {
          state.write('(');
          this[test.type](test, state);
          state.write(')');
        } else {
          this[test.type](test, state);
        }
        state.write(' ? ');
        this[node.consequent.type](node.consequent, state);
        state.write(' : ');
        this[node.alternate.type](node.alternate, state);
      },
      NewExpression(node, state) {
        state.write('new ');
        const precedence = state.expressionsPrecedence[node.callee.type];
        if (
          precedence === NEEDS_PARENTHESES ||
          precedence < state.expressionsPrecedence.CallExpression ||
          hasCallExpression(node.callee)
        ) {
          state.write('(');
          this[node.callee.type](node.callee, state);
          state.write(')');
        } else {
          this[node.callee.type](node.callee, state);
        }
        formatSequence(state, node['arguments']);
      },
      CallExpression(node, state) {
        const precedence = state.expressionsPrecedence[node.callee.type];
        if (
          precedence === NEEDS_PARENTHESES ||
          precedence < state.expressionsPrecedence.CallExpression
        ) {
          state.write('(');
          this[node.callee.type](node.callee, state);
          state.write(')');
        } else {
          this[node.callee.type](node.callee, state);
        }
        if (node.optional) {
          state.write('?.');
        }
        formatSequence(state, node['arguments']);
      },
      ChainExpression(node, state) {
        this[node.expression.type](node.expression, state);
      },
      MemberExpression(node, state) {
        const precedence = state.expressionsPrecedence[node.object.type];
        if (
          precedence === NEEDS_PARENTHESES ||
          precedence < state.expressionsPrecedence.MemberExpression
        ) {
          state.write('(');
          this[node.object.type](node.object, state);
          state.write(')');
        } else {
          this[node.object.type](node.object, state);
        }
        if (node.computed) {
          if (node.optional) {
            state.write('?.');
          }
          state.write('[');
          this[node.property.type](node.property, state);
          state.write(']');
        } else {
          if (node.optional) {
            state.write('?.');
          } else {
            state.write('.');
          }
          this[node.property.type](node.property, state);
        }
      },
      MetaProperty(node, state) {
        state.write(node.meta.name + '.' + node.property.name, node);
      },
      Identifier(node, state) {
        state.write(node.name, node);
      },
      PrivateIdentifier(node, state) {
        state.write(`#${node.name}`, node);
      },
      Literal(node, state) {
        if (node.raw != null) {
          // Non-standard property
          state.write(node.raw, node);
        } else if (node.regex != null) {
          this.RegExpLiteral(node, state);
        } else if (node.bigint != null) {
          state.write(node.bigint + 'n', node);
        } else {
          state.write(stringify(node.value), node);
        }
      },
      RegExpLiteral(node, state) {
        const { regex } = node;
        state.write(`/${regex.pattern}/${regex.flags}`, node);
      },
    };

    const EMPTY_OBJECT = {};

    class State {
      constructor(options) {
        const setup = options == null ? EMPTY_OBJECT : options;
        this.output = '';
        // Functional options
        if (setup.output != null) {
          this.output = setup.output;
          this.write = this.writeToStream;
        } else {
          this.output = '';
        }
        this.generator = setup.generator != null ? setup.generator : GENERATOR;
        this.expressionsPrecedence =
          setup.expressionsPrecedence != null
            ? setup.expressionsPrecedence
            : EXPRESSIONS_PRECEDENCE;
        // Formating setup
        this.indent = setup.indent != null ? setup.indent : '  ';
        this.lineEnd = setup.lineEnd != null ? setup.lineEnd : '\n';
        this.indentLevel =
          setup.startingIndentLevel != null ? setup.startingIndentLevel : 0;
        this.writeComments = setup.comments ? setup.comments : false;
        // Source map
        if (setup.sourceMap != null) {
          this.write =
            setup.output == null ? this.writeAndMap : this.writeToStreamAndMap;
          this.sourceMap = setup.sourceMap;
          this.line = 1;
          this.column = 0;
          this.lineEndSize = this.lineEnd.split('\n').length - 1;
          this.mapping = {
            original: null,
            // Uses the entire state to avoid generating ephemeral objects
            generated: this,
            name: undefined,
            source: setup.sourceMap.file || setup.sourceMap._file,
          };
        }
      }

      write(code) {
        this.output += code;
      }

      writeToStream(code) {
        this.output.write(code);
      }

      writeAndMap(code, node) {
        this.output += code;
        this.map(code, node);
      }

      writeToStreamAndMap(code, node) {
        this.output.write(code);
        this.map(code, node);
      }

      map(code, node) {
        if (node != null) {
          const { type } = node;
          if (type[0] === 'L' && type[2] === 'n') {
            // LineComment
            this.column = 0;
            this.line++;
            return
          }
          if (node.loc != null) {
            const { mapping } = this;
            mapping.original = node.loc.start;
            mapping.name = node.name;
            this.sourceMap.addMapping(mapping);
          }
          if (
            (type[0] === 'T' && type[8] === 'E') ||
            (type[0] === 'L' && type[1] === 'i' && typeof node.value === 'string')
          ) {
            // TemplateElement or Literal string node
            const { length } = code;
            let { column, line } = this;
            for (let i = 0; i < length; i++) {
              if (code[i] === '\n') {
                column = 0;
                line++;
              } else {
                column++;
              }
            }
            this.column = column;
            this.line = line;
            return
          }
        }
        const { length } = code;
        const { lineEnd } = this;
        if (length > 0) {
          if (
            this.lineEndSize > 0 &&
            (lineEnd.length === 1
              ? code[length - 1] === lineEnd
              : code.endsWith(lineEnd))
          ) {
            this.line += this.lineEndSize;
            this.column = 0;
          } else {
            this.column += length;
          }
        }
      }

      toString() {
        return this.output
      }
    }

    function generate(node, options) {
      /*
      Returns a string representing the rendered code of the provided AST `node`.
      The `options` are:

      - `indent`: string to use for indentation (defaults to `␣␣`)
      - `lineEnd`: string to use for line endings (defaults to `\n`)
      - `startingIndentLevel`: indent level to start from (defaults to `0`)
      - `comments`: generate comments if `true` (defaults to `false`)
      - `output`: output stream to write the rendered code to (defaults to `null`)
      - `generator`: custom code generator (defaults to `GENERATOR`)
      - `expressionsPrecedence`: custom map of node types and their precedence level (defaults to `EXPRESSIONS_PRECEDENCE`)
      */
      const state = new State(options);
      // Travel through the AST node and generate the code
      state.generator[node.type](node, state);
      return state.output
    }

    /** Returns true if this value is an async iterator */
    function IsAsyncIterator$3(value) {
        return IsObject$3(value) && !IsArray$3(value) && !IsUint8Array$3(value) && Symbol.asyncIterator in value;
    }
    /** Returns true if this value is an array */
    function IsArray$3(value) {
        return Array.isArray(value);
    }
    /** Returns true if this value is bigint */
    function IsBigInt$3(value) {
        return typeof value === 'bigint';
    }
    /** Returns true if this value is a boolean */
    function IsBoolean$3(value) {
        return typeof value === 'boolean';
    }
    /** Returns true if this value is a Date object */
    function IsDate$3(value) {
        return value instanceof globalThis.Date;
    }
    /** Returns true if this value is a function */
    function IsFunction$3(value) {
        return typeof value === 'function';
    }
    /** Returns true if this value is an iterator */
    function IsIterator$3(value) {
        return IsObject$3(value) && !IsArray$3(value) && !IsUint8Array$3(value) && Symbol.iterator in value;
    }
    /** Returns true if this value is null */
    function IsNull$3(value) {
        return value === null;
    }
    /** Returns true if this value is number */
    function IsNumber$3(value) {
        return typeof value === 'number';
    }
    /** Returns true if this value is an object */
    function IsObject$3(value) {
        return typeof value === 'object' && value !== null;
    }
    /** Returns true if this value is RegExp */
    function IsRegExp$2(value) {
        return value instanceof globalThis.RegExp;
    }
    /** Returns true if this value is string */
    function IsString$3(value) {
        return typeof value === 'string';
    }
    /** Returns true if this value is symbol */
    function IsSymbol$3(value) {
        return typeof value === 'symbol';
    }
    /** Returns true if this value is a Uint8Array */
    function IsUint8Array$3(value) {
        return value instanceof globalThis.Uint8Array;
    }
    /** Returns true if this value is undefined */
    function IsUndefined$3(value) {
        return value === undefined;
    }

    function ArrayType$1(value) {
        return value.map((value) => Visit$8(value));
    }
    function DateType$1(value) {
        return new Date(value.getTime());
    }
    function Uint8ArrayType$1(value) {
        return new Uint8Array(value);
    }
    function RegExpType(value) {
        return new RegExp(value.source, value.flags);
    }
    function ObjectType$1(value) {
        const result = {};
        for (const key of Object.getOwnPropertyNames(value)) {
            result[key] = Visit$8(value[key]);
        }
        for (const key of Object.getOwnPropertySymbols(value)) {
            result[key] = Visit$8(value[key]);
        }
        return result;
    }
    // prettier-ignore
    function Visit$8(value) {
        return (IsArray$3(value) ? ArrayType$1(value) :
            IsDate$3(value) ? DateType$1(value) :
                IsUint8Array$3(value) ? Uint8ArrayType$1(value) :
                    IsRegExp$2(value) ? RegExpType(value) :
                        IsObject$3(value) ? ObjectType$1(value) :
                            value);
    }
    /** Clones a value */
    function Clone(value) {
        return Visit$8(value);
    }

    /** Clones a Rest */
    function CloneRest(schemas) {
        return schemas.map((schema) => CloneType(schema));
    }
    /** Clones a Type */
    function CloneType(schema, options = {}) {
        return { ...Clone(schema), ...options };
    }

    /** The base Error type thrown for all TypeBox exceptions  */
    class TypeBoxError extends Error {
        constructor(message) {
            super(message);
        }
    }

    /** Symbol key applied to transform types */
    const TransformKind = Symbol.for('TypeBox.Transform');
    /** Symbol key applied to readonly types */
    const ReadonlyKind = Symbol.for('TypeBox.Readonly');
    /** Symbol key applied to optional types */
    const OptionalKind = Symbol.for('TypeBox.Optional');
    /** Symbol key applied to types */
    const Hint = Symbol.for('TypeBox.Hint');
    /** Symbol key applied to types */
    const Kind = Symbol.for('TypeBox.Kind');

    /** `[Kind-Only]` Returns true if this value has a Readonly symbol */
    function IsReadonly(value) {
        return IsObject$3(value) && value[ReadonlyKind] === 'Readonly';
    }
    /** `[Kind-Only]` Returns true if this value has a Optional symbol */
    function IsOptional$1(value) {
        return IsObject$3(value) && value[OptionalKind] === 'Optional';
    }
    /** `[Kind-Only]` Returns true if the given value is TAny */
    function IsAny$1(value) {
        return IsKindOf$1(value, 'Any');
    }
    /** `[Kind-Only]` Returns true if the given value is TArray */
    function IsArray$2(value) {
        return IsKindOf$1(value, 'Array');
    }
    /** `[Kind-Only]` Returns true if the given value is TAsyncIterator */
    function IsAsyncIterator$2(value) {
        return IsKindOf$1(value, 'AsyncIterator');
    }
    /** `[Kind-Only]` Returns true if the given value is TBigInt */
    function IsBigInt$2(value) {
        return IsKindOf$1(value, 'BigInt');
    }
    /** `[Kind-Only]` Returns true if the given value is TBoolean */
    function IsBoolean$2(value) {
        return IsKindOf$1(value, 'Boolean');
    }
    /** `[Kind-Only]` Returns true if the given value is TConstructor */
    function IsConstructor$1(value) {
        return IsKindOf$1(value, 'Constructor');
    }
    /** `[Kind-Only]` Returns true if the given value is TDate */
    function IsDate$2(value) {
        return IsKindOf$1(value, 'Date');
    }
    /** `[Kind-Only]` Returns true if the given value is TFunction */
    function IsFunction$2(value) {
        return IsKindOf$1(value, 'Function');
    }
    /** `[Kind-Only]` Returns true if the given value is TInteger */
    function IsInteger$2(value) {
        return IsKindOf$1(value, 'Integer');
    }
    /** `[Kind-Only]` Returns true if the given value is TIntersect */
    function IsIntersect$1(value) {
        return IsKindOf$1(value, 'Intersect');
    }
    /** `[Kind-Only]` Returns true if the given value is TIterator */
    function IsIterator$2(value) {
        return IsKindOf$1(value, 'Iterator');
    }
    /** `[Kind-Only]` Returns true if the given value is a TKind with the given name. */
    function IsKindOf$1(value, kind) {
        return IsObject$3(value) && Kind in value && value[Kind] === kind;
    }
    /** `[Kind-Only]` Returns true if the given value is TLiteral */
    function IsLiteral$1(value) {
        return IsKindOf$1(value, 'Literal');
    }
    /** `[Kind-Only]` Returns true if the given value is a TMappedKey */
    function IsMappedKey$1(value) {
        return IsKindOf$1(value, 'MappedKey');
    }
    /** `[Kind-Only]` Returns true if the given value is TMappedResult */
    function IsMappedResult$1(value) {
        return IsKindOf$1(value, 'MappedResult');
    }
    /** `[Kind-Only]` Returns true if the given value is TNever */
    function IsNever$1(value) {
        return IsKindOf$1(value, 'Never');
    }
    /** `[Kind-Only]` Returns true if the given value is TNot */
    function IsNot$1(value) {
        return IsKindOf$1(value, 'Not');
    }
    /** `[Kind-Only]` Returns true if the given value is TNull */
    function IsNull$2(value) {
        return IsKindOf$1(value, 'Null');
    }
    /** `[Kind-Only]` Returns true if the given value is TNumber */
    function IsNumber$2(value) {
        return IsKindOf$1(value, 'Number');
    }
    /** `[Kind-Only]` Returns true if the given value is TObject */
    function IsObject$2(value) {
        return IsKindOf$1(value, 'Object');
    }
    /** `[Kind-Only]` Returns true if the given value is TPromise */
    function IsPromise$2(value) {
        return IsKindOf$1(value, 'Promise');
    }
    /** `[Kind-Only]` Returns true if the given value is TRecord */
    function IsRecord$1(value) {
        return IsKindOf$1(value, 'Record');
    }
    /** `[Kind-Only]` Returns true if the given value is TRef */
    function IsRef$1(value) {
        return IsKindOf$1(value, 'Ref');
    }
    /** `[Kind-Only]` Returns true if the given value is TRegExp */
    function IsRegExp$1(value) {
        return IsKindOf$1(value, 'RegExp');
    }
    /** `[Kind-Only]` Returns true if the given value is TString */
    function IsString$2(value) {
        return IsKindOf$1(value, 'String');
    }
    /** `[Kind-Only]` Returns true if the given value is TSymbol */
    function IsSymbol$2(value) {
        return IsKindOf$1(value, 'Symbol');
    }
    /** `[Kind-Only]` Returns true if the given value is TTemplateLiteral */
    function IsTemplateLiteral$1(value) {
        return IsKindOf$1(value, 'TemplateLiteral');
    }
    /** `[Kind-Only]` Returns true if the given value is TThis */
    function IsThis$1(value) {
        return IsKindOf$1(value, 'This');
    }
    /** `[Kind-Only]` Returns true of this value is TTransform */
    function IsTransform$1(value) {
        return IsObject$3(value) && TransformKind in value;
    }
    /** `[Kind-Only]` Returns true if the given value is TTuple */
    function IsTuple$1(value) {
        return IsKindOf$1(value, 'Tuple');
    }
    /** `[Kind-Only]` Returns true if the given value is TUndefined */
    function IsUndefined$2(value) {
        return IsKindOf$1(value, 'Undefined');
    }
    /** `[Kind-Only]` Returns true if the given value is TUnion */
    function IsUnion$1(value) {
        return IsKindOf$1(value, 'Union');
    }
    /** `[Kind-Only]` Returns true if the given value is TUint8Array */
    function IsUint8Array$2(value) {
        return IsKindOf$1(value, 'Uint8Array');
    }
    /** `[Kind-Only]` Returns true if the given value is TUnknown */
    function IsUnknown$1(value) {
        return IsKindOf$1(value, 'Unknown');
    }
    /** `[Kind-Only]` Returns true if the given value is a raw TUnsafe */
    function IsUnsafe$1(value) {
        return IsKindOf$1(value, 'Unsafe');
    }
    /** `[Kind-Only]` Returns true if the given value is TVoid */
    function IsVoid$1(value) {
        return IsKindOf$1(value, 'Void');
    }
    /** `[Kind-Only]` Returns true if the given value is TKind */
    function IsKind$1(value) {
        return IsObject$3(value) && Kind in value && IsString$3(value[Kind]);
    }
    /** `[Kind-Only]` Returns true if the given value is TSchema */
    function IsSchema$1(value) {
        // prettier-ignore
        return (IsAny$1(value) ||
            IsArray$2(value) ||
            IsBoolean$2(value) ||
            IsBigInt$2(value) ||
            IsAsyncIterator$2(value) ||
            IsConstructor$1(value) ||
            IsDate$2(value) ||
            IsFunction$2(value) ||
            IsInteger$2(value) ||
            IsIntersect$1(value) ||
            IsIterator$2(value) ||
            IsLiteral$1(value) ||
            IsMappedKey$1(value) ||
            IsMappedResult$1(value) ||
            IsNever$1(value) ||
            IsNot$1(value) ||
            IsNull$2(value) ||
            IsNumber$2(value) ||
            IsObject$2(value) ||
            IsPromise$2(value) ||
            IsRecord$1(value) ||
            IsRef$1(value) ||
            IsRegExp$1(value) ||
            IsString$2(value) ||
            IsSymbol$2(value) ||
            IsTemplateLiteral$1(value) ||
            IsThis$1(value) ||
            IsTuple$1(value) ||
            IsUndefined$2(value) ||
            IsUnion$1(value) ||
            IsUint8Array$2(value) ||
            IsUnknown$1(value) ||
            IsUnsafe$1(value) ||
            IsVoid$1(value) ||
            IsKind$1(value));
    }

    const KnownTypes = [
        'Any',
        'Array',
        'AsyncIterator',
        'BigInt',
        'Boolean',
        'Constructor',
        'Date',
        'Enum',
        'Function',
        'Integer',
        'Intersect',
        'Iterator',
        'Literal',
        'MappedKey',
        'MappedResult',
        'Not',
        'Null',
        'Number',
        'Object',
        'Promise',
        'Record',
        'Ref',
        'RegExp',
        'String',
        'Symbol',
        'TemplateLiteral',
        'This',
        'Tuple',
        'Undefined',
        'Union',
        'Uint8Array',
        'Unknown',
        'Void',
    ];
    function IsPattern(value) {
        try {
            new RegExp(value);
            return true;
        }
        catch {
            return false;
        }
    }
    function IsControlCharacterFree(value) {
        if (!IsString$3(value))
            return false;
        for (let i = 0; i < value.length; i++) {
            const code = value.charCodeAt(i);
            if ((code >= 7 && code <= 13) || code === 27 || code === 127) {
                return false;
            }
        }
        return true;
    }
    function IsAdditionalProperties(value) {
        return IsOptionalBoolean(value) || IsSchema(value);
    }
    function IsOptionalBigInt(value) {
        return IsUndefined$3(value) || IsBigInt$3(value);
    }
    function IsOptionalNumber(value) {
        return IsUndefined$3(value) || IsNumber$3(value);
    }
    function IsOptionalBoolean(value) {
        return IsUndefined$3(value) || IsBoolean$3(value);
    }
    function IsOptionalString(value) {
        return IsUndefined$3(value) || IsString$3(value);
    }
    function IsOptionalPattern(value) {
        return IsUndefined$3(value) || (IsString$3(value) && IsControlCharacterFree(value) && IsPattern(value));
    }
    function IsOptionalFormat(value) {
        return IsUndefined$3(value) || (IsString$3(value) && IsControlCharacterFree(value));
    }
    function IsOptionalSchema(value) {
        return IsUndefined$3(value) || IsSchema(value);
    }
    /** Returns true if this value has a Optional symbol */
    function IsOptional(value) {
        return IsObject$3(value) && value[OptionalKind] === 'Optional';
    }
    // ------------------------------------------------------------------
    // Types
    // ------------------------------------------------------------------
    /** Returns true if the given value is TAny */
    function IsAny(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Any') &&
            IsOptionalString(value.$id));
    }
    /** Returns true if the given value is TArray */
    function IsArray$1(value) {
        return (IsKindOf(value, 'Array') &&
            value.type === 'array' &&
            IsOptionalString(value.$id) &&
            IsSchema(value.items) &&
            IsOptionalNumber(value.minItems) &&
            IsOptionalNumber(value.maxItems) &&
            IsOptionalBoolean(value.uniqueItems) &&
            IsOptionalSchema(value.contains) &&
            IsOptionalNumber(value.minContains) &&
            IsOptionalNumber(value.maxContains));
    }
    /** Returns true if the given value is TAsyncIterator */
    function IsAsyncIterator$1(value) {
        // prettier-ignore
        return (IsKindOf(value, 'AsyncIterator') &&
            value.type === 'AsyncIterator' &&
            IsOptionalString(value.$id) &&
            IsSchema(value.items));
    }
    /** Returns true if the given value is TBigInt */
    function IsBigInt$1(value) {
        // prettier-ignore
        return (IsKindOf(value, 'BigInt') &&
            value.type === 'bigint' &&
            IsOptionalString(value.$id) &&
            IsOptionalBigInt(value.exclusiveMaximum) &&
            IsOptionalBigInt(value.exclusiveMinimum) &&
            IsOptionalBigInt(value.maximum) &&
            IsOptionalBigInt(value.minimum) &&
            IsOptionalBigInt(value.multipleOf));
    }
    /** Returns true if the given value is TBoolean */
    function IsBoolean$1(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Boolean') &&
            value.type === 'boolean' &&
            IsOptionalString(value.$id));
    }
    /** Returns true if the given value is TConstructor */
    function IsConstructor(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Constructor') &&
            value.type === 'Constructor' &&
            IsOptionalString(value.$id) &&
            IsArray$3(value.parameters) &&
            value.parameters.every(schema => IsSchema(schema)) &&
            IsSchema(value.returns));
    }
    /** Returns true if the given value is TDate */
    function IsDate$1(value) {
        return (IsKindOf(value, 'Date') &&
            value.type === 'Date' &&
            IsOptionalString(value.$id) &&
            IsOptionalNumber(value.exclusiveMaximumTimestamp) &&
            IsOptionalNumber(value.exclusiveMinimumTimestamp) &&
            IsOptionalNumber(value.maximumTimestamp) &&
            IsOptionalNumber(value.minimumTimestamp) &&
            IsOptionalNumber(value.multipleOfTimestamp));
    }
    /** Returns true if the given value is TFunction */
    function IsFunction$1(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Function') &&
            value.type === 'Function' &&
            IsOptionalString(value.$id) &&
            IsArray$3(value.parameters) &&
            value.parameters.every(schema => IsSchema(schema)) &&
            IsSchema(value.returns));
    }
    /** Returns true if the given value is TInteger */
    function IsInteger$1(value) {
        return (IsKindOf(value, 'Integer') &&
            value.type === 'integer' &&
            IsOptionalString(value.$id) &&
            IsOptionalNumber(value.exclusiveMaximum) &&
            IsOptionalNumber(value.exclusiveMinimum) &&
            IsOptionalNumber(value.maximum) &&
            IsOptionalNumber(value.minimum) &&
            IsOptionalNumber(value.multipleOf));
    }
    /** Returns true if the given schema is TProperties */
    function IsProperties(value) {
        // prettier-ignore
        return (IsObject$3(value) &&
            Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema)));
    }
    /** Returns true if the given value is TIntersect */
    function IsIntersect(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Intersect') &&
            (IsString$3(value.type) && value.type !== 'object' ? false : true) &&
            IsArray$3(value.allOf) &&
            value.allOf.every(schema => IsSchema(schema) && !IsTransform(schema)) &&
            IsOptionalString(value.type) &&
            (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) &&
            IsOptionalString(value.$id));
    }
    /** Returns true if the given value is TIterator */
    function IsIterator$1(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Iterator') &&
            value.type === 'Iterator' &&
            IsOptionalString(value.$id) &&
            IsSchema(value.items));
    }
    /** Returns true if the given value is a TKind with the given name. */
    function IsKindOf(value, kind) {
        return IsObject$3(value) && Kind in value && value[Kind] === kind;
    }
    /** Returns true if the given value is TLiteral<string> */
    function IsLiteralString(value) {
        return IsLiteral(value) && IsString$3(value.const);
    }
    /** Returns true if the given value is TLiteral<number> */
    function IsLiteralNumber(value) {
        return IsLiteral(value) && IsNumber$3(value.const);
    }
    /** Returns true if the given value is TLiteral<boolean> */
    function IsLiteralBoolean(value) {
        return IsLiteral(value) && IsBoolean$3(value.const);
    }
    /** Returns true if the given value is TLiteral */
    function IsLiteral(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Literal') &&
            IsOptionalString(value.$id) && IsLiteralValue(value.const));
    }
    /** Returns true if the given value is a TLiteralValue */
    function IsLiteralValue(value) {
        return IsBoolean$3(value) || IsNumber$3(value) || IsString$3(value);
    }
    /** Returns true if the given value is a TMappedKey */
    function IsMappedKey(value) {
        // prettier-ignore
        return (IsKindOf(value, 'MappedKey') &&
            IsArray$3(value.keys) &&
            value.keys.every(key => IsNumber$3(key) || IsString$3(key)));
    }
    /** Returns true if the given value is TMappedResult */
    function IsMappedResult(value) {
        // prettier-ignore
        return (IsKindOf(value, 'MappedResult') &&
            IsProperties(value.properties));
    }
    /** Returns true if the given value is TNever */
    function IsNever(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Never') &&
            IsObject$3(value.not) &&
            Object.getOwnPropertyNames(value.not).length === 0);
    }
    /** Returns true if the given value is TNot */
    function IsNot(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Not') &&
            IsSchema(value.not));
    }
    /** Returns true if the given value is TNull */
    function IsNull$1(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Null') &&
            value.type === 'null' &&
            IsOptionalString(value.$id));
    }
    /** Returns true if the given value is TNumber */
    function IsNumber$1(value) {
        return (IsKindOf(value, 'Number') &&
            value.type === 'number' &&
            IsOptionalString(value.$id) &&
            IsOptionalNumber(value.exclusiveMaximum) &&
            IsOptionalNumber(value.exclusiveMinimum) &&
            IsOptionalNumber(value.maximum) &&
            IsOptionalNumber(value.minimum) &&
            IsOptionalNumber(value.multipleOf));
    }
    /** Returns true if the given value is TObject */
    function IsObject$1(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Object') &&
            value.type === 'object' &&
            IsOptionalString(value.$id) &&
            IsProperties(value.properties) &&
            IsAdditionalProperties(value.additionalProperties) &&
            IsOptionalNumber(value.minProperties) &&
            IsOptionalNumber(value.maxProperties));
    }
    /** Returns true if the given value is TPromise */
    function IsPromise$1(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Promise') &&
            value.type === 'Promise' &&
            IsOptionalString(value.$id) &&
            IsSchema(value.item));
    }
    /** Returns true if the given value is TRecord */
    function IsRecord(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Record') &&
            value.type === 'object' &&
            IsOptionalString(value.$id) &&
            IsAdditionalProperties(value.additionalProperties) &&
            IsObject$3(value.patternProperties) &&
            ((schema) => {
                const keys = Object.getOwnPropertyNames(schema.patternProperties);
                return (keys.length === 1 &&
                    IsPattern(keys[0]) &&
                    IsObject$3(schema.patternProperties) &&
                    IsSchema(schema.patternProperties[keys[0]]));
            })(value));
    }
    /** Returns true if the given value is TRef */
    function IsRef(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Ref') &&
            IsOptionalString(value.$id) &&
            IsString$3(value.$ref));
    }
    /** Returns true if the given value is TRegExp */
    function IsRegExp(value) {
        // prettier-ignore
        return (IsKindOf(value, 'RegExp') &&
            IsOptionalString(value.$id) &&
            IsString$3(value.source) &&
            IsString$3(value.flags) &&
            IsOptionalNumber(value.maxLength) &&
            IsOptionalNumber(value.minLength));
    }
    /** Returns true if the given value is TString */
    function IsString$1(value) {
        // prettier-ignore
        return (IsKindOf(value, 'String') &&
            value.type === 'string' &&
            IsOptionalString(value.$id) &&
            IsOptionalNumber(value.minLength) &&
            IsOptionalNumber(value.maxLength) &&
            IsOptionalPattern(value.pattern) &&
            IsOptionalFormat(value.format));
    }
    /** Returns true if the given value is TSymbol */
    function IsSymbol$1(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Symbol') &&
            value.type === 'symbol' &&
            IsOptionalString(value.$id));
    }
    /** Returns true if the given value is TTemplateLiteral */
    function IsTemplateLiteral(value) {
        // prettier-ignore
        return (IsKindOf(value, 'TemplateLiteral') &&
            value.type === 'string' &&
            IsString$3(value.pattern) &&
            value.pattern[0] === '^' &&
            value.pattern[value.pattern.length - 1] === '$');
    }
    /** Returns true if the given value is TThis */
    function IsThis(value) {
        // prettier-ignore
        return (IsKindOf(value, 'This') &&
            IsOptionalString(value.$id) &&
            IsString$3(value.$ref));
    }
    /** Returns true of this value is TTransform */
    function IsTransform(value) {
        return IsObject$3(value) && TransformKind in value;
    }
    /** Returns true if the given value is TTuple */
    function IsTuple(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Tuple') &&
            value.type === 'array' &&
            IsOptionalString(value.$id) &&
            IsNumber$3(value.minItems) &&
            IsNumber$3(value.maxItems) &&
            value.minItems === value.maxItems &&
            (( // empty
            IsUndefined$3(value.items) &&
                IsUndefined$3(value.additionalItems) &&
                value.minItems === 0) || (IsArray$3(value.items) &&
                value.items.every(schema => IsSchema(schema)))));
    }
    /** Returns true if the given value is TUndefined */
    function IsUndefined$1(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Undefined') &&
            value.type === 'undefined' &&
            IsOptionalString(value.$id));
    }
    /** Returns true if the given value is TUnion */
    function IsUnion(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Union') &&
            IsOptionalString(value.$id) &&
            IsObject$3(value) &&
            IsArray$3(value.anyOf) &&
            value.anyOf.every(schema => IsSchema(schema)));
    }
    /** Returns true if the given value is TUint8Array */
    function IsUint8Array$1(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Uint8Array') &&
            value.type === 'Uint8Array' &&
            IsOptionalString(value.$id) &&
            IsOptionalNumber(value.minByteLength) &&
            IsOptionalNumber(value.maxByteLength));
    }
    /** Returns true if the given value is TUnknown */
    function IsUnknown(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Unknown') &&
            IsOptionalString(value.$id));
    }
    /** Returns true if the given value is a raw TUnsafe */
    function IsUnsafe(value) {
        return IsKindOf(value, 'Unsafe');
    }
    /** Returns true if the given value is TVoid */
    function IsVoid(value) {
        // prettier-ignore
        return (IsKindOf(value, 'Void') &&
            value.type === 'void' &&
            IsOptionalString(value.$id));
    }
    /** Returns true if the given value is TKind */
    function IsKind(value) {
        return IsObject$3(value) && Kind in value && IsString$3(value[Kind]) && !KnownTypes.includes(value[Kind]);
    }
    /** Returns true if the given value is TSchema */
    function IsSchema(value) {
        // prettier-ignore
        return (IsObject$3(value)) && (IsAny(value) ||
            IsArray$1(value) ||
            IsBoolean$1(value) ||
            IsBigInt$1(value) ||
            IsAsyncIterator$1(value) ||
            IsConstructor(value) ||
            IsDate$1(value) ||
            IsFunction$1(value) ||
            IsInteger$1(value) ||
            IsIntersect(value) ||
            IsIterator$1(value) ||
            IsLiteral(value) ||
            IsMappedKey(value) ||
            IsMappedResult(value) ||
            IsNever(value) ||
            IsNot(value) ||
            IsNull$1(value) ||
            IsNumber$1(value) ||
            IsObject$1(value) ||
            IsPromise$1(value) ||
            IsRecord(value) ||
            IsRef(value) ||
            IsRegExp(value) ||
            IsString$1(value) ||
            IsSymbol$1(value) ||
            IsTemplateLiteral(value) ||
            IsThis(value) ||
            IsTuple(value) ||
            IsUndefined$1(value) ||
            IsUnion(value) ||
            IsUint8Array$1(value) ||
            IsUnknown(value) ||
            IsUnsafe(value) ||
            IsVoid(value) ||
            IsKind(value));
    }

    const PatternBoolean = '(true|false)';
    const PatternNumber = '(0|[1-9][0-9]*)';
    const PatternString = '(.*)';
    const PatternNever = '(?!.*)';
    const PatternNumberExact = `^${PatternNumber}$`;
    const PatternStringExact = `^${PatternString}$`;
    const PatternNeverExact = `^${PatternNever}$`;

    /** A registry for user defined string formats */
    const map$2 = new Map();
    /** Returns true if the user defined string format exists */
    function Has$1(format) {
        return map$2.has(format);
    }
    /** Sets a validation function for a user defined string format */
    function Set$2(format, func) {
        map$2.set(format, func);
    }
    /** Gets a validation function for a user defined string format */
    function Get$1(format) {
        return map$2.get(format);
    }

    /** A registry for user defined types */
    const map$1 = new Map();
    /** Returns true if this registry contains this kind */
    function Has(kind) {
        return map$1.has(kind);
    }
    /** Sets a validation function for a user defined type */
    function Set$1(kind, func) {
        map$1.set(kind, func);
    }
    /** Gets a custom validation function for a user defined type */
    function Get(kind) {
        return map$1.get(kind);
    }

    /** Returns true if element right is in the set of left */
    // prettier-ignore
    function SetIncludes(T, S) {
        return T.includes(S);
    }
    /** Returns a distinct set of elements */
    function SetDistinct(T) {
        return [...new Set(T)];
    }
    /** Returns the Intersect of the given sets */
    function SetIntersect(T, S) {
        return T.filter((L) => S.includes(L));
    }
    // prettier-ignore
    function SetIntersectManyResolve(T, Init) {
        return T.reduce((Acc, L) => {
            return SetIntersect(Acc, L);
        }, Init);
    }
    // prettier-ignore
    function SetIntersectMany(T) {
        return (T.length === 1
            ? T[0]
            // Use left to initialize the accumulator for resolve
            : T.length > 1
                ? SetIntersectManyResolve(T.slice(1), T[0])
                : []);
    }
    /** Returns the Union of multiple sets */
    function SetUnionMany(T) {
        const Acc = [];
        for (const L of T)
            Acc.push(...L);
        return Acc;
    }

    /** `[Json]` Creates an Any type */
    function Any(options = {}) {
        return { ...options, [Kind]: 'Any' };
    }

    /** `[Json]` Creates an Array type */
    function Array$1(schema, options = {}) {
        return {
            ...options,
            [Kind]: 'Array',
            type: 'array',
            items: CloneType(schema),
        };
    }

    /** `[JavaScript]` Creates a AsyncIterator type */
    function AsyncIterator(items, options = {}) {
        return {
            ...options,
            [Kind]: 'AsyncIterator',
            type: 'AsyncIterator',
            items: CloneType(items),
        };
    }

    function DiscardKey(value, key) {
        const { [key]: _, ...rest } = value;
        return rest;
    }
    function Discard(value, keys) {
        return keys.reduce((acc, key) => DiscardKey(acc, key), value);
    }

    /** `[Json]` Creates a Never type */
    function Never(options = {}) {
        return {
            ...options,
            [Kind]: 'Never',
            not: {},
        };
    }

    // prettier-ignore
    function MappedResult(properties) {
        return {
            [Kind]: 'MappedResult',
            properties
        };
    }

    /** `[JavaScript]` Creates a Constructor type */
    function Constructor(parameters, returns, options) {
        return {
            ...options,
            [Kind]: 'Constructor',
            type: 'Constructor',
            parameters: CloneRest(parameters),
            returns: CloneType(returns),
        };
    }

    /** `[JavaScript]` Creates a Function type */
    function Function$1(parameters, returns, options) {
        return {
            ...options,
            [Kind]: 'Function',
            type: 'Function',
            parameters: CloneRest(parameters),
            returns: CloneType(returns),
        };
    }

    function UnionCreate(T, options) {
        return { ...options, [Kind]: 'Union', anyOf: CloneRest(T) };
    }

    // prettier-ignore
    function IsUnionOptional(T) {
        return T.some(L => IsOptional$1(L));
    }
    // prettier-ignore
    function RemoveOptionalFromRest$1(T) {
        return T.map(L => IsOptional$1(L) ? RemoveOptionalFromType$1(L) : L);
    }
    // prettier-ignore
    function RemoveOptionalFromType$1(T) {
        return (Discard(T, [OptionalKind]));
    }
    // prettier-ignore
    function ResolveUnion(T, options) {
        return (IsUnionOptional(T)
            ? Optional(UnionCreate(RemoveOptionalFromRest$1(T), options))
            : UnionCreate(RemoveOptionalFromRest$1(T), options));
    }
    /** `[Json]` Creates an evaluated Union type */
    function UnionEvaluated(T, options = {}) {
        // prettier-ignore
        return (T.length === 0 ? Never(options) :
            T.length === 1 ? CloneType(T[0], options) :
                ResolveUnion(T, options));
    }

    /** `[Json]` Creates a Union type */
    function Union$1(T, options = {}) {
        // prettier-ignore
        return (T.length === 0 ? Never(options) :
            T.length === 1 ? CloneType(T[0], options) :
                UnionCreate(T, options));
    }

    // ------------------------------------------------------------------
    // TemplateLiteralParserError
    // ------------------------------------------------------------------
    class TemplateLiteralParserError extends TypeBoxError {
    }
    // -------------------------------------------------------------------
    // Unescape
    //
    // Unescape for these control characters specifically. Note that this
    // function is only called on non union group content, and where we
    // still want to allow the user to embed control characters in that
    // content. For review.
    // -------------------------------------------------------------------
    // prettier-ignore
    function Unescape(pattern) {
        return pattern
            .replace(/\\\$/g, '$')
            .replace(/\\\*/g, '*')
            .replace(/\\\^/g, '^')
            .replace(/\\\|/g, '|')
            .replace(/\\\(/g, '(')
            .replace(/\\\)/g, ')');
    }
    // -------------------------------------------------------------------
    // Control Characters
    // -------------------------------------------------------------------
    function IsNonEscaped(pattern, index, char) {
        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
    }
    function IsOpenParen(pattern, index) {
        return IsNonEscaped(pattern, index, '(');
    }
    function IsCloseParen(pattern, index) {
        return IsNonEscaped(pattern, index, ')');
    }
    function IsSeparator(pattern, index) {
        return IsNonEscaped(pattern, index, '|');
    }
    // -------------------------------------------------------------------
    // Control Groups
    // -------------------------------------------------------------------
    function IsGroup(pattern) {
        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
            return false;
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
                count += 1;
            if (IsCloseParen(pattern, index))
                count -= 1;
            if (count === 0 && index !== pattern.length - 1)
                return false;
        }
        return true;
    }
    // prettier-ignore
    function InGroup(pattern) {
        return pattern.slice(1, pattern.length - 1);
    }
    // prettier-ignore
    function IsPrecedenceOr(pattern) {
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
                count += 1;
            if (IsCloseParen(pattern, index))
                count -= 1;
            if (IsSeparator(pattern, index) && count === 0)
                return true;
        }
        return false;
    }
    // prettier-ignore
    function IsPrecedenceAnd(pattern) {
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
                return true;
        }
        return false;
    }
    // prettier-ignore
    function Or(pattern) {
        let [count, start] = [0, 0];
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
                count += 1;
            if (IsCloseParen(pattern, index))
                count -= 1;
            if (IsSeparator(pattern, index) && count === 0) {
                const range = pattern.slice(start, index);
                if (range.length > 0)
                    expressions.push(TemplateLiteralParse(range));
                start = index + 1;
            }
        }
        const range = pattern.slice(start);
        if (range.length > 0)
            expressions.push(TemplateLiteralParse(range));
        if (expressions.length === 0)
            return { type: 'const', const: '' };
        if (expressions.length === 1)
            return expressions[0];
        return { type: 'or', expr: expressions };
    }
    // prettier-ignore
    function And(pattern) {
        function Group(value, index) {
            if (!IsOpenParen(value, index))
                throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
            let count = 0;
            for (let scan = index; scan < value.length; scan++) {
                if (IsOpenParen(value, scan))
                    count += 1;
                if (IsCloseParen(value, scan))
                    count -= 1;
                if (count === 0)
                    return [index, scan];
            }
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
        }
        function Range(pattern, index) {
            for (let scan = index; scan < pattern.length; scan++) {
                if (IsOpenParen(pattern, scan))
                    return [index, scan];
            }
            return [index, pattern.length];
        }
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index)) {
                const [start, end] = Group(pattern, index);
                const range = pattern.slice(start, end + 1);
                expressions.push(TemplateLiteralParse(range));
                index = end;
            }
            else {
                const [start, end] = Range(pattern, index);
                const range = pattern.slice(start, end);
                if (range.length > 0)
                    expressions.push(TemplateLiteralParse(range));
                index = end - 1;
            }
        }
        return ((expressions.length === 0) ? { type: 'const', const: '' } :
            (expressions.length === 1) ? expressions[0] :
                { type: 'and', expr: expressions });
    }
    // ------------------------------------------------------------------
    // TemplateLiteralParse
    // ------------------------------------------------------------------
    /** Parses a pattern and returns an expression tree */
    function TemplateLiteralParse(pattern) {
        // prettier-ignore
        return (IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) :
            IsPrecedenceOr(pattern) ? Or(pattern) :
                IsPrecedenceAnd(pattern) ? And(pattern) :
                    { type: 'const', const: Unescape(pattern) });
    }
    // ------------------------------------------------------------------
    // TemplateLiteralParseExact
    // ------------------------------------------------------------------
    /** Parses a pattern and strips forward and trailing ^ and $ */
    function TemplateLiteralParseExact(pattern) {
        return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
    }

    // ------------------------------------------------------------------
    // TemplateLiteralFiniteError
    // ------------------------------------------------------------------
    class TemplateLiteralFiniteError extends TypeBoxError {
    }
    // ------------------------------------------------------------------
    // IsTemplateLiteralFiniteCheck
    // ------------------------------------------------------------------
    // prettier-ignore
    function IsNumberExpression(expression) {
        return (expression.type === 'or' &&
            expression.expr.length === 2 &&
            expression.expr[0].type === 'const' &&
            expression.expr[0].const === '0' &&
            expression.expr[1].type === 'const' &&
            expression.expr[1].const === '[1-9][0-9]*');
    }
    // prettier-ignore
    function IsBooleanExpression(expression) {
        return (expression.type === 'or' &&
            expression.expr.length === 2 &&
            expression.expr[0].type === 'const' &&
            expression.expr[0].const === 'true' &&
            expression.expr[1].type === 'const' &&
            expression.expr[1].const === 'false');
    }
    // prettier-ignore
    function IsStringExpression(expression) {
        return expression.type === 'const' && expression.const === '.*';
    }
    // ------------------------------------------------------------------
    // IsTemplateLiteralExpressionFinite
    // ------------------------------------------------------------------
    // prettier-ignore
    function IsTemplateLiteralExpressionFinite(expression) {
        return (IsNumberExpression(expression) || IsStringExpression(expression) ? false :
            IsBooleanExpression(expression) ? true :
                (expression.type === 'and') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :
                    (expression.type === 'or') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :
                        (expression.type === 'const') ? true :
                            (() => { throw new TemplateLiteralFiniteError(`Unknown expression type`); })());
    }
    /** Returns true if this TemplateLiteral resolves to a finite set of values */
    function IsTemplateLiteralFinite(schema) {
        const expression = TemplateLiteralParseExact(schema.pattern);
        return IsTemplateLiteralExpressionFinite(expression);
    }

    // ------------------------------------------------------------------
    // TemplateLiteralGenerateError
    // ------------------------------------------------------------------
    class TemplateLiteralGenerateError extends TypeBoxError {
    }
    // ------------------------------------------------------------------
    // TemplateLiteralExpressionGenerate
    // ------------------------------------------------------------------
    // prettier-ignore
    function* GenerateReduce(buffer) {
        if (buffer.length === 1)
            return yield* buffer[0];
        for (const left of buffer[0]) {
            for (const right of GenerateReduce(buffer.slice(1))) {
                yield `${left}${right}`;
            }
        }
    }
    // prettier-ignore
    function* GenerateAnd(expression) {
        return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
    }
    // prettier-ignore
    function* GenerateOr(expression) {
        for (const expr of expression.expr)
            yield* TemplateLiteralExpressionGenerate(expr);
    }
    // prettier-ignore
    function* GenerateConst(expression) {
        return yield expression.const;
    }
    function* TemplateLiteralExpressionGenerate(expression) {
        return expression.type === 'and'
            ? yield* GenerateAnd(expression)
            : expression.type === 'or'
                ? yield* GenerateOr(expression)
                : expression.type === 'const'
                    ? yield* GenerateConst(expression)
                    : (() => {
                        throw new TemplateLiteralGenerateError('Unknown expression');
                    })();
    }
    /** Generates a tuple of strings from the given TemplateLiteral. Returns an empty tuple if infinite. */
    function TemplateLiteralGenerate(schema) {
        const expression = TemplateLiteralParseExact(schema.pattern);
        // prettier-ignore
        return (IsTemplateLiteralExpressionFinite(expression)
            ? [...TemplateLiteralExpressionGenerate(expression)]
            : []);
    }

    /** `[Json]` Creates a Literal type */
    function Literal(value, options = {}) {
        return {
            ...options,
            [Kind]: 'Literal',
            const: value,
            type: typeof value,
        };
    }

    /** `[Json]` Creates a Boolean type */
    function Boolean$1(options = {}) {
        return {
            ...options,
            [Kind]: 'Boolean',
            type: 'boolean',
        };
    }

    /** `[JavaScript]` Creates a BigInt type */
    function BigInt$1(options = {}) {
        return {
            ...options,
            [Kind]: 'BigInt',
            type: 'bigint',
        };
    }

    /** `[Json]` Creates a Number type */
    function Number$1(options = {}) {
        return {
            ...options,
            [Kind]: 'Number',
            type: 'number',
        };
    }

    /** `[Json]` Creates a String type */
    function String$1(options = {}) {
        return { ...options, [Kind]: 'String', type: 'string' };
    }

    // ------------------------------------------------------------------
    // SyntaxParsers
    // ------------------------------------------------------------------
    // prettier-ignore
    function* FromUnion$d(syntax) {
        const trim = syntax.trim().replace(/"|'/g, '');
        return (trim === 'boolean' ? yield Boolean$1() :
            trim === 'number' ? yield Number$1() :
                trim === 'bigint' ? yield BigInt$1() :
                    trim === 'string' ? yield String$1() :
                        yield (() => {
                            const literals = trim.split('|').map((literal) => Literal(literal.trim()));
                            return (literals.length === 0 ? Never() :
                                literals.length === 1 ? literals[0] :
                                    UnionEvaluated(literals));
                        })());
    }
    // prettier-ignore
    function* FromTerminal(syntax) {
        if (syntax[1] !== '{') {
            const L = Literal('$');
            const R = FromSyntax(syntax.slice(1));
            return yield* [L, ...R];
        }
        for (let i = 2; i < syntax.length; i++) {
            if (syntax[i] === '}') {
                const L = FromUnion$d(syntax.slice(2, i));
                const R = FromSyntax(syntax.slice(i + 1));
                return yield* [...L, ...R];
            }
        }
        yield Literal(syntax);
    }
    // prettier-ignore
    function* FromSyntax(syntax) {
        for (let i = 0; i < syntax.length; i++) {
            if (syntax[i] === '$') {
                const L = Literal(syntax.slice(0, i));
                const R = FromTerminal(syntax.slice(i));
                return yield* [L, ...R];
            }
        }
        yield Literal(syntax);
    }
    /** Parses TemplateLiteralSyntax and returns a tuple of TemplateLiteralKinds */
    function TemplateLiteralSyntax(syntax) {
        return [...FromSyntax(syntax)];
    }

    // ------------------------------------------------------------------
    // TemplateLiteralPatternError
    // ------------------------------------------------------------------
    class TemplateLiteralPatternError extends TypeBoxError {
    }
    // ------------------------------------------------------------------
    // TemplateLiteralPattern
    // ------------------------------------------------------------------
    function Escape(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    // prettier-ignore
    function Visit$7(schema, acc) {
        return (IsTemplateLiteral$1(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) :
            IsUnion$1(schema) ? `(${schema.anyOf.map((schema) => Visit$7(schema, acc)).join('|')})` :
                IsNumber$2(schema) ? `${acc}${PatternNumber}` :
                    IsInteger$2(schema) ? `${acc}${PatternNumber}` :
                        IsBigInt$2(schema) ? `${acc}${PatternNumber}` :
                            IsString$2(schema) ? `${acc}${PatternString}` :
                                IsLiteral$1(schema) ? `${acc}${Escape(schema.const.toString())}` :
                                    IsBoolean$2(schema) ? `${acc}${PatternBoolean}` :
                                        (() => { throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`); })());
    }
    function TemplateLiteralPattern(kinds) {
        return `^${kinds.map((schema) => Visit$7(schema, '')).join('')}\$`;
    }

    /** Returns a Union from the given TemplateLiteral */
    function TemplateLiteralToUnion(schema) {
        const R = TemplateLiteralGenerate(schema);
        const L = R.map((S) => Literal(S));
        return UnionEvaluated(L);
    }

    /** `[Json]` Creates a TemplateLiteral type */
    // prettier-ignore
    function TemplateLiteral(unresolved, options = {}) {
        const pattern = IsString$3(unresolved)
            ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved))
            : TemplateLiteralPattern(unresolved);
        return { ...options, [Kind]: 'TemplateLiteral', type: 'string', pattern };
    }

    // prettier-ignore
    function FromTemplateLiteral$4(T) {
        const R = TemplateLiteralGenerate(T);
        return R.map(S => S.toString());
    }
    // prettier-ignore
    function FromUnion$c(T) {
        const Acc = [];
        for (const L of T)
            Acc.push(...IndexPropertyKeys(L));
        return Acc;
    }
    // prettier-ignore
    function FromLiteral$3(T) {
        return ([T.toString()] // TS 5.4 observes TLiteralValue as not having a toString()
        );
    }
    /** Returns a tuple of PropertyKeys derived from the given TSchema */
    // prettier-ignore
    function IndexPropertyKeys(T) {
        return [...new Set((IsTemplateLiteral$1(T) ? FromTemplateLiteral$4(T) :
                IsUnion$1(T) ? FromUnion$c(T.anyOf) :
                    IsLiteral$1(T) ? FromLiteral$3(T.const) :
                        IsNumber$2(T) ? ['[number]'] :
                            IsInteger$2(T) ? ['[number]'] :
                                []))];
    }

    // prettier-ignore
    function FromProperties$i(T, P, options) {
        const Acc = {};
        for (const K2 of Object.getOwnPropertyNames(P)) {
            Acc[K2] = Index(T, IndexPropertyKeys(P[K2]), options);
        }
        return Acc;
    }
    // prettier-ignore
    function FromMappedResult$b(T, R, options) {
        return FromProperties$i(T, R.properties, options);
    }
    // prettier-ignore
    function IndexFromMappedResult(T, R, options) {
        const P = FromMappedResult$b(T, R, options);
        return MappedResult(P);
    }

    // prettier-ignore
    function FromRest$7(T, K) {
        return T.map(L => IndexFromPropertyKey(L, K));
    }
    // prettier-ignore
    function FromIntersectRest(T) {
        return T.filter(L => !IsNever$1(L));
    }
    // prettier-ignore
    function FromIntersect$b(T, K) {
        return (IntersectEvaluated(FromIntersectRest(FromRest$7(T, K))));
    }
    // prettier-ignore
    function FromUnionRest(T) {
        return (T.some(L => IsNever$1(L))
            ? []
            : T);
    }
    // prettier-ignore
    function FromUnion$b(T, K) {
        return (UnionEvaluated(FromUnionRest(FromRest$7(T, K))));
    }
    // prettier-ignore
    function FromTuple$8(T, K) {
        return (K in T ? T[K] :
            K === '[number]' ? UnionEvaluated(T) :
                Never());
    }
    // prettier-ignore
    function FromArray$9(T, K) {
        return (K === '[number]'
            ? T
            : Never());
    }
    // prettier-ignore
    function FromProperty$1(T, K) {
        return (K in T ? T[K] : Never());
    }
    // prettier-ignore
    function IndexFromPropertyKey(T, K) {
        return (IsIntersect$1(T) ? FromIntersect$b(T.allOf, K) :
            IsUnion$1(T) ? FromUnion$b(T.anyOf, K) :
                IsTuple$1(T) ? FromTuple$8(T.items ?? [], K) :
                    IsArray$2(T) ? FromArray$9(T.items, K) :
                        IsObject$2(T) ? FromProperty$1(T.properties, K) :
                            Never());
    }
    // prettier-ignore
    function IndexFromPropertyKeys(T, K) {
        return K.map(L => IndexFromPropertyKey(T, L));
    }
    // prettier-ignore
    function FromSchema(T, K) {
        return (UnionEvaluated(IndexFromPropertyKeys(T, K)));
    }
    /** `[Json]` Returns an Indexed property type for the given keys */
    function Index(T, K, options = {}) {
        // prettier-ignore
        return (IsMappedResult$1(K) ? CloneType(IndexFromMappedResult(T, K, options)) :
            IsMappedKey$1(K) ? CloneType(IndexFromMappedKey(T, K, options)) :
                IsSchema$1(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) :
                    CloneType(FromSchema(T, K), options));
    }

    // prettier-ignore
    function MappedIndexPropertyKey(T, K, options) {
        return { [K]: Index(T, [K], options) };
    }
    // prettier-ignore
    function MappedIndexPropertyKeys(T, K, options) {
        return K.reduce((Acc, L) => {
            return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
        }, {});
    }
    // prettier-ignore
    function MappedIndexProperties(T, K, options) {
        return MappedIndexPropertyKeys(T, K.keys, options);
    }
    // prettier-ignore
    function IndexFromMappedKey(T, K, options) {
        const P = MappedIndexProperties(T, K, options);
        return MappedResult(P);
    }

    /** `[JavaScript]` Creates an Iterator type */
    function Iterator(items, options = {}) {
        return {
            ...options,
            [Kind]: 'Iterator',
            type: 'Iterator',
            items: CloneType(items),
        };
    }

    /** `[Json]` Creates an Object type */
    function _Object(properties, options = {}) {
        const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
        const optionalKeys = propertyKeys.filter((key) => IsOptional$1(properties[key]));
        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
        const clonedAdditionalProperties = IsSchema$1(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
        const clonedProperties = {};
        for (const key of propertyKeys)
            clonedProperties[key] = CloneType(properties[key]);
        return (requiredKeys.length > 0
            ? { ...options, ...clonedAdditionalProperties, [Kind]: 'Object', type: 'object', properties: clonedProperties, required: requiredKeys }
            : { ...options, ...clonedAdditionalProperties, [Kind]: 'Object', type: 'object', properties: clonedProperties });
    }
    /** `[Json]` Creates an Object type */
    const Object$1 = _Object;

    /** `[JavaScript]` Creates a Promise type */
    function Promise$1(item, options = {}) {
        return {
            ...options,
            [Kind]: 'Promise',
            type: 'Promise',
            item: CloneType(item),
        };
    }

    function RemoveReadonly(schema) {
        return Discard(CloneType(schema), [ReadonlyKind]);
    }
    function AddReadonly(schema) {
        return { ...CloneType(schema), [ReadonlyKind]: 'Readonly' };
    }
    // prettier-ignore
    function ReadonlyWithFlag(schema, F) {
        return (F === false
            ? RemoveReadonly(schema)
            : AddReadonly(schema));
    }
    /** `[Json]` Creates a Readonly property */
    function Readonly(schema, enable) {
        const F = enable ?? true;
        return IsMappedResult$1(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
    }

    // prettier-ignore
    function FromProperties$h(K, F) {
        const Acc = {};
        for (const K2 of globalThis.Object.getOwnPropertyNames(K))
            Acc[K2] = Readonly(K[K2], F);
        return Acc;
    }
    // prettier-ignore
    function FromMappedResult$a(R, F) {
        return FromProperties$h(R.properties, F);
    }
    // prettier-ignore
    function ReadonlyFromMappedResult(R, F) {
        const P = FromMappedResult$a(R, F);
        return MappedResult(P);
    }

    /** `[Json]` Creates a Tuple type */
    function Tuple(items, options = {}) {
        // return TupleResolver.Resolve(T)
        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
        // prettier-ignore
        return (items.length > 0 ?
            { ...options, [Kind]: 'Tuple', type: 'array', items: CloneRest(items), additionalItems, minItems, maxItems } :
            { ...options, [Kind]: 'Tuple', type: 'array', minItems, maxItems });
    }

    // prettier-ignore
    function FromMappedResult$9(K, P) {
        return (K in P
            ? FromSchemaType(K, P[K])
            : MappedResult(P));
    }
    // prettier-ignore
    function MappedKeyToKnownMappedResultProperties(K) {
        return { [K]: Literal(K) };
    }
    // prettier-ignore
    function MappedKeyToUnknownMappedResultProperties(P) {
        const Acc = {};
        for (const L of P)
            Acc[L] = Literal(L);
        return Acc;
    }
    // prettier-ignore
    function MappedKeyToMappedResultProperties(K, P) {
        return (SetIncludes(P, K)
            ? MappedKeyToKnownMappedResultProperties(K)
            : MappedKeyToUnknownMappedResultProperties(P));
    }
    // prettier-ignore
    function FromMappedKey$3(K, P) {
        const R = MappedKeyToMappedResultProperties(K, P);
        return FromMappedResult$9(K, R);
    }
    // prettier-ignore
    function FromRest$6(K, T) {
        return T.map(L => FromSchemaType(K, L));
    }
    // prettier-ignore
    function FromProperties$g(K, T) {
        const Acc = {};
        for (const K2 of globalThis.Object.getOwnPropertyNames(T))
            Acc[K2] = FromSchemaType(K, T[K2]);
        return Acc;
    }
    // prettier-ignore
    function FromSchemaType(K, T) {
        return (
        // unevaluated modifier types
        IsOptional$1(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) :
            IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) :
                // unevaluated mapped types
                IsMappedResult$1(T) ? FromMappedResult$9(K, T.properties) :
                    IsMappedKey$1(T) ? FromMappedKey$3(K, T.keys) :
                        // unevaluated types
                        IsConstructor$1(T) ? Constructor(FromRest$6(K, T.parameters), FromSchemaType(K, T.returns)) :
                            IsFunction$2(T) ? Function$1(FromRest$6(K, T.parameters), FromSchemaType(K, T.returns)) :
                                IsAsyncIterator$2(T) ? AsyncIterator(FromSchemaType(K, T.items)) :
                                    IsIterator$2(T) ? Iterator(FromSchemaType(K, T.items)) :
                                        IsIntersect$1(T) ? Intersect$1(FromRest$6(K, T.allOf)) :
                                            IsUnion$1(T) ? Union$1(FromRest$6(K, T.anyOf)) :
                                                IsTuple$1(T) ? Tuple(FromRest$6(K, T.items ?? [])) :
                                                    IsObject$2(T) ? Object$1(FromProperties$g(K, T.properties)) :
                                                        IsArray$2(T) ? Array$1(FromSchemaType(K, T.items)) :
                                                            IsPromise$2(T) ? Promise$1(FromSchemaType(K, T.item)) :
                                                                T);
    }
    // prettier-ignore
    function MappedFunctionReturnType(K, T) {
        const Acc = {};
        for (const L of K)
            Acc[L] = FromSchemaType(L, T);
        return Acc;
    }
    /** `[Json]` Creates a Mapped object type */
    function Mapped(key, map, options = {}) {
        const K = IsSchema$1(key) ? IndexPropertyKeys(key) : key;
        const RT = map({ [Kind]: 'MappedKey', keys: K });
        const R = MappedFunctionReturnType(K, RT);
        return CloneType(Object$1(R), options);
    }

    function RemoveOptional(schema) {
        return Discard(CloneType(schema), [OptionalKind]);
    }
    function AddOptional(schema) {
        return { ...CloneType(schema), [OptionalKind]: 'Optional' };
    }
    // prettier-ignore
    function OptionalWithFlag(schema, F) {
        return (F === false
            ? RemoveOptional(schema)
            : AddOptional(schema));
    }
    /** `[Json]` Creates a Optional property */
    function Optional(schema, enable) {
        const F = enable ?? true;
        return IsMappedResult$1(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
    }

    // prettier-ignore
    function FromProperties$f(P, F) {
        const Acc = {};
        for (const K2 of globalThis.Object.getOwnPropertyNames(P))
            Acc[K2] = Optional(P[K2], F);
        return Acc;
    }
    // prettier-ignore
    function FromMappedResult$8(R, F) {
        return FromProperties$f(R.properties, F);
    }
    // prettier-ignore
    function OptionalFromMappedResult(R, F) {
        const P = FromMappedResult$8(R, F);
        return MappedResult(P);
    }

    // ------------------------------------------------------------------
    // IntersectCreate
    // ------------------------------------------------------------------
    // prettier-ignore
    function IntersectCreate(T, options) {
        const allObjects = T.every((schema) => IsObject$2(schema));
        const clonedUnevaluatedProperties = IsSchema$1(options.unevaluatedProperties)
            ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) }
            : {};
        return ((options.unevaluatedProperties === false || IsSchema$1(options.unevaluatedProperties) || allObjects
            ? { ...options, ...clonedUnevaluatedProperties, [Kind]: 'Intersect', type: 'object', allOf: CloneRest(T) }
            : { ...options, ...clonedUnevaluatedProperties, [Kind]: 'Intersect', allOf: CloneRest(T) }));
    }

    // prettier-ignore
    function IsIntersectOptional(T) {
        return T.every(L => IsOptional$1(L));
    }
    // prettier-ignore
    function RemoveOptionalFromType(T) {
        return (Discard(T, [OptionalKind]));
    }
    // prettier-ignore
    function RemoveOptionalFromRest(T) {
        return T.map(L => IsOptional$1(L) ? RemoveOptionalFromType(L) : L);
    }
    // prettier-ignore
    function ResolveIntersect(T, options) {
        return (IsIntersectOptional(T)
            ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options))
            : IntersectCreate(RemoveOptionalFromRest(T), options));
    }
    /** `[Json]` Creates an evaluated Intersect type */
    function IntersectEvaluated(T, options = {}) {
        if (T.length === 0)
            return Never(options);
        if (T.length === 1)
            return CloneType(T[0], options);
        if (T.some((schema) => IsTransform$1(schema)))
            throw new Error('Cannot intersect transform types');
        return ResolveIntersect(T, options);
    }

    /** `[Json]` Creates an evaluated Intersect type */
    function Intersect$1(T, options = {}) {
        if (T.length === 0)
            return Never(options);
        if (T.length === 1)
            return CloneType(T[0], options);
        if (T.some((schema) => IsTransform$1(schema)))
            throw new Error('Cannot intersect transform types');
        return IntersectCreate(T, options);
    }

    // prettier-ignore
    function FromRest$5(T) {
        return T.map(L => AwaitedResolve(L));
    }
    // prettier-ignore
    function FromIntersect$a(T) {
        return Intersect$1(FromRest$5(T));
    }
    // prettier-ignore
    function FromUnion$a(T) {
        return Union$1(FromRest$5(T));
    }
    // prettier-ignore
    function FromPromise$5(T) {
        return AwaitedResolve(T);
    }
    // ----------------------------------------------------------------
    // AwaitedResolve
    // ----------------------------------------------------------------
    // prettier-ignore
    function AwaitedResolve(T) {
        return (IsIntersect$1(T) ? FromIntersect$a(T.allOf) :
            IsUnion$1(T) ? FromUnion$a(T.anyOf) :
                IsPromise$2(T) ? FromPromise$5(T.item) :
                    T);
    }
    /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
    function Awaited(T, options = {}) {
        return CloneType(AwaitedResolve(T), options);
    }

    // prettier-ignore
    function FromRest$4(T) {
        const Acc = [];
        for (const L of T)
            Acc.push(KeyOfPropertyKeys(L));
        return Acc;
    }
    // prettier-ignore
    function FromIntersect$9(T) {
        const C = FromRest$4(T);
        const R = SetUnionMany(C);
        return R;
    }
    // prettier-ignore
    function FromUnion$9(T) {
        const C = FromRest$4(T);
        const R = SetIntersectMany(C);
        return R;
    }
    // prettier-ignore
    function FromTuple$7(T) {
        return T.map((_, I) => I.toString());
    }
    // prettier-ignore
    function FromArray$8(_) {
        return (['[number]']);
    }
    // prettier-ignore
    function FromProperties$e(T) {
        return (globalThis.Object.getOwnPropertyNames(T));
    }
    // ------------------------------------------------------------------
    // FromPatternProperties
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromPatternProperties(patternProperties) {
        if (!includePatternProperties)
            return [];
        const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
        return patternPropertyKeys.map(key => {
            return (key[0] === '^' && key[key.length - 1] === '$')
                ? key.slice(1, key.length - 1)
                : key;
        });
    }
    /** Returns a tuple of PropertyKeys derived from the given TSchema. */
    // prettier-ignore
    function KeyOfPropertyKeys(T) {
        return (IsIntersect$1(T) ? FromIntersect$9(T.allOf) :
            IsUnion$1(T) ? FromUnion$9(T.anyOf) :
                IsTuple$1(T) ? FromTuple$7(T.items ?? []) :
                    IsArray$2(T) ? FromArray$8(T.items) :
                        IsObject$2(T) ? FromProperties$e(T.properties) :
                            IsRecord$1(T) ? FromPatternProperties(T.patternProperties) :
                                []);
    }
    // ----------------------------------------------------------------
    // KeyOfPattern
    // ----------------------------------------------------------------
    let includePatternProperties = false;
    /** Returns a regular expression pattern derived from the given TSchema */
    function KeyOfPattern(schema) {
        includePatternProperties = true;
        const keys = KeyOfPropertyKeys(schema);
        includePatternProperties = false;
        const pattern = keys.map((key) => `(${key})`);
        return `^(${pattern.join('|')})$`;
    }

    // prettier-ignore
    function KeyOfPropertyKeysToRest(T) {
        return T.map(L => L === '[number]' ? Number$1() : Literal(L));
    }
    /** `[Json]` Creates a KeyOf type */
    function KeyOf(T, options = {}) {
        if (IsMappedResult$1(T)) {
            return KeyOfFromMappedResult(T, options);
        }
        else {
            const K = KeyOfPropertyKeys(T);
            const S = KeyOfPropertyKeysToRest(K);
            const U = UnionEvaluated(S);
            return CloneType(U, options);
        }
    }

    // prettier-ignore
    function FromProperties$d(K, options) {
        const Acc = {};
        for (const K2 of globalThis.Object.getOwnPropertyNames(K))
            Acc[K2] = KeyOf(K[K2], options);
        return Acc;
    }
    // prettier-ignore
    function FromMappedResult$7(R, options) {
        return FromProperties$d(R.properties, options);
    }
    // prettier-ignore
    function KeyOfFromMappedResult(R, options) {
        const P = FromMappedResult$7(R, options);
        return MappedResult(P);
    }

    /**
     * `[Utility]` Resolves an array of keys and schemas from the given schema. This method is faster
     * than obtaining the keys and resolving each individually via indexing. This method was written
     * accellerate Intersect and Union encoding.
     */
    function KeyOfPropertyEntries(schema) {
        const keys = KeyOfPropertyKeys(schema);
        const schemas = IndexFromPropertyKeys(schema, keys);
        return keys.map((_, index) => [keys[index], schemas[index]]);
    }

    // prettier-ignore
    function CompositeKeys(T) {
        const Acc = [];
        for (const L of T)
            Acc.push(...KeyOfPropertyKeys(L));
        return SetDistinct(Acc);
    }
    // prettier-ignore
    function FilterNever(T) {
        return T.filter(L => !IsNever$1(L));
    }
    // prettier-ignore
    function CompositeProperty(T, K) {
        const Acc = [];
        for (const L of T)
            Acc.push(...IndexFromPropertyKeys(L, [K]));
        return FilterNever(Acc);
    }
    // prettier-ignore
    function CompositeProperties(T, K) {
        const Acc = {};
        for (const L of K) {
            Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
        }
        return Acc;
    }
    // prettier-ignore
    function Composite(T, options = {}) {
        const K = CompositeKeys(T);
        const P = CompositeProperties(T, K);
        const R = Object$1(P, options);
        return R;
    }

    /** `[JavaScript]` Creates a Date type */
    function Date$1(options = {}) {
        return {
            ...options,
            [Kind]: 'Date',
            type: 'Date',
        };
    }

    /** `[Json]` Creates a Null type */
    function Null(options = {}) {
        return {
            ...options,
            [Kind]: 'Null',
            type: 'null',
        };
    }

    /** `[JavaScript]` Creates a Symbol type */
    function Symbol$1(options) {
        return { ...options, [Kind]: 'Symbol', type: 'symbol' };
    }

    /** `[JavaScript]` Creates a Undefined type */
    function Undefined(options = {}) {
        return { ...options, [Kind]: 'Undefined', type: 'undefined' };
    }

    /** `[JavaScript]` Creates a Uint8Array type */
    function Uint8Array$1(options = {}) {
        return { ...options, [Kind]: 'Uint8Array', type: 'Uint8Array' };
    }

    /** `[Json]` Creates an Unknown type */
    function Unknown(options = {}) {
        return {
            ...options,
            [Kind]: 'Unknown',
        };
    }

    // prettier-ignore
    function FromArray$7(T) {
        return T.map(L => FromValue(L, false));
    }
    // prettier-ignore
    function FromProperties$c(value) {
        const Acc = {};
        for (const K of globalThis.Object.getOwnPropertyNames(value))
            Acc[K] = Readonly(FromValue(value[K], false));
        return Acc;
    }
    function ConditionalReadonly(T, root) {
        return (root === true ? T : Readonly(T));
    }
    // prettier-ignore
    function FromValue(value, root) {
        return (IsAsyncIterator$3(value) ? ConditionalReadonly(Any(), root) :
            IsIterator$3(value) ? ConditionalReadonly(Any(), root) :
                IsArray$3(value) ? Readonly(Tuple(FromArray$7(value))) :
                    IsUint8Array$3(value) ? Uint8Array$1() :
                        IsDate$3(value) ? Date$1() :
                            IsObject$3(value) ? ConditionalReadonly(Object$1(FromProperties$c(value)), root) :
                                IsFunction$3(value) ? ConditionalReadonly(Function$1([], Unknown()), root) :
                                    IsUndefined$3(value) ? Undefined() :
                                        IsNull$3(value) ? Null() :
                                            IsSymbol$3(value) ? Symbol$1() :
                                                IsBigInt$3(value) ? BigInt$1() :
                                                    IsNumber$3(value) ? Literal(value) :
                                                        IsBoolean$3(value) ? Literal(value) :
                                                            IsString$3(value) ? Literal(value) :
                                                                Object$1({}));
    }
    /** `[JavaScript]` Creates a readonly const type from the given value. */
    function Const(T, options = {}) {
        return CloneType(FromValue(T, true), options);
    }

    /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
    function ConstructorParameters(schema, options = {}) {
        return Tuple(CloneRest(schema.parameters), { ...options });
    }

    function FromRest$3(schema, references) {
        return schema.map((schema) => Deref$1(schema, references));
    }
    // prettier-ignore
    function FromProperties$b(properties, references) {
        const Acc = {};
        for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
            Acc[K] = Deref$1(properties[K], references);
        }
        return Acc;
    }
    // prettier-ignore
    function FromConstructor$4(schema, references) {
        schema.parameters = FromRest$3(schema.parameters, references);
        schema.returns = Deref$1(schema.returns, references);
        return schema;
    }
    // prettier-ignore
    function FromFunction$4(schema, references) {
        schema.parameters = FromRest$3(schema.parameters, references);
        schema.returns = Deref$1(schema.returns, references);
        return schema;
    }
    // prettier-ignore
    function FromIntersect$8(schema, references) {
        schema.allOf = FromRest$3(schema.allOf, references);
        return schema;
    }
    // prettier-ignore
    function FromUnion$8(schema, references) {
        schema.anyOf = FromRest$3(schema.anyOf, references);
        return schema;
    }
    // prettier-ignore
    function FromTuple$6(schema, references) {
        if (IsUndefined$3(schema.items))
            return schema;
        schema.items = FromRest$3(schema.items, references);
        return schema;
    }
    // prettier-ignore
    function FromArray$6(schema, references) {
        schema.items = Deref$1(schema.items, references);
        return schema;
    }
    // prettier-ignore
    function FromObject$6(schema, references) {
        schema.properties = FromProperties$b(schema.properties, references);
        return schema;
    }
    // prettier-ignore
    function FromPromise$4(schema, references) {
        schema.item = Deref$1(schema.item, references);
        return schema;
    }
    // prettier-ignore
    function FromAsyncIterator$4(schema, references) {
        schema.items = Deref$1(schema.items, references);
        return schema;
    }
    // prettier-ignore
    function FromIterator$4(schema, references) {
        schema.items = Deref$1(schema.items, references);
        return schema;
    }
    // prettier-ignore
    function FromRef$5(schema, references) {
        const target = references.find(remote => remote.$id === schema.$ref);
        if (target === undefined)
            throw Error(`Unable to dereference schema with $id ${schema.$ref}`);
        const discard = Discard(target, ['$id']);
        return Deref$1(discard, references);
    }
    // prettier-ignore
    function DerefResolve(schema, references) {
        return (IsConstructor$1(schema) ? FromConstructor$4(schema, references) :
            IsFunction$2(schema) ? FromFunction$4(schema, references) :
                IsIntersect$1(schema) ? FromIntersect$8(schema, references) :
                    IsUnion$1(schema) ? FromUnion$8(schema, references) :
                        IsTuple$1(schema) ? FromTuple$6(schema, references) :
                            IsArray$2(schema) ? FromArray$6(schema, references) :
                                IsObject$2(schema) ? FromObject$6(schema, references) :
                                    IsPromise$2(schema) ? FromPromise$4(schema, references) :
                                        IsAsyncIterator$2(schema) ? FromAsyncIterator$4(schema, references) :
                                            IsIterator$2(schema) ? FromIterator$4(schema, references) :
                                                IsRef$1(schema) ? FromRef$5(schema, references) :
                                                    schema);
    }
    // ------------------------------------------------------------------
    // TDeref
    // ------------------------------------------------------------------
    /** `[Json]` Creates a dereferenced type */
    function Deref$1(schema, references) {
        return DerefResolve(CloneType(schema), CloneRest(references));
    }

    /** `[Json]` Creates a Enum type */
    function Enum(item, options = {}) {
        if (IsUndefined$3(item))
            throw new Error('Enum undefined or empty');
        const values1 = globalThis.Object.getOwnPropertyNames(item)
            .filter((key) => isNaN(key))
            .map((key) => item[key]);
        const values2 = [...new Set(values1)];
        const anyOf = values2.map((value) => Literal(value));
        return Union$1(anyOf, { ...options, [Hint]: 'Enum' });
    }

    class ExtendsResolverError extends TypeBoxError {
    }
    var ExtendsResult;
    (function (ExtendsResult) {
        ExtendsResult[ExtendsResult["Union"] = 0] = "Union";
        ExtendsResult[ExtendsResult["True"] = 1] = "True";
        ExtendsResult[ExtendsResult["False"] = 2] = "False";
    })(ExtendsResult || (ExtendsResult = {}));
    // ------------------------------------------------------------------
    // IntoBooleanResult
    // ------------------------------------------------------------------
    // prettier-ignore
    function IntoBooleanResult(result) {
        return result === ExtendsResult.False ? result : ExtendsResult.True;
    }
    // ------------------------------------------------------------------
    // Throw
    // ------------------------------------------------------------------
    // prettier-ignore
    function Throw(message) {
        throw new ExtendsResolverError(message);
    }
    // ------------------------------------------------------------------
    // StructuralRight
    // ------------------------------------------------------------------
    // prettier-ignore
    function IsStructuralRight(right) {
        return (IsNever(right) ||
            IsIntersect(right) ||
            IsUnion(right) ||
            IsUnknown(right) ||
            IsAny(right));
    }
    // prettier-ignore
    function StructuralRight(left, right) {
        return (IsNever(right) ? FromNeverRight() :
            IsIntersect(right) ? FromIntersectRight(left, right) :
                IsUnion(right) ? FromUnionRight(left, right) :
                    IsUnknown(right) ? FromUnknownRight() :
                        IsAny(right) ? FromAnyRight() :
                            Throw('StructuralRight'));
    }
    // ------------------------------------------------------------------
    // Any
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromAnyRight(left, right) {
        return ExtendsResult.True;
    }
    // prettier-ignore
    function FromAny$2(left, right) {
        return (IsIntersect(right) ? FromIntersectRight(left, right) :
            (IsUnion(right) && right.anyOf.some((schema) => IsAny(schema) || IsUnknown(schema))) ? ExtendsResult.True :
                IsUnion(right) ? ExtendsResult.Union :
                    IsUnknown(right) ? ExtendsResult.True :
                        IsAny(right) ? ExtendsResult.True :
                            ExtendsResult.Union);
    }
    // ------------------------------------------------------------------
    // Array
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromArrayRight(left, right) {
        return (IsUnknown(left) ? ExtendsResult.False :
            IsAny(left) ? ExtendsResult.Union :
                IsNever(left) ? ExtendsResult.True :
                    ExtendsResult.False);
    }
    // prettier-ignore
    function FromArray$5(left, right) {
        return (IsObject$1(right) && IsObjectArrayLike(right) ? ExtendsResult.True :
            IsStructuralRight(right) ? StructuralRight(left, right) :
                !IsArray$1(right) ? ExtendsResult.False :
                    IntoBooleanResult(Visit$6(left.items, right.items)));
    }
    // ------------------------------------------------------------------
    // AsyncIterator
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromAsyncIterator$3(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            !IsAsyncIterator$1(right) ? ExtendsResult.False :
                IntoBooleanResult(Visit$6(left.items, right.items)));
    }
    // ------------------------------------------------------------------
    // BigInt
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromBigInt$2(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) ? FromObjectRight(left, right) :
                IsRecord(right) ? FromRecordRight(left, right) :
                    IsBigInt$1(right) ? ExtendsResult.True :
                        ExtendsResult.False);
    }
    // ------------------------------------------------------------------
    // Boolean
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromBooleanRight(left, right) {
        return (IsLiteralBoolean(left) ? ExtendsResult.True :
            IsBoolean$1(left) ? ExtendsResult.True :
                ExtendsResult.False);
    }
    // prettier-ignore
    function FromBoolean$2(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) ? FromObjectRight(left, right) :
                IsRecord(right) ? FromRecordRight(left, right) :
                    IsBoolean$1(right) ? ExtendsResult.True :
                        ExtendsResult.False);
    }
    // ------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromConstructor$3(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) ? FromObjectRight(left, right) :
                !IsConstructor(right) ? ExtendsResult.False :
                    left.parameters.length > right.parameters.length ? ExtendsResult.False :
                        (!left.parameters.every((schema, index) => IntoBooleanResult(Visit$6(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :
                            IntoBooleanResult(Visit$6(left.returns, right.returns)));
    }
    // ------------------------------------------------------------------
    // Date
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromDate$2(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) ? FromObjectRight(left, right) :
                IsRecord(right) ? FromRecordRight(left, right) :
                    IsDate$1(right) ? ExtendsResult.True :
                        ExtendsResult.False);
    }
    // ------------------------------------------------------------------
    // Function
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromFunction$3(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) ? FromObjectRight(left, right) :
                !IsFunction$1(right) ? ExtendsResult.False :
                    left.parameters.length > right.parameters.length ? ExtendsResult.False :
                        (!left.parameters.every((schema, index) => IntoBooleanResult(Visit$6(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :
                            IntoBooleanResult(Visit$6(left.returns, right.returns)));
    }
    // ------------------------------------------------------------------
    // Integer
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromIntegerRight(left, right) {
        return (IsLiteral(left) && IsNumber$3(left.const) ? ExtendsResult.True :
            IsNumber$1(left) || IsInteger$1(left) ? ExtendsResult.True :
                ExtendsResult.False);
    }
    // prettier-ignore
    function FromInteger$2(left, right) {
        return (IsInteger$1(right) || IsNumber$1(right) ? ExtendsResult.True :
            IsStructuralRight(right) ? StructuralRight(left, right) :
                IsObject$1(right) ? FromObjectRight(left, right) :
                    IsRecord(right) ? FromRecordRight(left, right) :
                        ExtendsResult.False);
    }
    // ------------------------------------------------------------------
    // Intersect
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromIntersectRight(left, right) {
        return right.allOf.every((schema) => Visit$6(left, schema) === ExtendsResult.True)
            ? ExtendsResult.True
            : ExtendsResult.False;
    }
    // prettier-ignore
    function FromIntersect$7(left, right) {
        return left.allOf.some((schema) => Visit$6(schema, right) === ExtendsResult.True)
            ? ExtendsResult.True
            : ExtendsResult.False;
    }
    // ------------------------------------------------------------------
    // Iterator
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromIterator$3(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            !IsIterator$1(right) ? ExtendsResult.False :
                IntoBooleanResult(Visit$6(left.items, right.items)));
    }
    // ------------------------------------------------------------------
    // Literal
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromLiteral$2(left, right) {
        return (IsLiteral(right) && right.const === left.const ? ExtendsResult.True :
            IsStructuralRight(right) ? StructuralRight(left, right) :
                IsObject$1(right) ? FromObjectRight(left, right) :
                    IsRecord(right) ? FromRecordRight(left, right) :
                        IsString$1(right) ? FromStringRight(left) :
                            IsNumber$1(right) ? FromNumberRight(left) :
                                IsInteger$1(right) ? FromIntegerRight(left) :
                                    IsBoolean$1(right) ? FromBooleanRight(left) :
                                        ExtendsResult.False);
    }
    // ------------------------------------------------------------------
    // Never
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromNeverRight(left, right) {
        return ExtendsResult.False;
    }
    // prettier-ignore
    function FromNever$2(left, right) {
        return ExtendsResult.True;
    }
    // ------------------------------------------------------------------
    // Not
    // ------------------------------------------------------------------
    // prettier-ignore
    function UnwrapTNot(schema) {
        let [current, depth] = [schema, 0];
        while (true) {
            if (!IsNot(current))
                break;
            current = current.not;
            depth += 1;
        }
        return depth % 2 === 0 ? current : Unknown();
    }
    // prettier-ignore
    function FromNot$5(left, right) {
        // TypeScript has no concept of negated types, and attempts to correctly check the negated
        // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer
        // the type. Instead we unwrap to either unknown or T and continue evaluating.
        // prettier-ignore
        return (IsNot(left) ? Visit$6(UnwrapTNot(left), right) :
            IsNot(right) ? Visit$6(left, UnwrapTNot(right)) :
                Throw('Invalid fallthrough for Not'));
    }
    // ------------------------------------------------------------------
    // Null
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromNull$2(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) ? FromObjectRight(left, right) :
                IsRecord(right) ? FromRecordRight(left, right) :
                    IsNull$1(right) ? ExtendsResult.True :
                        ExtendsResult.False);
    }
    // ------------------------------------------------------------------
    // Number
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromNumberRight(left, right) {
        return (IsLiteralNumber(left) ? ExtendsResult.True :
            IsNumber$1(left) || IsInteger$1(left) ? ExtendsResult.True :
                ExtendsResult.False);
    }
    // prettier-ignore
    function FromNumber$2(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) ? FromObjectRight(left, right) :
                IsRecord(right) ? FromRecordRight(left, right) :
                    IsInteger$1(right) || IsNumber$1(right) ? ExtendsResult.True :
                        ExtendsResult.False);
    }
    // ------------------------------------------------------------------
    // Object
    // ------------------------------------------------------------------
    // prettier-ignore
    function IsObjectPropertyCount(schema, count) {
        return Object.getOwnPropertyNames(schema.properties).length === count;
    }
    // prettier-ignore
    function IsObjectStringLike(schema) {
        return IsObjectArrayLike(schema);
    }
    // prettier-ignore
    function IsObjectSymbolLike(schema) {
        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((IsString$1(schema.properties.description.anyOf[0]) &&
            IsUndefined$1(schema.properties.description.anyOf[1])) || (IsString$1(schema.properties.description.anyOf[1]) &&
            IsUndefined$1(schema.properties.description.anyOf[0]))));
    }
    // prettier-ignore
    function IsObjectNumberLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    // prettier-ignore
    function IsObjectBooleanLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    // prettier-ignore
    function IsObjectBigIntLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    // prettier-ignore
    function IsObjectDateLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    // prettier-ignore
    function IsObjectUint8ArrayLike(schema) {
        return IsObjectArrayLike(schema);
    }
    // prettier-ignore
    function IsObjectFunctionLike(schema) {
        const length = Number$1();
        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit$6(schema.properties['length'], length)) === ExtendsResult.True);
    }
    // prettier-ignore
    function IsObjectConstructorLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    // prettier-ignore
    function IsObjectArrayLike(schema) {
        const length = Number$1();
        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit$6(schema.properties['length'], length)) === ExtendsResult.True);
    }
    // prettier-ignore
    function IsObjectPromiseLike(schema) {
        const then = Function$1([Any()], Any());
        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit$6(schema.properties['then'], then)) === ExtendsResult.True);
    }
    // ------------------------------------------------------------------
    // Property
    // ------------------------------------------------------------------
    // prettier-ignore
    function Property(left, right) {
        return (Visit$6(left, right) === ExtendsResult.False ? ExtendsResult.False :
            IsOptional(left) && !IsOptional(right) ? ExtendsResult.False :
                ExtendsResult.True);
    }
    // prettier-ignore
    function FromObjectRight(left, right) {
        return (IsUnknown(left) ? ExtendsResult.False :
            IsAny(left) ? ExtendsResult.Union : (IsNever(left) ||
                (IsLiteralString(left) && IsObjectStringLike(right)) ||
                (IsLiteralNumber(left) && IsObjectNumberLike(right)) ||
                (IsLiteralBoolean(left) && IsObjectBooleanLike(right)) ||
                (IsSymbol$1(left) && IsObjectSymbolLike(right)) ||
                (IsBigInt$1(left) && IsObjectBigIntLike(right)) ||
                (IsString$1(left) && IsObjectStringLike(right)) ||
                (IsSymbol$1(left) && IsObjectSymbolLike(right)) ||
                (IsNumber$1(left) && IsObjectNumberLike(right)) ||
                (IsInteger$1(left) && IsObjectNumberLike(right)) ||
                (IsBoolean$1(left) && IsObjectBooleanLike(right)) ||
                (IsUint8Array$1(left) && IsObjectUint8ArrayLike(right)) ||
                (IsDate$1(left) && IsObjectDateLike(right)) ||
                (IsConstructor(left) && IsObjectConstructorLike(right)) ||
                (IsFunction$1(left) && IsObjectFunctionLike(right))) ? ExtendsResult.True :
                (IsRecord(left) && IsString$1(RecordKey(left))) ? (() => {
                    // When expressing a Record with literal key values, the Record is converted into a Object with
                    // the Hint assigned as `Record`. This is used to invert the extends logic.
                    return right[Hint] === 'Record' ? ExtendsResult.True : ExtendsResult.False;
                })() :
                    (IsRecord(left) && IsNumber$1(RecordKey(left))) ? (() => {
                        return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
                    })() :
                        ExtendsResult.False);
    }
    // prettier-ignore
    function FromObject$5(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsRecord(right) ? FromRecordRight(left, right) :
                !IsObject$1(right) ? ExtendsResult.False :
                    (() => {
                        for (const key of Object.getOwnPropertyNames(right.properties)) {
                            if (!(key in left.properties) && !IsOptional(right.properties[key])) {
                                return ExtendsResult.False;
                            }
                            if (IsOptional(right.properties[key])) {
                                return ExtendsResult.True;
                            }
                            if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
                                return ExtendsResult.False;
                            }
                        }
                        return ExtendsResult.True;
                    })());
    }
    // ------------------------------------------------------------------
    // Promise
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromPromise$3(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) && IsObjectPromiseLike(right) ? ExtendsResult.True :
                !IsPromise$1(right) ? ExtendsResult.False :
                    IntoBooleanResult(Visit$6(left.item, right.item)));
    }
    // ------------------------------------------------------------------
    // Record
    // ------------------------------------------------------------------
    // prettier-ignore
    function RecordKey(schema) {
        return (PatternNumberExact in schema.patternProperties ? Number$1() :
            PatternStringExact in schema.patternProperties ? String$1() :
                Throw('Unknown record key pattern'));
    }
    // prettier-ignore
    function RecordValue(schema) {
        return (PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] :
            PatternStringExact in schema.patternProperties ? schema.patternProperties[PatternStringExact] :
                Throw('Unable to get record value schema'));
    }
    // prettier-ignore
    function FromRecordRight(left, right) {
        const [Key, Value] = [RecordKey(right), RecordValue(right)];
        return ((IsLiteralString(left) && IsNumber$1(Key) && IntoBooleanResult(Visit$6(left, Value)) === ExtendsResult.True) ? ExtendsResult.True :
            IsUint8Array$1(left) && IsNumber$1(Key) ? Visit$6(left, Value) :
                IsString$1(left) && IsNumber$1(Key) ? Visit$6(left, Value) :
                    IsArray$1(left) && IsNumber$1(Key) ? Visit$6(left, Value) :
                        IsObject$1(left) ? (() => {
                            for (const key of Object.getOwnPropertyNames(left.properties)) {
                                if (Property(Value, left.properties[key]) === ExtendsResult.False) {
                                    return ExtendsResult.False;
                                }
                            }
                            return ExtendsResult.True;
                        })() :
                            ExtendsResult.False);
    }
    // prettier-ignore
    function FromRecord$5(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) ? FromObjectRight(left, right) :
                !IsRecord(right) ? ExtendsResult.False :
                    Visit$6(RecordValue(left), RecordValue(right)));
    }
    // ------------------------------------------------------------------
    // RegExp
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromRegExp$2(left, right) {
        // Note: RegExp types evaluate as strings, not RegExp objects.
        // Here we remap either into string and continue evaluating.
        const L = IsRegExp(left) ? String$1() : left;
        const R = IsRegExp(right) ? String$1() : right;
        return Visit$6(L, R);
    }
    // ------------------------------------------------------------------
    // String
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromStringRight(left, right) {
        return (IsLiteral(left) && IsString$3(left.const) ? ExtendsResult.True :
            IsString$1(left) ? ExtendsResult.True :
                ExtendsResult.False);
    }
    // prettier-ignore
    function FromString$2(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) ? FromObjectRight(left, right) :
                IsRecord(right) ? FromRecordRight(left, right) :
                    IsString$1(right) ? ExtendsResult.True :
                        ExtendsResult.False);
    }
    // ------------------------------------------------------------------
    // Symbol
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromSymbol$2(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) ? FromObjectRight(left, right) :
                IsRecord(right) ? FromRecordRight(left, right) :
                    IsSymbol$1(right) ? ExtendsResult.True :
                        ExtendsResult.False);
    }
    // ------------------------------------------------------------------
    // TemplateLiteral
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromTemplateLiteral$3(left, right) {
        // TemplateLiteral types are resolved to either unions for finite expressions or string
        // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for
        // either type and continue evaluating.
        return (IsTemplateLiteral(left) ? Visit$6(TemplateLiteralToUnion(left), right) :
            IsTemplateLiteral(right) ? Visit$6(left, TemplateLiteralToUnion(right)) :
                Throw('Invalid fallthrough for TemplateLiteral'));
    }
    // ------------------------------------------------------------------
    // Tuple
    // ------------------------------------------------------------------
    // prettier-ignore
    function IsArrayOfTuple(left, right) {
        return (IsArray$1(right) &&
            left.items !== undefined &&
            left.items.every((schema) => Visit$6(schema, right.items) === ExtendsResult.True));
    }
    // prettier-ignore
    function FromTupleRight(left, right) {
        return (IsNever(left) ? ExtendsResult.True :
            IsUnknown(left) ? ExtendsResult.False :
                IsAny(left) ? ExtendsResult.Union :
                    ExtendsResult.False);
    }
    // prettier-ignore
    function FromTuple$5(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) && IsObjectArrayLike(right) ? ExtendsResult.True :
                IsArray$1(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True :
                    !IsTuple(right) ? ExtendsResult.False :
                        (IsUndefined$3(left.items) && !IsUndefined$3(right.items)) || (!IsUndefined$3(left.items) && IsUndefined$3(right.items)) ? ExtendsResult.False :
                            (IsUndefined$3(left.items) && !IsUndefined$3(right.items)) ? ExtendsResult.True :
                                left.items.every((schema, index) => Visit$6(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True :
                                    ExtendsResult.False);
    }
    // ------------------------------------------------------------------
    // Uint8Array
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromUint8Array$2(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) ? FromObjectRight(left, right) :
                IsRecord(right) ? FromRecordRight(left, right) :
                    IsUint8Array$1(right) ? ExtendsResult.True :
                        ExtendsResult.False);
    }
    // ------------------------------------------------------------------
    // Undefined
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromUndefined$2(left, right) {
        return (IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject$1(right) ? FromObjectRight(left, right) :
                IsRecord(right) ? FromRecordRight(left, right) :
                    IsVoid(right) ? FromVoidRight(left) :
                        IsUndefined$1(right) ? ExtendsResult.True :
                            ExtendsResult.False);
    }
    // ------------------------------------------------------------------
    // Union
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromUnionRight(left, right) {
        return right.anyOf.some((schema) => Visit$6(left, schema) === ExtendsResult.True)
            ? ExtendsResult.True
            : ExtendsResult.False;
    }
    // prettier-ignore
    function FromUnion$7(left, right) {
        return left.anyOf.every((schema) => Visit$6(schema, right) === ExtendsResult.True)
            ? ExtendsResult.True
            : ExtendsResult.False;
    }
    // ------------------------------------------------------------------
    // Unknown
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromUnknownRight(left, right) {
        return ExtendsResult.True;
    }
    // prettier-ignore
    function FromUnknown$2(left, right) {
        return (IsNever(right) ? FromNeverRight() :
            IsIntersect(right) ? FromIntersectRight(left, right) :
                IsUnion(right) ? FromUnionRight(left, right) :
                    IsAny(right) ? FromAnyRight() :
                        IsString$1(right) ? FromStringRight(left) :
                            IsNumber$1(right) ? FromNumberRight(left) :
                                IsInteger$1(right) ? FromIntegerRight(left) :
                                    IsBoolean$1(right) ? FromBooleanRight(left) :
                                        IsArray$1(right) ? FromArrayRight(left) :
                                            IsTuple(right) ? FromTupleRight(left) :
                                                IsObject$1(right) ? FromObjectRight(left, right) :
                                                    IsUnknown(right) ? ExtendsResult.True :
                                                        ExtendsResult.False);
    }
    // ------------------------------------------------------------------
    // Void
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromVoidRight(left, right) {
        return (IsUndefined$1(left) ? ExtendsResult.True :
            IsUndefined$1(left) ? ExtendsResult.True :
                ExtendsResult.False);
    }
    // prettier-ignore
    function FromVoid$2(left, right) {
        return (IsIntersect(right) ? FromIntersectRight(left, right) :
            IsUnion(right) ? FromUnionRight(left, right) :
                IsUnknown(right) ? FromUnknownRight() :
                    IsAny(right) ? FromAnyRight() :
                        IsObject$1(right) ? FromObjectRight(left, right) :
                            IsVoid(right) ? ExtendsResult.True :
                                ExtendsResult.False);
    }
    // prettier-ignore
    function Visit$6(left, right) {
        return (
        // resolvable
        (IsTemplateLiteral(left) || IsTemplateLiteral(right)) ? FromTemplateLiteral$3(left, right) :
            (IsRegExp(left) || IsRegExp(right)) ? FromRegExp$2(left, right) :
                (IsNot(left) || IsNot(right)) ? FromNot$5(left, right) :
                    // standard
                    IsAny(left) ? FromAny$2(left, right) :
                        IsArray$1(left) ? FromArray$5(left, right) :
                            IsBigInt$1(left) ? FromBigInt$2(left, right) :
                                IsBoolean$1(left) ? FromBoolean$2(left, right) :
                                    IsAsyncIterator$1(left) ? FromAsyncIterator$3(left, right) :
                                        IsConstructor(left) ? FromConstructor$3(left, right) :
                                            IsDate$1(left) ? FromDate$2(left, right) :
                                                IsFunction$1(left) ? FromFunction$3(left, right) :
                                                    IsInteger$1(left) ? FromInteger$2(left, right) :
                                                        IsIntersect(left) ? FromIntersect$7(left, right) :
                                                            IsIterator$1(left) ? FromIterator$3(left, right) :
                                                                IsLiteral(left) ? FromLiteral$2(left, right) :
                                                                    IsNever(left) ? FromNever$2() :
                                                                        IsNull$1(left) ? FromNull$2(left, right) :
                                                                            IsNumber$1(left) ? FromNumber$2(left, right) :
                                                                                IsObject$1(left) ? FromObject$5(left, right) :
                                                                                    IsRecord(left) ? FromRecord$5(left, right) :
                                                                                        IsString$1(left) ? FromString$2(left, right) :
                                                                                            IsSymbol$1(left) ? FromSymbol$2(left, right) :
                                                                                                IsTuple(left) ? FromTuple$5(left, right) :
                                                                                                    IsPromise$1(left) ? FromPromise$3(left, right) :
                                                                                                        IsUint8Array$1(left) ? FromUint8Array$2(left, right) :
                                                                                                            IsUndefined$1(left) ? FromUndefined$2(left, right) :
                                                                                                                IsUnion(left) ? FromUnion$7(left, right) :
                                                                                                                    IsUnknown(left) ? FromUnknown$2(left, right) :
                                                                                                                        IsVoid(left) ? FromVoid$2(left, right) :
                                                                                                                            Throw(`Unknown left type operand '${left[Kind]}'`));
    }
    function ExtendsCheck(left, right) {
        return Visit$6(left, right);
    }

    // prettier-ignore
    function FromProperties$a(P, Right, True, False, options) {
        const Acc = {};
        for (const K2 of globalThis.Object.getOwnPropertyNames(P))
            Acc[K2] = Extends(P[K2], Right, True, False, options);
        return Acc;
    }
    // prettier-ignore
    function FromMappedResult$6(Left, Right, True, False, options) {
        return FromProperties$a(Left.properties, Right, True, False, options);
    }
    // prettier-ignore
    function ExtendsFromMappedResult(Left, Right, True, False, options) {
        const P = FromMappedResult$6(Left, Right, True, False, options);
        return MappedResult(P);
    }

    // prettier-ignore
    function ExtendsResolve(left, right, trueType, falseType) {
        const R = ExtendsCheck(left, right);
        return (R === ExtendsResult.Union ? Union$1([trueType, falseType]) :
            R === ExtendsResult.True ? trueType :
                falseType);
    }
    /** `[Json]` Creates a Conditional type */
    function Extends(L, R, T, F, options = {}) {
        // prettier-ignore
        return (IsMappedResult$1(L) ? ExtendsFromMappedResult(L, R, T, F, options) :
            IsMappedKey$1(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) :
                CloneType(ExtendsResolve(L, R, T, F), options));
    }

    // prettier-ignore
    function FromPropertyKey$2(K, U, L, R, options) {
        return {
            [K]: Extends(Literal(K), U, L, R, options)
        };
    }
    // prettier-ignore
    function FromPropertyKeys$2(K, U, L, R, options) {
        return K.reduce((Acc, LK) => {
            return { ...Acc, ...FromPropertyKey$2(LK, U, L, R, options) };
        }, {});
    }
    // prettier-ignore
    function FromMappedKey$2(K, U, L, R, options) {
        return FromPropertyKeys$2(K.keys, U, L, R, options);
    }
    // prettier-ignore
    function ExtendsFromMappedKey(T, U, L, R, options) {
        const P = FromMappedKey$2(T, U, L, R, options);
        return MappedResult(P);
    }

    /** Fast undefined check used for properties of type undefined */
    function Intersect(schema) {
        return schema.allOf.every((schema) => ExtendsUndefinedCheck(schema));
    }
    function Union(schema) {
        return schema.anyOf.some((schema) => ExtendsUndefinedCheck(schema));
    }
    function Not$1(schema) {
        return !ExtendsUndefinedCheck(schema.not);
    }
    /** Fast undefined check used for properties of type undefined */
    // prettier-ignore
    function ExtendsUndefinedCheck(schema) {
        return (schema[Kind] === 'Intersect' ? Intersect(schema) :
            schema[Kind] === 'Union' ? Union(schema) :
                schema[Kind] === 'Not' ? Not$1(schema) :
                    schema[Kind] === 'Undefined' ? true :
                        false);
    }

    function ExcludeFromTemplateLiteral(L, R) {
        return Exclude(TemplateLiteralToUnion(L), R);
    }

    function ExcludeRest(L, R) {
        const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
        return excluded.length === 1 ? excluded[0] : Union$1(excluded);
    }
    /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
    function Exclude(L, R, options = {}) {
        // overloads
        if (IsTemplateLiteral$1(L))
            return CloneType(ExcludeFromTemplateLiteral(L, R), options);
        if (IsMappedResult$1(L))
            return CloneType(ExcludeFromMappedResult(L, R), options);
        // prettier-ignore
        return CloneType(IsUnion$1(L) ? ExcludeRest(L.anyOf, R) :
            ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
    }

    // prettier-ignore
    function FromProperties$9(P, U) {
        const Acc = {};
        for (const K2 of globalThis.Object.getOwnPropertyNames(P))
            Acc[K2] = Exclude(P[K2], U);
        return Acc;
    }
    // prettier-ignore
    function FromMappedResult$5(R, T) {
        return FromProperties$9(R.properties, T);
    }
    // prettier-ignore
    function ExcludeFromMappedResult(R, T) {
        const P = FromMappedResult$5(R, T);
        return MappedResult(P);
    }

    function ExtractFromTemplateLiteral(L, R) {
        return Extract(TemplateLiteralToUnion(L), R);
    }

    function ExtractRest(L, R) {
        const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
        return extracted.length === 1 ? extracted[0] : Union$1(extracted);
    }
    /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
    function Extract(L, R, options = {}) {
        // overloads
        if (IsTemplateLiteral$1(L))
            return CloneType(ExtractFromTemplateLiteral(L, R), options);
        if (IsMappedResult$1(L))
            return CloneType(ExtractFromMappedResult(L, R), options);
        // prettier-ignore
        return CloneType(IsUnion$1(L) ? ExtractRest(L.anyOf, R) :
            ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
    }

    // prettier-ignore
    function FromProperties$8(P, T) {
        const Acc = {};
        for (const K2 of globalThis.Object.getOwnPropertyNames(P))
            Acc[K2] = Extract(P[K2], T);
        return Acc;
    }
    // prettier-ignore
    function FromMappedResult$4(R, T) {
        return FromProperties$8(R.properties, T);
    }
    // prettier-ignore
    function ExtractFromMappedResult(R, T) {
        const P = FromMappedResult$4(R, T);
        return MappedResult(P);
    }

    /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
    function InstanceType(schema, options = {}) {
        return CloneType(schema.returns, options);
    }

    /** `[Json]` Creates an Integer type */
    function Integer(options = {}) {
        return {
            ...options,
            [Kind]: 'Integer',
            type: 'integer',
        };
    }

    // prettier-ignore
    function MappedIntrinsicPropertyKey(K, M, options) {
        return {
            [K]: Intrinsic(Literal(K), M, options)
        };
    }
    // prettier-ignore
    function MappedIntrinsicPropertyKeys(K, M, options) {
        return K.reduce((Acc, L) => {
            return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
        }, {});
    }
    // prettier-ignore
    function MappedIntrinsicProperties(T, M, options) {
        return MappedIntrinsicPropertyKeys(T['keys'], M, options);
    }
    // prettier-ignore
    function IntrinsicFromMappedKey(T, M, options) {
        const P = MappedIntrinsicProperties(T, M, options);
        return MappedResult(P);
    }

    // ------------------------------------------------------------------
    // Apply
    // ------------------------------------------------------------------
    function ApplyUncapitalize(value) {
        const [first, rest] = [value.slice(0, 1), value.slice(1)];
        return [first.toLowerCase(), rest].join('');
    }
    function ApplyCapitalize(value) {
        const [first, rest] = [value.slice(0, 1), value.slice(1)];
        return [first.toUpperCase(), rest].join('');
    }
    function ApplyUppercase(value) {
        return value.toUpperCase();
    }
    function ApplyLowercase(value) {
        return value.toLowerCase();
    }
    function FromTemplateLiteral$2(schema, mode, options) {
        // note: template literals require special runtime handling as they are encoded in string patterns.
        // This diverges from the mapped type which would otherwise map on the template literal kind.
        const expression = TemplateLiteralParseExact(schema.pattern);
        const finite = IsTemplateLiteralExpressionFinite(expression);
        if (!finite)
            return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
        const strings = [...TemplateLiteralExpressionGenerate(expression)];
        const literals = strings.map((value) => Literal(value));
        const mapped = FromRest$2(literals, mode);
        const union = Union$1(mapped);
        return TemplateLiteral([union], options);
    }
    // prettier-ignore
    function FromLiteralValue(value, mode) {
        return (typeof value === 'string' ? (mode === 'Uncapitalize' ? ApplyUncapitalize(value) :
            mode === 'Capitalize' ? ApplyCapitalize(value) :
                mode === 'Uppercase' ? ApplyUppercase(value) :
                    mode === 'Lowercase' ? ApplyLowercase(value) :
                        value) : value.toString());
    }
    // prettier-ignore
    function FromRest$2(T, M) {
        return T.map(L => Intrinsic(L, M));
    }
    /** Applies an intrinsic string manipulation to the given type. */
    function Intrinsic(schema, mode, options = {}) {
        // prettier-ignore
        return (
        // Intrinsic-Mapped-Inference
        IsMappedKey$1(schema) ? IntrinsicFromMappedKey(schema, mode, options) :
            // Standard-Inference
            IsTemplateLiteral$1(schema) ? FromTemplateLiteral$2(schema, mode, schema) :
                IsUnion$1(schema) ? Union$1(FromRest$2(schema.anyOf, mode), options) :
                    IsLiteral$1(schema) ? Literal(FromLiteralValue(schema.const, mode), options) :
                        schema);
    }

    /** `[Json]` Intrinsic function to Capitalize LiteralString types */
    function Capitalize(T, options = {}) {
        return Intrinsic(T, 'Capitalize', options);
    }

    /** `[Json]` Intrinsic function to Lowercase LiteralString types */
    function Lowercase(T, options = {}) {
        return Intrinsic(T, 'Lowercase', options);
    }

    /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
    function Uncapitalize(T, options = {}) {
        return Intrinsic(T, 'Uncapitalize', options);
    }

    /** `[Json]` Intrinsic function to Uppercase LiteralString types */
    function Uppercase(T, options = {}) {
        return Intrinsic(T, 'Uppercase', options);
    }

    /** `[Json]` Creates a Not type */
    function Not(schema, options) {
        return {
            ...options,
            [Kind]: 'Not',
            not: CloneType(schema),
        };
    }

    // prettier-ignore
    function FromProperties$7(P, K, options) {
        const Acc = {};
        for (const K2 of globalThis.Object.getOwnPropertyNames(P))
            Acc[K2] = Omit(P[K2], K, options);
        return Acc;
    }
    // prettier-ignore
    function FromMappedResult$3(R, K, options) {
        return FromProperties$7(R.properties, K, options);
    }
    // prettier-ignore
    function OmitFromMappedResult(R, K, options) {
        const P = FromMappedResult$3(R, K, options);
        return MappedResult(P);
    }

    // prettier-ignore
    function FromIntersect$6(T, K) {
        return T.map((T) => OmitResolve(T, K));
    }
    // prettier-ignore
    function FromUnion$6(T, K) {
        return T.map((T) => OmitResolve(T, K));
    }
    // ------------------------------------------------------------------
    // FromProperty
    // ------------------------------------------------------------------
    // prettier-ignore
    function FromProperty(T, K) {
        const { [K]: _, ...R } = T;
        return R;
    }
    // prettier-ignore
    function FromProperties$6(T, K) {
        return K.reduce((T, K2) => FromProperty(T, K2), T);
    }
    // ------------------------------------------------------------------
    // OmitResolve
    // ------------------------------------------------------------------
    // prettier-ignore
    function OmitResolve(T, K) {
        return (IsIntersect$1(T) ? Intersect$1(FromIntersect$6(T.allOf, K)) :
            IsUnion$1(T) ? Union$1(FromUnion$6(T.anyOf, K)) :
                IsObject$2(T) ? Object$1(FromProperties$6(T.properties, K)) :
                    Object$1({}));
    }
    function Omit(T, K, options = {}) {
        // mapped
        if (IsMappedKey$1(K))
            return OmitFromMappedKey(T, K, options);
        if (IsMappedResult$1(T))
            return OmitFromMappedResult(T, K, options);
        // non-mapped
        const I = IsSchema$1(K) ? IndexPropertyKeys(K) : K;
        const D = Discard(T, [TransformKind, '$id', 'required']);
        const R = CloneType(OmitResolve(T, I), options);
        return { ...D, ...R };
    }

    // prettier-ignore
    function FromPropertyKey$1(T, K, options) {
        return {
            [K]: Omit(T, [K], options)
        };
    }
    // prettier-ignore
    function FromPropertyKeys$1(T, K, options) {
        return K.reduce((Acc, LK) => {
            return { ...Acc, ...FromPropertyKey$1(T, LK, options) };
        }, {});
    }
    // prettier-ignore
    function FromMappedKey$1(T, K, options) {
        return FromPropertyKeys$1(T, K.keys, options);
    }
    // prettier-ignore
    function OmitFromMappedKey(T, K, options) {
        const P = FromMappedKey$1(T, K, options);
        return MappedResult(P);
    }

    /** `[JavaScript]` Extracts the Parameters from the given Function type */
    function Parameters(schema, options = {}) {
        return Tuple(CloneRest(schema.parameters), { ...options });
    }

    // prettier-ignore
    function FromRest$1(T) {
        return T.map(L => PartialResolve(L));
    }
    // prettier-ignore
    function FromProperties$5(T) {
        const Acc = {};
        for (const K of globalThis.Object.getOwnPropertyNames(T))
            Acc[K] = Optional(T[K]);
        return Acc;
    }
    // ------------------------------------------------------------------
    // PartialResolve
    // ------------------------------------------------------------------
    // prettier-ignore
    function PartialResolve(T) {
        return (IsIntersect$1(T) ? Intersect$1(FromRest$1(T.allOf)) :
            IsUnion$1(T) ? Union$1(FromRest$1(T.anyOf)) :
                IsObject$2(T) ? Object$1(FromProperties$5(T.properties)) :
                    Object$1({}));
    }
    /** `[Json]` Constructs a type where all properties are optional */
    function Partial(T, options = {}) {
        if (IsMappedResult$1(T))
            return PartialFromMappedResult(T, options);
        const D = Discard(T, [TransformKind, '$id', 'required']);
        const R = CloneType(PartialResolve(T), options);
        return { ...D, ...R };
    }

    // prettier-ignore
    function FromProperties$4(K, options) {
        const Acc = {};
        for (const K2 of globalThis.Object.getOwnPropertyNames(K))
            Acc[K2] = Partial(K[K2], options);
        return Acc;
    }
    // prettier-ignore
    function FromMappedResult$2(R, options) {
        return FromProperties$4(R.properties, options);
    }
    // prettier-ignore
    function PartialFromMappedResult(R, options) {
        const P = FromMappedResult$2(R, options);
        return MappedResult(P);
    }

    // prettier-ignore
    function FromProperties$3(P, K, options) {
        const Acc = {};
        for (const K2 of globalThis.Object.getOwnPropertyNames(P))
            Acc[K2] = Pick(P[K2], K, options);
        return Acc;
    }
    // prettier-ignore
    function FromMappedResult$1(R, K, options) {
        return FromProperties$3(R.properties, K, options);
    }
    // prettier-ignore
    function PickFromMappedResult(R, K, options) {
        const P = FromMappedResult$1(R, K, options);
        return MappedResult(P);
    }

    function FromIntersect$5(T, K) {
        return T.map((T) => PickResolve(T, K));
    }
    // prettier-ignore
    function FromUnion$5(T, K) {
        return T.map((T) => PickResolve(T, K));
    }
    // prettier-ignore
    function FromProperties$2(T, K) {
        const Acc = {};
        for (const K2 of K)
            if (K2 in T)
                Acc[K2] = T[K2];
        return Acc;
    }
    // ------------------------------------------------------------------
    // PickResolve
    // ------------------------------------------------------------------
    // prettier-ignore
    function PickResolve(T, K) {
        return (IsIntersect$1(T) ? Intersect$1(FromIntersect$5(T.allOf, K)) :
            IsUnion$1(T) ? Union$1(FromUnion$5(T.anyOf, K)) :
                IsObject$2(T) ? Object$1(FromProperties$2(T.properties, K)) :
                    Object$1({}));
    }
    function Pick(T, K, options = {}) {
        // mapped
        if (IsMappedKey$1(K))
            return PickFromMappedKey(T, K, options);
        if (IsMappedResult$1(T))
            return PickFromMappedResult(T, K, options);
        // non-mapped
        const I = IsSchema$1(K) ? IndexPropertyKeys(K) : K;
        const D = Discard(T, [TransformKind, '$id', 'required']);
        const R = CloneType(PickResolve(T, I), options);
        return { ...D, ...R };
    }

    // prettier-ignore
    function FromPropertyKey(T, K, options) {
        return {
            [K]: Pick(T, [K], options)
        };
    }
    // prettier-ignore
    function FromPropertyKeys(T, K, options) {
        return K.reduce((Acc, LK) => {
            return { ...Acc, ...FromPropertyKey(T, LK, options) };
        }, {});
    }
    // prettier-ignore
    function FromMappedKey(T, K, options) {
        return FromPropertyKeys(T, K.keys, options);
    }
    // prettier-ignore
    function PickFromMappedKey(T, K, options) {
        const P = FromMappedKey(T, K, options);
        return MappedResult(P);
    }

    /** `[Json]` Creates a Readonly and Optional property */
    function ReadonlyOptional(schema) {
        return Readonly(Optional(schema));
    }

    // ------------------------------------------------------------------
    // RecordCreateFromPattern
    // ------------------------------------------------------------------
    // prettier-ignore
    function RecordCreateFromPattern(pattern, T, options) {
        return {
            ...options,
            [Kind]: 'Record',
            type: 'object',
            patternProperties: { [pattern]: CloneType(T) }
        };
    }
    // ------------------------------------------------------------------
    // RecordCreateFromKeys
    // ------------------------------------------------------------------
    // prettier-ignore
    function RecordCreateFromKeys(K, T, options) {
        const Acc = {};
        for (const K2 of K)
            Acc[K2] = CloneType(T);
        return Object$1(Acc, { ...options, [Hint]: 'Record' });
    }
    // prettier-ignore
    function FromTemplateLiteralKey(K, T, options) {
        return (IsTemplateLiteralFinite(K)
            ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options)
            : RecordCreateFromPattern(K.pattern, T, options));
    }
    // prettier-ignore
    function FromUnionKey(K, T, options) {
        return RecordCreateFromKeys(IndexPropertyKeys(Union$1(K)), T, options);
    }
    // prettier-ignore
    function FromLiteralKey(K, T, options) {
        return RecordCreateFromKeys([K.toString()], T, options);
    }
    // prettier-ignore
    function FromRegExpKey(K, T, options) {
        return RecordCreateFromPattern(K.source, T, options);
    }
    // prettier-ignore
    function FromStringKey(K, T, options) {
        const pattern = IsUndefined$3(K.pattern) ? PatternStringExact : K.pattern;
        return RecordCreateFromPattern(pattern, T, options);
    }
    // prettier-ignore
    function FromAnyKey(K, T, options) {
        return RecordCreateFromPattern(PatternStringExact, T, options);
    }
    // prettier-ignore
    function FromNeverKey(K, T, options) {
        return RecordCreateFromPattern(PatternNeverExact, T, options);
    }
    // prettier-ignore
    function FromIntegerKey(_, T, options) {
        return RecordCreateFromPattern(PatternNumberExact, T, options);
    }
    // prettier-ignore
    function FromNumberKey(_, T, options) {
        return RecordCreateFromPattern(PatternNumberExact, T, options);
    }
    // ------------------------------------------------------------------
    // TRecordOrObject
    // ------------------------------------------------------------------
    /** `[Json]` Creates a Record type */
    function Record(K, T, options = {}) {
        // prettier-ignore
        return (IsUnion$1(K) ? FromUnionKey(K.anyOf, T, options) :
            IsTemplateLiteral$1(K) ? FromTemplateLiteralKey(K, T, options) :
                IsLiteral$1(K) ? FromLiteralKey(K.const, T, options) :
                    IsInteger$2(K) ? FromIntegerKey(K, T, options) :
                        IsNumber$2(K) ? FromNumberKey(K, T, options) :
                            IsRegExp$1(K) ? FromRegExpKey(K, T, options) :
                                IsString$2(K) ? FromStringKey(K, T, options) :
                                    IsAny$1(K) ? FromAnyKey(K, T, options) :
                                        IsNever$1(K) ? FromNeverKey(K, T, options) :
                                            Never(options));
    }

    // Auto Tracked For Recursive Types without ID's
    let Ordinal = 0;
    /** `[Json]` Creates a Recursive type */
    function Recursive(callback, options = {}) {
        if (IsUndefined$3(options.$id))
            options.$id = `T${Ordinal++}`;
        const thisType = callback({ [Kind]: 'This', $ref: `${options.$id}` });
        thisType.$id = options.$id;
        // prettier-ignore
        return CloneType({ ...options, [Hint]: 'Recursive', ...thisType });
    }

    /** `[Json]` Creates a Ref type. */
    function Ref(unresolved, options = {}) {
        if (IsString$3(unresolved))
            return { ...options, [Kind]: 'Ref', $ref: unresolved };
        if (IsUndefined$3(unresolved.$id))
            throw new Error('Reference target type must specify an $id');
        return {
            ...options,
            [Kind]: 'Ref',
            $ref: unresolved.$id,
        };
    }

    /** `[JavaScript]` Creates a RegExp type */
    function RegExp$1(unresolved, options = {}) {
        const expr = IsString$3(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
        return { ...options, [Kind]: 'RegExp', type: 'RegExp', source: expr.source, flags: expr.flags };
    }

    // prettier-ignore
    function FromRest(T) {
        return T.map(L => RequiredResolve(L));
    }
    // prettier-ignore
    function FromProperties$1(T) {
        const Acc = {};
        for (const K of globalThis.Object.getOwnPropertyNames(T))
            Acc[K] = Discard(T[K], [OptionalKind]);
        return Acc;
    }
    // ------------------------------------------------------------------
    // RequiredResolve
    // ------------------------------------------------------------------
    // prettier-ignore
    function RequiredResolve(T) {
        return (IsIntersect$1(T) ? Intersect$1(FromRest(T.allOf)) :
            IsUnion$1(T) ? Union$1(FromRest(T.anyOf)) :
                IsObject$2(T) ? Object$1(FromProperties$1(T.properties)) :
                    Object$1({}));
    }
    /** `[Json]` Constructs a type where all properties are required */
    function Required(T, options = {}) {
        if (IsMappedResult$1(T)) {
            return RequiredFromMappedResult(T, options);
        }
        else {
            const D = Discard(T, [TransformKind, '$id', 'required']);
            const R = CloneType(RequiredResolve(T), options);
            return { ...D, ...R };
        }
    }

    // prettier-ignore
    function FromProperties(P, options) {
        const Acc = {};
        for (const K2 of globalThis.Object.getOwnPropertyNames(P))
            Acc[K2] = Required(P[K2], options);
        return Acc;
    }
    // prettier-ignore
    function FromMappedResult(R, options) {
        return FromProperties(R.properties, options);
    }
    // prettier-ignore
    function RequiredFromMappedResult(R, options) {
        const P = FromMappedResult(R, options);
        return MappedResult(P);
    }

    // prettier-ignore
    function RestResolve(T) {
        return (IsIntersect$1(T) ? CloneRest(T.allOf) :
            IsUnion$1(T) ? CloneRest(T.anyOf) :
                IsTuple$1(T) ? CloneRest(T.items ?? []) :
                    []);
    }
    /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
    function Rest(T) {
        return CloneRest(RestResolve(T));
    }

    /** `[JavaScript]` Extracts the ReturnType from the given Function type */
    function ReturnType(schema, options = {}) {
        return CloneType(schema.returns, options);
    }

    /** `[Json]` Omits compositing symbols from this schema. */
    function Strict(schema) {
        return JSON.parse(JSON.stringify(schema));
    }

    // ------------------------------------------------------------------
    // TransformBuilders
    // ------------------------------------------------------------------
    class TransformDecodeBuilder {
        constructor(schema) {
            this.schema = schema;
        }
        Decode(decode) {
            return new TransformEncodeBuilder(this.schema, decode);
        }
    }
    // prettier-ignore
    class TransformEncodeBuilder {
        constructor(schema, decode) {
            this.schema = schema;
            this.decode = decode;
        }
        EncodeTransform(encode, schema) {
            const Encode = (value) => schema[TransformKind].Encode(encode(value));
            const Decode = (value) => this.decode(schema[TransformKind].Decode(value));
            const Codec = { Encode: Encode, Decode: Decode };
            return { ...schema, [TransformKind]: Codec };
        }
        EncodeSchema(encode, schema) {
            const Codec = { Decode: this.decode, Encode: encode };
            return { ...schema, [TransformKind]: Codec };
        }
        Encode(encode) {
            const schema = CloneType(this.schema);
            return (IsTransform$1(schema) ? this.EncodeTransform(encode, schema) : this.EncodeSchema(encode, schema));
        }
    }
    /** `[Json]` Creates a Transform type */
    function Transform(schema) {
        return new TransformDecodeBuilder(schema);
    }

    /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
    function Unsafe(options = {}) {
        return {
            ...options,
            [Kind]: options[Kind] ?? 'Unsafe',
        };
    }

    /** `[JavaScript]` Creates a Void type */
    function Void(options = {}) {
        return {
            ...options,
            [Kind]: 'Void',
            type: 'void',
        };
    }

    // ------------------------------------------------------------------
    // Type: Module
    // ------------------------------------------------------------------

    var TypeBuilder = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Any: Any,
        Array: Array$1,
        AsyncIterator: AsyncIterator,
        Awaited: Awaited,
        BigInt: BigInt$1,
        Boolean: Boolean$1,
        Capitalize: Capitalize,
        Composite: Composite,
        Const: Const,
        Constructor: Constructor,
        ConstructorParameters: ConstructorParameters,
        Date: Date$1,
        Deref: Deref$1,
        Enum: Enum,
        Exclude: Exclude,
        Extends: Extends,
        Extract: Extract,
        Function: Function$1,
        Index: Index,
        InstanceType: InstanceType,
        Integer: Integer,
        Intersect: Intersect$1,
        Iterator: Iterator,
        KeyOf: KeyOf,
        Literal: Literal,
        Lowercase: Lowercase,
        Mapped: Mapped,
        Never: Never,
        Not: Not,
        Null: Null,
        Number: Number$1,
        Object: Object$1,
        Omit: Omit,
        Optional: Optional,
        Parameters: Parameters,
        Partial: Partial,
        Pick: Pick,
        Promise: Promise$1,
        Readonly: Readonly,
        ReadonlyOptional: ReadonlyOptional,
        Record: Record,
        Recursive: Recursive,
        Ref: Ref,
        RegExp: RegExp$1,
        Required: Required,
        Rest: Rest,
        ReturnType: ReturnType,
        Strict: Strict,
        String: String$1,
        Symbol: Symbol$1,
        TemplateLiteral: TemplateLiteral,
        Transform: Transform,
        Tuple: Tuple,
        Uint8Array: Uint8Array$1,
        Uncapitalize: Uncapitalize,
        Undefined: Undefined,
        Union: Union$1,
        Unknown: Unknown,
        Unsafe: Unsafe,
        Uppercase: Uppercase,
        Void: Void
    });

    // ------------------------------------------------------------------
    // JsonTypeBuilder
    // ------------------------------------------------------------------
    /** JavaScript Type Builder with Static Resolution for TypeScript */
    const Type = TypeBuilder;

    const QueueOptionsSchema = Type.Object({
        // TODO: adds func type to json schema which is not supported
        //_queue?: Queue;
        concurrency: Type.Optional(Type.Number()),
        timeout: Type.Optional(Type.Number()), // TODO
    }, {
        additionalProperties: false,
        title: "QueueOptions",
    });
    class Queue {
        constructor(opts = {}) {
            this.concurrency = 1;
            this._running = 0;
            this._queue = [];
            if (opts.concurrency)
                this.concurrency = opts.concurrency;
        }
        runNext() {
            const job = this._queue.shift();
            if (!job)
                return;
            this._running++;
            job
                .func()
                .then((result) => job.resolve(result))
                .catch((error) => job.reject(error))
                .finally(() => {
                this._running--;
                this.checkQueue();
            });
        }
        checkQueue() {
            if (this._running < this.concurrency)
                this.runNext();
        }
        add(func) {
            return new Promise((resolve, reject) => {
                this._queue.push({ func, resolve, reject });
                this.checkQueue();
            });
        }
    }

    // Yahoo's servers returned an HTTP 400 for this request.
    class BadRequestError extends Error {
        constructor() {
            super(...arguments);
            this.name = "BadRequestError";
        }
    }
    // Yahoo's servers returned a 'not-ok' status for this request.
    // https://developer.mozilla.org/en-US/docs/Web/API/Response/ok
    class HTTPError extends Error {
        constructor() {
            super(...arguments);
            this.name = "HTTPError";
        }
    }
    // A YahooFinance method was called with invalid options.
    class InvalidOptionsError extends Error {
        constructor() {
            super(...arguments);
            this.name = "InvalidOptionsError";
        }
    }
    // An internal method yahooFinanceFetch() was called without this._env set.
    class NoEnvironmentError extends Error {
        constructor() {
            super(...arguments);
            this.name = "NoEnvironmentError";
        }
    }
    class FailedYahooValidationError extends Error {
        constructor(message, { result, errors }) {
            super(message);
            this.name = "FailedYahooValidationError";
            this.result = result;
            this.errors = errors;
        }
    }
    const errors$1 = {
        BadRequestError,
        HTTPError,
        InvalidOptionsError,
        NoEnvironmentError,
        FailedYahooValidationError,
    };

    var name = "yahoo-finance2";
    var version$1 = "2.13.3";
    var repository = "https://github.com/gadicc/node-yahoo-finance2";
    var pkg = {
    	name: name,
    	version: version$1,
    	repository: repository};

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getAugmentedNamespace(n) {
      if (n.__esModule) return n;
      var f = n.default;
    	if (typeof f == "function") {
    		var a = function a () {
    			if (this instanceof a) {
            return Reflect.construct(f, arguments, this.constructor);
    			}
    			return f.apply(this, arguments);
    		};
    		a.prototype = f.prototype;
      } else a = {};
      Object.defineProperty(a, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    var cookie = {};

    /** Highest positive signed 32-bit float value */
    const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

    /** Bootstring parameters */
    const base = 36;
    const tMin = 1;
    const tMax = 26;
    const skew = 38;
    const damp = 700;
    const initialBias = 72;
    const initialN = 128; // 0x80
    const delimiter = '-'; // '\x2D'

    /** Regular expressions */
    const regexPunycode = /^xn--/;
    const regexNonASCII = /[^\0-\x7F]/; // Note: U+007F DEL is excluded too.
    const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

    /** Error messages */
    const errors = {
    	'overflow': 'Overflow: input needs wider integers to process',
    	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    	'invalid-input': 'Invalid input'
    };

    /** Convenience shortcuts */
    const baseMinusTMin = base - tMin;
    const floor = Math.floor;
    const stringFromCharCode = String.fromCharCode;

    /*--------------------------------------------------------------------------*/

    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    function error(type) {
    	throw new RangeError(errors[type]);
    }

    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    function map(array, callback) {
    	const result = [];
    	let length = array.length;
    	while (length--) {
    		result[length] = callback(array[length]);
    	}
    	return result;
    }

    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {String} A new string of characters returned by the callback
     * function.
     */
    function mapDomain(domain, callback) {
    	const parts = domain.split('@');
    	let result = '';
    	if (parts.length > 1) {
    		// In email addresses, only the domain name should be punycoded. Leave
    		// the local part (i.e. everything up to `@`) intact.
    		result = parts[0] + '@';
    		domain = parts[1];
    	}
    	// Avoid `split(regex)` for IE8 compatibility. See #17.
    	domain = domain.replace(regexSeparators, '\x2E');
    	const labels = domain.split('.');
    	const encoded = map(labels, callback).join('.');
    	return result + encoded;
    }

    /**
     * Creates an array containing the numeric code points of each Unicode
     * character in the string. While JavaScript uses UCS-2 internally,
     * this function will convert a pair of surrogate halves (each of which
     * UCS-2 exposes as separate characters) into a single code point,
     * matching UTF-16.
     * @see `punycode.ucs2.encode`
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode.ucs2
     * @name decode
     * @param {String} string The Unicode input string (UCS-2).
     * @returns {Array} The new array of code points.
     */
    function ucs2decode(string) {
    	const output = [];
    	let counter = 0;
    	const length = string.length;
    	while (counter < length) {
    		const value = string.charCodeAt(counter++);
    		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
    			// It's a high surrogate, and there is a next character.
    			const extra = string.charCodeAt(counter++);
    			if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
    				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
    			} else {
    				// It's an unmatched surrogate; only append this code unit, in case the
    				// next code unit is the high surrogate of a surrogate pair.
    				output.push(value);
    				counter--;
    			}
    		} else {
    			output.push(value);
    		}
    	}
    	return output;
    }

    /**
     * Creates a string based on an array of numeric code points.
     * @see `punycode.ucs2.decode`
     * @memberOf punycode.ucs2
     * @name encode
     * @param {Array} codePoints The array of numeric code points.
     * @returns {String} The new Unicode string (UCS-2).
     */
    const ucs2encode = codePoints => String.fromCodePoint(...codePoints);

    /**
     * Converts a basic code point into a digit/integer.
     * @see `digitToBasic()`
     * @private
     * @param {Number} codePoint The basic numeric code point value.
     * @returns {Number} The numeric value of a basic code point (for use in
     * representing integers) in the range `0` to `base - 1`, or `base` if
     * the code point does not represent a value.
     */
    const basicToDigit = function(codePoint) {
    	if (codePoint >= 0x30 && codePoint < 0x3A) {
    		return 26 + (codePoint - 0x30);
    	}
    	if (codePoint >= 0x41 && codePoint < 0x5B) {
    		return codePoint - 0x41;
    	}
    	if (codePoint >= 0x61 && codePoint < 0x7B) {
    		return codePoint - 0x61;
    	}
    	return base;
    };

    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    const digitToBasic = function(digit, flag) {
    	//  0..25 map to ASCII a..z or A..Z
    	// 26..35 map to ASCII 0..9
    	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };

    /**
     * Bias adaptation function as per section 3.4 of RFC 3492.
     * https://tools.ietf.org/html/rfc3492#section-3.4
     * @private
     */
    const adapt = function(delta, numPoints, firstTime) {
    	let k = 0;
    	delta = firstTime ? floor(delta / damp) : delta >> 1;
    	delta += floor(delta / numPoints);
    	for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
    		delta = floor(delta / baseMinusTMin);
    	}
    	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };

    /**
     * Converts a Punycode string of ASCII-only symbols to a string of Unicode
     * symbols.
     * @memberOf punycode
     * @param {String} input The Punycode string of ASCII-only symbols.
     * @returns {String} The resulting string of Unicode symbols.
     */
    const decode = function(input) {
    	// Don't use UCS-2.
    	const output = [];
    	const inputLength = input.length;
    	let i = 0;
    	let n = initialN;
    	let bias = initialBias;

    	// Handle the basic code points: let `basic` be the number of input code
    	// points before the last delimiter, or `0` if there is none, then copy
    	// the first basic code points to the output.

    	let basic = input.lastIndexOf(delimiter);
    	if (basic < 0) {
    		basic = 0;
    	}

    	for (let j = 0; j < basic; ++j) {
    		// if it's not a basic code point
    		if (input.charCodeAt(j) >= 0x80) {
    			error('not-basic');
    		}
    		output.push(input.charCodeAt(j));
    	}

    	// Main decoding loop: start just after the last delimiter if any basic code
    	// points were copied; start at the beginning otherwise.

    	for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

    		// `index` is the index of the next character to be consumed.
    		// Decode a generalized variable-length integer into `delta`,
    		// which gets added to `i`. The overflow checking is easier
    		// if we increase `i` as we go, then subtract off its starting
    		// value at the end to obtain `delta`.
    		const oldi = i;
    		for (let w = 1, k = base; /* no condition */; k += base) {

    			if (index >= inputLength) {
    				error('invalid-input');
    			}

    			const digit = basicToDigit(input.charCodeAt(index++));

    			if (digit >= base) {
    				error('invalid-input');
    			}
    			if (digit > floor((maxInt - i) / w)) {
    				error('overflow');
    			}

    			i += digit * w;
    			const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

    			if (digit < t) {
    				break;
    			}

    			const baseMinusT = base - t;
    			if (w > floor(maxInt / baseMinusT)) {
    				error('overflow');
    			}

    			w *= baseMinusT;

    		}

    		const out = output.length + 1;
    		bias = adapt(i - oldi, out, oldi == 0);

    		// `i` was supposed to wrap around from `out` to `0`,
    		// incrementing `n` each time, so we'll fix that now:
    		if (floor(i / out) > maxInt - n) {
    			error('overflow');
    		}

    		n += floor(i / out);
    		i %= out;

    		// Insert `n` at position `i` of the output.
    		output.splice(i++, 0, n);

    	}

    	return String.fromCodePoint(...output);
    };

    /**
     * Converts a string of Unicode symbols (e.g. a domain name label) to a
     * Punycode string of ASCII-only symbols.
     * @memberOf punycode
     * @param {String} input The string of Unicode symbols.
     * @returns {String} The resulting Punycode string of ASCII-only symbols.
     */
    const encode = function(input) {
    	const output = [];

    	// Convert the input in UCS-2 to an array of Unicode code points.
    	input = ucs2decode(input);

    	// Cache the length.
    	const inputLength = input.length;

    	// Initialize the state.
    	let n = initialN;
    	let delta = 0;
    	let bias = initialBias;

    	// Handle the basic code points.
    	for (const currentValue of input) {
    		if (currentValue < 0x80) {
    			output.push(stringFromCharCode(currentValue));
    		}
    	}

    	const basicLength = output.length;
    	let handledCPCount = basicLength;

    	// `handledCPCount` is the number of code points that have been handled;
    	// `basicLength` is the number of basic code points.

    	// Finish the basic string with a delimiter unless it's empty.
    	if (basicLength) {
    		output.push(delimiter);
    	}

    	// Main encoding loop:
    	while (handledCPCount < inputLength) {

    		// All non-basic code points < n have been handled already. Find the next
    		// larger one:
    		let m = maxInt;
    		for (const currentValue of input) {
    			if (currentValue >= n && currentValue < m) {
    				m = currentValue;
    			}
    		}

    		// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
    		// but guard against overflow.
    		const handledCPCountPlusOne = handledCPCount + 1;
    		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
    			error('overflow');
    		}

    		delta += (m - n) * handledCPCountPlusOne;
    		n = m;

    		for (const currentValue of input) {
    			if (currentValue < n && ++delta > maxInt) {
    				error('overflow');
    			}
    			if (currentValue === n) {
    				// Represent delta as a generalized variable-length integer.
    				let q = delta;
    				for (let k = base; /* no condition */; k += base) {
    					const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
    					if (q < t) {
    						break;
    					}
    					const qMinusT = q - t;
    					const baseMinusT = base - t;
    					output.push(
    						stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
    					);
    					q = floor(qMinusT / baseMinusT);
    				}

    				output.push(stringFromCharCode(digitToBasic(q, 0)));
    				bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
    				delta = 0;
    				++handledCPCount;
    			}
    		}

    		++delta;
    		++n;

    	}
    	return output.join('');
    };

    /**
     * Converts a Punycode string representing a domain name or an email address
     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
     * it doesn't matter if you call it on a string that has already been
     * converted to Unicode.
     * @memberOf punycode
     * @param {String} input The Punycoded domain name or email address to
     * convert to Unicode.
     * @returns {String} The Unicode representation of the given Punycode
     * string.
     */
    const toUnicode = function(input) {
    	return mapDomain(input, function(string) {
    		return regexPunycode.test(string)
    			? decode(string.slice(4).toLowerCase())
    			: string;
    	});
    };

    /**
     * Converts a Unicode string representing a domain name or an email address to
     * Punycode. Only the non-ASCII parts of the domain name will be converted,
     * i.e. it doesn't matter if you call it with a domain that's already in
     * ASCII.
     * @memberOf punycode
     * @param {String} input The domain name or email address to convert, as a
     * Unicode string.
     * @returns {String} The Punycode representation of the given domain name or
     * email address.
     */
    const toASCII = function(input) {
    	return mapDomain(input, function(string) {
    		return regexNonASCII.test(string)
    			? 'xn--' + encode(string)
    			: string;
    	});
    };

    /*--------------------------------------------------------------------------*/

    /** Define the public API */
    const punycode = {
    	/**
    	 * A string representing the current Punycode.js version number.
    	 * @memberOf punycode
    	 * @type String
    	 */
    	'version': '2.3.1',
    	/**
    	 * An object of methods to convert from JavaScript's internal character
    	 * representation (UCS-2) to Unicode code points, and back.
    	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
    	 * @memberOf punycode
    	 * @type Object
    	 */
    	'ucs2': {
    		'decode': ucs2decode,
    		'encode': ucs2encode
    	},
    	'decode': decode,
    	'encode': encode,
    	'toASCII': toASCII,
    	'toUnicode': toUnicode
    };

    var punycode_es6 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        decode: decode,
        default: punycode,
        encode: encode,
        toASCII: toASCII,
        toUnicode: toUnicode,
        ucs2decode: ucs2decode,
        ucs2encode: ucs2encode
    });

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(punycode_es6);

    var requiresPort;
    var hasRequiredRequiresPort;

    function requireRequiresPort () {
    	if (hasRequiredRequiresPort) return requiresPort;
    	hasRequiredRequiresPort = 1;

    	/**
    	 * Check if we're required to add a port number.
    	 *
    	 * @see https://url.spec.whatwg.org/#default-port
    	 * @param {Number|String} port Port number we need to check
    	 * @param {String} protocol Protocol we need to check against.
    	 * @returns {Boolean} Is it a default port for the given protocol
    	 * @api private
    	 */
    	requiresPort = function required(port, protocol) {
    	  protocol = protocol.split(':')[0];
    	  port = +port;

    	  if (!port) return false;

    	  switch (protocol) {
    	    case 'http':
    	    case 'ws':
    	    return port !== 80;

    	    case 'https':
    	    case 'wss':
    	    return port !== 443;

    	    case 'ftp':
    	    return port !== 21;

    	    case 'gopher':
    	    return port !== 70;

    	    case 'file':
    	    return false;
    	  }

    	  return port !== 0;
    	};
    	return requiresPort;
    }

    var querystringify = {};

    var hasRequiredQuerystringify;

    function requireQuerystringify () {
    	if (hasRequiredQuerystringify) return querystringify;
    	hasRequiredQuerystringify = 1;

    	var has = Object.prototype.hasOwnProperty
    	  , undef;

    	/**
    	 * Decode a URI encoded string.
    	 *
    	 * @param {String} input The URI encoded string.
    	 * @returns {String|Null} The decoded string.
    	 * @api private
    	 */
    	function decode(input) {
    	  try {
    	    return decodeURIComponent(input.replace(/\+/g, ' '));
    	  } catch (e) {
    	    return null;
    	  }
    	}

    	/**
    	 * Attempts to encode a given input.
    	 *
    	 * @param {String} input The string that needs to be encoded.
    	 * @returns {String|Null} The encoded string.
    	 * @api private
    	 */
    	function encode(input) {
    	  try {
    	    return encodeURIComponent(input);
    	  } catch (e) {
    	    return null;
    	  }
    	}

    	/**
    	 * Simple query string parser.
    	 *
    	 * @param {String} query The query string that needs to be parsed.
    	 * @returns {Object}
    	 * @api public
    	 */
    	function querystring(query) {
    	  var parser = /([^=?#&]+)=?([^&]*)/g
    	    , result = {}
    	    , part;

    	  while (part = parser.exec(query)) {
    	    var key = decode(part[1])
    	      , value = decode(part[2]);

    	    //
    	    // Prevent overriding of existing properties. This ensures that build-in
    	    // methods like `toString` or __proto__ are not overriden by malicious
    	    // querystrings.
    	    //
    	    // In the case if failed decoding, we want to omit the key/value pairs
    	    // from the result.
    	    //
    	    if (key === null || value === null || key in result) continue;
    	    result[key] = value;
    	  }

    	  return result;
    	}

    	/**
    	 * Transform a query string to an object.
    	 *
    	 * @param {Object} obj Object that should be transformed.
    	 * @param {String} prefix Optional prefix.
    	 * @returns {String}
    	 * @api public
    	 */
    	function querystringify$1(obj, prefix) {
    	  prefix = prefix || '';

    	  var pairs = []
    	    , value
    	    , key;

    	  //
    	  // Optionally prefix with a '?' if needed
    	  //
    	  if ('string' !== typeof prefix) prefix = '?';

    	  for (key in obj) {
    	    if (has.call(obj, key)) {
    	      value = obj[key];

    	      //
    	      // Edge cases where we actually want to encode the value to an empty
    	      // string instead of the stringified value.
    	      //
    	      if (!value && (value === null || value === undef || isNaN(value))) {
    	        value = '';
    	      }

    	      key = encode(key);
    	      value = encode(value);

    	      //
    	      // If we failed to encode the strings, we should bail out as we don't
    	      // want to add invalid strings to the query.
    	      //
    	      if (key === null || value === null) continue;
    	      pairs.push(key +'='+ value);
    	    }
    	  }

    	  return pairs.length ? prefix + pairs.join('&') : '';
    	}

    	//
    	// Expose the module.
    	//
    	querystringify.stringify = querystringify$1;
    	querystringify.parse = querystring;
    	return querystringify;
    }

    var urlParse;
    var hasRequiredUrlParse;

    function requireUrlParse () {
    	if (hasRequiredUrlParse) return urlParse;
    	hasRequiredUrlParse = 1;

    	var required = requireRequiresPort()
    	  , qs = requireQuerystringify()
    	  , controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
    	  , CRHTLF = /[\n\r\t]/g
    	  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
    	  , port = /:\d+$/
    	  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
    	  , windowsDriveLetter = /^[a-zA-Z]:/;

    	/**
    	 * Remove control characters and whitespace from the beginning of a string.
    	 *
    	 * @param {Object|String} str String to trim.
    	 * @returns {String} A new string representing `str` stripped of control
    	 *     characters and whitespace from its beginning.
    	 * @public
    	 */
    	function trimLeft(str) {
    	  return (str ? str : '').toString().replace(controlOrWhitespace, '');
    	}

    	/**
    	 * These are the parse rules for the URL parser, it informs the parser
    	 * about:
    	 *
    	 * 0. The char it Needs to parse, if it's a string it should be done using
    	 *    indexOf, RegExp using exec and NaN means set as current value.
    	 * 1. The property we should set when parsing this value.
    	 * 2. Indication if it's backwards or forward parsing, when set as number it's
    	 *    the value of extra chars that should be split off.
    	 * 3. Inherit from location if non existing in the parser.
    	 * 4. `toLowerCase` the resulting value.
    	 */
    	var rules = [
    	  ['#', 'hash'],                        // Extract from the back.
    	  ['?', 'query'],                       // Extract from the back.
    	  function sanitize(address, url) {     // Sanitize what is left of the address
    	    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
    	  },
    	  ['/', 'pathname'],                    // Extract from the back.
    	  ['@', 'auth', 1],                     // Extract from the front.
    	  [NaN, 'host', undefined, 1, 1],       // Set left over value.
    	  [/:(\d*)$/, 'port', undefined, 1],    // RegExp the back.
    	  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
    	];

    	/**
    	 * These properties should not be copied or inherited from. This is only needed
    	 * for all non blob URL's as a blob URL does not include a hash, only the
    	 * origin.
    	 *
    	 * @type {Object}
    	 * @private
    	 */
    	var ignore = { hash: 1, query: 1 };

    	/**
    	 * The location object differs when your code is loaded through a normal page,
    	 * Worker or through a worker using a blob. And with the blobble begins the
    	 * trouble as the location object will contain the URL of the blob, not the
    	 * location of the page where our code is loaded in. The actual origin is
    	 * encoded in the `pathname` so we can thankfully generate a good "default"
    	 * location from it so we can generate proper relative URL's again.
    	 *
    	 * @param {Object|String} loc Optional default location object.
    	 * @returns {Object} lolcation object.
    	 * @public
    	 */
    	function lolcation(loc) {
    	  var globalVar;

    	  if (typeof window !== 'undefined') globalVar = window;
    	  else if (typeof commonjsGlobal !== 'undefined') globalVar = commonjsGlobal;
    	  else if (typeof self !== 'undefined') globalVar = self;
    	  else globalVar = {};

    	  var location = globalVar.location || {};
    	  loc = loc || location;

    	  var finaldestination = {}
    	    , type = typeof loc
    	    , key;

    	  if ('blob:' === loc.protocol) {
    	    finaldestination = new Url(unescape(loc.pathname), {});
    	  } else if ('string' === type) {
    	    finaldestination = new Url(loc, {});
    	    for (key in ignore) delete finaldestination[key];
    	  } else if ('object' === type) {
    	    for (key in loc) {
    	      if (key in ignore) continue;
    	      finaldestination[key] = loc[key];
    	    }

    	    if (finaldestination.slashes === undefined) {
    	      finaldestination.slashes = slashes.test(loc.href);
    	    }
    	  }

    	  return finaldestination;
    	}

    	/**
    	 * Check whether a protocol scheme is special.
    	 *
    	 * @param {String} The protocol scheme of the URL
    	 * @return {Boolean} `true` if the protocol scheme is special, else `false`
    	 * @private
    	 */
    	function isSpecial(scheme) {
    	  return (
    	    scheme === 'file:' ||
    	    scheme === 'ftp:' ||
    	    scheme === 'http:' ||
    	    scheme === 'https:' ||
    	    scheme === 'ws:' ||
    	    scheme === 'wss:'
    	  );
    	}

    	/**
    	 * @typedef ProtocolExtract
    	 * @type Object
    	 * @property {String} protocol Protocol matched in the URL, in lowercase.
    	 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
    	 * @property {String} rest Rest of the URL that is not part of the protocol.
    	 */

    	/**
    	 * Extract protocol information from a URL with/without double slash ("//").
    	 *
    	 * @param {String} address URL we want to extract from.
    	 * @param {Object} location
    	 * @return {ProtocolExtract} Extracted information.
    	 * @private
    	 */
    	function extractProtocol(address, location) {
    	  address = trimLeft(address);
    	  address = address.replace(CRHTLF, '');
    	  location = location || {};

    	  var match = protocolre.exec(address);
    	  var protocol = match[1] ? match[1].toLowerCase() : '';
    	  var forwardSlashes = !!match[2];
    	  var otherSlashes = !!match[3];
    	  var slashesCount = 0;
    	  var rest;

    	  if (forwardSlashes) {
    	    if (otherSlashes) {
    	      rest = match[2] + match[3] + match[4];
    	      slashesCount = match[2].length + match[3].length;
    	    } else {
    	      rest = match[2] + match[4];
    	      slashesCount = match[2].length;
    	    }
    	  } else {
    	    if (otherSlashes) {
    	      rest = match[3] + match[4];
    	      slashesCount = match[3].length;
    	    } else {
    	      rest = match[4];
    	    }
    	  }

    	  if (protocol === 'file:') {
    	    if (slashesCount >= 2) {
    	      rest = rest.slice(2);
    	    }
    	  } else if (isSpecial(protocol)) {
    	    rest = match[4];
    	  } else if (protocol) {
    	    if (forwardSlashes) {
    	      rest = rest.slice(2);
    	    }
    	  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    	    rest = match[4];
    	  }

    	  return {
    	    protocol: protocol,
    	    slashes: forwardSlashes || isSpecial(protocol),
    	    slashesCount: slashesCount,
    	    rest: rest
    	  };
    	}

    	/**
    	 * Resolve a relative URL pathname against a base URL pathname.
    	 *
    	 * @param {String} relative Pathname of the relative URL.
    	 * @param {String} base Pathname of the base URL.
    	 * @return {String} Resolved pathname.
    	 * @private
    	 */
    	function resolve(relative, base) {
    	  if (relative === '') return base;

    	  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    	    , i = path.length
    	    , last = path[i - 1]
    	    , unshift = false
    	    , up = 0;

    	  while (i--) {
    	    if (path[i] === '.') {
    	      path.splice(i, 1);
    	    } else if (path[i] === '..') {
    	      path.splice(i, 1);
    	      up++;
    	    } else if (up) {
    	      if (i === 0) unshift = true;
    	      path.splice(i, 1);
    	      up--;
    	    }
    	  }

    	  if (unshift) path.unshift('');
    	  if (last === '.' || last === '..') path.push('');

    	  return path.join('/');
    	}

    	/**
    	 * The actual URL instance. Instead of returning an object we've opted-in to
    	 * create an actual constructor as it's much more memory efficient and
    	 * faster and it pleases my OCD.
    	 *
    	 * It is worth noting that we should not use `URL` as class name to prevent
    	 * clashes with the global URL instance that got introduced in browsers.
    	 *
    	 * @constructor
    	 * @param {String} address URL we want to parse.
    	 * @param {Object|String} [location] Location defaults for relative paths.
    	 * @param {Boolean|Function} [parser] Parser for the query string.
    	 * @private
    	 */
    	function Url(address, location, parser) {
    	  address = trimLeft(address);
    	  address = address.replace(CRHTLF, '');

    	  if (!(this instanceof Url)) {
    	    return new Url(address, location, parser);
    	  }

    	  var relative, extracted, parse, instruction, index, key
    	    , instructions = rules.slice()
    	    , type = typeof location
    	    , url = this
    	    , i = 0;

    	  //
    	  // The following if statements allows this module two have compatibility with
    	  // 2 different API:
    	  //
    	  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
    	  //    where the boolean indicates that the query string should also be parsed.
    	  //
    	  // 2. The `URL` interface of the browser which accepts a URL, object as
    	  //    arguments. The supplied object will be used as default values / fall-back
    	  //    for relative paths.
    	  //
    	  if ('object' !== type && 'string' !== type) {
    	    parser = location;
    	    location = null;
    	  }

    	  if (parser && 'function' !== typeof parser) parser = qs.parse;

    	  location = lolcation(location);

    	  //
    	  // Extract protocol information before running the instructions.
    	  //
    	  extracted = extractProtocol(address || '', location);
    	  relative = !extracted.protocol && !extracted.slashes;
    	  url.slashes = extracted.slashes || relative && location.slashes;
    	  url.protocol = extracted.protocol || location.protocol || '';
    	  address = extracted.rest;

    	  //
    	  // When the authority component is absent the URL starts with a path
    	  // component.
    	  //
    	  if (
    	    extracted.protocol === 'file:' && (
    	      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    	    (!extracted.slashes &&
    	      (extracted.protocol ||
    	        extracted.slashesCount < 2 ||
    	        !isSpecial(url.protocol)))
    	  ) {
    	    instructions[3] = [/(.*)/, 'pathname'];
    	  }

    	  for (; i < instructions.length; i++) {
    	    instruction = instructions[i];

    	    if (typeof instruction === 'function') {
    	      address = instruction(address, url);
    	      continue;
    	    }

    	    parse = instruction[0];
    	    key = instruction[1];

    	    if (parse !== parse) {
    	      url[key] = address;
    	    } else if ('string' === typeof parse) {
    	      index = parse === '@'
    	        ? address.lastIndexOf(parse)
    	        : address.indexOf(parse);

    	      if (~index) {
    	        if ('number' === typeof instruction[2]) {
    	          url[key] = address.slice(0, index);
    	          address = address.slice(index + instruction[2]);
    	        } else {
    	          url[key] = address.slice(index);
    	          address = address.slice(0, index);
    	        }
    	      }
    	    } else if ((index = parse.exec(address))) {
    	      url[key] = index[1];
    	      address = address.slice(0, index.index);
    	    }

    	    url[key] = url[key] || (
    	      relative && instruction[3] ? location[key] || '' : ''
    	    );

    	    //
    	    // Hostname, host and protocol should be lowercased so they can be used to
    	    // create a proper `origin`.
    	    //
    	    if (instruction[4]) url[key] = url[key].toLowerCase();
    	  }

    	  //
    	  // Also parse the supplied query string in to an object. If we're supplied
    	  // with a custom parser as function use that instead of the default build-in
    	  // parser.
    	  //
    	  if (parser) url.query = parser(url.query);

    	  //
    	  // If the URL is relative, resolve the pathname against the base URL.
    	  //
    	  if (
    	      relative
    	    && location.slashes
    	    && url.pathname.charAt(0) !== '/'
    	    && (url.pathname !== '' || location.pathname !== '')
    	  ) {
    	    url.pathname = resolve(url.pathname, location.pathname);
    	  }

    	  //
    	  // Default to a / for pathname if none exists. This normalizes the URL
    	  // to always have a /
    	  //
    	  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    	    url.pathname = '/' + url.pathname;
    	  }

    	  //
    	  // We should not add port numbers if they are already the default port number
    	  // for a given protocol. As the host also contains the port number we're going
    	  // override it with the hostname which contains no port number.
    	  //
    	  if (!required(url.port, url.protocol)) {
    	    url.host = url.hostname;
    	    url.port = '';
    	  }

    	  //
    	  // Parse down the `auth` for the username and password.
    	  //
    	  url.username = url.password = '';

    	  if (url.auth) {
    	    index = url.auth.indexOf(':');

    	    if (~index) {
    	      url.username = url.auth.slice(0, index);
    	      url.username = encodeURIComponent(decodeURIComponent(url.username));

    	      url.password = url.auth.slice(index + 1);
    	      url.password = encodeURIComponent(decodeURIComponent(url.password));
    	    } else {
    	      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    	    }

    	    url.auth = url.password ? url.username +':'+ url.password : url.username;
    	  }

    	  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    	    ? url.protocol +'//'+ url.host
    	    : 'null';

    	  //
    	  // The href is just the compiled result.
    	  //
    	  url.href = url.toString();
    	}

    	/**
    	 * This is convenience method for changing properties in the URL instance to
    	 * insure that they all propagate correctly.
    	 *
    	 * @param {String} part          Property we need to adjust.
    	 * @param {Mixed} value          The newly assigned value.
    	 * @param {Boolean|Function} fn  When setting the query, it will be the function
    	 *                               used to parse the query.
    	 *                               When setting the protocol, double slash will be
    	 *                               removed from the final url if it is true.
    	 * @returns {URL} URL instance for chaining.
    	 * @public
    	 */
    	function set(part, value, fn) {
    	  var url = this;

    	  switch (part) {
    	    case 'query':
    	      if ('string' === typeof value && value.length) {
    	        value = (fn || qs.parse)(value);
    	      }

    	      url[part] = value;
    	      break;

    	    case 'port':
    	      url[part] = value;

    	      if (!required(value, url.protocol)) {
    	        url.host = url.hostname;
    	        url[part] = '';
    	      } else if (value) {
    	        url.host = url.hostname +':'+ value;
    	      }

    	      break;

    	    case 'hostname':
    	      url[part] = value;

    	      if (url.port) value += ':'+ url.port;
    	      url.host = value;
    	      break;

    	    case 'host':
    	      url[part] = value;

    	      if (port.test(value)) {
    	        value = value.split(':');
    	        url.port = value.pop();
    	        url.hostname = value.join(':');
    	      } else {
    	        url.hostname = value;
    	        url.port = '';
    	      }

    	      break;

    	    case 'protocol':
    	      url.protocol = value.toLowerCase();
    	      url.slashes = !fn;
    	      break;

    	    case 'pathname':
    	    case 'hash':
    	      if (value) {
    	        var char = part === 'pathname' ? '/' : '#';
    	        url[part] = value.charAt(0) !== char ? char + value : value;
    	      } else {
    	        url[part] = value;
    	      }
    	      break;

    	    case 'username':
    	    case 'password':
    	      url[part] = encodeURIComponent(value);
    	      break;

    	    case 'auth':
    	      var index = value.indexOf(':');

    	      if (~index) {
    	        url.username = value.slice(0, index);
    	        url.username = encodeURIComponent(decodeURIComponent(url.username));

    	        url.password = value.slice(index + 1);
    	        url.password = encodeURIComponent(decodeURIComponent(url.password));
    	      } else {
    	        url.username = encodeURIComponent(decodeURIComponent(value));
    	      }
    	  }

    	  for (var i = 0; i < rules.length; i++) {
    	    var ins = rules[i];

    	    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
    	  }

    	  url.auth = url.password ? url.username +':'+ url.password : url.username;

    	  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    	    ? url.protocol +'//'+ url.host
    	    : 'null';

    	  url.href = url.toString();

    	  return url;
    	}

    	/**
    	 * Transform the properties back in to a valid and full URL string.
    	 *
    	 * @param {Function} stringify Optional query stringify function.
    	 * @returns {String} Compiled version of the URL.
    	 * @public
    	 */
    	function toString(stringify) {
    	  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

    	  var query
    	    , url = this
    	    , host = url.host
    	    , protocol = url.protocol;

    	  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

    	  var result =
    	    protocol +
    	    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

    	  if (url.username) {
    	    result += url.username;
    	    if (url.password) result += ':'+ url.password;
    	    result += '@';
    	  } else if (url.password) {
    	    result += ':'+ url.password;
    	    result += '@';
    	  } else if (
    	    url.protocol !== 'file:' &&
    	    isSpecial(url.protocol) &&
    	    !host &&
    	    url.pathname !== '/'
    	  ) {
    	    //
    	    // Add back the empty userinfo, otherwise the original invalid URL
    	    // might be transformed into a valid one with `url.pathname` as host.
    	    //
    	    result += '@';
    	  }

    	  //
    	  // Trailing colon is removed from `url.host` when it is parsed. If it still
    	  // ends with a colon, then add back the trailing colon that was removed. This
    	  // prevents an invalid URL from being transformed into a valid one.
    	  //
    	  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
    	    host += ':';
    	  }

    	  result += host + url.pathname;

    	  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
    	  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

    	  if (url.hash) result += url.hash;

    	  return result;
    	}

    	Url.prototype = { set: set, toString: toString };

    	//
    	// Expose the URL parser and some additional properties that might be useful for
    	// others or testing.
    	//
    	Url.extractProtocol = extractProtocol;
    	Url.location = lolcation;
    	Url.trimLeft = trimLeft;
    	Url.qs = qs;

    	urlParse = Url;
    	return urlParse;
    }

    var pubsuffixPsl = {};

    var psl = {};

    var hasRequiredPsl;

    function requirePsl () {
    	if (hasRequiredPsl) return psl;
    	hasRequiredPsl = 1;
    	(function (exports) {
    Object.defineProperties(exports,{__esModule:{value:true},[Symbol.toStringTag]:{value:"Module"}});function K(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var O,F;function Q(){if(F)return O;F=1;const e=2147483647,s=36,c=1,o=26,t=38,d=700,z=72,y=128,g="-",P=/^xn--/,V=/[^\0-\x7F]/,G=/[\x2E\u3002\uFF0E\uFF61]/g,W={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},C=s-c,h=Math.floor,I=String.fromCharCode;function v(a){throw new RangeError(W[a])}function U(a,i){const m=[];let n=a.length;for(;n--;)m[n]=i(a[n]);return m}function S(a,i){const m=a.split("@");let n="";m.length>1&&(n=m[0]+"@",a=m[1]),a=a.replace(G,".");const r=a.split("."),p=U(r,i).join(".");return n+p}function L(a){const i=[];let m=0;const n=a.length;for(;m<n;){const r=a.charCodeAt(m++);if(r>=55296&&r<=56319&&m<n){const p=a.charCodeAt(m++);(p&64512)==56320?i.push(((r&1023)<<10)+(p&1023)+65536):(i.push(r),m--);}else i.push(r);}return i}const $=a=>String.fromCodePoint(...a),J=function(a){return a>=48&&a<58?26+(a-48):a>=65&&a<91?a-65:a>=97&&a<123?a-97:s},D=function(a,i){return a+22+75*(a<26)-((i!=0)<<5)},T=function(a,i,m){let n=0;for(a=m?h(a/d):a>>1,a+=h(a/i);a>C*o>>1;n+=s)a=h(a/C);return h(n+(C+1)*a/(a+t))},E=function(a){const i=[],m=a.length;let n=0,r=y,p=z,j=a.lastIndexOf(g);j<0&&(j=0);for(let u=0;u<j;++u)a.charCodeAt(u)>=128&&v("not-basic"),i.push(a.charCodeAt(u));for(let u=j>0?j+1:0;u<m;){const k=n;for(let l=1,b=s;;b+=s){u>=m&&v("invalid-input");const w=J(a.charCodeAt(u++));w>=s&&v("invalid-input"),w>h((e-n)/l)&&v("overflow"),n+=w*l;const x=b<=p?c:b>=p+o?o:b-p;if(w<x)break;const q=s-x;l>h(e/q)&&v("overflow"),l*=q;}const f=i.length+1;p=T(n-k,f,k==0),h(n/f)>e-r&&v("overflow"),r+=h(n/f),n%=f,i.splice(n++,0,r);}return String.fromCodePoint(...i)},B=function(a){const i=[];a=L(a);const m=a.length;let n=y,r=0,p=z;for(const k of a)k<128&&i.push(I(k));const j=i.length;let u=j;for(j&&i.push(g);u<m;){let k=e;for(const l of a)l>=n&&l<k&&(k=l);const f=u+1;k-n>h((e-r)/f)&&v("overflow"),r+=(k-n)*f,n=k;for(const l of a)if(l<n&&++r>e&&v("overflow"),l===n){let b=r;for(let w=s;;w+=s){const x=w<=p?c:w>=p+o?o:w-p;if(b<x)break;const q=b-x,M=s-x;i.push(I(D(x+q%M,0))),b=h(q/M);}i.push(I(D(b,0))),p=T(r,f,u===j),r=0,++u;}++r,++n;}return i.join("")};return O={version:"2.3.1",ucs2:{decode:L,encode:$},decode:E,encode:B,toASCII:function(a){return S(a,function(i){return V.test(i)?"xn--"+B(i):i})},toUnicode:function(a){return S(a,function(i){return P.test(i)?E(i.slice(4).toLowerCase()):i})}},O}var X=Q();const A=K(X),Y=["ac","com.ac","edu.ac","gov.ac","mil.ac","net.ac","org.ac","ad","ae","ac.ae","co.ae","gov.ae","mil.ae","net.ae","org.ae","sch.ae","aero","airline.aero","airport.aero","accident-investigation.aero","accident-prevention.aero","aerobatic.aero","aeroclub.aero","aerodrome.aero","agents.aero","air-surveillance.aero","air-traffic-control.aero","aircraft.aero","airtraffic.aero","ambulance.aero","association.aero","author.aero","ballooning.aero","broker.aero","caa.aero","cargo.aero","catering.aero","certification.aero","championship.aero","charter.aero","civilaviation.aero","club.aero","conference.aero","consultant.aero","consulting.aero","control.aero","council.aero","crew.aero","design.aero","dgca.aero","educator.aero","emergency.aero","engine.aero","engineer.aero","entertainment.aero","equipment.aero","exchange.aero","express.aero","federation.aero","flight.aero","freight.aero","fuel.aero","gliding.aero","government.aero","groundhandling.aero","group.aero","hanggliding.aero","homebuilt.aero","insurance.aero","journal.aero","journalist.aero","leasing.aero","logistics.aero","magazine.aero","maintenance.aero","marketplace.aero","media.aero","microlight.aero","modelling.aero","navigation.aero","parachuting.aero","paragliding.aero","passenger-association.aero","pilot.aero","press.aero","production.aero","recreation.aero","repbody.aero","res.aero","research.aero","rotorcraft.aero","safety.aero","scientist.aero","services.aero","show.aero","skydiving.aero","software.aero","student.aero","taxi.aero","trader.aero","trading.aero","trainer.aero","union.aero","workinggroup.aero","works.aero","af","com.af","edu.af","gov.af","net.af","org.af","ag","co.ag","com.ag","net.ag","nom.ag","org.ag","ai","com.ai","net.ai","off.ai","org.ai","al","com.al","edu.al","gov.al","mil.al","net.al","org.al","am","co.am","com.am","commune.am","net.am","org.am","ao","co.ao","ed.ao","edu.ao","gov.ao","gv.ao","it.ao","og.ao","org.ao","pb.ao","aq","ar","bet.ar","com.ar","coop.ar","edu.ar","gob.ar","gov.ar","int.ar","mil.ar","musica.ar","mutual.ar","net.ar","org.ar","senasa.ar","tur.ar","arpa","e164.arpa","home.arpa","in-addr.arpa","ip6.arpa","iris.arpa","uri.arpa","urn.arpa","as","gov.as","asia","at","ac.at","sth.ac.at","co.at","gv.at","or.at","au","asn.au","com.au","edu.au","gov.au","id.au","net.au","org.au","conf.au","oz.au","act.au","nsw.au","nt.au","qld.au","sa.au","tas.au","vic.au","wa.au","act.edu.au","catholic.edu.au","nsw.edu.au","nt.edu.au","qld.edu.au","sa.edu.au","tas.edu.au","vic.edu.au","wa.edu.au","qld.gov.au","sa.gov.au","tas.gov.au","vic.gov.au","wa.gov.au","schools.nsw.edu.au","aw","com.aw","ax","az","biz.az","com.az","edu.az","gov.az","info.az","int.az","mil.az","name.az","net.az","org.az","pp.az","pro.az","ba","com.ba","edu.ba","gov.ba","mil.ba","net.ba","org.ba","bb","biz.bb","co.bb","com.bb","edu.bb","gov.bb","info.bb","net.bb","org.bb","store.bb","tv.bb","*.bd","be","ac.be","bf","gov.bf","bg","0.bg","1.bg","2.bg","3.bg","4.bg","5.bg","6.bg","7.bg","8.bg","9.bg","a.bg","b.bg","c.bg","d.bg","e.bg","f.bg","g.bg","h.bg","i.bg","j.bg","k.bg","l.bg","m.bg","n.bg","o.bg","p.bg","q.bg","r.bg","s.bg","t.bg","u.bg","v.bg","w.bg","x.bg","y.bg","z.bg","bh","com.bh","edu.bh","gov.bh","net.bh","org.bh","bi","co.bi","com.bi","edu.bi","or.bi","org.bi","biz","bj","africa.bj","agro.bj","architectes.bj","assur.bj","avocats.bj","co.bj","com.bj","eco.bj","econo.bj","edu.bj","info.bj","loisirs.bj","money.bj","net.bj","org.bj","ote.bj","restaurant.bj","resto.bj","tourism.bj","univ.bj","bm","com.bm","edu.bm","gov.bm","net.bm","org.bm","bn","com.bn","edu.bn","gov.bn","net.bn","org.bn","bo","com.bo","edu.bo","gob.bo","int.bo","mil.bo","net.bo","org.bo","tv.bo","web.bo","academia.bo","agro.bo","arte.bo","blog.bo","bolivia.bo","ciencia.bo","cooperativa.bo","democracia.bo","deporte.bo","ecologia.bo","economia.bo","empresa.bo","indigena.bo","industria.bo","info.bo","medicina.bo","movimiento.bo","musica.bo","natural.bo","nombre.bo","noticias.bo","patria.bo","plurinacional.bo","politica.bo","profesional.bo","pueblo.bo","revista.bo","salud.bo","tecnologia.bo","tksat.bo","transporte.bo","wiki.bo","br","9guacu.br","abc.br","adm.br","adv.br","agr.br","aju.br","am.br","anani.br","aparecida.br","app.br","arq.br","art.br","ato.br","b.br","barueri.br","belem.br","bet.br","bhz.br","bib.br","bio.br","blog.br","bmd.br","boavista.br","bsb.br","campinagrande.br","campinas.br","caxias.br","cim.br","cng.br","cnt.br","com.br","contagem.br","coop.br","coz.br","cri.br","cuiaba.br","curitiba.br","def.br","des.br","det.br","dev.br","ecn.br","eco.br","edu.br","emp.br","enf.br","eng.br","esp.br","etc.br","eti.br","far.br","feira.br","flog.br","floripa.br","fm.br","fnd.br","fortal.br","fot.br","foz.br","fst.br","g12.br","geo.br","ggf.br","goiania.br","gov.br","ac.gov.br","al.gov.br","am.gov.br","ap.gov.br","ba.gov.br","ce.gov.br","df.gov.br","es.gov.br","go.gov.br","ma.gov.br","mg.gov.br","ms.gov.br","mt.gov.br","pa.gov.br","pb.gov.br","pe.gov.br","pi.gov.br","pr.gov.br","rj.gov.br","rn.gov.br","ro.gov.br","rr.gov.br","rs.gov.br","sc.gov.br","se.gov.br","sp.gov.br","to.gov.br","gru.br","imb.br","ind.br","inf.br","jab.br","jampa.br","jdf.br","joinville.br","jor.br","jus.br","leg.br","leilao.br","lel.br","log.br","londrina.br","macapa.br","maceio.br","manaus.br","maringa.br","mat.br","med.br","mil.br","morena.br","mp.br","mus.br","natal.br","net.br","niteroi.br","*.nom.br","not.br","ntr.br","odo.br","ong.br","org.br","osasco.br","palmas.br","poa.br","ppg.br","pro.br","psc.br","psi.br","pvh.br","qsl.br","radio.br","rec.br","recife.br","rep.br","ribeirao.br","rio.br","riobranco.br","riopreto.br","salvador.br","sampa.br","santamaria.br","santoandre.br","saobernardo.br","saogonca.br","seg.br","sjc.br","slg.br","slz.br","sorocaba.br","srv.br","taxi.br","tc.br","tec.br","teo.br","the.br","tmp.br","trd.br","tur.br","tv.br","udi.br","vet.br","vix.br","vlog.br","wiki.br","zlg.br","bs","com.bs","edu.bs","gov.bs","net.bs","org.bs","bt","com.bt","edu.bt","gov.bt","net.bt","org.bt","bv","bw","co.bw","org.bw","by","gov.by","mil.by","com.by","of.by","bz","co.bz","com.bz","edu.bz","gov.bz","net.bz","org.bz","ca","ab.ca","bc.ca","mb.ca","nb.ca","nf.ca","nl.ca","ns.ca","nt.ca","nu.ca","on.ca","pe.ca","qc.ca","sk.ca","yk.ca","gc.ca","cat","cc","cd","gov.cd","cf","cg","ch","ci","ac.ci","aéroport.ci","asso.ci","co.ci","com.ci","ed.ci","edu.ci","go.ci","gouv.ci","int.ci","net.ci","or.ci","org.ci","*.ck","!www.ck","cl","co.cl","gob.cl","gov.cl","mil.cl","cm","co.cm","com.cm","gov.cm","net.cm","cn","ac.cn","com.cn","edu.cn","gov.cn","mil.cn","net.cn","org.cn","公司.cn","網絡.cn","网络.cn","ah.cn","bj.cn","cq.cn","fj.cn","gd.cn","gs.cn","gx.cn","gz.cn","ha.cn","hb.cn","he.cn","hi.cn","hk.cn","hl.cn","hn.cn","jl.cn","js.cn","jx.cn","ln.cn","mo.cn","nm.cn","nx.cn","qh.cn","sc.cn","sd.cn","sh.cn","sn.cn","sx.cn","tj.cn","tw.cn","xj.cn","xz.cn","yn.cn","zj.cn","co","com.co","edu.co","gov.co","mil.co","net.co","nom.co","org.co","com","coop","cr","ac.cr","co.cr","ed.cr","fi.cr","go.cr","or.cr","sa.cr","cu","com.cu","edu.cu","gob.cu","inf.cu","nat.cu","net.cu","org.cu","cv","com.cv","edu.cv","id.cv","int.cv","net.cv","nome.cv","org.cv","publ.cv","cw","com.cw","edu.cw","net.cw","org.cw","cx","gov.cx","cy","ac.cy","biz.cy","com.cy","ekloges.cy","gov.cy","ltd.cy","mil.cy","net.cy","org.cy","press.cy","pro.cy","tm.cy","cz","de","dj","dk","dm","co.dm","com.dm","edu.dm","gov.dm","net.dm","org.dm","do","art.do","com.do","edu.do","gob.do","gov.do","mil.do","net.do","org.do","sld.do","web.do","dz","art.dz","asso.dz","com.dz","edu.dz","gov.dz","net.dz","org.dz","pol.dz","soc.dz","tm.dz","ec","com.ec","edu.ec","fin.ec","gob.ec","gov.ec","info.ec","k12.ec","med.ec","mil.ec","net.ec","org.ec","pro.ec","edu","ee","aip.ee","com.ee","edu.ee","fie.ee","gov.ee","lib.ee","med.ee","org.ee","pri.ee","riik.ee","eg","ac.eg","com.eg","edu.eg","eun.eg","gov.eg","info.eg","me.eg","mil.eg","name.eg","net.eg","org.eg","sci.eg","sport.eg","tv.eg","*.er","es","com.es","edu.es","gob.es","nom.es","org.es","et","biz.et","com.et","edu.et","gov.et","info.et","name.et","net.et","org.et","eu","fi","aland.fi","fj","ac.fj","biz.fj","com.fj","gov.fj","info.fj","mil.fj","name.fj","net.fj","org.fj","pro.fj","*.fk","fm","com.fm","edu.fm","net.fm","org.fm","fo","fr","asso.fr","com.fr","gouv.fr","nom.fr","prd.fr","tm.fr","avoues.fr","cci.fr","greta.fr","huissier-justice.fr","ga","gb","gd","edu.gd","gov.gd","ge","com.ge","edu.ge","gov.ge","net.ge","org.ge","pvt.ge","school.ge","gf","gg","co.gg","net.gg","org.gg","gh","com.gh","edu.gh","gov.gh","mil.gh","org.gh","gi","com.gi","edu.gi","gov.gi","ltd.gi","mod.gi","org.gi","gl","co.gl","com.gl","edu.gl","net.gl","org.gl","gm","gn","ac.gn","com.gn","edu.gn","gov.gn","net.gn","org.gn","gov","gp","asso.gp","com.gp","edu.gp","mobi.gp","net.gp","org.gp","gq","gr","com.gr","edu.gr","gov.gr","net.gr","org.gr","gs","gt","com.gt","edu.gt","gob.gt","ind.gt","mil.gt","net.gt","org.gt","gu","com.gu","edu.gu","gov.gu","guam.gu","info.gu","net.gu","org.gu","web.gu","gw","gy","co.gy","com.gy","edu.gy","gov.gy","net.gy","org.gy","hk","com.hk","edu.hk","gov.hk","idv.hk","net.hk","org.hk","个人.hk","個人.hk","公司.hk","政府.hk","敎育.hk","教育.hk","箇人.hk","組織.hk","組织.hk","網絡.hk","網络.hk","组織.hk","组织.hk","网絡.hk","网络.hk","hm","hn","com.hn","edu.hn","gob.hn","mil.hn","net.hn","org.hn","hr","com.hr","from.hr","iz.hr","name.hr","ht","adult.ht","art.ht","asso.ht","com.ht","coop.ht","edu.ht","firm.ht","gouv.ht","info.ht","med.ht","net.ht","org.ht","perso.ht","pol.ht","pro.ht","rel.ht","shop.ht","hu","2000.hu","agrar.hu","bolt.hu","casino.hu","city.hu","co.hu","erotica.hu","erotika.hu","film.hu","forum.hu","games.hu","hotel.hu","info.hu","ingatlan.hu","jogasz.hu","konyvelo.hu","lakas.hu","media.hu","news.hu","org.hu","priv.hu","reklam.hu","sex.hu","shop.hu","sport.hu","suli.hu","szex.hu","tm.hu","tozsde.hu","utazas.hu","video.hu","id","ac.id","biz.id","co.id","desa.id","go.id","mil.id","my.id","net.id","or.id","ponpes.id","sch.id","web.id","ie","gov.ie","il","ac.il","co.il","gov.il","idf.il","k12.il","muni.il","net.il","org.il","ישראל","אקדמיה.ישראל","ישוב.ישראל","צהל.ישראל","ממשל.ישראל","im","ac.im","co.im","ltd.co.im","plc.co.im","com.im","net.im","org.im","tt.im","tv.im","in","5g.in","6g.in","ac.in","ai.in","am.in","bihar.in","biz.in","business.in","ca.in","cn.in","co.in","com.in","coop.in","cs.in","delhi.in","dr.in","edu.in","er.in","firm.in","gen.in","gov.in","gujarat.in","ind.in","info.in","int.in","internet.in","io.in","me.in","mil.in","net.in","nic.in","org.in","pg.in","post.in","pro.in","res.in","travel.in","tv.in","uk.in","up.in","us.in","info","int","eu.int","io","co.io","com.io","edu.io","gov.io","mil.io","net.io","nom.io","org.io","iq","com.iq","edu.iq","gov.iq","mil.iq","net.iq","org.iq","ir","ac.ir","co.ir","gov.ir","id.ir","net.ir","org.ir","sch.ir","ایران.ir","ايران.ir","is","it","edu.it","gov.it","abr.it","abruzzo.it","aosta-valley.it","aostavalley.it","bas.it","basilicata.it","cal.it","calabria.it","cam.it","campania.it","emilia-romagna.it","emiliaromagna.it","emr.it","friuli-v-giulia.it","friuli-ve-giulia.it","friuli-vegiulia.it","friuli-venezia-giulia.it","friuli-veneziagiulia.it","friuli-vgiulia.it","friuliv-giulia.it","friulive-giulia.it","friulivegiulia.it","friulivenezia-giulia.it","friuliveneziagiulia.it","friulivgiulia.it","fvg.it","laz.it","lazio.it","lig.it","liguria.it","lom.it","lombardia.it","lombardy.it","lucania.it","mar.it","marche.it","mol.it","molise.it","piedmont.it","piemonte.it","pmn.it","pug.it","puglia.it","sar.it","sardegna.it","sardinia.it","sic.it","sicilia.it","sicily.it","taa.it","tos.it","toscana.it","trentin-sud-tirol.it","trentin-süd-tirol.it","trentin-sudtirol.it","trentin-südtirol.it","trentin-sued-tirol.it","trentin-suedtirol.it","trentino.it","trentino-a-adige.it","trentino-aadige.it","trentino-alto-adige.it","trentino-altoadige.it","trentino-s-tirol.it","trentino-stirol.it","trentino-sud-tirol.it","trentino-süd-tirol.it","trentino-sudtirol.it","trentino-südtirol.it","trentino-sued-tirol.it","trentino-suedtirol.it","trentinoa-adige.it","trentinoaadige.it","trentinoalto-adige.it","trentinoaltoadige.it","trentinos-tirol.it","trentinostirol.it","trentinosud-tirol.it","trentinosüd-tirol.it","trentinosudtirol.it","trentinosüdtirol.it","trentinosued-tirol.it","trentinosuedtirol.it","trentinsud-tirol.it","trentinsüd-tirol.it","trentinsudtirol.it","trentinsüdtirol.it","trentinsued-tirol.it","trentinsuedtirol.it","tuscany.it","umb.it","umbria.it","val-d-aosta.it","val-daosta.it","vald-aosta.it","valdaosta.it","valle-aosta.it","valle-d-aosta.it","valle-daosta.it","valleaosta.it","valled-aosta.it","valledaosta.it","vallee-aoste.it","vallée-aoste.it","vallee-d-aoste.it","vallée-d-aoste.it","valleeaoste.it","valléeaoste.it","valleedaoste.it","valléedaoste.it","vao.it","vda.it","ven.it","veneto.it","ag.it","agrigento.it","al.it","alessandria.it","alto-adige.it","altoadige.it","an.it","ancona.it","andria-barletta-trani.it","andria-trani-barletta.it","andriabarlettatrani.it","andriatranibarletta.it","ao.it","aosta.it","aoste.it","ap.it","aq.it","aquila.it","ar.it","arezzo.it","ascoli-piceno.it","ascolipiceno.it","asti.it","at.it","av.it","avellino.it","ba.it","balsan.it","balsan-sudtirol.it","balsan-südtirol.it","balsan-suedtirol.it","bari.it","barletta-trani-andria.it","barlettatraniandria.it","belluno.it","benevento.it","bergamo.it","bg.it","bi.it","biella.it","bl.it","bn.it","bo.it","bologna.it","bolzano.it","bolzano-altoadige.it","bozen.it","bozen-sudtirol.it","bozen-südtirol.it","bozen-suedtirol.it","br.it","brescia.it","brindisi.it","bs.it","bt.it","bulsan.it","bulsan-sudtirol.it","bulsan-südtirol.it","bulsan-suedtirol.it","bz.it","ca.it","cagliari.it","caltanissetta.it","campidano-medio.it","campidanomedio.it","campobasso.it","carbonia-iglesias.it","carboniaiglesias.it","carrara-massa.it","carraramassa.it","caserta.it","catania.it","catanzaro.it","cb.it","ce.it","cesena-forli.it","cesena-forlì.it","cesenaforli.it","cesenaforlì.it","ch.it","chieti.it","ci.it","cl.it","cn.it","co.it","como.it","cosenza.it","cr.it","cremona.it","crotone.it","cs.it","ct.it","cuneo.it","cz.it","dell-ogliastra.it","dellogliastra.it","en.it","enna.it","fc.it","fe.it","fermo.it","ferrara.it","fg.it","fi.it","firenze.it","florence.it","fm.it","foggia.it","forli-cesena.it","forlì-cesena.it","forlicesena.it","forlìcesena.it","fr.it","frosinone.it","ge.it","genoa.it","genova.it","go.it","gorizia.it","gr.it","grosseto.it","iglesias-carbonia.it","iglesiascarbonia.it","im.it","imperia.it","is.it","isernia.it","kr.it","la-spezia.it","laquila.it","laspezia.it","latina.it","lc.it","le.it","lecce.it","lecco.it","li.it","livorno.it","lo.it","lodi.it","lt.it","lu.it","lucca.it","macerata.it","mantova.it","massa-carrara.it","massacarrara.it","matera.it","mb.it","mc.it","me.it","medio-campidano.it","mediocampidano.it","messina.it","mi.it","milan.it","milano.it","mn.it","mo.it","modena.it","monza.it","monza-brianza.it","monza-e-della-brianza.it","monzabrianza.it","monzaebrianza.it","monzaedellabrianza.it","ms.it","mt.it","na.it","naples.it","napoli.it","no.it","novara.it","nu.it","nuoro.it","og.it","ogliastra.it","olbia-tempio.it","olbiatempio.it","or.it","oristano.it","ot.it","pa.it","padova.it","padua.it","palermo.it","parma.it","pavia.it","pc.it","pd.it","pe.it","perugia.it","pesaro-urbino.it","pesarourbino.it","pescara.it","pg.it","pi.it","piacenza.it","pisa.it","pistoia.it","pn.it","po.it","pordenone.it","potenza.it","pr.it","prato.it","pt.it","pu.it","pv.it","pz.it","ra.it","ragusa.it","ravenna.it","rc.it","re.it","reggio-calabria.it","reggio-emilia.it","reggiocalabria.it","reggioemilia.it","rg.it","ri.it","rieti.it","rimini.it","rm.it","rn.it","ro.it","roma.it","rome.it","rovigo.it","sa.it","salerno.it","sassari.it","savona.it","si.it","siena.it","siracusa.it","so.it","sondrio.it","sp.it","sr.it","ss.it","südtirol.it","suedtirol.it","sv.it","ta.it","taranto.it","te.it","tempio-olbia.it","tempioolbia.it","teramo.it","terni.it","tn.it","to.it","torino.it","tp.it","tr.it","trani-andria-barletta.it","trani-barletta-andria.it","traniandriabarletta.it","tranibarlettaandria.it","trapani.it","trento.it","treviso.it","trieste.it","ts.it","turin.it","tv.it","ud.it","udine.it","urbino-pesaro.it","urbinopesaro.it","va.it","varese.it","vb.it","vc.it","ve.it","venezia.it","venice.it","verbania.it","vercelli.it","verona.it","vi.it","vibo-valentia.it","vibovalentia.it","vicenza.it","viterbo.it","vr.it","vs.it","vt.it","vv.it","je","co.je","net.je","org.je","*.jm","jo","agri.jo","ai.jo","com.jo","edu.jo","eng.jo","fm.jo","gov.jo","mil.jo","net.jo","org.jo","per.jo","phd.jo","sch.jo","tv.jo","jobs","jp","ac.jp","ad.jp","co.jp","ed.jp","go.jp","gr.jp","lg.jp","ne.jp","or.jp","aichi.jp","akita.jp","aomori.jp","chiba.jp","ehime.jp","fukui.jp","fukuoka.jp","fukushima.jp","gifu.jp","gunma.jp","hiroshima.jp","hokkaido.jp","hyogo.jp","ibaraki.jp","ishikawa.jp","iwate.jp","kagawa.jp","kagoshima.jp","kanagawa.jp","kochi.jp","kumamoto.jp","kyoto.jp","mie.jp","miyagi.jp","miyazaki.jp","nagano.jp","nagasaki.jp","nara.jp","niigata.jp","oita.jp","okayama.jp","okinawa.jp","osaka.jp","saga.jp","saitama.jp","shiga.jp","shimane.jp","shizuoka.jp","tochigi.jp","tokushima.jp","tokyo.jp","tottori.jp","toyama.jp","wakayama.jp","yamagata.jp","yamaguchi.jp","yamanashi.jp","三重.jp","京都.jp","佐賀.jp","兵庫.jp","北海道.jp","千葉.jp","和歌山.jp","埼玉.jp","大分.jp","大阪.jp","奈良.jp","宮城.jp","宮崎.jp","富山.jp","山口.jp","山形.jp","山梨.jp","岐阜.jp","岡山.jp","岩手.jp","島根.jp","広島.jp","徳島.jp","愛媛.jp","愛知.jp","新潟.jp","東京.jp","栃木.jp","沖縄.jp","滋賀.jp","熊本.jp","石川.jp","神奈川.jp","福井.jp","福岡.jp","福島.jp","秋田.jp","群馬.jp","茨城.jp","長崎.jp","長野.jp","青森.jp","静岡.jp","香川.jp","高知.jp","鳥取.jp","鹿児島.jp","*.kawasaki.jp","!city.kawasaki.jp","*.kitakyushu.jp","!city.kitakyushu.jp","*.kobe.jp","!city.kobe.jp","*.nagoya.jp","!city.nagoya.jp","*.sapporo.jp","!city.sapporo.jp","*.sendai.jp","!city.sendai.jp","*.yokohama.jp","!city.yokohama.jp","aisai.aichi.jp","ama.aichi.jp","anjo.aichi.jp","asuke.aichi.jp","chiryu.aichi.jp","chita.aichi.jp","fuso.aichi.jp","gamagori.aichi.jp","handa.aichi.jp","hazu.aichi.jp","hekinan.aichi.jp","higashiura.aichi.jp","ichinomiya.aichi.jp","inazawa.aichi.jp","inuyama.aichi.jp","isshiki.aichi.jp","iwakura.aichi.jp","kanie.aichi.jp","kariya.aichi.jp","kasugai.aichi.jp","kira.aichi.jp","kiyosu.aichi.jp","komaki.aichi.jp","konan.aichi.jp","kota.aichi.jp","mihama.aichi.jp","miyoshi.aichi.jp","nishio.aichi.jp","nisshin.aichi.jp","obu.aichi.jp","oguchi.aichi.jp","oharu.aichi.jp","okazaki.aichi.jp","owariasahi.aichi.jp","seto.aichi.jp","shikatsu.aichi.jp","shinshiro.aichi.jp","shitara.aichi.jp","tahara.aichi.jp","takahama.aichi.jp","tobishima.aichi.jp","toei.aichi.jp","togo.aichi.jp","tokai.aichi.jp","tokoname.aichi.jp","toyoake.aichi.jp","toyohashi.aichi.jp","toyokawa.aichi.jp","toyone.aichi.jp","toyota.aichi.jp","tsushima.aichi.jp","yatomi.aichi.jp","akita.akita.jp","daisen.akita.jp","fujisato.akita.jp","gojome.akita.jp","hachirogata.akita.jp","happou.akita.jp","higashinaruse.akita.jp","honjo.akita.jp","honjyo.akita.jp","ikawa.akita.jp","kamikoani.akita.jp","kamioka.akita.jp","katagami.akita.jp","kazuno.akita.jp","kitaakita.akita.jp","kosaka.akita.jp","kyowa.akita.jp","misato.akita.jp","mitane.akita.jp","moriyoshi.akita.jp","nikaho.akita.jp","noshiro.akita.jp","odate.akita.jp","oga.akita.jp","ogata.akita.jp","semboku.akita.jp","yokote.akita.jp","yurihonjo.akita.jp","aomori.aomori.jp","gonohe.aomori.jp","hachinohe.aomori.jp","hashikami.aomori.jp","hiranai.aomori.jp","hirosaki.aomori.jp","itayanagi.aomori.jp","kuroishi.aomori.jp","misawa.aomori.jp","mutsu.aomori.jp","nakadomari.aomori.jp","noheji.aomori.jp","oirase.aomori.jp","owani.aomori.jp","rokunohe.aomori.jp","sannohe.aomori.jp","shichinohe.aomori.jp","shingo.aomori.jp","takko.aomori.jp","towada.aomori.jp","tsugaru.aomori.jp","tsuruta.aomori.jp","abiko.chiba.jp","asahi.chiba.jp","chonan.chiba.jp","chosei.chiba.jp","choshi.chiba.jp","chuo.chiba.jp","funabashi.chiba.jp","futtsu.chiba.jp","hanamigawa.chiba.jp","ichihara.chiba.jp","ichikawa.chiba.jp","ichinomiya.chiba.jp","inzai.chiba.jp","isumi.chiba.jp","kamagaya.chiba.jp","kamogawa.chiba.jp","kashiwa.chiba.jp","katori.chiba.jp","katsuura.chiba.jp","kimitsu.chiba.jp","kisarazu.chiba.jp","kozaki.chiba.jp","kujukuri.chiba.jp","kyonan.chiba.jp","matsudo.chiba.jp","midori.chiba.jp","mihama.chiba.jp","minamiboso.chiba.jp","mobara.chiba.jp","mutsuzawa.chiba.jp","nagara.chiba.jp","nagareyama.chiba.jp","narashino.chiba.jp","narita.chiba.jp","noda.chiba.jp","oamishirasato.chiba.jp","omigawa.chiba.jp","onjuku.chiba.jp","otaki.chiba.jp","sakae.chiba.jp","sakura.chiba.jp","shimofusa.chiba.jp","shirako.chiba.jp","shiroi.chiba.jp","shisui.chiba.jp","sodegaura.chiba.jp","sosa.chiba.jp","tako.chiba.jp","tateyama.chiba.jp","togane.chiba.jp","tohnosho.chiba.jp","tomisato.chiba.jp","urayasu.chiba.jp","yachimata.chiba.jp","yachiyo.chiba.jp","yokaichiba.chiba.jp","yokoshibahikari.chiba.jp","yotsukaido.chiba.jp","ainan.ehime.jp","honai.ehime.jp","ikata.ehime.jp","imabari.ehime.jp","iyo.ehime.jp","kamijima.ehime.jp","kihoku.ehime.jp","kumakogen.ehime.jp","masaki.ehime.jp","matsuno.ehime.jp","matsuyama.ehime.jp","namikata.ehime.jp","niihama.ehime.jp","ozu.ehime.jp","saijo.ehime.jp","seiyo.ehime.jp","shikokuchuo.ehime.jp","tobe.ehime.jp","toon.ehime.jp","uchiko.ehime.jp","uwajima.ehime.jp","yawatahama.ehime.jp","echizen.fukui.jp","eiheiji.fukui.jp","fukui.fukui.jp","ikeda.fukui.jp","katsuyama.fukui.jp","mihama.fukui.jp","minamiechizen.fukui.jp","obama.fukui.jp","ohi.fukui.jp","ono.fukui.jp","sabae.fukui.jp","sakai.fukui.jp","takahama.fukui.jp","tsuruga.fukui.jp","wakasa.fukui.jp","ashiya.fukuoka.jp","buzen.fukuoka.jp","chikugo.fukuoka.jp","chikuho.fukuoka.jp","chikujo.fukuoka.jp","chikushino.fukuoka.jp","chikuzen.fukuoka.jp","chuo.fukuoka.jp","dazaifu.fukuoka.jp","fukuchi.fukuoka.jp","hakata.fukuoka.jp","higashi.fukuoka.jp","hirokawa.fukuoka.jp","hisayama.fukuoka.jp","iizuka.fukuoka.jp","inatsuki.fukuoka.jp","kaho.fukuoka.jp","kasuga.fukuoka.jp","kasuya.fukuoka.jp","kawara.fukuoka.jp","keisen.fukuoka.jp","koga.fukuoka.jp","kurate.fukuoka.jp","kurogi.fukuoka.jp","kurume.fukuoka.jp","minami.fukuoka.jp","miyako.fukuoka.jp","miyama.fukuoka.jp","miyawaka.fukuoka.jp","mizumaki.fukuoka.jp","munakata.fukuoka.jp","nakagawa.fukuoka.jp","nakama.fukuoka.jp","nishi.fukuoka.jp","nogata.fukuoka.jp","ogori.fukuoka.jp","okagaki.fukuoka.jp","okawa.fukuoka.jp","oki.fukuoka.jp","omuta.fukuoka.jp","onga.fukuoka.jp","onojo.fukuoka.jp","oto.fukuoka.jp","saigawa.fukuoka.jp","sasaguri.fukuoka.jp","shingu.fukuoka.jp","shinyoshitomi.fukuoka.jp","shonai.fukuoka.jp","soeda.fukuoka.jp","sue.fukuoka.jp","tachiarai.fukuoka.jp","tagawa.fukuoka.jp","takata.fukuoka.jp","toho.fukuoka.jp","toyotsu.fukuoka.jp","tsuiki.fukuoka.jp","ukiha.fukuoka.jp","umi.fukuoka.jp","usui.fukuoka.jp","yamada.fukuoka.jp","yame.fukuoka.jp","yanagawa.fukuoka.jp","yukuhashi.fukuoka.jp","aizubange.fukushima.jp","aizumisato.fukushima.jp","aizuwakamatsu.fukushima.jp","asakawa.fukushima.jp","bandai.fukushima.jp","date.fukushima.jp","fukushima.fukushima.jp","furudono.fukushima.jp","futaba.fukushima.jp","hanawa.fukushima.jp","higashi.fukushima.jp","hirata.fukushima.jp","hirono.fukushima.jp","iitate.fukushima.jp","inawashiro.fukushima.jp","ishikawa.fukushima.jp","iwaki.fukushima.jp","izumizaki.fukushima.jp","kagamiishi.fukushima.jp","kaneyama.fukushima.jp","kawamata.fukushima.jp","kitakata.fukushima.jp","kitashiobara.fukushima.jp","koori.fukushima.jp","koriyama.fukushima.jp","kunimi.fukushima.jp","miharu.fukushima.jp","mishima.fukushima.jp","namie.fukushima.jp","nango.fukushima.jp","nishiaizu.fukushima.jp","nishigo.fukushima.jp","okuma.fukushima.jp","omotego.fukushima.jp","ono.fukushima.jp","otama.fukushima.jp","samegawa.fukushima.jp","shimogo.fukushima.jp","shirakawa.fukushima.jp","showa.fukushima.jp","soma.fukushima.jp","sukagawa.fukushima.jp","taishin.fukushima.jp","tamakawa.fukushima.jp","tanagura.fukushima.jp","tenei.fukushima.jp","yabuki.fukushima.jp","yamato.fukushima.jp","yamatsuri.fukushima.jp","yanaizu.fukushima.jp","yugawa.fukushima.jp","anpachi.gifu.jp","ena.gifu.jp","gifu.gifu.jp","ginan.gifu.jp","godo.gifu.jp","gujo.gifu.jp","hashima.gifu.jp","hichiso.gifu.jp","hida.gifu.jp","higashishirakawa.gifu.jp","ibigawa.gifu.jp","ikeda.gifu.jp","kakamigahara.gifu.jp","kani.gifu.jp","kasahara.gifu.jp","kasamatsu.gifu.jp","kawaue.gifu.jp","kitagata.gifu.jp","mino.gifu.jp","minokamo.gifu.jp","mitake.gifu.jp","mizunami.gifu.jp","motosu.gifu.jp","nakatsugawa.gifu.jp","ogaki.gifu.jp","sakahogi.gifu.jp","seki.gifu.jp","sekigahara.gifu.jp","shirakawa.gifu.jp","tajimi.gifu.jp","takayama.gifu.jp","tarui.gifu.jp","toki.gifu.jp","tomika.gifu.jp","wanouchi.gifu.jp","yamagata.gifu.jp","yaotsu.gifu.jp","yoro.gifu.jp","annaka.gunma.jp","chiyoda.gunma.jp","fujioka.gunma.jp","higashiagatsuma.gunma.jp","isesaki.gunma.jp","itakura.gunma.jp","kanna.gunma.jp","kanra.gunma.jp","katashina.gunma.jp","kawaba.gunma.jp","kiryu.gunma.jp","kusatsu.gunma.jp","maebashi.gunma.jp","meiwa.gunma.jp","midori.gunma.jp","minakami.gunma.jp","naganohara.gunma.jp","nakanojo.gunma.jp","nanmoku.gunma.jp","numata.gunma.jp","oizumi.gunma.jp","ora.gunma.jp","ota.gunma.jp","shibukawa.gunma.jp","shimonita.gunma.jp","shinto.gunma.jp","showa.gunma.jp","takasaki.gunma.jp","takayama.gunma.jp","tamamura.gunma.jp","tatebayashi.gunma.jp","tomioka.gunma.jp","tsukiyono.gunma.jp","tsumagoi.gunma.jp","ueno.gunma.jp","yoshioka.gunma.jp","asaminami.hiroshima.jp","daiwa.hiroshima.jp","etajima.hiroshima.jp","fuchu.hiroshima.jp","fukuyama.hiroshima.jp","hatsukaichi.hiroshima.jp","higashihiroshima.hiroshima.jp","hongo.hiroshima.jp","jinsekikogen.hiroshima.jp","kaita.hiroshima.jp","kui.hiroshima.jp","kumano.hiroshima.jp","kure.hiroshima.jp","mihara.hiroshima.jp","miyoshi.hiroshima.jp","naka.hiroshima.jp","onomichi.hiroshima.jp","osakikamijima.hiroshima.jp","otake.hiroshima.jp","saka.hiroshima.jp","sera.hiroshima.jp","seranishi.hiroshima.jp","shinichi.hiroshima.jp","shobara.hiroshima.jp","takehara.hiroshima.jp","abashiri.hokkaido.jp","abira.hokkaido.jp","aibetsu.hokkaido.jp","akabira.hokkaido.jp","akkeshi.hokkaido.jp","asahikawa.hokkaido.jp","ashibetsu.hokkaido.jp","ashoro.hokkaido.jp","assabu.hokkaido.jp","atsuma.hokkaido.jp","bibai.hokkaido.jp","biei.hokkaido.jp","bifuka.hokkaido.jp","bihoro.hokkaido.jp","biratori.hokkaido.jp","chippubetsu.hokkaido.jp","chitose.hokkaido.jp","date.hokkaido.jp","ebetsu.hokkaido.jp","embetsu.hokkaido.jp","eniwa.hokkaido.jp","erimo.hokkaido.jp","esan.hokkaido.jp","esashi.hokkaido.jp","fukagawa.hokkaido.jp","fukushima.hokkaido.jp","furano.hokkaido.jp","furubira.hokkaido.jp","haboro.hokkaido.jp","hakodate.hokkaido.jp","hamatonbetsu.hokkaido.jp","hidaka.hokkaido.jp","higashikagura.hokkaido.jp","higashikawa.hokkaido.jp","hiroo.hokkaido.jp","hokuryu.hokkaido.jp","hokuto.hokkaido.jp","honbetsu.hokkaido.jp","horokanai.hokkaido.jp","horonobe.hokkaido.jp","ikeda.hokkaido.jp","imakane.hokkaido.jp","ishikari.hokkaido.jp","iwamizawa.hokkaido.jp","iwanai.hokkaido.jp","kamifurano.hokkaido.jp","kamikawa.hokkaido.jp","kamishihoro.hokkaido.jp","kamisunagawa.hokkaido.jp","kamoenai.hokkaido.jp","kayabe.hokkaido.jp","kembuchi.hokkaido.jp","kikonai.hokkaido.jp","kimobetsu.hokkaido.jp","kitahiroshima.hokkaido.jp","kitami.hokkaido.jp","kiyosato.hokkaido.jp","koshimizu.hokkaido.jp","kunneppu.hokkaido.jp","kuriyama.hokkaido.jp","kuromatsunai.hokkaido.jp","kushiro.hokkaido.jp","kutchan.hokkaido.jp","kyowa.hokkaido.jp","mashike.hokkaido.jp","matsumae.hokkaido.jp","mikasa.hokkaido.jp","minamifurano.hokkaido.jp","mombetsu.hokkaido.jp","moseushi.hokkaido.jp","mukawa.hokkaido.jp","muroran.hokkaido.jp","naie.hokkaido.jp","nakagawa.hokkaido.jp","nakasatsunai.hokkaido.jp","nakatombetsu.hokkaido.jp","nanae.hokkaido.jp","nanporo.hokkaido.jp","nayoro.hokkaido.jp","nemuro.hokkaido.jp","niikappu.hokkaido.jp","niki.hokkaido.jp","nishiokoppe.hokkaido.jp","noboribetsu.hokkaido.jp","numata.hokkaido.jp","obihiro.hokkaido.jp","obira.hokkaido.jp","oketo.hokkaido.jp","okoppe.hokkaido.jp","otaru.hokkaido.jp","otobe.hokkaido.jp","otofuke.hokkaido.jp","otoineppu.hokkaido.jp","oumu.hokkaido.jp","ozora.hokkaido.jp","pippu.hokkaido.jp","rankoshi.hokkaido.jp","rebun.hokkaido.jp","rikubetsu.hokkaido.jp","rishiri.hokkaido.jp","rishirifuji.hokkaido.jp","saroma.hokkaido.jp","sarufutsu.hokkaido.jp","shakotan.hokkaido.jp","shari.hokkaido.jp","shibecha.hokkaido.jp","shibetsu.hokkaido.jp","shikabe.hokkaido.jp","shikaoi.hokkaido.jp","shimamaki.hokkaido.jp","shimizu.hokkaido.jp","shimokawa.hokkaido.jp","shinshinotsu.hokkaido.jp","shintoku.hokkaido.jp","shiranuka.hokkaido.jp","shiraoi.hokkaido.jp","shiriuchi.hokkaido.jp","sobetsu.hokkaido.jp","sunagawa.hokkaido.jp","taiki.hokkaido.jp","takasu.hokkaido.jp","takikawa.hokkaido.jp","takinoue.hokkaido.jp","teshikaga.hokkaido.jp","tobetsu.hokkaido.jp","tohma.hokkaido.jp","tomakomai.hokkaido.jp","tomari.hokkaido.jp","toya.hokkaido.jp","toyako.hokkaido.jp","toyotomi.hokkaido.jp","toyoura.hokkaido.jp","tsubetsu.hokkaido.jp","tsukigata.hokkaido.jp","urakawa.hokkaido.jp","urausu.hokkaido.jp","uryu.hokkaido.jp","utashinai.hokkaido.jp","wakkanai.hokkaido.jp","wassamu.hokkaido.jp","yakumo.hokkaido.jp","yoichi.hokkaido.jp","aioi.hyogo.jp","akashi.hyogo.jp","ako.hyogo.jp","amagasaki.hyogo.jp","aogaki.hyogo.jp","asago.hyogo.jp","ashiya.hyogo.jp","awaji.hyogo.jp","fukusaki.hyogo.jp","goshiki.hyogo.jp","harima.hyogo.jp","himeji.hyogo.jp","ichikawa.hyogo.jp","inagawa.hyogo.jp","itami.hyogo.jp","kakogawa.hyogo.jp","kamigori.hyogo.jp","kamikawa.hyogo.jp","kasai.hyogo.jp","kasuga.hyogo.jp","kawanishi.hyogo.jp","miki.hyogo.jp","minamiawaji.hyogo.jp","nishinomiya.hyogo.jp","nishiwaki.hyogo.jp","ono.hyogo.jp","sanda.hyogo.jp","sannan.hyogo.jp","sasayama.hyogo.jp","sayo.hyogo.jp","shingu.hyogo.jp","shinonsen.hyogo.jp","shiso.hyogo.jp","sumoto.hyogo.jp","taishi.hyogo.jp","taka.hyogo.jp","takarazuka.hyogo.jp","takasago.hyogo.jp","takino.hyogo.jp","tamba.hyogo.jp","tatsuno.hyogo.jp","toyooka.hyogo.jp","yabu.hyogo.jp","yashiro.hyogo.jp","yoka.hyogo.jp","yokawa.hyogo.jp","ami.ibaraki.jp","asahi.ibaraki.jp","bando.ibaraki.jp","chikusei.ibaraki.jp","daigo.ibaraki.jp","fujishiro.ibaraki.jp","hitachi.ibaraki.jp","hitachinaka.ibaraki.jp","hitachiomiya.ibaraki.jp","hitachiota.ibaraki.jp","ibaraki.ibaraki.jp","ina.ibaraki.jp","inashiki.ibaraki.jp","itako.ibaraki.jp","iwama.ibaraki.jp","joso.ibaraki.jp","kamisu.ibaraki.jp","kasama.ibaraki.jp","kashima.ibaraki.jp","kasumigaura.ibaraki.jp","koga.ibaraki.jp","miho.ibaraki.jp","mito.ibaraki.jp","moriya.ibaraki.jp","naka.ibaraki.jp","namegata.ibaraki.jp","oarai.ibaraki.jp","ogawa.ibaraki.jp","omitama.ibaraki.jp","ryugasaki.ibaraki.jp","sakai.ibaraki.jp","sakuragawa.ibaraki.jp","shimodate.ibaraki.jp","shimotsuma.ibaraki.jp","shirosato.ibaraki.jp","sowa.ibaraki.jp","suifu.ibaraki.jp","takahagi.ibaraki.jp","tamatsukuri.ibaraki.jp","tokai.ibaraki.jp","tomobe.ibaraki.jp","tone.ibaraki.jp","toride.ibaraki.jp","tsuchiura.ibaraki.jp","tsukuba.ibaraki.jp","uchihara.ibaraki.jp","ushiku.ibaraki.jp","yachiyo.ibaraki.jp","yamagata.ibaraki.jp","yawara.ibaraki.jp","yuki.ibaraki.jp","anamizu.ishikawa.jp","hakui.ishikawa.jp","hakusan.ishikawa.jp","kaga.ishikawa.jp","kahoku.ishikawa.jp","kanazawa.ishikawa.jp","kawakita.ishikawa.jp","komatsu.ishikawa.jp","nakanoto.ishikawa.jp","nanao.ishikawa.jp","nomi.ishikawa.jp","nonoichi.ishikawa.jp","noto.ishikawa.jp","shika.ishikawa.jp","suzu.ishikawa.jp","tsubata.ishikawa.jp","tsurugi.ishikawa.jp","uchinada.ishikawa.jp","wajima.ishikawa.jp","fudai.iwate.jp","fujisawa.iwate.jp","hanamaki.iwate.jp","hiraizumi.iwate.jp","hirono.iwate.jp","ichinohe.iwate.jp","ichinoseki.iwate.jp","iwaizumi.iwate.jp","iwate.iwate.jp","joboji.iwate.jp","kamaishi.iwate.jp","kanegasaki.iwate.jp","karumai.iwate.jp","kawai.iwate.jp","kitakami.iwate.jp","kuji.iwate.jp","kunohe.iwate.jp","kuzumaki.iwate.jp","miyako.iwate.jp","mizusawa.iwate.jp","morioka.iwate.jp","ninohe.iwate.jp","noda.iwate.jp","ofunato.iwate.jp","oshu.iwate.jp","otsuchi.iwate.jp","rikuzentakata.iwate.jp","shiwa.iwate.jp","shizukuishi.iwate.jp","sumita.iwate.jp","tanohata.iwate.jp","tono.iwate.jp","yahaba.iwate.jp","yamada.iwate.jp","ayagawa.kagawa.jp","higashikagawa.kagawa.jp","kanonji.kagawa.jp","kotohira.kagawa.jp","manno.kagawa.jp","marugame.kagawa.jp","mitoyo.kagawa.jp","naoshima.kagawa.jp","sanuki.kagawa.jp","tadotsu.kagawa.jp","takamatsu.kagawa.jp","tonosho.kagawa.jp","uchinomi.kagawa.jp","utazu.kagawa.jp","zentsuji.kagawa.jp","akune.kagoshima.jp","amami.kagoshima.jp","hioki.kagoshima.jp","isa.kagoshima.jp","isen.kagoshima.jp","izumi.kagoshima.jp","kagoshima.kagoshima.jp","kanoya.kagoshima.jp","kawanabe.kagoshima.jp","kinko.kagoshima.jp","kouyama.kagoshima.jp","makurazaki.kagoshima.jp","matsumoto.kagoshima.jp","minamitane.kagoshima.jp","nakatane.kagoshima.jp","nishinoomote.kagoshima.jp","satsumasendai.kagoshima.jp","soo.kagoshima.jp","tarumizu.kagoshima.jp","yusui.kagoshima.jp","aikawa.kanagawa.jp","atsugi.kanagawa.jp","ayase.kanagawa.jp","chigasaki.kanagawa.jp","ebina.kanagawa.jp","fujisawa.kanagawa.jp","hadano.kanagawa.jp","hakone.kanagawa.jp","hiratsuka.kanagawa.jp","isehara.kanagawa.jp","kaisei.kanagawa.jp","kamakura.kanagawa.jp","kiyokawa.kanagawa.jp","matsuda.kanagawa.jp","minamiashigara.kanagawa.jp","miura.kanagawa.jp","nakai.kanagawa.jp","ninomiya.kanagawa.jp","odawara.kanagawa.jp","oi.kanagawa.jp","oiso.kanagawa.jp","sagamihara.kanagawa.jp","samukawa.kanagawa.jp","tsukui.kanagawa.jp","yamakita.kanagawa.jp","yamato.kanagawa.jp","yokosuka.kanagawa.jp","yugawara.kanagawa.jp","zama.kanagawa.jp","zushi.kanagawa.jp","aki.kochi.jp","geisei.kochi.jp","hidaka.kochi.jp","higashitsuno.kochi.jp","ino.kochi.jp","kagami.kochi.jp","kami.kochi.jp","kitagawa.kochi.jp","kochi.kochi.jp","mihara.kochi.jp","motoyama.kochi.jp","muroto.kochi.jp","nahari.kochi.jp","nakamura.kochi.jp","nankoku.kochi.jp","nishitosa.kochi.jp","niyodogawa.kochi.jp","ochi.kochi.jp","okawa.kochi.jp","otoyo.kochi.jp","otsuki.kochi.jp","sakawa.kochi.jp","sukumo.kochi.jp","susaki.kochi.jp","tosa.kochi.jp","tosashimizu.kochi.jp","toyo.kochi.jp","tsuno.kochi.jp","umaji.kochi.jp","yasuda.kochi.jp","yusuhara.kochi.jp","amakusa.kumamoto.jp","arao.kumamoto.jp","aso.kumamoto.jp","choyo.kumamoto.jp","gyokuto.kumamoto.jp","kamiamakusa.kumamoto.jp","kikuchi.kumamoto.jp","kumamoto.kumamoto.jp","mashiki.kumamoto.jp","mifune.kumamoto.jp","minamata.kumamoto.jp","minamioguni.kumamoto.jp","nagasu.kumamoto.jp","nishihara.kumamoto.jp","oguni.kumamoto.jp","ozu.kumamoto.jp","sumoto.kumamoto.jp","takamori.kumamoto.jp","uki.kumamoto.jp","uto.kumamoto.jp","yamaga.kumamoto.jp","yamato.kumamoto.jp","yatsushiro.kumamoto.jp","ayabe.kyoto.jp","fukuchiyama.kyoto.jp","higashiyama.kyoto.jp","ide.kyoto.jp","ine.kyoto.jp","joyo.kyoto.jp","kameoka.kyoto.jp","kamo.kyoto.jp","kita.kyoto.jp","kizu.kyoto.jp","kumiyama.kyoto.jp","kyotamba.kyoto.jp","kyotanabe.kyoto.jp","kyotango.kyoto.jp","maizuru.kyoto.jp","minami.kyoto.jp","minamiyamashiro.kyoto.jp","miyazu.kyoto.jp","muko.kyoto.jp","nagaokakyo.kyoto.jp","nakagyo.kyoto.jp","nantan.kyoto.jp","oyamazaki.kyoto.jp","sakyo.kyoto.jp","seika.kyoto.jp","tanabe.kyoto.jp","uji.kyoto.jp","ujitawara.kyoto.jp","wazuka.kyoto.jp","yamashina.kyoto.jp","yawata.kyoto.jp","asahi.mie.jp","inabe.mie.jp","ise.mie.jp","kameyama.mie.jp","kawagoe.mie.jp","kiho.mie.jp","kisosaki.mie.jp","kiwa.mie.jp","komono.mie.jp","kumano.mie.jp","kuwana.mie.jp","matsusaka.mie.jp","meiwa.mie.jp","mihama.mie.jp","minamiise.mie.jp","misugi.mie.jp","miyama.mie.jp","nabari.mie.jp","shima.mie.jp","suzuka.mie.jp","tado.mie.jp","taiki.mie.jp","taki.mie.jp","tamaki.mie.jp","toba.mie.jp","tsu.mie.jp","udono.mie.jp","ureshino.mie.jp","watarai.mie.jp","yokkaichi.mie.jp","furukawa.miyagi.jp","higashimatsushima.miyagi.jp","ishinomaki.miyagi.jp","iwanuma.miyagi.jp","kakuda.miyagi.jp","kami.miyagi.jp","kawasaki.miyagi.jp","marumori.miyagi.jp","matsushima.miyagi.jp","minamisanriku.miyagi.jp","misato.miyagi.jp","murata.miyagi.jp","natori.miyagi.jp","ogawara.miyagi.jp","ohira.miyagi.jp","onagawa.miyagi.jp","osaki.miyagi.jp","rifu.miyagi.jp","semine.miyagi.jp","shibata.miyagi.jp","shichikashuku.miyagi.jp","shikama.miyagi.jp","shiogama.miyagi.jp","shiroishi.miyagi.jp","tagajo.miyagi.jp","taiwa.miyagi.jp","tome.miyagi.jp","tomiya.miyagi.jp","wakuya.miyagi.jp","watari.miyagi.jp","yamamoto.miyagi.jp","zao.miyagi.jp","aya.miyazaki.jp","ebino.miyazaki.jp","gokase.miyazaki.jp","hyuga.miyazaki.jp","kadogawa.miyazaki.jp","kawaminami.miyazaki.jp","kijo.miyazaki.jp","kitagawa.miyazaki.jp","kitakata.miyazaki.jp","kitaura.miyazaki.jp","kobayashi.miyazaki.jp","kunitomi.miyazaki.jp","kushima.miyazaki.jp","mimata.miyazaki.jp","miyakonojo.miyazaki.jp","miyazaki.miyazaki.jp","morotsuka.miyazaki.jp","nichinan.miyazaki.jp","nishimera.miyazaki.jp","nobeoka.miyazaki.jp","saito.miyazaki.jp","shiiba.miyazaki.jp","shintomi.miyazaki.jp","takaharu.miyazaki.jp","takanabe.miyazaki.jp","takazaki.miyazaki.jp","tsuno.miyazaki.jp","achi.nagano.jp","agematsu.nagano.jp","anan.nagano.jp","aoki.nagano.jp","asahi.nagano.jp","azumino.nagano.jp","chikuhoku.nagano.jp","chikuma.nagano.jp","chino.nagano.jp","fujimi.nagano.jp","hakuba.nagano.jp","hara.nagano.jp","hiraya.nagano.jp","iida.nagano.jp","iijima.nagano.jp","iiyama.nagano.jp","iizuna.nagano.jp","ikeda.nagano.jp","ikusaka.nagano.jp","ina.nagano.jp","karuizawa.nagano.jp","kawakami.nagano.jp","kiso.nagano.jp","kisofukushima.nagano.jp","kitaaiki.nagano.jp","komagane.nagano.jp","komoro.nagano.jp","matsukawa.nagano.jp","matsumoto.nagano.jp","miasa.nagano.jp","minamiaiki.nagano.jp","minamimaki.nagano.jp","minamiminowa.nagano.jp","minowa.nagano.jp","miyada.nagano.jp","miyota.nagano.jp","mochizuki.nagano.jp","nagano.nagano.jp","nagawa.nagano.jp","nagiso.nagano.jp","nakagawa.nagano.jp","nakano.nagano.jp","nozawaonsen.nagano.jp","obuse.nagano.jp","ogawa.nagano.jp","okaya.nagano.jp","omachi.nagano.jp","omi.nagano.jp","ookuwa.nagano.jp","ooshika.nagano.jp","otaki.nagano.jp","otari.nagano.jp","sakae.nagano.jp","sakaki.nagano.jp","saku.nagano.jp","sakuho.nagano.jp","shimosuwa.nagano.jp","shinanomachi.nagano.jp","shiojiri.nagano.jp","suwa.nagano.jp","suzaka.nagano.jp","takagi.nagano.jp","takamori.nagano.jp","takayama.nagano.jp","tateshina.nagano.jp","tatsuno.nagano.jp","togakushi.nagano.jp","togura.nagano.jp","tomi.nagano.jp","ueda.nagano.jp","wada.nagano.jp","yamagata.nagano.jp","yamanouchi.nagano.jp","yasaka.nagano.jp","yasuoka.nagano.jp","chijiwa.nagasaki.jp","futsu.nagasaki.jp","goto.nagasaki.jp","hasami.nagasaki.jp","hirado.nagasaki.jp","iki.nagasaki.jp","isahaya.nagasaki.jp","kawatana.nagasaki.jp","kuchinotsu.nagasaki.jp","matsuura.nagasaki.jp","nagasaki.nagasaki.jp","obama.nagasaki.jp","omura.nagasaki.jp","oseto.nagasaki.jp","saikai.nagasaki.jp","sasebo.nagasaki.jp","seihi.nagasaki.jp","shimabara.nagasaki.jp","shinkamigoto.nagasaki.jp","togitsu.nagasaki.jp","tsushima.nagasaki.jp","unzen.nagasaki.jp","ando.nara.jp","gose.nara.jp","heguri.nara.jp","higashiyoshino.nara.jp","ikaruga.nara.jp","ikoma.nara.jp","kamikitayama.nara.jp","kanmaki.nara.jp","kashiba.nara.jp","kashihara.nara.jp","katsuragi.nara.jp","kawai.nara.jp","kawakami.nara.jp","kawanishi.nara.jp","koryo.nara.jp","kurotaki.nara.jp","mitsue.nara.jp","miyake.nara.jp","nara.nara.jp","nosegawa.nara.jp","oji.nara.jp","ouda.nara.jp","oyodo.nara.jp","sakurai.nara.jp","sango.nara.jp","shimoichi.nara.jp","shimokitayama.nara.jp","shinjo.nara.jp","soni.nara.jp","takatori.nara.jp","tawaramoto.nara.jp","tenkawa.nara.jp","tenri.nara.jp","uda.nara.jp","yamatokoriyama.nara.jp","yamatotakada.nara.jp","yamazoe.nara.jp","yoshino.nara.jp","aga.niigata.jp","agano.niigata.jp","gosen.niigata.jp","itoigawa.niigata.jp","izumozaki.niigata.jp","joetsu.niigata.jp","kamo.niigata.jp","kariwa.niigata.jp","kashiwazaki.niigata.jp","minamiuonuma.niigata.jp","mitsuke.niigata.jp","muika.niigata.jp","murakami.niigata.jp","myoko.niigata.jp","nagaoka.niigata.jp","niigata.niigata.jp","ojiya.niigata.jp","omi.niigata.jp","sado.niigata.jp","sanjo.niigata.jp","seiro.niigata.jp","seirou.niigata.jp","sekikawa.niigata.jp","shibata.niigata.jp","tagami.niigata.jp","tainai.niigata.jp","tochio.niigata.jp","tokamachi.niigata.jp","tsubame.niigata.jp","tsunan.niigata.jp","uonuma.niigata.jp","yahiko.niigata.jp","yoita.niigata.jp","yuzawa.niigata.jp","beppu.oita.jp","bungoono.oita.jp","bungotakada.oita.jp","hasama.oita.jp","hiji.oita.jp","himeshima.oita.jp","hita.oita.jp","kamitsue.oita.jp","kokonoe.oita.jp","kuju.oita.jp","kunisaki.oita.jp","kusu.oita.jp","oita.oita.jp","saiki.oita.jp","taketa.oita.jp","tsukumi.oita.jp","usa.oita.jp","usuki.oita.jp","yufu.oita.jp","akaiwa.okayama.jp","asakuchi.okayama.jp","bizen.okayama.jp","hayashima.okayama.jp","ibara.okayama.jp","kagamino.okayama.jp","kasaoka.okayama.jp","kibichuo.okayama.jp","kumenan.okayama.jp","kurashiki.okayama.jp","maniwa.okayama.jp","misaki.okayama.jp","nagi.okayama.jp","niimi.okayama.jp","nishiawakura.okayama.jp","okayama.okayama.jp","satosho.okayama.jp","setouchi.okayama.jp","shinjo.okayama.jp","shoo.okayama.jp","soja.okayama.jp","takahashi.okayama.jp","tamano.okayama.jp","tsuyama.okayama.jp","wake.okayama.jp","yakage.okayama.jp","aguni.okinawa.jp","ginowan.okinawa.jp","ginoza.okinawa.jp","gushikami.okinawa.jp","haebaru.okinawa.jp","higashi.okinawa.jp","hirara.okinawa.jp","iheya.okinawa.jp","ishigaki.okinawa.jp","ishikawa.okinawa.jp","itoman.okinawa.jp","izena.okinawa.jp","kadena.okinawa.jp","kin.okinawa.jp","kitadaito.okinawa.jp","kitanakagusuku.okinawa.jp","kumejima.okinawa.jp","kunigami.okinawa.jp","minamidaito.okinawa.jp","motobu.okinawa.jp","nago.okinawa.jp","naha.okinawa.jp","nakagusuku.okinawa.jp","nakijin.okinawa.jp","nanjo.okinawa.jp","nishihara.okinawa.jp","ogimi.okinawa.jp","okinawa.okinawa.jp","onna.okinawa.jp","shimoji.okinawa.jp","taketomi.okinawa.jp","tarama.okinawa.jp","tokashiki.okinawa.jp","tomigusuku.okinawa.jp","tonaki.okinawa.jp","urasoe.okinawa.jp","uruma.okinawa.jp","yaese.okinawa.jp","yomitan.okinawa.jp","yonabaru.okinawa.jp","yonaguni.okinawa.jp","zamami.okinawa.jp","abeno.osaka.jp","chihayaakasaka.osaka.jp","chuo.osaka.jp","daito.osaka.jp","fujiidera.osaka.jp","habikino.osaka.jp","hannan.osaka.jp","higashiosaka.osaka.jp","higashisumiyoshi.osaka.jp","higashiyodogawa.osaka.jp","hirakata.osaka.jp","ibaraki.osaka.jp","ikeda.osaka.jp","izumi.osaka.jp","izumiotsu.osaka.jp","izumisano.osaka.jp","kadoma.osaka.jp","kaizuka.osaka.jp","kanan.osaka.jp","kashiwara.osaka.jp","katano.osaka.jp","kawachinagano.osaka.jp","kishiwada.osaka.jp","kita.osaka.jp","kumatori.osaka.jp","matsubara.osaka.jp","minato.osaka.jp","minoh.osaka.jp","misaki.osaka.jp","moriguchi.osaka.jp","neyagawa.osaka.jp","nishi.osaka.jp","nose.osaka.jp","osakasayama.osaka.jp","sakai.osaka.jp","sayama.osaka.jp","sennan.osaka.jp","settsu.osaka.jp","shijonawate.osaka.jp","shimamoto.osaka.jp","suita.osaka.jp","tadaoka.osaka.jp","taishi.osaka.jp","tajiri.osaka.jp","takaishi.osaka.jp","takatsuki.osaka.jp","tondabayashi.osaka.jp","toyonaka.osaka.jp","toyono.osaka.jp","yao.osaka.jp","ariake.saga.jp","arita.saga.jp","fukudomi.saga.jp","genkai.saga.jp","hamatama.saga.jp","hizen.saga.jp","imari.saga.jp","kamimine.saga.jp","kanzaki.saga.jp","karatsu.saga.jp","kashima.saga.jp","kitagata.saga.jp","kitahata.saga.jp","kiyama.saga.jp","kouhoku.saga.jp","kyuragi.saga.jp","nishiarita.saga.jp","ogi.saga.jp","omachi.saga.jp","ouchi.saga.jp","saga.saga.jp","shiroishi.saga.jp","taku.saga.jp","tara.saga.jp","tosu.saga.jp","yoshinogari.saga.jp","arakawa.saitama.jp","asaka.saitama.jp","chichibu.saitama.jp","fujimi.saitama.jp","fujimino.saitama.jp","fukaya.saitama.jp","hanno.saitama.jp","hanyu.saitama.jp","hasuda.saitama.jp","hatogaya.saitama.jp","hatoyama.saitama.jp","hidaka.saitama.jp","higashichichibu.saitama.jp","higashimatsuyama.saitama.jp","honjo.saitama.jp","ina.saitama.jp","iruma.saitama.jp","iwatsuki.saitama.jp","kamiizumi.saitama.jp","kamikawa.saitama.jp","kamisato.saitama.jp","kasukabe.saitama.jp","kawagoe.saitama.jp","kawaguchi.saitama.jp","kawajima.saitama.jp","kazo.saitama.jp","kitamoto.saitama.jp","koshigaya.saitama.jp","kounosu.saitama.jp","kuki.saitama.jp","kumagaya.saitama.jp","matsubushi.saitama.jp","minano.saitama.jp","misato.saitama.jp","miyashiro.saitama.jp","miyoshi.saitama.jp","moroyama.saitama.jp","nagatoro.saitama.jp","namegawa.saitama.jp","niiza.saitama.jp","ogano.saitama.jp","ogawa.saitama.jp","ogose.saitama.jp","okegawa.saitama.jp","omiya.saitama.jp","otaki.saitama.jp","ranzan.saitama.jp","ryokami.saitama.jp","saitama.saitama.jp","sakado.saitama.jp","satte.saitama.jp","sayama.saitama.jp","shiki.saitama.jp","shiraoka.saitama.jp","soka.saitama.jp","sugito.saitama.jp","toda.saitama.jp","tokigawa.saitama.jp","tokorozawa.saitama.jp","tsurugashima.saitama.jp","urawa.saitama.jp","warabi.saitama.jp","yashio.saitama.jp","yokoze.saitama.jp","yono.saitama.jp","yorii.saitama.jp","yoshida.saitama.jp","yoshikawa.saitama.jp","yoshimi.saitama.jp","aisho.shiga.jp","gamo.shiga.jp","higashiomi.shiga.jp","hikone.shiga.jp","koka.shiga.jp","konan.shiga.jp","kosei.shiga.jp","koto.shiga.jp","kusatsu.shiga.jp","maibara.shiga.jp","moriyama.shiga.jp","nagahama.shiga.jp","nishiazai.shiga.jp","notogawa.shiga.jp","omihachiman.shiga.jp","otsu.shiga.jp","ritto.shiga.jp","ryuoh.shiga.jp","takashima.shiga.jp","takatsuki.shiga.jp","torahime.shiga.jp","toyosato.shiga.jp","yasu.shiga.jp","akagi.shimane.jp","ama.shimane.jp","gotsu.shimane.jp","hamada.shimane.jp","higashiizumo.shimane.jp","hikawa.shimane.jp","hikimi.shimane.jp","izumo.shimane.jp","kakinoki.shimane.jp","masuda.shimane.jp","matsue.shimane.jp","misato.shimane.jp","nishinoshima.shimane.jp","ohda.shimane.jp","okinoshima.shimane.jp","okuizumo.shimane.jp","shimane.shimane.jp","tamayu.shimane.jp","tsuwano.shimane.jp","unnan.shimane.jp","yakumo.shimane.jp","yasugi.shimane.jp","yatsuka.shimane.jp","arai.shizuoka.jp","atami.shizuoka.jp","fuji.shizuoka.jp","fujieda.shizuoka.jp","fujikawa.shizuoka.jp","fujinomiya.shizuoka.jp","fukuroi.shizuoka.jp","gotemba.shizuoka.jp","haibara.shizuoka.jp","hamamatsu.shizuoka.jp","higashiizu.shizuoka.jp","ito.shizuoka.jp","iwata.shizuoka.jp","izu.shizuoka.jp","izunokuni.shizuoka.jp","kakegawa.shizuoka.jp","kannami.shizuoka.jp","kawanehon.shizuoka.jp","kawazu.shizuoka.jp","kikugawa.shizuoka.jp","kosai.shizuoka.jp","makinohara.shizuoka.jp","matsuzaki.shizuoka.jp","minamiizu.shizuoka.jp","mishima.shizuoka.jp","morimachi.shizuoka.jp","nishiizu.shizuoka.jp","numazu.shizuoka.jp","omaezaki.shizuoka.jp","shimada.shizuoka.jp","shimizu.shizuoka.jp","shimoda.shizuoka.jp","shizuoka.shizuoka.jp","susono.shizuoka.jp","yaizu.shizuoka.jp","yoshida.shizuoka.jp","ashikaga.tochigi.jp","bato.tochigi.jp","haga.tochigi.jp","ichikai.tochigi.jp","iwafune.tochigi.jp","kaminokawa.tochigi.jp","kanuma.tochigi.jp","karasuyama.tochigi.jp","kuroiso.tochigi.jp","mashiko.tochigi.jp","mibu.tochigi.jp","moka.tochigi.jp","motegi.tochigi.jp","nasu.tochigi.jp","nasushiobara.tochigi.jp","nikko.tochigi.jp","nishikata.tochigi.jp","nogi.tochigi.jp","ohira.tochigi.jp","ohtawara.tochigi.jp","oyama.tochigi.jp","sakura.tochigi.jp","sano.tochigi.jp","shimotsuke.tochigi.jp","shioya.tochigi.jp","takanezawa.tochigi.jp","tochigi.tochigi.jp","tsuga.tochigi.jp","ujiie.tochigi.jp","utsunomiya.tochigi.jp","yaita.tochigi.jp","aizumi.tokushima.jp","anan.tokushima.jp","ichiba.tokushima.jp","itano.tokushima.jp","kainan.tokushima.jp","komatsushima.tokushima.jp","matsushige.tokushima.jp","mima.tokushima.jp","minami.tokushima.jp","miyoshi.tokushima.jp","mugi.tokushima.jp","nakagawa.tokushima.jp","naruto.tokushima.jp","sanagochi.tokushima.jp","shishikui.tokushima.jp","tokushima.tokushima.jp","wajiki.tokushima.jp","adachi.tokyo.jp","akiruno.tokyo.jp","akishima.tokyo.jp","aogashima.tokyo.jp","arakawa.tokyo.jp","bunkyo.tokyo.jp","chiyoda.tokyo.jp","chofu.tokyo.jp","chuo.tokyo.jp","edogawa.tokyo.jp","fuchu.tokyo.jp","fussa.tokyo.jp","hachijo.tokyo.jp","hachioji.tokyo.jp","hamura.tokyo.jp","higashikurume.tokyo.jp","higashimurayama.tokyo.jp","higashiyamato.tokyo.jp","hino.tokyo.jp","hinode.tokyo.jp","hinohara.tokyo.jp","inagi.tokyo.jp","itabashi.tokyo.jp","katsushika.tokyo.jp","kita.tokyo.jp","kiyose.tokyo.jp","kodaira.tokyo.jp","koganei.tokyo.jp","kokubunji.tokyo.jp","komae.tokyo.jp","koto.tokyo.jp","kouzushima.tokyo.jp","kunitachi.tokyo.jp","machida.tokyo.jp","meguro.tokyo.jp","minato.tokyo.jp","mitaka.tokyo.jp","mizuho.tokyo.jp","musashimurayama.tokyo.jp","musashino.tokyo.jp","nakano.tokyo.jp","nerima.tokyo.jp","ogasawara.tokyo.jp","okutama.tokyo.jp","ome.tokyo.jp","oshima.tokyo.jp","ota.tokyo.jp","setagaya.tokyo.jp","shibuya.tokyo.jp","shinagawa.tokyo.jp","shinjuku.tokyo.jp","suginami.tokyo.jp","sumida.tokyo.jp","tachikawa.tokyo.jp","taito.tokyo.jp","tama.tokyo.jp","toshima.tokyo.jp","chizu.tottori.jp","hino.tottori.jp","kawahara.tottori.jp","koge.tottori.jp","kotoura.tottori.jp","misasa.tottori.jp","nanbu.tottori.jp","nichinan.tottori.jp","sakaiminato.tottori.jp","tottori.tottori.jp","wakasa.tottori.jp","yazu.tottori.jp","yonago.tottori.jp","asahi.toyama.jp","fuchu.toyama.jp","fukumitsu.toyama.jp","funahashi.toyama.jp","himi.toyama.jp","imizu.toyama.jp","inami.toyama.jp","johana.toyama.jp","kamiichi.toyama.jp","kurobe.toyama.jp","nakaniikawa.toyama.jp","namerikawa.toyama.jp","nanto.toyama.jp","nyuzen.toyama.jp","oyabe.toyama.jp","taira.toyama.jp","takaoka.toyama.jp","tateyama.toyama.jp","toga.toyama.jp","tonami.toyama.jp","toyama.toyama.jp","unazuki.toyama.jp","uozu.toyama.jp","yamada.toyama.jp","arida.wakayama.jp","aridagawa.wakayama.jp","gobo.wakayama.jp","hashimoto.wakayama.jp","hidaka.wakayama.jp","hirogawa.wakayama.jp","inami.wakayama.jp","iwade.wakayama.jp","kainan.wakayama.jp","kamitonda.wakayama.jp","katsuragi.wakayama.jp","kimino.wakayama.jp","kinokawa.wakayama.jp","kitayama.wakayama.jp","koya.wakayama.jp","koza.wakayama.jp","kozagawa.wakayama.jp","kudoyama.wakayama.jp","kushimoto.wakayama.jp","mihama.wakayama.jp","misato.wakayama.jp","nachikatsuura.wakayama.jp","shingu.wakayama.jp","shirahama.wakayama.jp","taiji.wakayama.jp","tanabe.wakayama.jp","wakayama.wakayama.jp","yuasa.wakayama.jp","yura.wakayama.jp","asahi.yamagata.jp","funagata.yamagata.jp","higashine.yamagata.jp","iide.yamagata.jp","kahoku.yamagata.jp","kaminoyama.yamagata.jp","kaneyama.yamagata.jp","kawanishi.yamagata.jp","mamurogawa.yamagata.jp","mikawa.yamagata.jp","murayama.yamagata.jp","nagai.yamagata.jp","nakayama.yamagata.jp","nanyo.yamagata.jp","nishikawa.yamagata.jp","obanazawa.yamagata.jp","oe.yamagata.jp","oguni.yamagata.jp","ohkura.yamagata.jp","oishida.yamagata.jp","sagae.yamagata.jp","sakata.yamagata.jp","sakegawa.yamagata.jp","shinjo.yamagata.jp","shirataka.yamagata.jp","shonai.yamagata.jp","takahata.yamagata.jp","tendo.yamagata.jp","tozawa.yamagata.jp","tsuruoka.yamagata.jp","yamagata.yamagata.jp","yamanobe.yamagata.jp","yonezawa.yamagata.jp","yuza.yamagata.jp","abu.yamaguchi.jp","hagi.yamaguchi.jp","hikari.yamaguchi.jp","hofu.yamaguchi.jp","iwakuni.yamaguchi.jp","kudamatsu.yamaguchi.jp","mitou.yamaguchi.jp","nagato.yamaguchi.jp","oshima.yamaguchi.jp","shimonoseki.yamaguchi.jp","shunan.yamaguchi.jp","tabuse.yamaguchi.jp","tokuyama.yamaguchi.jp","toyota.yamaguchi.jp","ube.yamaguchi.jp","yuu.yamaguchi.jp","chuo.yamanashi.jp","doshi.yamanashi.jp","fuefuki.yamanashi.jp","fujikawa.yamanashi.jp","fujikawaguchiko.yamanashi.jp","fujiyoshida.yamanashi.jp","hayakawa.yamanashi.jp","hokuto.yamanashi.jp","ichikawamisato.yamanashi.jp","kai.yamanashi.jp","kofu.yamanashi.jp","koshu.yamanashi.jp","kosuge.yamanashi.jp","minami-alps.yamanashi.jp","minobu.yamanashi.jp","nakamichi.yamanashi.jp","nanbu.yamanashi.jp","narusawa.yamanashi.jp","nirasaki.yamanashi.jp","nishikatsura.yamanashi.jp","oshino.yamanashi.jp","otsuki.yamanashi.jp","showa.yamanashi.jp","tabayama.yamanashi.jp","tsuru.yamanashi.jp","uenohara.yamanashi.jp","yamanakako.yamanashi.jp","yamanashi.yamanashi.jp","ke","ac.ke","co.ke","go.ke","info.ke","me.ke","mobi.ke","ne.ke","or.ke","sc.ke","kg","com.kg","edu.kg","gov.kg","mil.kg","net.kg","org.kg","*.kh","ki","biz.ki","com.ki","edu.ki","gov.ki","info.ki","net.ki","org.ki","km","ass.km","com.km","edu.km","gov.km","mil.km","nom.km","org.km","prd.km","tm.km","asso.km","coop.km","gouv.km","medecin.km","notaires.km","pharmaciens.km","presse.km","veterinaire.km","kn","edu.kn","gov.kn","net.kn","org.kn","kp","com.kp","edu.kp","gov.kp","org.kp","rep.kp","tra.kp","kr","ac.kr","co.kr","es.kr","go.kr","hs.kr","kg.kr","mil.kr","ms.kr","ne.kr","or.kr","pe.kr","re.kr","sc.kr","busan.kr","chungbuk.kr","chungnam.kr","daegu.kr","daejeon.kr","gangwon.kr","gwangju.kr","gyeongbuk.kr","gyeonggi.kr","gyeongnam.kr","incheon.kr","jeju.kr","jeonbuk.kr","jeonnam.kr","seoul.kr","ulsan.kr","kw","com.kw","edu.kw","emb.kw","gov.kw","ind.kw","net.kw","org.kw","ky","com.ky","edu.ky","net.ky","org.ky","kz","com.kz","edu.kz","gov.kz","mil.kz","net.kz","org.kz","la","com.la","edu.la","gov.la","info.la","int.la","net.la","org.la","per.la","lb","com.lb","edu.lb","gov.lb","net.lb","org.lb","lc","co.lc","com.lc","edu.lc","gov.lc","net.lc","org.lc","li","lk","ac.lk","assn.lk","com.lk","edu.lk","gov.lk","grp.lk","hotel.lk","int.lk","ltd.lk","net.lk","ngo.lk","org.lk","sch.lk","soc.lk","web.lk","lr","com.lr","edu.lr","gov.lr","net.lr","org.lr","ls","ac.ls","biz.ls","co.ls","edu.ls","gov.ls","info.ls","net.ls","org.ls","sc.ls","lt","gov.lt","lu","lv","asn.lv","com.lv","conf.lv","edu.lv","gov.lv","id.lv","mil.lv","net.lv","org.lv","ly","com.ly","edu.ly","gov.ly","id.ly","med.ly","net.ly","org.ly","plc.ly","sch.ly","ma","ac.ma","co.ma","gov.ma","net.ma","org.ma","press.ma","mc","asso.mc","tm.mc","md","me","ac.me","co.me","edu.me","gov.me","its.me","net.me","org.me","priv.me","mg","co.mg","com.mg","edu.mg","gov.mg","mil.mg","nom.mg","org.mg","prd.mg","mh","mil","mk","com.mk","edu.mk","gov.mk","inf.mk","name.mk","net.mk","org.mk","ml","com.ml","edu.ml","gouv.ml","gov.ml","net.ml","org.ml","presse.ml","*.mm","mn","edu.mn","gov.mn","org.mn","mo","com.mo","edu.mo","gov.mo","net.mo","org.mo","mobi","mp","mq","mr","gov.mr","ms","com.ms","edu.ms","gov.ms","net.ms","org.ms","mt","com.mt","edu.mt","net.mt","org.mt","mu","ac.mu","co.mu","com.mu","gov.mu","net.mu","or.mu","org.mu","museum","mv","aero.mv","biz.mv","com.mv","coop.mv","edu.mv","gov.mv","info.mv","int.mv","mil.mv","museum.mv","name.mv","net.mv","org.mv","pro.mv","mw","ac.mw","biz.mw","co.mw","com.mw","coop.mw","edu.mw","gov.mw","int.mw","net.mw","org.mw","mx","com.mx","edu.mx","gob.mx","net.mx","org.mx","my","biz.my","com.my","edu.my","gov.my","mil.my","name.my","net.my","org.my","mz","ac.mz","adv.mz","co.mz","edu.mz","gov.mz","mil.mz","net.mz","org.mz","na","alt.na","co.na","com.na","gov.na","net.na","org.na","name","nc","asso.nc","nom.nc","ne","net","nf","arts.nf","com.nf","firm.nf","info.nf","net.nf","other.nf","per.nf","rec.nf","store.nf","web.nf","ng","com.ng","edu.ng","gov.ng","i.ng","mil.ng","mobi.ng","name.ng","net.ng","org.ng","sch.ng","ni","ac.ni","biz.ni","co.ni","com.ni","edu.ni","gob.ni","in.ni","info.ni","int.ni","mil.ni","net.ni","nom.ni","org.ni","web.ni","nl","no","fhs.no","folkebibl.no","fylkesbibl.no","idrett.no","museum.no","priv.no","vgs.no","dep.no","herad.no","kommune.no","mil.no","stat.no","aa.no","ah.no","bu.no","fm.no","hl.no","hm.no","jan-mayen.no","mr.no","nl.no","nt.no","of.no","ol.no","oslo.no","rl.no","sf.no","st.no","svalbard.no","tm.no","tr.no","va.no","vf.no","gs.aa.no","gs.ah.no","gs.bu.no","gs.fm.no","gs.hl.no","gs.hm.no","gs.jan-mayen.no","gs.mr.no","gs.nl.no","gs.nt.no","gs.of.no","gs.ol.no","gs.oslo.no","gs.rl.no","gs.sf.no","gs.st.no","gs.svalbard.no","gs.tm.no","gs.tr.no","gs.va.no","gs.vf.no","akrehamn.no","åkrehamn.no","algard.no","ålgård.no","arna.no","bronnoysund.no","brønnøysund.no","brumunddal.no","bryne.no","drobak.no","drøbak.no","egersund.no","fetsund.no","floro.no","florø.no","fredrikstad.no","hokksund.no","honefoss.no","hønefoss.no","jessheim.no","jorpeland.no","jørpeland.no","kirkenes.no","kopervik.no","krokstadelva.no","langevag.no","langevåg.no","leirvik.no","mjondalen.no","mjøndalen.no","mo-i-rana.no","mosjoen.no","mosjøen.no","nesoddtangen.no","orkanger.no","osoyro.no","osøyro.no","raholt.no","råholt.no","sandnessjoen.no","sandnessjøen.no","skedsmokorset.no","slattum.no","spjelkavik.no","stathelle.no","stavern.no","stjordalshalsen.no","stjørdalshalsen.no","tananger.no","tranby.no","vossevangen.no","aarborte.no","aejrie.no","afjord.no","åfjord.no","agdenes.no","nes.akershus.no","aknoluokta.no","ákŋoluokta.no","al.no","ål.no","alaheadju.no","álaheadju.no","alesund.no","ålesund.no","alstahaug.no","alta.no","áltá.no","alvdal.no","amli.no","åmli.no","amot.no","åmot.no","andasuolo.no","andebu.no","andoy.no","andøy.no","ardal.no","årdal.no","aremark.no","arendal.no","ås.no","aseral.no","åseral.no","asker.no","askim.no","askoy.no","askøy.no","askvoll.no","asnes.no","åsnes.no","audnedaln.no","aukra.no","aure.no","aurland.no","aurskog-holand.no","aurskog-høland.no","austevoll.no","austrheim.no","averoy.no","averøy.no","badaddja.no","bådåddjå.no","bærum.no","bahcavuotna.no","báhcavuotna.no","bahccavuotna.no","báhccavuotna.no","baidar.no","báidár.no","bajddar.no","bájddar.no","balat.no","bálát.no","balestrand.no","ballangen.no","balsfjord.no","bamble.no","bardu.no","barum.no","batsfjord.no","båtsfjord.no","bearalvahki.no","bearalváhki.no","beardu.no","beiarn.no","berg.no","bergen.no","berlevag.no","berlevåg.no","bievat.no","bievát.no","bindal.no","birkenes.no","bjarkoy.no","bjarkøy.no","bjerkreim.no","bjugn.no","bodo.no","bodø.no","bokn.no","bomlo.no","bømlo.no","bremanger.no","bronnoy.no","brønnøy.no","budejju.no","nes.buskerud.no","bygland.no","bykle.no","cahcesuolo.no","čáhcesuolo.no","davvenjarga.no","davvenjárga.no","davvesiida.no","deatnu.no","dielddanuorri.no","divtasvuodna.no","divttasvuotna.no","donna.no","dønna.no","dovre.no","drammen.no","drangedal.no","dyroy.no","dyrøy.no","eid.no","eidfjord.no","eidsberg.no","eidskog.no","eidsvoll.no","eigersund.no","elverum.no","enebakk.no","engerdal.no","etne.no","etnedal.no","evenassi.no","evenášši.no","evenes.no","evje-og-hornnes.no","farsund.no","fauske.no","fedje.no","fet.no","finnoy.no","finnøy.no","fitjar.no","fjaler.no","fjell.no","fla.no","flå.no","flakstad.no","flatanger.no","flekkefjord.no","flesberg.no","flora.no","folldal.no","forde.no","førde.no","forsand.no","fosnes.no","fræna.no","frana.no","frei.no","frogn.no","froland.no","frosta.no","froya.no","frøya.no","fuoisku.no","fuossko.no","fusa.no","fyresdal.no","gaivuotna.no","gáivuotna.no","galsa.no","gálsá.no","gamvik.no","gangaviika.no","gáŋgaviika.no","gaular.no","gausdal.no","giehtavuoatna.no","gildeskal.no","gildeskål.no","giske.no","gjemnes.no","gjerdrum.no","gjerstad.no","gjesdal.no","gjovik.no","gjøvik.no","gloppen.no","gol.no","gran.no","grane.no","granvin.no","gratangen.no","grimstad.no","grong.no","grue.no","gulen.no","guovdageaidnu.no","ha.no","hå.no","habmer.no","hábmer.no","hadsel.no","hægebostad.no","hagebostad.no","halden.no","halsa.no","hamar.no","hamaroy.no","hammarfeasta.no","hámmárfeasta.no","hammerfest.no","hapmir.no","hápmir.no","haram.no","hareid.no","harstad.no","hasvik.no","hattfjelldal.no","haugesund.no","os.hedmark.no","valer.hedmark.no","våler.hedmark.no","hemne.no","hemnes.no","hemsedal.no","hitra.no","hjartdal.no","hjelmeland.no","hobol.no","hobøl.no","hof.no","hol.no","hole.no","holmestrand.no","holtalen.no","holtålen.no","os.hordaland.no","hornindal.no","horten.no","hoyanger.no","høyanger.no","hoylandet.no","høylandet.no","hurdal.no","hurum.no","hvaler.no","hyllestad.no","ibestad.no","inderoy.no","inderøy.no","iveland.no","ivgu.no","jevnaker.no","jolster.no","jølster.no","jondal.no","kafjord.no","kåfjord.no","karasjohka.no","kárášjohka.no","karasjok.no","karlsoy.no","karmoy.no","karmøy.no","kautokeino.no","klabu.no","klæbu.no","klepp.no","kongsberg.no","kongsvinger.no","kraanghke.no","kråanghke.no","kragero.no","kragerø.no","kristiansand.no","kristiansund.no","krodsherad.no","krødsherad.no","kvæfjord.no","kvænangen.no","kvafjord.no","kvalsund.no","kvam.no","kvanangen.no","kvinesdal.no","kvinnherad.no","kviteseid.no","kvitsoy.no","kvitsøy.no","laakesvuemie.no","lærdal.no","lahppi.no","láhppi.no","lardal.no","larvik.no","lavagis.no","lavangen.no","leangaviika.no","leaŋgaviika.no","lebesby.no","leikanger.no","leirfjord.no","leka.no","leksvik.no","lenvik.no","lerdal.no","lesja.no","levanger.no","lier.no","lierne.no","lillehammer.no","lillesand.no","lindas.no","lindås.no","lindesnes.no","loabat.no","loabát.no","lodingen.no","lødingen.no","lom.no","loppa.no","lorenskog.no","lørenskog.no","loten.no","løten.no","lund.no","lunner.no","luroy.no","lurøy.no","luster.no","lyngdal.no","lyngen.no","malatvuopmi.no","málatvuopmi.no","malselv.no","målselv.no","malvik.no","mandal.no","marker.no","marnardal.no","masfjorden.no","masoy.no","måsøy.no","matta-varjjat.no","mátta-várjjat.no","meland.no","meldal.no","melhus.no","meloy.no","meløy.no","meraker.no","meråker.no","midsund.no","midtre-gauldal.no","moareke.no","moåreke.no","modalen.no","modum.no","molde.no","heroy.more-og-romsdal.no","sande.more-og-romsdal.no","herøy.møre-og-romsdal.no","sande.møre-og-romsdal.no","moskenes.no","moss.no","mosvik.no","muosat.no","muosát.no","naamesjevuemie.no","nååmesjevuemie.no","nærøy.no","namdalseid.no","namsos.no","namsskogan.no","nannestad.no","naroy.no","narviika.no","narvik.no","naustdal.no","navuotna.no","návuotna.no","nedre-eiker.no","nesna.no","nesodden.no","nesseby.no","nesset.no","nissedal.no","nittedal.no","nord-aurdal.no","nord-fron.no","nord-odal.no","norddal.no","nordkapp.no","bo.nordland.no","bø.nordland.no","heroy.nordland.no","herøy.nordland.no","nordre-land.no","nordreisa.no","nore-og-uvdal.no","notodden.no","notteroy.no","nøtterøy.no","odda.no","oksnes.no","øksnes.no","omasvuotna.no","oppdal.no","oppegard.no","oppegård.no","orkdal.no","orland.no","ørland.no","orskog.no","ørskog.no","orsta.no","ørsta.no","osen.no","osteroy.no","osterøy.no","valer.ostfold.no","våler.østfold.no","ostre-toten.no","østre-toten.no","overhalla.no","ovre-eiker.no","øvre-eiker.no","oyer.no","øyer.no","oygarden.no","øygarden.no","oystre-slidre.no","øystre-slidre.no","porsanger.no","porsangu.no","porsáŋgu.no","porsgrunn.no","rade.no","råde.no","radoy.no","radøy.no","rælingen.no","rahkkeravju.no","ráhkkerávju.no","raisa.no","ráisa.no","rakkestad.no","ralingen.no","rana.no","randaberg.no","rauma.no","rendalen.no","rennebu.no","rennesoy.no","rennesøy.no","rindal.no","ringebu.no","ringerike.no","ringsaker.no","risor.no","risør.no","rissa.no","roan.no","rodoy.no","rødøy.no","rollag.no","romsa.no","romskog.no","rømskog.no","roros.no","røros.no","rost.no","røst.no","royken.no","røyken.no","royrvik.no","røyrvik.no","ruovat.no","rygge.no","salangen.no","salat.no","sálat.no","sálát.no","saltdal.no","samnanger.no","sandefjord.no","sandnes.no","sandoy.no","sandøy.no","sarpsborg.no","sauda.no","sauherad.no","sel.no","selbu.no","selje.no","seljord.no","siellak.no","sigdal.no","siljan.no","sirdal.no","skanit.no","skánit.no","skanland.no","skånland.no","skaun.no","skedsmo.no","ski.no","skien.no","skierva.no","skiervá.no","skiptvet.no","skjak.no","skjåk.no","skjervoy.no","skjervøy.no","skodje.no","smola.no","smøla.no","snaase.no","snåase.no","snasa.no","snåsa.no","snillfjord.no","snoasa.no","sogndal.no","sogne.no","søgne.no","sokndal.no","sola.no","solund.no","somna.no","sømna.no","sondre-land.no","søndre-land.no","songdalen.no","sor-aurdal.no","sør-aurdal.no","sor-fron.no","sør-fron.no","sor-odal.no","sør-odal.no","sor-varanger.no","sør-varanger.no","sorfold.no","sørfold.no","sorreisa.no","sørreisa.no","sortland.no","sorum.no","sørum.no","spydeberg.no","stange.no","stavanger.no","steigen.no","steinkjer.no","stjordal.no","stjørdal.no","stokke.no","stor-elvdal.no","stord.no","stordal.no","storfjord.no","strand.no","stranda.no","stryn.no","sula.no","suldal.no","sund.no","sunndal.no","surnadal.no","sveio.no","svelvik.no","sykkylven.no","tana.no","bo.telemark.no","bø.telemark.no","time.no","tingvoll.no","tinn.no","tjeldsund.no","tjome.no","tjøme.no","tokke.no","tolga.no","tonsberg.no","tønsberg.no","torsken.no","træna.no","trana.no","tranoy.no","tranøy.no","troandin.no","trogstad.no","trøgstad.no","tromsa.no","tromso.no","tromsø.no","trondheim.no","trysil.no","tvedestrand.no","tydal.no","tynset.no","tysfjord.no","tysnes.no","tysvær.no","tysvar.no","ullensaker.no","ullensvang.no","ulvik.no","unjarga.no","unjárga.no","utsira.no","vaapste.no","vadso.no","vadsø.no","værøy.no","vaga.no","vågå.no","vagan.no","vågan.no","vagsoy.no","vågsøy.no","vaksdal.no","valle.no","vang.no","vanylven.no","vardo.no","vardø.no","varggat.no","várggát.no","varoy.no","vefsn.no","vega.no","vegarshei.no","vegårshei.no","vennesla.no","verdal.no","verran.no","vestby.no","sande.vestfold.no","vestnes.no","vestre-slidre.no","vestre-toten.no","vestvagoy.no","vestvågøy.no","vevelstad.no","vik.no","vikna.no","vindafjord.no","voagat.no","volda.no","voss.no","*.np","nr","biz.nr","com.nr","edu.nr","gov.nr","info.nr","net.nr","org.nr","nu","nz","ac.nz","co.nz","cri.nz","geek.nz","gen.nz","govt.nz","health.nz","iwi.nz","kiwi.nz","maori.nz","māori.nz","mil.nz","net.nz","org.nz","parliament.nz","school.nz","om","co.om","com.om","edu.om","gov.om","med.om","museum.om","net.om","org.om","pro.om","onion","org","pa","abo.pa","ac.pa","com.pa","edu.pa","gob.pa","ing.pa","med.pa","net.pa","nom.pa","org.pa","sld.pa","pe","com.pe","edu.pe","gob.pe","mil.pe","net.pe","nom.pe","org.pe","pf","com.pf","edu.pf","org.pf","*.pg","ph","com.ph","edu.ph","gov.ph","i.ph","mil.ph","net.ph","ngo.ph","org.ph","pk","ac.pk","biz.pk","com.pk","edu.pk","fam.pk","gkp.pk","gob.pk","gog.pk","gok.pk","gon.pk","gop.pk","gos.pk","gov.pk","net.pk","org.pk","web.pk","pl","com.pl","net.pl","org.pl","agro.pl","aid.pl","atm.pl","auto.pl","biz.pl","edu.pl","gmina.pl","gsm.pl","info.pl","mail.pl","media.pl","miasta.pl","mil.pl","nieruchomosci.pl","nom.pl","pc.pl","powiat.pl","priv.pl","realestate.pl","rel.pl","sex.pl","shop.pl","sklep.pl","sos.pl","szkola.pl","targi.pl","tm.pl","tourism.pl","travel.pl","turystyka.pl","gov.pl","ap.gov.pl","griw.gov.pl","ic.gov.pl","is.gov.pl","kmpsp.gov.pl","konsulat.gov.pl","kppsp.gov.pl","kwp.gov.pl","kwpsp.gov.pl","mup.gov.pl","mw.gov.pl","oia.gov.pl","oirm.gov.pl","oke.gov.pl","oow.gov.pl","oschr.gov.pl","oum.gov.pl","pa.gov.pl","pinb.gov.pl","piw.gov.pl","po.gov.pl","pr.gov.pl","psp.gov.pl","psse.gov.pl","pup.gov.pl","rzgw.gov.pl","sa.gov.pl","sdn.gov.pl","sko.gov.pl","so.gov.pl","sr.gov.pl","starostwo.gov.pl","ug.gov.pl","ugim.gov.pl","um.gov.pl","umig.gov.pl","upow.gov.pl","uppo.gov.pl","us.gov.pl","uw.gov.pl","uzs.gov.pl","wif.gov.pl","wiih.gov.pl","winb.gov.pl","wios.gov.pl","witd.gov.pl","wiw.gov.pl","wkz.gov.pl","wsa.gov.pl","wskr.gov.pl","wsse.gov.pl","wuoz.gov.pl","wzmiuw.gov.pl","zp.gov.pl","zpisdn.gov.pl","augustow.pl","babia-gora.pl","bedzin.pl","beskidy.pl","bialowieza.pl","bialystok.pl","bielawa.pl","bieszczady.pl","boleslawiec.pl","bydgoszcz.pl","bytom.pl","cieszyn.pl","czeladz.pl","czest.pl","dlugoleka.pl","elblag.pl","elk.pl","glogow.pl","gniezno.pl","gorlice.pl","grajewo.pl","ilawa.pl","jaworzno.pl","jelenia-gora.pl","jgora.pl","kalisz.pl","karpacz.pl","kartuzy.pl","kaszuby.pl","katowice.pl","kazimierz-dolny.pl","kepno.pl","ketrzyn.pl","klodzko.pl","kobierzyce.pl","kolobrzeg.pl","konin.pl","konskowola.pl","kutno.pl","lapy.pl","lebork.pl","legnica.pl","lezajsk.pl","limanowa.pl","lomza.pl","lowicz.pl","lubin.pl","lukow.pl","malbork.pl","malopolska.pl","mazowsze.pl","mazury.pl","mielec.pl","mielno.pl","mragowo.pl","naklo.pl","nowaruda.pl","nysa.pl","olawa.pl","olecko.pl","olkusz.pl","olsztyn.pl","opoczno.pl","opole.pl","ostroda.pl","ostroleka.pl","ostrowiec.pl","ostrowwlkp.pl","pila.pl","pisz.pl","podhale.pl","podlasie.pl","polkowice.pl","pomorskie.pl","pomorze.pl","prochowice.pl","pruszkow.pl","przeworsk.pl","pulawy.pl","radom.pl","rawa-maz.pl","rybnik.pl","rzeszow.pl","sanok.pl","sejny.pl","skoczow.pl","slask.pl","slupsk.pl","sosnowiec.pl","stalowa-wola.pl","starachowice.pl","stargard.pl","suwalki.pl","swidnica.pl","swiebodzin.pl","swinoujscie.pl","szczecin.pl","szczytno.pl","tarnobrzeg.pl","tgory.pl","turek.pl","tychy.pl","ustka.pl","walbrzych.pl","warmia.pl","warszawa.pl","waw.pl","wegrow.pl","wielun.pl","wlocl.pl","wloclawek.pl","wodzislaw.pl","wolomin.pl","wroclaw.pl","zachpomor.pl","zagan.pl","zarow.pl","zgora.pl","zgorzelec.pl","pm","pn","co.pn","edu.pn","gov.pn","net.pn","org.pn","post","pr","biz.pr","com.pr","edu.pr","gov.pr","info.pr","isla.pr","name.pr","net.pr","org.pr","pro.pr","ac.pr","est.pr","prof.pr","pro","aaa.pro","aca.pro","acct.pro","avocat.pro","bar.pro","cpa.pro","eng.pro","jur.pro","law.pro","med.pro","recht.pro","ps","com.ps","edu.ps","gov.ps","net.ps","org.ps","plo.ps","sec.ps","pt","com.pt","edu.pt","gov.pt","int.pt","net.pt","nome.pt","org.pt","publ.pt","pw","belau.pw","co.pw","ed.pw","go.pw","or.pw","py","com.py","coop.py","edu.py","gov.py","mil.py","net.py","org.py","qa","com.qa","edu.qa","gov.qa","mil.qa","name.qa","net.qa","org.qa","sch.qa","re","asso.re","com.re","ro","arts.ro","com.ro","firm.ro","info.ro","nom.ro","nt.ro","org.ro","rec.ro","store.ro","tm.ro","www.ro","rs","ac.rs","co.rs","edu.rs","gov.rs","in.rs","org.rs","ru","rw","ac.rw","co.rw","coop.rw","gov.rw","mil.rw","net.rw","org.rw","sa","com.sa","edu.sa","gov.sa","med.sa","net.sa","org.sa","pub.sa","sch.sa","sb","com.sb","edu.sb","gov.sb","net.sb","org.sb","sc","com.sc","edu.sc","gov.sc","net.sc","org.sc","sd","com.sd","edu.sd","gov.sd","info.sd","med.sd","net.sd","org.sd","tv.sd","se","a.se","ac.se","b.se","bd.se","brand.se","c.se","d.se","e.se","f.se","fh.se","fhsk.se","fhv.se","g.se","h.se","i.se","k.se","komforb.se","kommunalforbund.se","komvux.se","l.se","lanbib.se","m.se","n.se","naturbruksgymn.se","o.se","org.se","p.se","parti.se","pp.se","press.se","r.se","s.se","t.se","tm.se","u.se","w.se","x.se","y.se","z.se","sg","com.sg","edu.sg","gov.sg","net.sg","org.sg","sh","com.sh","gov.sh","mil.sh","net.sh","org.sh","si","sj","sk","sl","com.sl","edu.sl","gov.sl","net.sl","org.sl","sm","sn","art.sn","com.sn","edu.sn","gouv.sn","org.sn","perso.sn","univ.sn","so","com.so","edu.so","gov.so","me.so","net.so","org.so","sr","ss","biz.ss","co.ss","com.ss","edu.ss","gov.ss","me.ss","net.ss","org.ss","sch.ss","st","co.st","com.st","consulado.st","edu.st","embaixada.st","mil.st","net.st","org.st","principe.st","saotome.st","store.st","su","sv","com.sv","edu.sv","gob.sv","org.sv","red.sv","sx","gov.sx","sy","com.sy","edu.sy","gov.sy","mil.sy","net.sy","org.sy","sz","ac.sz","co.sz","org.sz","tc","td","tel","tf","tg","th","ac.th","co.th","go.th","in.th","mi.th","net.th","or.th","tj","ac.tj","biz.tj","co.tj","com.tj","edu.tj","go.tj","gov.tj","int.tj","mil.tj","name.tj","net.tj","nic.tj","org.tj","test.tj","web.tj","tk","tl","gov.tl","tm","co.tm","com.tm","edu.tm","gov.tm","mil.tm","net.tm","nom.tm","org.tm","tn","com.tn","ens.tn","fin.tn","gov.tn","ind.tn","info.tn","intl.tn","mincom.tn","nat.tn","net.tn","org.tn","perso.tn","tourism.tn","to","com.to","edu.to","gov.to","mil.to","net.to","org.to","tr","av.tr","bbs.tr","bel.tr","biz.tr","com.tr","dr.tr","edu.tr","gen.tr","gov.tr","info.tr","k12.tr","kep.tr","mil.tr","name.tr","net.tr","org.tr","pol.tr","tel.tr","tsk.tr","tv.tr","web.tr","nc.tr","gov.nc.tr","tt","biz.tt","co.tt","com.tt","edu.tt","gov.tt","info.tt","mil.tt","name.tt","net.tt","org.tt","pro.tt","tv","tw","club.tw","com.tw","ebiz.tw","edu.tw","game.tw","gov.tw","idv.tw","mil.tw","net.tw","org.tw","tz","ac.tz","co.tz","go.tz","hotel.tz","info.tz","me.tz","mil.tz","mobi.tz","ne.tz","or.tz","sc.tz","tv.tz","ua","com.ua","edu.ua","gov.ua","in.ua","net.ua","org.ua","cherkassy.ua","cherkasy.ua","chernigov.ua","chernihiv.ua","chernivtsi.ua","chernovtsy.ua","ck.ua","cn.ua","cr.ua","crimea.ua","cv.ua","dn.ua","dnepropetrovsk.ua","dnipropetrovsk.ua","donetsk.ua","dp.ua","if.ua","ivano-frankivsk.ua","kh.ua","kharkiv.ua","kharkov.ua","kherson.ua","khmelnitskiy.ua","khmelnytskyi.ua","kiev.ua","kirovograd.ua","km.ua","kr.ua","kropyvnytskyi.ua","krym.ua","ks.ua","kv.ua","kyiv.ua","lg.ua","lt.ua","lugansk.ua","luhansk.ua","lutsk.ua","lv.ua","lviv.ua","mk.ua","mykolaiv.ua","nikolaev.ua","od.ua","odesa.ua","odessa.ua","pl.ua","poltava.ua","rivne.ua","rovno.ua","rv.ua","sb.ua","sebastopol.ua","sevastopol.ua","sm.ua","sumy.ua","te.ua","ternopil.ua","uz.ua","uzhgorod.ua","uzhhorod.ua","vinnica.ua","vinnytsia.ua","vn.ua","volyn.ua","yalta.ua","zakarpattia.ua","zaporizhzhe.ua","zaporizhzhia.ua","zhitomir.ua","zhytomyr.ua","zp.ua","zt.ua","ug","ac.ug","co.ug","com.ug","go.ug","ne.ug","or.ug","org.ug","sc.ug","uk","ac.uk","co.uk","gov.uk","ltd.uk","me.uk","net.uk","nhs.uk","org.uk","plc.uk","police.uk","*.sch.uk","us","dni.us","fed.us","isa.us","kids.us","nsn.us","ak.us","al.us","ar.us","as.us","az.us","ca.us","co.us","ct.us","dc.us","de.us","fl.us","ga.us","gu.us","hi.us","ia.us","id.us","il.us","in.us","ks.us","ky.us","la.us","ma.us","md.us","me.us","mi.us","mn.us","mo.us","ms.us","mt.us","nc.us","nd.us","ne.us","nh.us","nj.us","nm.us","nv.us","ny.us","oh.us","ok.us","or.us","pa.us","pr.us","ri.us","sc.us","sd.us","tn.us","tx.us","ut.us","va.us","vi.us","vt.us","wa.us","wi.us","wv.us","wy.us","k12.ak.us","k12.al.us","k12.ar.us","k12.as.us","k12.az.us","k12.ca.us","k12.co.us","k12.ct.us","k12.dc.us","k12.fl.us","k12.ga.us","k12.gu.us","k12.ia.us","k12.id.us","k12.il.us","k12.in.us","k12.ks.us","k12.ky.us","k12.la.us","k12.ma.us","k12.md.us","k12.me.us","k12.mi.us","k12.mn.us","k12.mo.us","k12.ms.us","k12.mt.us","k12.nc.us","k12.ne.us","k12.nh.us","k12.nj.us","k12.nm.us","k12.nv.us","k12.ny.us","k12.oh.us","k12.ok.us","k12.or.us","k12.pa.us","k12.pr.us","k12.sc.us","k12.tn.us","k12.tx.us","k12.ut.us","k12.va.us","k12.vi.us","k12.vt.us","k12.wa.us","k12.wi.us","cc.ak.us","lib.ak.us","cc.al.us","lib.al.us","cc.ar.us","lib.ar.us","cc.as.us","lib.as.us","cc.az.us","lib.az.us","cc.ca.us","lib.ca.us","cc.co.us","lib.co.us","cc.ct.us","lib.ct.us","cc.dc.us","lib.dc.us","cc.de.us","cc.fl.us","cc.ga.us","cc.gu.us","cc.hi.us","cc.ia.us","cc.id.us","cc.il.us","cc.in.us","cc.ks.us","cc.ky.us","cc.la.us","cc.ma.us","cc.md.us","cc.me.us","cc.mi.us","cc.mn.us","cc.mo.us","cc.ms.us","cc.mt.us","cc.nc.us","cc.nd.us","cc.ne.us","cc.nh.us","cc.nj.us","cc.nm.us","cc.nv.us","cc.ny.us","cc.oh.us","cc.ok.us","cc.or.us","cc.pa.us","cc.pr.us","cc.ri.us","cc.sc.us","cc.sd.us","cc.tn.us","cc.tx.us","cc.ut.us","cc.va.us","cc.vi.us","cc.vt.us","cc.wa.us","cc.wi.us","cc.wv.us","cc.wy.us","k12.wy.us","lib.fl.us","lib.ga.us","lib.gu.us","lib.hi.us","lib.ia.us","lib.id.us","lib.il.us","lib.in.us","lib.ks.us","lib.ky.us","lib.la.us","lib.ma.us","lib.md.us","lib.me.us","lib.mi.us","lib.mn.us","lib.mo.us","lib.ms.us","lib.mt.us","lib.nc.us","lib.nd.us","lib.ne.us","lib.nh.us","lib.nj.us","lib.nm.us","lib.nv.us","lib.ny.us","lib.oh.us","lib.ok.us","lib.or.us","lib.pa.us","lib.pr.us","lib.ri.us","lib.sc.us","lib.sd.us","lib.tn.us","lib.tx.us","lib.ut.us","lib.va.us","lib.vi.us","lib.vt.us","lib.wa.us","lib.wi.us","lib.wy.us","chtr.k12.ma.us","paroch.k12.ma.us","pvt.k12.ma.us","ann-arbor.mi.us","cog.mi.us","dst.mi.us","eaton.mi.us","gen.mi.us","mus.mi.us","tec.mi.us","washtenaw.mi.us","uy","com.uy","edu.uy","gub.uy","mil.uy","net.uy","org.uy","uz","co.uz","com.uz","net.uz","org.uz","va","vc","com.vc","edu.vc","gov.vc","mil.vc","net.vc","org.vc","ve","arts.ve","bib.ve","co.ve","com.ve","e12.ve","edu.ve","firm.ve","gob.ve","gov.ve","info.ve","int.ve","mil.ve","net.ve","nom.ve","org.ve","rar.ve","rec.ve","store.ve","tec.ve","web.ve","vg","vi","co.vi","com.vi","k12.vi","net.vi","org.vi","vn","ac.vn","ai.vn","biz.vn","com.vn","edu.vn","gov.vn","health.vn","id.vn","info.vn","int.vn","io.vn","name.vn","net.vn","org.vn","pro.vn","angiang.vn","bacgiang.vn","backan.vn","baclieu.vn","bacninh.vn","baria-vungtau.vn","bentre.vn","binhdinh.vn","binhduong.vn","binhphuoc.vn","binhthuan.vn","camau.vn","cantho.vn","caobang.vn","daklak.vn","daknong.vn","danang.vn","dienbien.vn","dongnai.vn","dongthap.vn","gialai.vn","hagiang.vn","haiduong.vn","haiphong.vn","hanam.vn","hanoi.vn","hatinh.vn","haugiang.vn","hoabinh.vn","hungyen.vn","khanhhoa.vn","kiengiang.vn","kontum.vn","laichau.vn","lamdong.vn","langson.vn","laocai.vn","longan.vn","namdinh.vn","nghean.vn","ninhbinh.vn","ninhthuan.vn","phutho.vn","phuyen.vn","quangbinh.vn","quangnam.vn","quangngai.vn","quangninh.vn","quangtri.vn","soctrang.vn","sonla.vn","tayninh.vn","thaibinh.vn","thainguyen.vn","thanhhoa.vn","thanhphohochiminh.vn","thuathienhue.vn","tiengiang.vn","travinh.vn","tuyenquang.vn","vinhlong.vn","vinhphuc.vn","yenbai.vn","vu","com.vu","edu.vu","net.vu","org.vu","wf","ws","com.ws","edu.ws","gov.ws","net.ws","org.ws","yt","امارات","հայ","বাংলা","бг","البحرين","бел","中国","中國","الجزائر","مصر","ею","ευ","موريتانيا","გე","ελ","香港","個人.香港","公司.香港","政府.香港","教育.香港","組織.香港","網絡.香港","ಭಾರತ","ଭାରତ","ভাৰত","भारतम्","भारोत","ڀارت","ഭാരതം","भारत","بارت","بھارت","భారత్","ભારત","ਭਾਰਤ","ভারত","இந்தியா","ایران","ايران","عراق","الاردن","한국","қаз","ລາວ","ලංකා","இலங்கை","المغرب","мкд","мон","澳門","澳门","مليسيا","عمان","پاکستان","پاكستان","فلسطين","срб","ак.срб","обр.срб","од.срб","орг.срб","пр.срб","упр.срб","рф","قطر","السعودية","السعودیة","السعودیۃ","السعوديه","سودان","新加坡","சிங்கப்பூர்","سورية","سوريا","ไทย","ทหาร.ไทย","ธุรกิจ.ไทย","เน็ต.ไทย","รัฐบาล.ไทย","ศึกษา.ไทย","องค์กร.ไทย","تونس","台灣","台湾","臺灣","укр","اليمن","xxx","ye","com.ye","edu.ye","gov.ye","mil.ye","net.ye","org.ye","ac.za","agric.za","alt.za","co.za","edu.za","gov.za","grondar.za","law.za","mil.za","net.za","ngo.za","nic.za","nis.za","nom.za","org.za","school.za","tm.za","web.za","zm","ac.zm","biz.zm","co.zm","com.zm","edu.zm","gov.zm","info.zm","mil.zm","net.zm","org.zm","sch.zm","zw","ac.zw","co.zw","gov.zw","mil.zw","org.zw","aaa","aarp","abb","abbott","abbvie","abc","able","abogado","abudhabi","academy","accenture","accountant","accountants","aco","actor","ads","adult","aeg","aetna","afl","africa","agakhan","agency","aig","airbus","airforce","airtel","akdn","alibaba","alipay","allfinanz","allstate","ally","alsace","alstom","amazon","americanexpress","americanfamily","amex","amfam","amica","amsterdam","analytics","android","anquan","anz","aol","apartments","app","apple","aquarelle","arab","aramco","archi","army","art","arte","asda","associates","athleta","attorney","auction","audi","audible","audio","auspost","author","auto","autos","aws","axa","azure","baby","baidu","banamex","band","bank","bar","barcelona","barclaycard","barclays","barefoot","bargains","baseball","basketball","bauhaus","bayern","bbc","bbt","bbva","bcg","bcn","beats","beauty","beer","bentley","berlin","best","bestbuy","bet","bharti","bible","bid","bike","bing","bingo","bio","black","blackfriday","blockbuster","blog","bloomberg","blue","bms","bmw","bnpparibas","boats","boehringer","bofa","bom","bond","boo","book","booking","bosch","bostik","boston","bot","boutique","box","bradesco","bridgestone","broadway","broker","brother","brussels","build","builders","business","buy","buzz","bzh","cab","cafe","cal","call","calvinklein","cam","camera","camp","canon","capetown","capital","capitalone","car","caravan","cards","care","career","careers","cars","casa","case","cash","casino","catering","catholic","cba","cbn","cbre","center","ceo","cern","cfa","cfd","chanel","channel","charity","chase","chat","cheap","chintai","christmas","chrome","church","cipriani","circle","cisco","citadel","citi","citic","city","claims","cleaning","click","clinic","clinique","clothing","cloud","club","clubmed","coach","codes","coffee","college","cologne","commbank","community","company","compare","computer","comsec","condos","construction","consulting","contact","contractors","cooking","cool","corsica","country","coupon","coupons","courses","cpa","credit","creditcard","creditunion","cricket","crown","crs","cruise","cruises","cuisinella","cymru","cyou","dad","dance","data","date","dating","datsun","day","dclk","dds","deal","dealer","deals","degree","delivery","dell","deloitte","delta","democrat","dental","dentist","desi","design","dev","dhl","diamonds","diet","digital","direct","directory","discount","discover","dish","diy","dnp","docs","doctor","dog","domains","dot","download","drive","dtv","dubai","dunlop","dupont","durban","dvag","dvr","earth","eat","eco","edeka","education","email","emerck","energy","engineer","engineering","enterprises","epson","equipment","ericsson","erni","esq","estate","eurovision","eus","events","exchange","expert","exposed","express","extraspace","fage","fail","fairwinds","faith","family","fan","fans","farm","farmers","fashion","fast","fedex","feedback","ferrari","ferrero","fidelity","fido","film","final","finance","financial","fire","firestone","firmdale","fish","fishing","fit","fitness","flickr","flights","flir","florist","flowers","fly","foo","food","football","ford","forex","forsale","forum","foundation","fox","free","fresenius","frl","frogans","frontier","ftr","fujitsu","fun","fund","furniture","futbol","fyi","gal","gallery","gallo","gallup","game","games","gap","garden","gay","gbiz","gdn","gea","gent","genting","george","ggee","gift","gifts","gives","giving","glass","gle","global","globo","gmail","gmbh","gmo","gmx","godaddy","gold","goldpoint","golf","goo","goodyear","goog","google","gop","got","grainger","graphics","gratis","green","gripe","grocery","group","gucci","guge","guide","guitars","guru","hair","hamburg","hangout","haus","hbo","hdfc","hdfcbank","health","healthcare","help","helsinki","here","hermes","hiphop","hisamitsu","hitachi","hiv","hkt","hockey","holdings","holiday","homedepot","homegoods","homes","homesense","honda","horse","hospital","host","hosting","hot","hotels","hotmail","house","how","hsbc","hughes","hyatt","hyundai","ibm","icbc","ice","icu","ieee","ifm","ikano","imamat","imdb","immo","immobilien","inc","industries","infiniti","ing","ink","institute","insurance","insure","international","intuit","investments","ipiranga","irish","ismaili","ist","istanbul","itau","itv","jaguar","java","jcb","jeep","jetzt","jewelry","jio","jll","jmp","jnj","joburg","jot","joy","jpmorgan","jprs","juegos","juniper","kaufen","kddi","kerryhotels","kerrylogistics","kerryproperties","kfh","kia","kids","kim","kindle","kitchen","kiwi","koeln","komatsu","kosher","kpmg","kpn","krd","kred","kuokgroup","kyoto","lacaixa","lamborghini","lamer","lancaster","land","landrover","lanxess","lasalle","lat","latino","latrobe","law","lawyer","lds","lease","leclerc","lefrak","legal","lego","lexus","lgbt","lidl","life","lifeinsurance","lifestyle","lighting","like","lilly","limited","limo","lincoln","link","lipsy","live","living","llc","llp","loan","loans","locker","locus","lol","london","lotte","lotto","love","lpl","lplfinancial","ltd","ltda","lundbeck","luxe","luxury","madrid","maif","maison","makeup","man","management","mango","map","market","marketing","markets","marriott","marshalls","mattel","mba","mckinsey","med","media","meet","melbourne","meme","memorial","men","menu","merck","merckmsd","miami","microsoft","mini","mint","mit","mitsubishi","mlb","mls","mma","mobile","moda","moe","moi","mom","monash","money","monster","mormon","mortgage","moscow","moto","motorcycles","mov","movie","msd","mtn","mtr","music","nab","nagoya","navy","nba","nec","netbank","netflix","network","neustar","new","news","next","nextdirect","nexus","nfl","ngo","nhk","nico","nike","nikon","ninja","nissan","nissay","nokia","norton","now","nowruz","nowtv","nra","nrw","ntt","nyc","obi","observer","office","okinawa","olayan","olayangroup","ollo","omega","one","ong","onl","online","ooo","open","oracle","orange","organic","origins","osaka","otsuka","ott","ovh","page","panasonic","paris","pars","partners","parts","party","pay","pccw","pet","pfizer","pharmacy","phd","philips","phone","photo","photography","photos","physio","pics","pictet","pictures","pid","pin","ping","pink","pioneer","pizza","place","play","playstation","plumbing","plus","pnc","pohl","poker","politie","porn","pramerica","praxi","press","prime","prod","productions","prof","progressive","promo","properties","property","protection","pru","prudential","pub","pwc","qpon","quebec","quest","racing","radio","read","realestate","realtor","realty","recipes","red","redstone","redumbrella","rehab","reise","reisen","reit","reliance","ren","rent","rentals","repair","report","republican","rest","restaurant","review","reviews","rexroth","rich","richardli","ricoh","ril","rio","rip","rocks","rodeo","rogers","room","rsvp","rugby","ruhr","run","rwe","ryukyu","saarland","safe","safety","sakura","sale","salon","samsclub","samsung","sandvik","sandvikcoromant","sanofi","sap","sarl","sas","save","saxo","sbi","sbs","scb","schaeffler","schmidt","scholarships","school","schule","schwarz","science","scot","search","seat","secure","security","seek","select","sener","services","seven","sew","sex","sexy","sfr","shangrila","sharp","shell","shia","shiksha","shoes","shop","shopping","shouji","show","silk","sina","singles","site","ski","skin","sky","skype","sling","smart","smile","sncf","soccer","social","softbank","software","sohu","solar","solutions","song","sony","soy","spa","space","sport","spot","srl","stada","staples","star","statebank","statefarm","stc","stcgroup","stockholm","storage","store","stream","studio","study","style","sucks","supplies","supply","support","surf","surgery","suzuki","swatch","swiss","sydney","systems","tab","taipei","talk","taobao","target","tatamotors","tatar","tattoo","tax","taxi","tci","tdk","team","tech","technology","temasek","tennis","teva","thd","theater","theatre","tiaa","tickets","tienda","tips","tires","tirol","tjmaxx","tjx","tkmaxx","tmall","today","tokyo","tools","top","toray","toshiba","total","tours","town","toyota","toys","trade","trading","training","travel","travelers","travelersinsurance","trust","trv","tube","tui","tunes","tushu","tvs","ubank","ubs","unicom","university","uno","uol","ups","vacations","vana","vanguard","vegas","ventures","verisign","versicherung","vet","viajes","video","vig","viking","villas","vin","vip","virgin","visa","vision","viva","vivo","vlaanderen","vodka","volvo","vote","voting","voto","voyage","wales","walmart","walter","wang","wanggou","watch","watches","weather","weatherchannel","webcam","weber","website","wed","wedding","weibo","weir","whoswho","wien","wiki","williamhill","win","windows","wine","winners","wme","wolterskluwer","woodside","work","works","world","wow","wtc","wtf","xbox","xerox","xihuan","xin","कॉम","セール","佛山","慈善","集团","在线","点看","คอม","八卦","موقع","公益","公司","香格里拉","网站","移动","我爱你","москва","католик","онлайн","сайт","联通","קום","时尚","微博","淡马锡","ファッション","орг","नेट","ストア","アマゾン","삼성","商标","商店","商城","дети","ポイント","新闻","家電","كوم","中文网","中信","娱乐","谷歌","電訊盈科","购物","クラウド","通販","网店","संगठन","餐厅","网络","ком","亚马逊","食品","飞利浦","手机","ارامكو","العليان","بازار","ابوظبي","كاثوليك","همراه","닷컴","政府","شبكة","بيتك","عرب","机构","组织机构","健康","招聘","рус","大拿","みんな","グーグル","世界","書籍","网址","닷넷","コム","天主教","游戏","vermögensberater","vermögensberatung","企业","信息","嘉里大酒店","嘉里","广东","政务","xyz","yachts","yahoo","yamaxun","yandex","yodobashi","yoga","yokohama","you","youtube","yun","zappos","zara","zero","zip","zone","zuerich","co.krd","edu.krd","art.pl","gliwice.pl","krakow.pl","poznan.pl","wroc.pl","zakopane.pl","lib.de.us","12chars.dev","12chars.it","12chars.pro","cc.ua","inf.ua","ltd.ua","611.to","a2hosted.com","cpserver.com","aaa.vodka","*.on-acorn.io","activetrail.biz","adaptable.app","adobeaemcloud.com","*.dev.adobeaemcloud.com","aem.live","hlx.live","adobeaemcloud.net","aem.page","hlx.page","hlx3.page","adobeio-static.net","adobeioruntime.net","africa.com","beep.pl","airkitapps.com","airkitapps-au.com","airkitapps.eu","aivencloud.com","akadns.net","akamai.net","akamai-staging.net","akamaiedge.net","akamaiedge-staging.net","akamaihd.net","akamaihd-staging.net","akamaiorigin.net","akamaiorigin-staging.net","akamaized.net","akamaized-staging.net","edgekey.net","edgekey-staging.net","edgesuite.net","edgesuite-staging.net","barsy.ca","*.compute.estate","*.alces.network","kasserver.com","altervista.org","alwaysdata.net","myamaze.net","execute-api.cn-north-1.amazonaws.com.cn","execute-api.cn-northwest-1.amazonaws.com.cn","execute-api.af-south-1.amazonaws.com","execute-api.ap-east-1.amazonaws.com","execute-api.ap-northeast-1.amazonaws.com","execute-api.ap-northeast-2.amazonaws.com","execute-api.ap-northeast-3.amazonaws.com","execute-api.ap-south-1.amazonaws.com","execute-api.ap-south-2.amazonaws.com","execute-api.ap-southeast-1.amazonaws.com","execute-api.ap-southeast-2.amazonaws.com","execute-api.ap-southeast-3.amazonaws.com","execute-api.ap-southeast-4.amazonaws.com","execute-api.ap-southeast-5.amazonaws.com","execute-api.ca-central-1.amazonaws.com","execute-api.ca-west-1.amazonaws.com","execute-api.eu-central-1.amazonaws.com","execute-api.eu-central-2.amazonaws.com","execute-api.eu-north-1.amazonaws.com","execute-api.eu-south-1.amazonaws.com","execute-api.eu-south-2.amazonaws.com","execute-api.eu-west-1.amazonaws.com","execute-api.eu-west-2.amazonaws.com","execute-api.eu-west-3.amazonaws.com","execute-api.il-central-1.amazonaws.com","execute-api.me-central-1.amazonaws.com","execute-api.me-south-1.amazonaws.com","execute-api.sa-east-1.amazonaws.com","execute-api.us-east-1.amazonaws.com","execute-api.us-east-2.amazonaws.com","execute-api.us-gov-east-1.amazonaws.com","execute-api.us-gov-west-1.amazonaws.com","execute-api.us-west-1.amazonaws.com","execute-api.us-west-2.amazonaws.com","cloudfront.net","auth.af-south-1.amazoncognito.com","auth.ap-east-1.amazoncognito.com","auth.ap-northeast-1.amazoncognito.com","auth.ap-northeast-2.amazoncognito.com","auth.ap-northeast-3.amazoncognito.com","auth.ap-south-1.amazoncognito.com","auth.ap-south-2.amazoncognito.com","auth.ap-southeast-1.amazoncognito.com","auth.ap-southeast-2.amazoncognito.com","auth.ap-southeast-3.amazoncognito.com","auth.ap-southeast-4.amazoncognito.com","auth.ca-central-1.amazoncognito.com","auth.ca-west-1.amazoncognito.com","auth.eu-central-1.amazoncognito.com","auth.eu-central-2.amazoncognito.com","auth.eu-north-1.amazoncognito.com","auth.eu-south-1.amazoncognito.com","auth.eu-south-2.amazoncognito.com","auth.eu-west-1.amazoncognito.com","auth.eu-west-2.amazoncognito.com","auth.eu-west-3.amazoncognito.com","auth.il-central-1.amazoncognito.com","auth.me-central-1.amazoncognito.com","auth.me-south-1.amazoncognito.com","auth.sa-east-1.amazoncognito.com","auth.us-east-1.amazoncognito.com","auth-fips.us-east-1.amazoncognito.com","auth.us-east-2.amazoncognito.com","auth-fips.us-east-2.amazoncognito.com","auth-fips.us-gov-west-1.amazoncognito.com","auth.us-west-1.amazoncognito.com","auth-fips.us-west-1.amazoncognito.com","auth.us-west-2.amazoncognito.com","auth-fips.us-west-2.amazoncognito.com","*.compute.amazonaws.com.cn","*.compute.amazonaws.com","*.compute-1.amazonaws.com","us-east-1.amazonaws.com","emrappui-prod.cn-north-1.amazonaws.com.cn","emrnotebooks-prod.cn-north-1.amazonaws.com.cn","emrstudio-prod.cn-north-1.amazonaws.com.cn","emrappui-prod.cn-northwest-1.amazonaws.com.cn","emrnotebooks-prod.cn-northwest-1.amazonaws.com.cn","emrstudio-prod.cn-northwest-1.amazonaws.com.cn","emrappui-prod.af-south-1.amazonaws.com","emrnotebooks-prod.af-south-1.amazonaws.com","emrstudio-prod.af-south-1.amazonaws.com","emrappui-prod.ap-east-1.amazonaws.com","emrnotebooks-prod.ap-east-1.amazonaws.com","emrstudio-prod.ap-east-1.amazonaws.com","emrappui-prod.ap-northeast-1.amazonaws.com","emrnotebooks-prod.ap-northeast-1.amazonaws.com","emrstudio-prod.ap-northeast-1.amazonaws.com","emrappui-prod.ap-northeast-2.amazonaws.com","emrnotebooks-prod.ap-northeast-2.amazonaws.com","emrstudio-prod.ap-northeast-2.amazonaws.com","emrappui-prod.ap-northeast-3.amazonaws.com","emrnotebooks-prod.ap-northeast-3.amazonaws.com","emrstudio-prod.ap-northeast-3.amazonaws.com","emrappui-prod.ap-south-1.amazonaws.com","emrnotebooks-prod.ap-south-1.amazonaws.com","emrstudio-prod.ap-south-1.amazonaws.com","emrappui-prod.ap-south-2.amazonaws.com","emrnotebooks-prod.ap-south-2.amazonaws.com","emrstudio-prod.ap-south-2.amazonaws.com","emrappui-prod.ap-southeast-1.amazonaws.com","emrnotebooks-prod.ap-southeast-1.amazonaws.com","emrstudio-prod.ap-southeast-1.amazonaws.com","emrappui-prod.ap-southeast-2.amazonaws.com","emrnotebooks-prod.ap-southeast-2.amazonaws.com","emrstudio-prod.ap-southeast-2.amazonaws.com","emrappui-prod.ap-southeast-3.amazonaws.com","emrnotebooks-prod.ap-southeast-3.amazonaws.com","emrstudio-prod.ap-southeast-3.amazonaws.com","emrappui-prod.ap-southeast-4.amazonaws.com","emrnotebooks-prod.ap-southeast-4.amazonaws.com","emrstudio-prod.ap-southeast-4.amazonaws.com","emrappui-prod.ca-central-1.amazonaws.com","emrnotebooks-prod.ca-central-1.amazonaws.com","emrstudio-prod.ca-central-1.amazonaws.com","emrappui-prod.ca-west-1.amazonaws.com","emrnotebooks-prod.ca-west-1.amazonaws.com","emrstudio-prod.ca-west-1.amazonaws.com","emrappui-prod.eu-central-1.amazonaws.com","emrnotebooks-prod.eu-central-1.amazonaws.com","emrstudio-prod.eu-central-1.amazonaws.com","emrappui-prod.eu-central-2.amazonaws.com","emrnotebooks-prod.eu-central-2.amazonaws.com","emrstudio-prod.eu-central-2.amazonaws.com","emrappui-prod.eu-north-1.amazonaws.com","emrnotebooks-prod.eu-north-1.amazonaws.com","emrstudio-prod.eu-north-1.amazonaws.com","emrappui-prod.eu-south-1.amazonaws.com","emrnotebooks-prod.eu-south-1.amazonaws.com","emrstudio-prod.eu-south-1.amazonaws.com","emrappui-prod.eu-south-2.amazonaws.com","emrnotebooks-prod.eu-south-2.amazonaws.com","emrstudio-prod.eu-south-2.amazonaws.com","emrappui-prod.eu-west-1.amazonaws.com","emrnotebooks-prod.eu-west-1.amazonaws.com","emrstudio-prod.eu-west-1.amazonaws.com","emrappui-prod.eu-west-2.amazonaws.com","emrnotebooks-prod.eu-west-2.amazonaws.com","emrstudio-prod.eu-west-2.amazonaws.com","emrappui-prod.eu-west-3.amazonaws.com","emrnotebooks-prod.eu-west-3.amazonaws.com","emrstudio-prod.eu-west-3.amazonaws.com","emrappui-prod.il-central-1.amazonaws.com","emrnotebooks-prod.il-central-1.amazonaws.com","emrstudio-prod.il-central-1.amazonaws.com","emrappui-prod.me-central-1.amazonaws.com","emrnotebooks-prod.me-central-1.amazonaws.com","emrstudio-prod.me-central-1.amazonaws.com","emrappui-prod.me-south-1.amazonaws.com","emrnotebooks-prod.me-south-1.amazonaws.com","emrstudio-prod.me-south-1.amazonaws.com","emrappui-prod.sa-east-1.amazonaws.com","emrnotebooks-prod.sa-east-1.amazonaws.com","emrstudio-prod.sa-east-1.amazonaws.com","emrappui-prod.us-east-1.amazonaws.com","emrnotebooks-prod.us-east-1.amazonaws.com","emrstudio-prod.us-east-1.amazonaws.com","emrappui-prod.us-east-2.amazonaws.com","emrnotebooks-prod.us-east-2.amazonaws.com","emrstudio-prod.us-east-2.amazonaws.com","emrappui-prod.us-gov-east-1.amazonaws.com","emrnotebooks-prod.us-gov-east-1.amazonaws.com","emrstudio-prod.us-gov-east-1.amazonaws.com","emrappui-prod.us-gov-west-1.amazonaws.com","emrnotebooks-prod.us-gov-west-1.amazonaws.com","emrstudio-prod.us-gov-west-1.amazonaws.com","emrappui-prod.us-west-1.amazonaws.com","emrnotebooks-prod.us-west-1.amazonaws.com","emrstudio-prod.us-west-1.amazonaws.com","emrappui-prod.us-west-2.amazonaws.com","emrnotebooks-prod.us-west-2.amazonaws.com","emrstudio-prod.us-west-2.amazonaws.com","*.cn-north-1.airflow.amazonaws.com.cn","*.cn-northwest-1.airflow.amazonaws.com.cn","*.af-south-1.airflow.amazonaws.com","*.ap-east-1.airflow.amazonaws.com","*.ap-northeast-1.airflow.amazonaws.com","*.ap-northeast-2.airflow.amazonaws.com","*.ap-northeast-3.airflow.amazonaws.com","*.ap-south-1.airflow.amazonaws.com","*.ap-south-2.airflow.amazonaws.com","*.ap-southeast-1.airflow.amazonaws.com","*.ap-southeast-2.airflow.amazonaws.com","*.ap-southeast-3.airflow.amazonaws.com","*.ap-southeast-4.airflow.amazonaws.com","*.ca-central-1.airflow.amazonaws.com","*.ca-west-1.airflow.amazonaws.com","*.eu-central-1.airflow.amazonaws.com","*.eu-central-2.airflow.amazonaws.com","*.eu-north-1.airflow.amazonaws.com","*.eu-south-1.airflow.amazonaws.com","*.eu-south-2.airflow.amazonaws.com","*.eu-west-1.airflow.amazonaws.com","*.eu-west-2.airflow.amazonaws.com","*.eu-west-3.airflow.amazonaws.com","*.il-central-1.airflow.amazonaws.com","*.me-central-1.airflow.amazonaws.com","*.me-south-1.airflow.amazonaws.com","*.sa-east-1.airflow.amazonaws.com","*.us-east-1.airflow.amazonaws.com","*.us-east-2.airflow.amazonaws.com","*.us-west-1.airflow.amazonaws.com","*.us-west-2.airflow.amazonaws.com","s3.dualstack.cn-north-1.amazonaws.com.cn","s3-accesspoint.dualstack.cn-north-1.amazonaws.com.cn","s3-website.dualstack.cn-north-1.amazonaws.com.cn","s3.cn-north-1.amazonaws.com.cn","s3-accesspoint.cn-north-1.amazonaws.com.cn","s3-deprecated.cn-north-1.amazonaws.com.cn","s3-object-lambda.cn-north-1.amazonaws.com.cn","s3-website.cn-north-1.amazonaws.com.cn","s3.dualstack.cn-northwest-1.amazonaws.com.cn","s3-accesspoint.dualstack.cn-northwest-1.amazonaws.com.cn","s3.cn-northwest-1.amazonaws.com.cn","s3-accesspoint.cn-northwest-1.amazonaws.com.cn","s3-object-lambda.cn-northwest-1.amazonaws.com.cn","s3-website.cn-northwest-1.amazonaws.com.cn","s3.dualstack.af-south-1.amazonaws.com","s3-accesspoint.dualstack.af-south-1.amazonaws.com","s3-website.dualstack.af-south-1.amazonaws.com","s3.af-south-1.amazonaws.com","s3-accesspoint.af-south-1.amazonaws.com","s3-object-lambda.af-south-1.amazonaws.com","s3-website.af-south-1.amazonaws.com","s3.dualstack.ap-east-1.amazonaws.com","s3-accesspoint.dualstack.ap-east-1.amazonaws.com","s3.ap-east-1.amazonaws.com","s3-accesspoint.ap-east-1.amazonaws.com","s3-object-lambda.ap-east-1.amazonaws.com","s3-website.ap-east-1.amazonaws.com","s3.dualstack.ap-northeast-1.amazonaws.com","s3-accesspoint.dualstack.ap-northeast-1.amazonaws.com","s3-website.dualstack.ap-northeast-1.amazonaws.com","s3.ap-northeast-1.amazonaws.com","s3-accesspoint.ap-northeast-1.amazonaws.com","s3-object-lambda.ap-northeast-1.amazonaws.com","s3-website.ap-northeast-1.amazonaws.com","s3.dualstack.ap-northeast-2.amazonaws.com","s3-accesspoint.dualstack.ap-northeast-2.amazonaws.com","s3-website.dualstack.ap-northeast-2.amazonaws.com","s3.ap-northeast-2.amazonaws.com","s3-accesspoint.ap-northeast-2.amazonaws.com","s3-object-lambda.ap-northeast-2.amazonaws.com","s3-website.ap-northeast-2.amazonaws.com","s3.dualstack.ap-northeast-3.amazonaws.com","s3-accesspoint.dualstack.ap-northeast-3.amazonaws.com","s3-website.dualstack.ap-northeast-3.amazonaws.com","s3.ap-northeast-3.amazonaws.com","s3-accesspoint.ap-northeast-3.amazonaws.com","s3-object-lambda.ap-northeast-3.amazonaws.com","s3-website.ap-northeast-3.amazonaws.com","s3.dualstack.ap-south-1.amazonaws.com","s3-accesspoint.dualstack.ap-south-1.amazonaws.com","s3-website.dualstack.ap-south-1.amazonaws.com","s3.ap-south-1.amazonaws.com","s3-accesspoint.ap-south-1.amazonaws.com","s3-object-lambda.ap-south-1.amazonaws.com","s3-website.ap-south-1.amazonaws.com","s3.dualstack.ap-south-2.amazonaws.com","s3-accesspoint.dualstack.ap-south-2.amazonaws.com","s3-website.dualstack.ap-south-2.amazonaws.com","s3.ap-south-2.amazonaws.com","s3-accesspoint.ap-south-2.amazonaws.com","s3-object-lambda.ap-south-2.amazonaws.com","s3-website.ap-south-2.amazonaws.com","s3.dualstack.ap-southeast-1.amazonaws.com","s3-accesspoint.dualstack.ap-southeast-1.amazonaws.com","s3-website.dualstack.ap-southeast-1.amazonaws.com","s3.ap-southeast-1.amazonaws.com","s3-accesspoint.ap-southeast-1.amazonaws.com","s3-object-lambda.ap-southeast-1.amazonaws.com","s3-website.ap-southeast-1.amazonaws.com","s3.dualstack.ap-southeast-2.amazonaws.com","s3-accesspoint.dualstack.ap-southeast-2.amazonaws.com","s3-website.dualstack.ap-southeast-2.amazonaws.com","s3.ap-southeast-2.amazonaws.com","s3-accesspoint.ap-southeast-2.amazonaws.com","s3-object-lambda.ap-southeast-2.amazonaws.com","s3-website.ap-southeast-2.amazonaws.com","s3.dualstack.ap-southeast-3.amazonaws.com","s3-accesspoint.dualstack.ap-southeast-3.amazonaws.com","s3-website.dualstack.ap-southeast-3.amazonaws.com","s3.ap-southeast-3.amazonaws.com","s3-accesspoint.ap-southeast-3.amazonaws.com","s3-object-lambda.ap-southeast-3.amazonaws.com","s3-website.ap-southeast-3.amazonaws.com","s3.dualstack.ap-southeast-4.amazonaws.com","s3-accesspoint.dualstack.ap-southeast-4.amazonaws.com","s3-website.dualstack.ap-southeast-4.amazonaws.com","s3.ap-southeast-4.amazonaws.com","s3-accesspoint.ap-southeast-4.amazonaws.com","s3-object-lambda.ap-southeast-4.amazonaws.com","s3-website.ap-southeast-4.amazonaws.com","s3.dualstack.ap-southeast-5.amazonaws.com","s3-accesspoint.dualstack.ap-southeast-5.amazonaws.com","s3-website.dualstack.ap-southeast-5.amazonaws.com","s3.ap-southeast-5.amazonaws.com","s3-accesspoint.ap-southeast-5.amazonaws.com","s3-deprecated.ap-southeast-5.amazonaws.com","s3-object-lambda.ap-southeast-5.amazonaws.com","s3-website.ap-southeast-5.amazonaws.com","s3.dualstack.ca-central-1.amazonaws.com","s3-accesspoint.dualstack.ca-central-1.amazonaws.com","s3-accesspoint-fips.dualstack.ca-central-1.amazonaws.com","s3-fips.dualstack.ca-central-1.amazonaws.com","s3-website.dualstack.ca-central-1.amazonaws.com","s3.ca-central-1.amazonaws.com","s3-accesspoint.ca-central-1.amazonaws.com","s3-accesspoint-fips.ca-central-1.amazonaws.com","s3-fips.ca-central-1.amazonaws.com","s3-object-lambda.ca-central-1.amazonaws.com","s3-website.ca-central-1.amazonaws.com","s3.dualstack.ca-west-1.amazonaws.com","s3-accesspoint.dualstack.ca-west-1.amazonaws.com","s3-accesspoint-fips.dualstack.ca-west-1.amazonaws.com","s3-fips.dualstack.ca-west-1.amazonaws.com","s3-website.dualstack.ca-west-1.amazonaws.com","s3.ca-west-1.amazonaws.com","s3-accesspoint.ca-west-1.amazonaws.com","s3-accesspoint-fips.ca-west-1.amazonaws.com","s3-fips.ca-west-1.amazonaws.com","s3-object-lambda.ca-west-1.amazonaws.com","s3-website.ca-west-1.amazonaws.com","s3.dualstack.eu-central-1.amazonaws.com","s3-accesspoint.dualstack.eu-central-1.amazonaws.com","s3-website.dualstack.eu-central-1.amazonaws.com","s3.eu-central-1.amazonaws.com","s3-accesspoint.eu-central-1.amazonaws.com","s3-object-lambda.eu-central-1.amazonaws.com","s3-website.eu-central-1.amazonaws.com","s3.dualstack.eu-central-2.amazonaws.com","s3-accesspoint.dualstack.eu-central-2.amazonaws.com","s3-website.dualstack.eu-central-2.amazonaws.com","s3.eu-central-2.amazonaws.com","s3-accesspoint.eu-central-2.amazonaws.com","s3-object-lambda.eu-central-2.amazonaws.com","s3-website.eu-central-2.amazonaws.com","s3.dualstack.eu-north-1.amazonaws.com","s3-accesspoint.dualstack.eu-north-1.amazonaws.com","s3.eu-north-1.amazonaws.com","s3-accesspoint.eu-north-1.amazonaws.com","s3-object-lambda.eu-north-1.amazonaws.com","s3-website.eu-north-1.amazonaws.com","s3.dualstack.eu-south-1.amazonaws.com","s3-accesspoint.dualstack.eu-south-1.amazonaws.com","s3-website.dualstack.eu-south-1.amazonaws.com","s3.eu-south-1.amazonaws.com","s3-accesspoint.eu-south-1.amazonaws.com","s3-object-lambda.eu-south-1.amazonaws.com","s3-website.eu-south-1.amazonaws.com","s3.dualstack.eu-south-2.amazonaws.com","s3-accesspoint.dualstack.eu-south-2.amazonaws.com","s3-website.dualstack.eu-south-2.amazonaws.com","s3.eu-south-2.amazonaws.com","s3-accesspoint.eu-south-2.amazonaws.com","s3-object-lambda.eu-south-2.amazonaws.com","s3-website.eu-south-2.amazonaws.com","s3.dualstack.eu-west-1.amazonaws.com","s3-accesspoint.dualstack.eu-west-1.amazonaws.com","s3-website.dualstack.eu-west-1.amazonaws.com","s3.eu-west-1.amazonaws.com","s3-accesspoint.eu-west-1.amazonaws.com","s3-deprecated.eu-west-1.amazonaws.com","s3-object-lambda.eu-west-1.amazonaws.com","s3-website.eu-west-1.amazonaws.com","s3.dualstack.eu-west-2.amazonaws.com","s3-accesspoint.dualstack.eu-west-2.amazonaws.com","s3.eu-west-2.amazonaws.com","s3-accesspoint.eu-west-2.amazonaws.com","s3-object-lambda.eu-west-2.amazonaws.com","s3-website.eu-west-2.amazonaws.com","s3.dualstack.eu-west-3.amazonaws.com","s3-accesspoint.dualstack.eu-west-3.amazonaws.com","s3-website.dualstack.eu-west-3.amazonaws.com","s3.eu-west-3.amazonaws.com","s3-accesspoint.eu-west-3.amazonaws.com","s3-object-lambda.eu-west-3.amazonaws.com","s3-website.eu-west-3.amazonaws.com","s3.dualstack.il-central-1.amazonaws.com","s3-accesspoint.dualstack.il-central-1.amazonaws.com","s3-website.dualstack.il-central-1.amazonaws.com","s3.il-central-1.amazonaws.com","s3-accesspoint.il-central-1.amazonaws.com","s3-object-lambda.il-central-1.amazonaws.com","s3-website.il-central-1.amazonaws.com","s3.dualstack.me-central-1.amazonaws.com","s3-accesspoint.dualstack.me-central-1.amazonaws.com","s3-website.dualstack.me-central-1.amazonaws.com","s3.me-central-1.amazonaws.com","s3-accesspoint.me-central-1.amazonaws.com","s3-object-lambda.me-central-1.amazonaws.com","s3-website.me-central-1.amazonaws.com","s3.dualstack.me-south-1.amazonaws.com","s3-accesspoint.dualstack.me-south-1.amazonaws.com","s3.me-south-1.amazonaws.com","s3-accesspoint.me-south-1.amazonaws.com","s3-object-lambda.me-south-1.amazonaws.com","s3-website.me-south-1.amazonaws.com","s3.amazonaws.com","s3-1.amazonaws.com","s3-ap-east-1.amazonaws.com","s3-ap-northeast-1.amazonaws.com","s3-ap-northeast-2.amazonaws.com","s3-ap-northeast-3.amazonaws.com","s3-ap-south-1.amazonaws.com","s3-ap-southeast-1.amazonaws.com","s3-ap-southeast-2.amazonaws.com","s3-ca-central-1.amazonaws.com","s3-eu-central-1.amazonaws.com","s3-eu-north-1.amazonaws.com","s3-eu-west-1.amazonaws.com","s3-eu-west-2.amazonaws.com","s3-eu-west-3.amazonaws.com","s3-external-1.amazonaws.com","s3-fips-us-gov-east-1.amazonaws.com","s3-fips-us-gov-west-1.amazonaws.com","mrap.accesspoint.s3-global.amazonaws.com","s3-me-south-1.amazonaws.com","s3-sa-east-1.amazonaws.com","s3-us-east-2.amazonaws.com","s3-us-gov-east-1.amazonaws.com","s3-us-gov-west-1.amazonaws.com","s3-us-west-1.amazonaws.com","s3-us-west-2.amazonaws.com","s3-website-ap-northeast-1.amazonaws.com","s3-website-ap-southeast-1.amazonaws.com","s3-website-ap-southeast-2.amazonaws.com","s3-website-eu-west-1.amazonaws.com","s3-website-sa-east-1.amazonaws.com","s3-website-us-east-1.amazonaws.com","s3-website-us-gov-west-1.amazonaws.com","s3-website-us-west-1.amazonaws.com","s3-website-us-west-2.amazonaws.com","s3.dualstack.sa-east-1.amazonaws.com","s3-accesspoint.dualstack.sa-east-1.amazonaws.com","s3-website.dualstack.sa-east-1.amazonaws.com","s3.sa-east-1.amazonaws.com","s3-accesspoint.sa-east-1.amazonaws.com","s3-object-lambda.sa-east-1.amazonaws.com","s3-website.sa-east-1.amazonaws.com","s3.dualstack.us-east-1.amazonaws.com","s3-accesspoint.dualstack.us-east-1.amazonaws.com","s3-accesspoint-fips.dualstack.us-east-1.amazonaws.com","s3-fips.dualstack.us-east-1.amazonaws.com","s3-website.dualstack.us-east-1.amazonaws.com","s3.us-east-1.amazonaws.com","s3-accesspoint.us-east-1.amazonaws.com","s3-accesspoint-fips.us-east-1.amazonaws.com","s3-deprecated.us-east-1.amazonaws.com","s3-fips.us-east-1.amazonaws.com","s3-object-lambda.us-east-1.amazonaws.com","s3-website.us-east-1.amazonaws.com","s3.dualstack.us-east-2.amazonaws.com","s3-accesspoint.dualstack.us-east-2.amazonaws.com","s3-accesspoint-fips.dualstack.us-east-2.amazonaws.com","s3-fips.dualstack.us-east-2.amazonaws.com","s3-website.dualstack.us-east-2.amazonaws.com","s3.us-east-2.amazonaws.com","s3-accesspoint.us-east-2.amazonaws.com","s3-accesspoint-fips.us-east-2.amazonaws.com","s3-deprecated.us-east-2.amazonaws.com","s3-fips.us-east-2.amazonaws.com","s3-object-lambda.us-east-2.amazonaws.com","s3-website.us-east-2.amazonaws.com","s3.dualstack.us-gov-east-1.amazonaws.com","s3-accesspoint.dualstack.us-gov-east-1.amazonaws.com","s3-accesspoint-fips.dualstack.us-gov-east-1.amazonaws.com","s3-fips.dualstack.us-gov-east-1.amazonaws.com","s3.us-gov-east-1.amazonaws.com","s3-accesspoint.us-gov-east-1.amazonaws.com","s3-accesspoint-fips.us-gov-east-1.amazonaws.com","s3-fips.us-gov-east-1.amazonaws.com","s3-object-lambda.us-gov-east-1.amazonaws.com","s3-website.us-gov-east-1.amazonaws.com","s3.dualstack.us-gov-west-1.amazonaws.com","s3-accesspoint.dualstack.us-gov-west-1.amazonaws.com","s3-accesspoint-fips.dualstack.us-gov-west-1.amazonaws.com","s3-fips.dualstack.us-gov-west-1.amazonaws.com","s3.us-gov-west-1.amazonaws.com","s3-accesspoint.us-gov-west-1.amazonaws.com","s3-accesspoint-fips.us-gov-west-1.amazonaws.com","s3-fips.us-gov-west-1.amazonaws.com","s3-object-lambda.us-gov-west-1.amazonaws.com","s3-website.us-gov-west-1.amazonaws.com","s3.dualstack.us-west-1.amazonaws.com","s3-accesspoint.dualstack.us-west-1.amazonaws.com","s3-accesspoint-fips.dualstack.us-west-1.amazonaws.com","s3-fips.dualstack.us-west-1.amazonaws.com","s3-website.dualstack.us-west-1.amazonaws.com","s3.us-west-1.amazonaws.com","s3-accesspoint.us-west-1.amazonaws.com","s3-accesspoint-fips.us-west-1.amazonaws.com","s3-fips.us-west-1.amazonaws.com","s3-object-lambda.us-west-1.amazonaws.com","s3-website.us-west-1.amazonaws.com","s3.dualstack.us-west-2.amazonaws.com","s3-accesspoint.dualstack.us-west-2.amazonaws.com","s3-accesspoint-fips.dualstack.us-west-2.amazonaws.com","s3-fips.dualstack.us-west-2.amazonaws.com","s3-website.dualstack.us-west-2.amazonaws.com","s3.us-west-2.amazonaws.com","s3-accesspoint.us-west-2.amazonaws.com","s3-accesspoint-fips.us-west-2.amazonaws.com","s3-deprecated.us-west-2.amazonaws.com","s3-fips.us-west-2.amazonaws.com","s3-object-lambda.us-west-2.amazonaws.com","s3-website.us-west-2.amazonaws.com","labeling.ap-northeast-1.sagemaker.aws","labeling.ap-northeast-2.sagemaker.aws","labeling.ap-south-1.sagemaker.aws","labeling.ap-southeast-1.sagemaker.aws","labeling.ap-southeast-2.sagemaker.aws","labeling.ca-central-1.sagemaker.aws","labeling.eu-central-1.sagemaker.aws","labeling.eu-west-1.sagemaker.aws","labeling.eu-west-2.sagemaker.aws","labeling.us-east-1.sagemaker.aws","labeling.us-east-2.sagemaker.aws","labeling.us-west-2.sagemaker.aws","notebook.af-south-1.sagemaker.aws","notebook.ap-east-1.sagemaker.aws","notebook.ap-northeast-1.sagemaker.aws","notebook.ap-northeast-2.sagemaker.aws","notebook.ap-northeast-3.sagemaker.aws","notebook.ap-south-1.sagemaker.aws","notebook.ap-south-2.sagemaker.aws","notebook.ap-southeast-1.sagemaker.aws","notebook.ap-southeast-2.sagemaker.aws","notebook.ap-southeast-3.sagemaker.aws","notebook.ap-southeast-4.sagemaker.aws","notebook.ca-central-1.sagemaker.aws","notebook-fips.ca-central-1.sagemaker.aws","notebook.ca-west-1.sagemaker.aws","notebook-fips.ca-west-1.sagemaker.aws","notebook.eu-central-1.sagemaker.aws","notebook.eu-central-2.sagemaker.aws","notebook.eu-north-1.sagemaker.aws","notebook.eu-south-1.sagemaker.aws","notebook.eu-south-2.sagemaker.aws","notebook.eu-west-1.sagemaker.aws","notebook.eu-west-2.sagemaker.aws","notebook.eu-west-3.sagemaker.aws","notebook.il-central-1.sagemaker.aws","notebook.me-central-1.sagemaker.aws","notebook.me-south-1.sagemaker.aws","notebook.sa-east-1.sagemaker.aws","notebook.us-east-1.sagemaker.aws","notebook-fips.us-east-1.sagemaker.aws","notebook.us-east-2.sagemaker.aws","notebook-fips.us-east-2.sagemaker.aws","notebook.us-gov-east-1.sagemaker.aws","notebook-fips.us-gov-east-1.sagemaker.aws","notebook.us-gov-west-1.sagemaker.aws","notebook-fips.us-gov-west-1.sagemaker.aws","notebook.us-west-1.sagemaker.aws","notebook-fips.us-west-1.sagemaker.aws","notebook.us-west-2.sagemaker.aws","notebook-fips.us-west-2.sagemaker.aws","notebook.cn-north-1.sagemaker.com.cn","notebook.cn-northwest-1.sagemaker.com.cn","studio.af-south-1.sagemaker.aws","studio.ap-east-1.sagemaker.aws","studio.ap-northeast-1.sagemaker.aws","studio.ap-northeast-2.sagemaker.aws","studio.ap-northeast-3.sagemaker.aws","studio.ap-south-1.sagemaker.aws","studio.ap-southeast-1.sagemaker.aws","studio.ap-southeast-2.sagemaker.aws","studio.ap-southeast-3.sagemaker.aws","studio.ca-central-1.sagemaker.aws","studio.eu-central-1.sagemaker.aws","studio.eu-north-1.sagemaker.aws","studio.eu-south-1.sagemaker.aws","studio.eu-south-2.sagemaker.aws","studio.eu-west-1.sagemaker.aws","studio.eu-west-2.sagemaker.aws","studio.eu-west-3.sagemaker.aws","studio.il-central-1.sagemaker.aws","studio.me-central-1.sagemaker.aws","studio.me-south-1.sagemaker.aws","studio.sa-east-1.sagemaker.aws","studio.us-east-1.sagemaker.aws","studio.us-east-2.sagemaker.aws","studio.us-gov-east-1.sagemaker.aws","studio-fips.us-gov-east-1.sagemaker.aws","studio.us-gov-west-1.sagemaker.aws","studio-fips.us-gov-west-1.sagemaker.aws","studio.us-west-1.sagemaker.aws","studio.us-west-2.sagemaker.aws","studio.cn-north-1.sagemaker.com.cn","studio.cn-northwest-1.sagemaker.com.cn","*.experiments.sagemaker.aws","analytics-gateway.ap-northeast-1.amazonaws.com","analytics-gateway.ap-northeast-2.amazonaws.com","analytics-gateway.ap-south-1.amazonaws.com","analytics-gateway.ap-southeast-1.amazonaws.com","analytics-gateway.ap-southeast-2.amazonaws.com","analytics-gateway.eu-central-1.amazonaws.com","analytics-gateway.eu-west-1.amazonaws.com","analytics-gateway.us-east-1.amazonaws.com","analytics-gateway.us-east-2.amazonaws.com","analytics-gateway.us-west-2.amazonaws.com","amplifyapp.com","*.awsapprunner.com","webview-assets.aws-cloud9.af-south-1.amazonaws.com","vfs.cloud9.af-south-1.amazonaws.com","webview-assets.cloud9.af-south-1.amazonaws.com","webview-assets.aws-cloud9.ap-east-1.amazonaws.com","vfs.cloud9.ap-east-1.amazonaws.com","webview-assets.cloud9.ap-east-1.amazonaws.com","webview-assets.aws-cloud9.ap-northeast-1.amazonaws.com","vfs.cloud9.ap-northeast-1.amazonaws.com","webview-assets.cloud9.ap-northeast-1.amazonaws.com","webview-assets.aws-cloud9.ap-northeast-2.amazonaws.com","vfs.cloud9.ap-northeast-2.amazonaws.com","webview-assets.cloud9.ap-northeast-2.amazonaws.com","webview-assets.aws-cloud9.ap-northeast-3.amazonaws.com","vfs.cloud9.ap-northeast-3.amazonaws.com","webview-assets.cloud9.ap-northeast-3.amazonaws.com","webview-assets.aws-cloud9.ap-south-1.amazonaws.com","vfs.cloud9.ap-south-1.amazonaws.com","webview-assets.cloud9.ap-south-1.amazonaws.com","webview-assets.aws-cloud9.ap-southeast-1.amazonaws.com","vfs.cloud9.ap-southeast-1.amazonaws.com","webview-assets.cloud9.ap-southeast-1.amazonaws.com","webview-assets.aws-cloud9.ap-southeast-2.amazonaws.com","vfs.cloud9.ap-southeast-2.amazonaws.com","webview-assets.cloud9.ap-southeast-2.amazonaws.com","webview-assets.aws-cloud9.ca-central-1.amazonaws.com","vfs.cloud9.ca-central-1.amazonaws.com","webview-assets.cloud9.ca-central-1.amazonaws.com","webview-assets.aws-cloud9.eu-central-1.amazonaws.com","vfs.cloud9.eu-central-1.amazonaws.com","webview-assets.cloud9.eu-central-1.amazonaws.com","webview-assets.aws-cloud9.eu-north-1.amazonaws.com","vfs.cloud9.eu-north-1.amazonaws.com","webview-assets.cloud9.eu-north-1.amazonaws.com","webview-assets.aws-cloud9.eu-south-1.amazonaws.com","vfs.cloud9.eu-south-1.amazonaws.com","webview-assets.cloud9.eu-south-1.amazonaws.com","webview-assets.aws-cloud9.eu-west-1.amazonaws.com","vfs.cloud9.eu-west-1.amazonaws.com","webview-assets.cloud9.eu-west-1.amazonaws.com","webview-assets.aws-cloud9.eu-west-2.amazonaws.com","vfs.cloud9.eu-west-2.amazonaws.com","webview-assets.cloud9.eu-west-2.amazonaws.com","webview-assets.aws-cloud9.eu-west-3.amazonaws.com","vfs.cloud9.eu-west-3.amazonaws.com","webview-assets.cloud9.eu-west-3.amazonaws.com","webview-assets.aws-cloud9.il-central-1.amazonaws.com","vfs.cloud9.il-central-1.amazonaws.com","webview-assets.aws-cloud9.me-south-1.amazonaws.com","vfs.cloud9.me-south-1.amazonaws.com","webview-assets.cloud9.me-south-1.amazonaws.com","webview-assets.aws-cloud9.sa-east-1.amazonaws.com","vfs.cloud9.sa-east-1.amazonaws.com","webview-assets.cloud9.sa-east-1.amazonaws.com","webview-assets.aws-cloud9.us-east-1.amazonaws.com","vfs.cloud9.us-east-1.amazonaws.com","webview-assets.cloud9.us-east-1.amazonaws.com","webview-assets.aws-cloud9.us-east-2.amazonaws.com","vfs.cloud9.us-east-2.amazonaws.com","webview-assets.cloud9.us-east-2.amazonaws.com","webview-assets.aws-cloud9.us-west-1.amazonaws.com","vfs.cloud9.us-west-1.amazonaws.com","webview-assets.cloud9.us-west-1.amazonaws.com","webview-assets.aws-cloud9.us-west-2.amazonaws.com","vfs.cloud9.us-west-2.amazonaws.com","webview-assets.cloud9.us-west-2.amazonaws.com","awsapps.com","cn-north-1.eb.amazonaws.com.cn","cn-northwest-1.eb.amazonaws.com.cn","elasticbeanstalk.com","af-south-1.elasticbeanstalk.com","ap-east-1.elasticbeanstalk.com","ap-northeast-1.elasticbeanstalk.com","ap-northeast-2.elasticbeanstalk.com","ap-northeast-3.elasticbeanstalk.com","ap-south-1.elasticbeanstalk.com","ap-southeast-1.elasticbeanstalk.com","ap-southeast-2.elasticbeanstalk.com","ap-southeast-3.elasticbeanstalk.com","ca-central-1.elasticbeanstalk.com","eu-central-1.elasticbeanstalk.com","eu-north-1.elasticbeanstalk.com","eu-south-1.elasticbeanstalk.com","eu-west-1.elasticbeanstalk.com","eu-west-2.elasticbeanstalk.com","eu-west-3.elasticbeanstalk.com","il-central-1.elasticbeanstalk.com","me-south-1.elasticbeanstalk.com","sa-east-1.elasticbeanstalk.com","us-east-1.elasticbeanstalk.com","us-east-2.elasticbeanstalk.com","us-gov-east-1.elasticbeanstalk.com","us-gov-west-1.elasticbeanstalk.com","us-west-1.elasticbeanstalk.com","us-west-2.elasticbeanstalk.com","*.elb.amazonaws.com.cn","*.elb.amazonaws.com","awsglobalaccelerator.com","*.private.repost.aws","eero.online","eero-stage.online","apigee.io","panel.dev","siiites.com","appspacehosted.com","appspaceusercontent.com","appudo.net","on-aptible.com","f5.si","arvanedge.ir","user.aseinet.ne.jp","gv.vc","d.gv.vc","user.party.eus","pimienta.org","poivron.org","potager.org","sweetpepper.org","myasustor.com","cdn.prod.atlassian-dev.net","translated.page","myfritz.link","myfritz.net","onavstack.net","*.awdev.ca","*.advisor.ws","ecommerce-shop.pl","b-data.io","balena-devices.com","base.ec","official.ec","buyshop.jp","fashionstore.jp","handcrafted.jp","kawaiishop.jp","supersale.jp","theshop.jp","shopselect.net","base.shop","beagleboard.io","*.beget.app","pages.gay","bnr.la","bitbucket.io","blackbaudcdn.net","of.je","bluebite.io","boomla.net","boutir.com","boxfuse.io","square7.ch","bplaced.com","bplaced.de","square7.de","bplaced.net","square7.net","*.s.brave.io","shop.brendly.hr","shop.brendly.rs","browsersafetymark.io","radio.am","radio.fm","uk0.bigv.io","dh.bytemark.co.uk","vm.bytemark.co.uk","cafjs.com","canva-apps.cn","*.my.canvasite.cn","canva-apps.com","*.my.canva.site","drr.ac","uwu.ai","carrd.co","crd.co","ju.mp","api.gov.uk","cdn77-storage.com","rsc.contentproxy9.cz","r.cdn77.net","cdn77-ssl.net","c.cdn77.org","rsc.cdn77.org","ssl.origin.cdn77-secure.org","za.bz","br.com","cn.com","de.com","eu.com","jpn.com","mex.com","ru.com","sa.com","uk.com","us.com","za.com","com.de","gb.net","hu.net","jp.net","se.net","uk.net","ae.org","com.se","cx.ua","discourse.group","discourse.team","clerk.app","clerkstage.app","*.lcl.dev","*.lclstage.dev","*.stg.dev","*.stgstage.dev","cleverapps.cc","*.services.clever-cloud.com","cleverapps.io","cleverapps.tech","clickrising.net","cloudns.asia","cloudns.be","cloud-ip.biz","cloudns.biz","cloudns.cc","cloudns.ch","cloudns.cl","cloudns.club","dnsabr.com","ip-ddns.com","cloudns.cx","cloudns.eu","cloudns.in","cloudns.info","ddns-ip.net","dns-cloud.net","dns-dynamic.net","cloudns.nz","cloudns.org","ip-dynamic.org","cloudns.ph","cloudns.pro","cloudns.pw","cloudns.us","c66.me","cloud66.ws","cloud66.zone","jdevcloud.com","wpdevcloud.com","cloudaccess.host","freesite.host","cloudaccess.net","*.cloudera.site","cf-ipfs.com","cloudflare-ipfs.com","trycloudflare.com","pages.dev","r2.dev","workers.dev","cloudflare.net","cdn.cloudflare.net","cdn.cloudflareanycast.net","cdn.cloudflarecn.net","cdn.cloudflareglobal.net","cust.cloudscale.ch","objects.lpg.cloudscale.ch","objects.rma.cloudscale.ch","wnext.app","cnpy.gdn","*.otap.co","co.ca","co.com","codeberg.page","csb.app","preview.csb.app","co.nl","co.no","webhosting.be","hosting-cluster.nl","ctfcloud.net","convex.site","ac.ru","edu.ru","gov.ru","int.ru","mil.ru","test.ru","dyn.cosidns.de","dnsupdater.de","dynamisches-dns.de","internet-dns.de","l-o-g-i-n.de","dynamic-dns.info","feste-ip.net","knx-server.net","static-access.net","craft.me","realm.cz","on.crisp.email","*.cryptonomic.net","curv.dev","cfolks.pl","cyon.link","cyon.site","platform0.app","fnwk.site","folionetwork.site","biz.dk","co.dk","firm.dk","reg.dk","store.dk","dyndns.dappnode.io","builtwithdark.com","darklang.io","demo.datadetect.com","instance.datadetect.com","edgestack.me","dattolocal.com","dattorelay.com","dattoweb.com","mydatto.com","dattolocal.net","mydatto.net","ddnss.de","dyn.ddnss.de","dyndns.ddnss.de","dyn-ip24.de","dyndns1.de","home-webserver.de","dyn.home-webserver.de","myhome-server.de","ddnss.org","debian.net","definima.io","definima.net","deno.dev","deno-staging.dev","dedyn.io","deta.app","deta.dev","dfirma.pl","dkonto.pl","you2.pl","ondigitalocean.app","*.digitaloceanspaces.com","us.kg","rss.my.id","diher.solutions","discordsays.com","discordsez.com","jozi.biz","dnshome.de","online.th","shop.th","drayddns.com","shoparena.pl","dreamhosters.com","durumis.com","mydrobo.com","drud.io","drud.us","duckdns.org","dy.fi","tunk.org","dyndns.biz","for-better.biz","for-more.biz","for-some.biz","for-the.biz","selfip.biz","webhop.biz","ftpaccess.cc","game-server.cc","myphotos.cc","scrapping.cc","blogdns.com","cechire.com","dnsalias.com","dnsdojo.com","doesntexist.com","dontexist.com","doomdns.com","dyn-o-saur.com","dynalias.com","dyndns-at-home.com","dyndns-at-work.com","dyndns-blog.com","dyndns-free.com","dyndns-home.com","dyndns-ip.com","dyndns-mail.com","dyndns-office.com","dyndns-pics.com","dyndns-remote.com","dyndns-server.com","dyndns-web.com","dyndns-wiki.com","dyndns-work.com","est-a-la-maison.com","est-a-la-masion.com","est-le-patron.com","est-mon-blogueur.com","from-ak.com","from-al.com","from-ar.com","from-ca.com","from-ct.com","from-dc.com","from-de.com","from-fl.com","from-ga.com","from-hi.com","from-ia.com","from-id.com","from-il.com","from-in.com","from-ks.com","from-ky.com","from-ma.com","from-md.com","from-mi.com","from-mn.com","from-mo.com","from-ms.com","from-mt.com","from-nc.com","from-nd.com","from-ne.com","from-nh.com","from-nj.com","from-nm.com","from-nv.com","from-oh.com","from-ok.com","from-or.com","from-pa.com","from-pr.com","from-ri.com","from-sc.com","from-sd.com","from-tn.com","from-tx.com","from-ut.com","from-va.com","from-vt.com","from-wa.com","from-wi.com","from-wv.com","from-wy.com","getmyip.com","gotdns.com","hobby-site.com","homelinux.com","homeunix.com","iamallama.com","is-a-anarchist.com","is-a-blogger.com","is-a-bookkeeper.com","is-a-bulls-fan.com","is-a-caterer.com","is-a-chef.com","is-a-conservative.com","is-a-cpa.com","is-a-cubicle-slave.com","is-a-democrat.com","is-a-designer.com","is-a-doctor.com","is-a-financialadvisor.com","is-a-geek.com","is-a-green.com","is-a-guru.com","is-a-hard-worker.com","is-a-hunter.com","is-a-landscaper.com","is-a-lawyer.com","is-a-liberal.com","is-a-libertarian.com","is-a-llama.com","is-a-musician.com","is-a-nascarfan.com","is-a-nurse.com","is-a-painter.com","is-a-personaltrainer.com","is-a-photographer.com","is-a-player.com","is-a-republican.com","is-a-rockstar.com","is-a-socialist.com","is-a-student.com","is-a-teacher.com","is-a-techie.com","is-a-therapist.com","is-an-accountant.com","is-an-actor.com","is-an-actress.com","is-an-anarchist.com","is-an-artist.com","is-an-engineer.com","is-an-entertainer.com","is-certified.com","is-gone.com","is-into-anime.com","is-into-cars.com","is-into-cartoons.com","is-into-games.com","is-leet.com","is-not-certified.com","is-slick.com","is-uberleet.com","is-with-theband.com","isa-geek.com","isa-hockeynut.com","issmarterthanyou.com","likes-pie.com","likescandy.com","neat-url.com","saves-the-whales.com","selfip.com","sells-for-less.com","sells-for-u.com","servebbs.com","simple-url.com","space-to-rent.com","teaches-yoga.com","writesthisblog.com","ath.cx","fuettertdasnetz.de","isteingeek.de","istmein.de","lebtimnetz.de","leitungsen.de","traeumtgerade.de","barrel-of-knowledge.info","barrell-of-knowledge.info","dyndns.info","for-our.info","groks-the.info","groks-this.info","here-for-more.info","knowsitall.info","selfip.info","webhop.info","forgot.her.name","forgot.his.name","at-band-camp.net","blogdns.net","broke-it.net","buyshouses.net","dnsalias.net","dnsdojo.net","does-it.net","dontexist.net","dynalias.net","dynathome.net","endofinternet.net","from-az.net","from-co.net","from-la.net","from-ny.net","gets-it.net","ham-radio-op.net","homeftp.net","homeip.net","homelinux.net","homeunix.net","in-the-band.net","is-a-chef.net","is-a-geek.net","isa-geek.net","kicks-ass.net","office-on-the.net","podzone.net","scrapper-site.net","selfip.net","sells-it.net","servebbs.net","serveftp.net","thruhere.net","webhop.net","merseine.nu","mine.nu","shacknet.nu","blogdns.org","blogsite.org","boldlygoingnowhere.org","dnsalias.org","dnsdojo.org","doesntexist.org","dontexist.org","doomdns.org","dvrdns.org","dynalias.org","dyndns.org","go.dyndns.org","home.dyndns.org","endofinternet.org","endoftheinternet.org","from-me.org","game-host.org","gotdns.org","hobby-site.org","homedns.org","homeftp.org","homelinux.org","homeunix.org","is-a-bruinsfan.org","is-a-candidate.org","is-a-celticsfan.org","is-a-chef.org","is-a-geek.org","is-a-knight.org","is-a-linux-user.org","is-a-patsfan.org","is-a-soxfan.org","is-found.org","is-lost.org","is-saved.org","is-very-bad.org","is-very-evil.org","is-very-good.org","is-very-nice.org","is-very-sweet.org","isa-geek.org","kicks-ass.org","misconfused.org","podzone.org","readmyblog.org","selfip.org","sellsyourhome.org","servebbs.org","serveftp.org","servegame.org","stuff-4-sale.org","webhop.org","better-than.tv","dyndns.tv","on-the-web.tv","worse-than.tv","is-by.us","land-4-sale.us","stuff-4-sale.us","dyndns.ws","mypets.ws","ddnsfree.com","ddnsgeek.com","giize.com","gleeze.com","kozow.com","loseyourip.com","ooguy.com","theworkpc.com","casacam.net","dynu.net","accesscam.org","camdvr.org","freeddns.org","mywire.org","webredirect.org","myddns.rocks","dynv6.net","e4.cz","easypanel.app","easypanel.host","*.ewp.live","twmail.cc","twmail.net","twmail.org","mymailer.com.tw","url.tw","at.emf.camp","rt.ht","elementor.cloud","elementor.cool","en-root.fr","mytuleap.com","tuleap-partners.com","encr.app","encoreapi.com","eu.encoway.cloud","eu.org","al.eu.org","asso.eu.org","at.eu.org","au.eu.org","be.eu.org","bg.eu.org","ca.eu.org","cd.eu.org","ch.eu.org","cn.eu.org","cy.eu.org","cz.eu.org","de.eu.org","dk.eu.org","edu.eu.org","ee.eu.org","es.eu.org","fi.eu.org","fr.eu.org","gr.eu.org","hr.eu.org","hu.eu.org","ie.eu.org","il.eu.org","in.eu.org","int.eu.org","is.eu.org","it.eu.org","jp.eu.org","kr.eu.org","lt.eu.org","lu.eu.org","lv.eu.org","me.eu.org","mk.eu.org","mt.eu.org","my.eu.org","net.eu.org","ng.eu.org","nl.eu.org","no.eu.org","nz.eu.org","pl.eu.org","pt.eu.org","ro.eu.org","ru.eu.org","se.eu.org","si.eu.org","sk.eu.org","tr.eu.org","uk.eu.org","us.eu.org","eurodir.ru","eu-1.evennode.com","eu-2.evennode.com","eu-3.evennode.com","eu-4.evennode.com","us-1.evennode.com","us-2.evennode.com","us-3.evennode.com","us-4.evennode.com","relay.evervault.app","relay.evervault.dev","expo.app","staging.expo.app","onfabrica.com","ru.net","adygeya.ru","bashkiria.ru","bir.ru","cbg.ru","com.ru","dagestan.ru","grozny.ru","kalmykia.ru","kustanai.ru","marine.ru","mordovia.ru","msk.ru","mytis.ru","nalchik.ru","nov.ru","pyatigorsk.ru","spb.ru","vladikavkaz.ru","vladimir.ru","abkhazia.su","adygeya.su","aktyubinsk.su","arkhangelsk.su","armenia.su","ashgabad.su","azerbaijan.su","balashov.su","bashkiria.su","bryansk.su","bukhara.su","chimkent.su","dagestan.su","east-kazakhstan.su","exnet.su","georgia.su","grozny.su","ivanovo.su","jambyl.su","kalmykia.su","kaluga.su","karacol.su","karaganda.su","karelia.su","khakassia.su","krasnodar.su","kurgan.su","kustanai.su","lenug.su","mangyshlak.su","mordovia.su","msk.su","murmansk.su","nalchik.su","navoi.su","north-kazakhstan.su","nov.su","obninsk.su","penza.su","pokrovsk.su","sochi.su","spb.su","tashkent.su","termez.su","togliatti.su","troitsk.su","tselinograd.su","tula.su","tuva.su","vladikavkaz.su","vladimir.su","vologda.su","channelsdvr.net","u.channelsdvr.net","edgecompute.app","fastly-edge.com","fastly-terrarium.com","freetls.fastly.net","map.fastly.net","a.prod.fastly.net","global.prod.fastly.net","a.ssl.fastly.net","b.ssl.fastly.net","global.ssl.fastly.net","fastlylb.net","map.fastlylb.net","*.user.fm","fastvps-server.com","fastvps.host","myfast.host","fastvps.site","myfast.space","conn.uk","copro.uk","hosp.uk","fedorainfracloud.org","fedorapeople.org","cloud.fedoraproject.org","app.os.fedoraproject.org","app.os.stg.fedoraproject.org","mydobiss.com","fh-muenster.io","filegear.me","firebaseapp.com","fldrv.com","flutterflow.app","fly.dev","shw.io","edgeapp.net","forgeblocks.com","id.forgerock.io","framer.ai","framer.app","framercanvas.com","framer.media","framer.photos","framer.website","framer.wiki","0e.vc","freebox-os.com","freeboxos.com","fbx-os.fr","fbxos.fr","freebox-os.fr","freeboxos.fr","freedesktop.org","freemyip.com","*.frusky.de","wien.funkfeuer.at","daemon.asia","dix.asia","mydns.bz","0am.jp","0g0.jp","0j0.jp","0t0.jp","mydns.jp","pgw.jp","wjg.jp","keyword-on.net","live-on.net","server-on.net","mydns.tw","mydns.vc","*.futurecms.at","*.ex.futurecms.at","*.in.futurecms.at","futurehosting.at","futuremailing.at","*.ex.ortsinfo.at","*.kunden.ortsinfo.at","*.statics.cloud","aliases121.com","campaign.gov.uk","service.gov.uk","independent-commission.uk","independent-inquest.uk","independent-inquiry.uk","independent-panel.uk","independent-review.uk","public-inquiry.uk","royal-commission.uk","gehirn.ne.jp","usercontent.jp","gentapps.com","gentlentapis.com","lab.ms","cdn-edges.net","localcert.net","localhostcert.net","gsj.bz","githubusercontent.com","githubpreview.dev","github.io","gitlab.io","gitapp.si","gitpage.si","glitch.me","nog.community","co.ro","shop.ro","lolipop.io","angry.jp","babyblue.jp","babymilk.jp","backdrop.jp","bambina.jp","bitter.jp","blush.jp","boo.jp","boy.jp","boyfriend.jp","but.jp","candypop.jp","capoo.jp","catfood.jp","cheap.jp","chicappa.jp","chillout.jp","chips.jp","chowder.jp","chu.jp","ciao.jp","cocotte.jp","coolblog.jp","cranky.jp","cutegirl.jp","daa.jp","deca.jp","deci.jp","digick.jp","egoism.jp","fakefur.jp","fem.jp","flier.jp","floppy.jp","fool.jp","frenchkiss.jp","girlfriend.jp","girly.jp","gloomy.jp","gonna.jp","greater.jp","hacca.jp","heavy.jp","her.jp","hiho.jp","hippy.jp","holy.jp","hungry.jp","icurus.jp","itigo.jp","jellybean.jp","kikirara.jp","kill.jp","kilo.jp","kuron.jp","littlestar.jp","lolipopmc.jp","lolitapunk.jp","lomo.jp","lovepop.jp","lovesick.jp","main.jp","mods.jp","mond.jp","mongolian.jp","moo.jp","namaste.jp","nikita.jp","nobushi.jp","noor.jp","oops.jp","parallel.jp","parasite.jp","pecori.jp","peewee.jp","penne.jp","pepper.jp","perma.jp","pigboat.jp","pinoko.jp","punyu.jp","pupu.jp","pussycat.jp","pya.jp","raindrop.jp","readymade.jp","sadist.jp","schoolbus.jp","secret.jp","staba.jp","stripper.jp","sub.jp","sunnyday.jp","thick.jp","tonkotsu.jp","under.jp","upper.jp","velvet.jp","verse.jp","versus.jp","vivian.jp","watson.jp","weblike.jp","whitesnow.jp","zombie.jp","heteml.net","graphic.design","goip.de","blogspot.ae","blogspot.al","blogspot.am","*.hosted.app","*.run.app","web.app","blogspot.com.ar","blogspot.co.at","blogspot.com.au","blogspot.ba","blogspot.be","blogspot.bg","blogspot.bj","blogspot.com.br","blogspot.com.by","blogspot.ca","blogspot.cf","blogspot.ch","blogspot.cl","blogspot.com.co","*.0emm.com","appspot.com","*.r.appspot.com","blogspot.com","codespot.com","googleapis.com","googlecode.com","pagespeedmobilizer.com","withgoogle.com","withyoutube.com","blogspot.cv","blogspot.com.cy","blogspot.cz","blogspot.de","*.gateway.dev","blogspot.dk","blogspot.com.ee","blogspot.com.eg","blogspot.com.es","blogspot.fi","blogspot.fr","cloud.goog","translate.goog","*.usercontent.goog","blogspot.gr","blogspot.hk","blogspot.hr","blogspot.hu","blogspot.co.id","blogspot.ie","blogspot.co.il","blogspot.in","blogspot.is","blogspot.it","blogspot.jp","blogspot.co.ke","blogspot.kr","blogspot.li","blogspot.lt","blogspot.lu","blogspot.md","blogspot.mk","blogspot.com.mt","blogspot.mx","blogspot.my","cloudfunctions.net","blogspot.com.ng","blogspot.nl","blogspot.no","blogspot.co.nz","blogspot.pe","blogspot.pt","blogspot.qa","blogspot.re","blogspot.ro","blogspot.rs","blogspot.ru","blogspot.se","blogspot.sg","blogspot.si","blogspot.sk","blogspot.sn","blogspot.td","blogspot.com.tr","blogspot.tw","blogspot.ug","blogspot.co.uk","blogspot.com.uy","blogspot.vn","blogspot.co.za","goupile.fr","pymnt.uk","cloudapps.digital","london.cloudapps.digital","gov.nl","grafana-dev.net","grayjayleagues.com","günstigbestellen.de","günstigliefern.de","fin.ci","free.hr","caa.li","ua.rs","conf.se","häkkinen.fi","hrsn.dev","hashbang.sh","hasura.app","hasura-app.io","hatenablog.com","hatenadiary.com","hateblo.jp","hatenablog.jp","hatenadiary.jp","hatenadiary.org","pages.it.hs-heilbronn.de","pages-research.it.hs-heilbronn.de","heiyu.space","helioho.st","heliohost.us","hepforge.org","herokuapp.com","herokussl.com","heyflow.page","heyflow.site","ravendb.cloud","ravendb.community","development.run","ravendb.run","homesklep.pl","*.kin.one","*.id.pub","*.kin.pub","secaas.hk","hoplix.shop","orx.biz","biz.gl","biz.ng","co.biz.ng","dl.biz.ng","go.biz.ng","lg.biz.ng","on.biz.ng","col.ng","firm.ng","gen.ng","ltd.ng","ngo.ng","plc.ng","ie.ua","hostyhosting.io","hf.space","static.hf.space","hypernode.io","iobb.net","co.cz","*.moonscale.io","moonscale.net","gr.com","iki.fi","ibxos.it","iliadboxos.it","smushcdn.com","wphostedmail.com","wpmucdn.com","tempurl.host","wpmudev.host","dyn-berlin.de","in-berlin.de","in-brb.de","in-butter.de","in-dsl.de","in-vpn.de","in-dsl.net","in-vpn.net","in-dsl.org","in-vpn.org","biz.at","info.at","info.cx","ac.leg.br","al.leg.br","am.leg.br","ap.leg.br","ba.leg.br","ce.leg.br","df.leg.br","es.leg.br","go.leg.br","ma.leg.br","mg.leg.br","ms.leg.br","mt.leg.br","pa.leg.br","pb.leg.br","pe.leg.br","pi.leg.br","pr.leg.br","rj.leg.br","rn.leg.br","ro.leg.br","rr.leg.br","rs.leg.br","sc.leg.br","se.leg.br","sp.leg.br","to.leg.br","pixolino.com","na4u.ru","apps-1and1.com","live-website.com","apps-1and1.net","websitebuilder.online","app-ionos.space","iopsys.se","*.dweb.link","ipifony.net","ir.md","is-a-good.dev","is-a.dev","iservschule.de","mein-iserv.de","schulplattform.de","schulserver.de","test-iserv.de","iserv.dev","mel.cloudlets.com.au","cloud.interhostsolutions.be","alp1.ae.flow.ch","appengine.flow.ch","es-1.axarnet.cloud","diadem.cloud","vip.jelastic.cloud","jele.cloud","it1.eur.aruba.jenv-aruba.cloud","it1.jenv-aruba.cloud","keliweb.cloud","cs.keliweb.cloud","oxa.cloud","tn.oxa.cloud","uk.oxa.cloud","primetel.cloud","uk.primetel.cloud","ca.reclaim.cloud","uk.reclaim.cloud","us.reclaim.cloud","ch.trendhosting.cloud","de.trendhosting.cloud","jele.club","dopaas.com","paas.hosted-by-previder.com","rag-cloud.hosteur.com","rag-cloud-ch.hosteur.com","jcloud.ik-server.com","jcloud-ver-jpc.ik-server.com","demo.jelastic.com","paas.massivegrid.com","jed.wafaicloud.com","ryd.wafaicloud.com","j.scaleforce.com.cy","jelastic.dogado.eu","fi.cloudplatform.fi","demo.datacenter.fi","paas.datacenter.fi","jele.host","mircloud.host","paas.beebyte.io","sekd1.beebyteapp.io","jele.io","jc.neen.it","jcloud.kz","cloudjiffy.net","fra1-de.cloudjiffy.net","west1-us.cloudjiffy.net","jls-sto1.elastx.net","jls-sto2.elastx.net","jls-sto3.elastx.net","fr-1.paas.massivegrid.net","lon-1.paas.massivegrid.net","lon-2.paas.massivegrid.net","ny-1.paas.massivegrid.net","ny-2.paas.massivegrid.net","sg-1.paas.massivegrid.net","jelastic.saveincloud.net","nordeste-idc.saveincloud.net","j.scaleforce.net","sdscloud.pl","unicloud.pl","mircloud.ru","enscaled.sg","jele.site","jelastic.team","orangecloud.tn","j.layershift.co.uk","phx.enscaled.us","mircloud.us","myjino.ru","*.hosting.myjino.ru","*.landing.myjino.ru","*.spectrum.myjino.ru","*.vps.myjino.ru","jotelulu.cloud","webadorsite.com","jouwweb.site","*.cns.joyent.com","*.triton.zone","js.org","kaas.gg","khplay.nl","kapsi.fi","ezproxy.kuleuven.be","kuleuven.cloud","keymachine.de","kinghost.net","uni5.net","knightpoint.systems","koobin.events","webthings.io","krellian.net","oya.to","git-repos.de","lcube-server.de","svn-repos.de","leadpages.co","lpages.co","lpusercontent.com","lelux.site","libp2p.direct","runcontainers.dev","co.business","co.education","co.events","co.financial","co.network","co.place","co.technology","linkyard-cloud.ch","linkyard.cloud","members.linode.com","*.nodebalancer.linode.com","*.linodeobjects.com","ip.linodeusercontent.com","we.bs","filegear-sg.me","ggff.net","*.user.localcert.dev","lodz.pl","pabianice.pl","plock.pl","sieradz.pl","skierniewice.pl","zgierz.pl","loginline.app","loginline.dev","loginline.io","loginline.services","loginline.site","lohmus.me","servers.run","krasnik.pl","leczna.pl","lubartow.pl","lublin.pl","poniatowa.pl","swidnik.pl","glug.org.uk","lug.org.uk","lugs.org.uk","barsy.bg","barsy.club","barsycenter.com","barsyonline.com","barsy.de","barsy.dev","barsy.eu","barsy.gr","barsy.in","barsy.info","barsy.io","barsy.me","barsy.menu","barsyonline.menu","barsy.mobi","barsy.net","barsy.online","barsy.org","barsy.pro","barsy.pub","barsy.ro","barsy.rs","barsy.shop","barsyonline.shop","barsy.site","barsy.store","barsy.support","barsy.uk","barsy.co.uk","barsyonline.co.uk","*.magentosite.cloud","hb.cldmail.ru","matlab.cloud","modelscape.com","mwcloudnonprod.com","polyspace.com","mayfirst.info","mayfirst.org","mazeplay.com","mcdir.me","mcdir.ru","vps.mcdir.ru","mcpre.ru","mediatech.by","mediatech.dev","hra.health","medusajs.app","miniserver.com","memset.net","messerli.app","atmeta.com","apps.fbsbx.com","*.cloud.metacentrum.cz","custom.metacentrum.cz","flt.cloud.muni.cz","usr.cloud.muni.cz","meteorapp.com","eu.meteorapp.com","co.pl","*.azurecontainer.io","azure-api.net","azure-mobile.net","azureedge.net","azurefd.net","azurestaticapps.net","1.azurestaticapps.net","2.azurestaticapps.net","3.azurestaticapps.net","4.azurestaticapps.net","5.azurestaticapps.net","6.azurestaticapps.net","7.azurestaticapps.net","centralus.azurestaticapps.net","eastasia.azurestaticapps.net","eastus2.azurestaticapps.net","westeurope.azurestaticapps.net","westus2.azurestaticapps.net","azurewebsites.net","cloudapp.net","trafficmanager.net","blob.core.windows.net","servicebus.windows.net","routingthecloud.com","sn.mynetname.net","routingthecloud.net","routingthecloud.org","csx.cc","mydbserver.com","webspaceconfig.de","mittwald.info","mittwaldserver.info","typo3server.info","project.space","modx.dev","bmoattachments.org","net.ru","org.ru","pp.ru","hostedpi.com","caracal.mythic-beasts.com","customer.mythic-beasts.com","fentiger.mythic-beasts.com","lynx.mythic-beasts.com","ocelot.mythic-beasts.com","oncilla.mythic-beasts.com","onza.mythic-beasts.com","sphinx.mythic-beasts.com","vs.mythic-beasts.com","x.mythic-beasts.com","yali.mythic-beasts.com","cust.retrosnub.co.uk","ui.nabu.casa","cloud.nospamproxy.com","netfy.app","netlify.app","4u.com","nfshost.com","ipfs.nftstorage.link","ngo.us","ngrok.app","ngrok-free.app","ngrok.dev","ngrok-free.dev","ngrok.io","ap.ngrok.io","au.ngrok.io","eu.ngrok.io","in.ngrok.io","jp.ngrok.io","sa.ngrok.io","us.ngrok.io","ngrok.pizza","ngrok.pro","torun.pl","nh-serv.co.uk","nimsite.uk","mmafan.biz","myftp.biz","no-ip.biz","no-ip.ca","fantasyleague.cc","gotdns.ch","3utilities.com","blogsyte.com","ciscofreak.com","damnserver.com","ddnsking.com","ditchyourip.com","dnsiskinky.com","dynns.com","geekgalaxy.com","health-carereform.com","homesecuritymac.com","homesecuritypc.com","myactivedirectory.com","mysecuritycamera.com","myvnc.com","net-freaks.com","onthewifi.com","point2this.com","quicksytes.com","securitytactics.com","servebeer.com","servecounterstrike.com","serveexchange.com","serveftp.com","servegame.com","servehalflife.com","servehttp.com","servehumour.com","serveirc.com","servemp3.com","servep2p.com","servepics.com","servequake.com","servesarcasm.com","stufftoread.com","unusualperson.com","workisboring.com","dvrcam.info","ilovecollege.info","no-ip.info","brasilia.me","ddns.me","dnsfor.me","hopto.me","loginto.me","noip.me","webhop.me","bounceme.net","ddns.net","eating-organic.net","mydissent.net","myeffect.net","mymediapc.net","mypsx.net","mysecuritycamera.net","nhlfan.net","no-ip.net","pgafan.net","privatizehealthinsurance.net","redirectme.net","serveblog.net","serveminecraft.net","sytes.net","cable-modem.org","collegefan.org","couchpotatofries.org","hopto.org","mlbfan.org","myftp.org","mysecuritycamera.org","nflfan.org","no-ip.org","read-books.org","ufcfan.org","zapto.org","no-ip.co.uk","golffan.us","noip.us","pointto.us","stage.nodeart.io","*.developer.app","noop.app","*.northflank.app","*.build.run","*.code.run","*.database.run","*.migration.run","noticeable.news","notion.site","dnsking.ch","mypi.co","n4t.co","001www.com","myiphost.com","forumz.info","soundcast.me","tcp4.me","dnsup.net","hicam.net","now-dns.net","ownip.net","vpndns.net","dynserv.org","now-dns.org","x443.pw","now-dns.top","ntdll.top","freeddns.us","nsupdate.info","nerdpol.ovh","nyc.mn","prvcy.page","obl.ong","observablehq.cloud","static.observableusercontent.com","omg.lol","cloudycluster.net","omniwe.site","123webseite.at","123website.be","simplesite.com.br","123website.ch","simplesite.com","123webseite.de","123hjemmeside.dk","123miweb.es","123kotisivu.fi","123siteweb.fr","simplesite.gr","123homepage.it","123website.lu","123website.nl","123hjemmeside.no","service.one","simplesite.pl","123paginaweb.pt","123minsida.se","is-a-fullstack.dev","is-cool.dev","is-not-a.dev","localplayer.dev","is-local.org","opensocial.site","opencraft.hosting","16-b.it","32-b.it","64-b.it","orsites.com","operaunite.com","*.customer-oci.com","*.oci.customer-oci.com","*.ocp.customer-oci.com","*.ocs.customer-oci.com","*.oraclecloudapps.com","*.oraclegovcloudapps.com","*.oraclegovcloudapps.uk","tech.orange","can.re","authgear-staging.com","authgearapps.com","skygearapp.com","outsystemscloud.com","*.hosting.ovh.net","*.webpaas.ovh.net","ownprovider.com","own.pm","*.owo.codes","ox.rs","oy.lc","pgfog.com","pagexl.com","gotpantheon.com","pantheonsite.io","*.paywhirl.com","*.xmit.co","xmit.dev","madethis.site","srv.us","gh.srv.us","gl.srv.us","lk3.ru","mypep.link","perspecta.cloud","on-web.fr","*.upsun.app","upsunapp.com","ent.platform.sh","eu.platform.sh","us.platform.sh","*.platformsh.site","*.tst.site","platter-app.com","platter-app.dev","platterp.us","pley.games","onporter.run","co.bn","postman-echo.com","pstmn.io","mock.pstmn.io","httpbin.org","prequalifyme.today","xen.prgmr.com","priv.at","protonet.io","chirurgiens-dentistes-en-france.fr","byen.site","pubtls.org","pythonanywhere.com","eu.pythonanywhere.com","qa2.com","qcx.io","*.sys.qcx.io","myqnapcloud.cn","alpha-myqnapcloud.com","dev-myqnapcloud.com","mycloudnas.com","mynascloud.com","myqnapcloud.com","qoto.io","qualifioapp.com","ladesk.com","qbuser.com","*.quipelements.com","vapor.cloud","vaporcloud.io","rackmaze.com","rackmaze.net","cloudsite.builders","myradweb.net","servername.us","web.in","in.net","myrdbx.io","site.rb-hosting.io","*.on-rancher.cloud","*.on-k3s.io","*.on-rio.io","ravpage.co.il","readthedocs-hosted.com","readthedocs.io","rhcloud.com","instances.spawn.cc","onrender.com","app.render.com","replit.app","id.replit.app","firewalledreplit.co","id.firewalledreplit.co","repl.co","id.repl.co","replit.dev","archer.replit.dev","bones.replit.dev","canary.replit.dev","global.replit.dev","hacker.replit.dev","id.replit.dev","janeway.replit.dev","kim.replit.dev","kira.replit.dev","kirk.replit.dev","odo.replit.dev","paris.replit.dev","picard.replit.dev","pike.replit.dev","prerelease.replit.dev","reed.replit.dev","riker.replit.dev","sisko.replit.dev","spock.replit.dev","staging.replit.dev","sulu.replit.dev","tarpit.replit.dev","teams.replit.dev","tucker.replit.dev","wesley.replit.dev","worf.replit.dev","repl.run","resindevice.io","devices.resinstaging.io","hzc.io","adimo.co.uk","itcouldbewor.se","aus.basketball","nz.basketball","git-pages.rit.edu","rocky.page","rub.de","ruhr-uni-bochum.de","io.noc.ruhr-uni-bochum.de","биз.рус","ком.рус","крым.рус","мир.рус","мск.рус","орг.рус","самара.рус","сочи.рус","спб.рус","я.рус","ras.ru","nyat.app","180r.com","dojin.com","sakuratan.com","sakuraweb.com","x0.com","2-d.jp","bona.jp","crap.jp","daynight.jp","eek.jp","flop.jp","halfmoon.jp","jeez.jp","matrix.jp","mimoza.jp","ivory.ne.jp","mail-box.ne.jp","mints.ne.jp","mokuren.ne.jp","opal.ne.jp","sakura.ne.jp","sumomo.ne.jp","topaz.ne.jp","netgamers.jp","nyanta.jp","o0o0.jp","rdy.jp","rgr.jp","rulez.jp","s3.isk01.sakurastorage.jp","s3.isk02.sakurastorage.jp","saloon.jp","sblo.jp","skr.jp","tank.jp","uh-oh.jp","undo.jp","rs.webaccel.jp","user.webaccel.jp","websozai.jp","xii.jp","squares.net","jpn.org","kirara.st","x0.to","from.tv","sakura.tv","*.builder.code.com","*.dev-builder.code.com","*.stg-builder.code.com","*.001.test.code-builder-stg.platform.salesforce.com","*.d.crm.dev","*.w.crm.dev","*.wa.crm.dev","*.wb.crm.dev","*.wc.crm.dev","*.wd.crm.dev","*.we.crm.dev","*.wf.crm.dev","sandcats.io","logoip.com","logoip.de","fr-par-1.baremetal.scw.cloud","fr-par-2.baremetal.scw.cloud","nl-ams-1.baremetal.scw.cloud","cockpit.fr-par.scw.cloud","fnc.fr-par.scw.cloud","functions.fnc.fr-par.scw.cloud","k8s.fr-par.scw.cloud","nodes.k8s.fr-par.scw.cloud","s3.fr-par.scw.cloud","s3-website.fr-par.scw.cloud","whm.fr-par.scw.cloud","priv.instances.scw.cloud","pub.instances.scw.cloud","k8s.scw.cloud","cockpit.nl-ams.scw.cloud","k8s.nl-ams.scw.cloud","nodes.k8s.nl-ams.scw.cloud","s3.nl-ams.scw.cloud","s3-website.nl-ams.scw.cloud","whm.nl-ams.scw.cloud","cockpit.pl-waw.scw.cloud","k8s.pl-waw.scw.cloud","nodes.k8s.pl-waw.scw.cloud","s3.pl-waw.scw.cloud","s3-website.pl-waw.scw.cloud","scalebook.scw.cloud","smartlabeling.scw.cloud","dedibox.fr","schokokeks.net","gov.scot","service.gov.scot","scrysec.com","client.scrypted.io","firewall-gateway.com","firewall-gateway.de","my-gateway.de","my-router.de","spdns.de","spdns.eu","firewall-gateway.net","my-firewall.org","myfirewall.org","spdns.org","seidat.net","sellfy.store","minisite.ms","senseering.net","servebolt.cloud","biz.ua","co.ua","pp.ua","as.sh.cn","sheezy.games","shiftedit.io","myshopblocks.com","myshopify.com","shopitsite.com","shopware.shop","shopware.store","mo-siemens.io","1kapp.com","appchizi.com","applinzi.com","sinaapp.com","vipsinaapp.com","siteleaf.net","small-web.org","aeroport.fr","avocat.fr","chambagri.fr","chirurgiens-dentistes.fr","experts-comptables.fr","medecin.fr","notaires.fr","pharmacien.fr","port.fr","veterinaire.fr","vp4.me","*.snowflake.app","*.privatelink.snowflake.app","streamlit.app","streamlitapp.com","try-snowplow.com","mafelo.net","playstation-cloud.com","srht.site","apps.lair.io","*.stolos.io","spacekit.io","ind.mom","customer.speedpartner.de","myspreadshop.at","myspreadshop.com.au","myspreadshop.be","myspreadshop.ca","myspreadshop.ch","myspreadshop.com","myspreadshop.de","myspreadshop.dk","myspreadshop.es","myspreadshop.fi","myspreadshop.fr","myspreadshop.ie","myspreadshop.it","myspreadshop.net","myspreadshop.nl","myspreadshop.no","myspreadshop.pl","myspreadshop.se","myspreadshop.co.uk","w-corp-staticblitz.com","w-credentialless-staticblitz.com","w-staticblitz.com","stackhero-network.com","runs.onstackit.cloud","stackit.gg","stackit.rocks","stackit.run","stackit.zone","musician.io","novecore.site","api.stdlib.com","feedback.ac","forms.ac","assessments.cx","calculators.cx","funnels.cx","paynow.cx","quizzes.cx","researched.cx","tests.cx","surveys.so","storebase.store","storipress.app","storj.farm","strapiapp.com","media.strapiapp.com","vps-host.net","atl.jelastic.vps-host.net","njs.jelastic.vps-host.net","ric.jelastic.vps-host.net","streak-link.com","streaklinks.com","streakusercontent.com","soc.srcf.net","user.srcf.net","utwente.io","temp-dns.com","supabase.co","supabase.in","supabase.net","syncloud.it","dscloud.biz","direct.quickconnect.cn","dsmynas.com","familyds.com","diskstation.me","dscloud.me","i234.me","myds.me","synology.me","dscloud.mobi","dsmynas.net","familyds.net","dsmynas.org","familyds.org","direct.quickconnect.to","vpnplus.to","mytabit.com","mytabit.co.il","tabitorder.co.il","taifun-dns.de","ts.net","*.c.ts.net","gda.pl","gdansk.pl","gdynia.pl","med.pl","sopot.pl","taveusercontent.com","p.tawk.email","p.tawkto.email","site.tb-hosting.com","edugit.io","s3.teckids.org","telebit.app","telebit.io","*.telebit.xyz","*.firenet.ch","*.svc.firenet.ch","reservd.com","thingdustdata.com","cust.dev.thingdust.io","reservd.dev.thingdust.io","cust.disrec.thingdust.io","reservd.disrec.thingdust.io","cust.prod.thingdust.io","cust.testing.thingdust.io","reservd.testing.thingdust.io","tickets.io","arvo.network","azimuth.network","tlon.network","torproject.net","pages.torproject.net","townnews-staging.com","12hp.at","2ix.at","4lima.at","lima-city.at","12hp.ch","2ix.ch","4lima.ch","lima-city.ch","trafficplex.cloud","de.cool","12hp.de","2ix.de","4lima.de","lima-city.de","1337.pictures","clan.rip","lima-city.rocks","webspace.rocks","lima.zone","*.transurl.be","*.transurl.eu","site.transip.me","*.transurl.nl","tuxfamily.org","dd-dns.de","dray-dns.de","draydns.de","dyn-vpn.de","dynvpn.de","mein-vigor.de","my-vigor.de","my-wan.de","syno-ds.de","synology-diskstation.de","synology-ds.de","diskstation.eu","diskstation.org","typedream.app","pro.typeform.com","*.uberspace.de","uber.space","hk.com","inc.hk","ltd.hk","hk.org","it.com","unison-services.cloud","virtual-user.de","virtualuser.de","name.pm","sch.tf","biz.wf","sch.wf","org.yt","rs.ba","bielsko.pl","upli.io","urown.cloud","dnsupdate.info","us.org","v.ua","express.val.run","web.val.run","vercel.app","v0.build","vercel.dev","vusercontent.net","now.sh","2038.io","router.management","v-info.info","voorloper.cloud","*.vultrobjects.com","wafflecell.com","webflow.io","webflowtest.io","*.webhare.dev","bookonline.app","hotelwithflight.com","reserve-online.com","reserve-online.net","cprapid.com","pleskns.com","wp2.host","pdns.page","plesk.page","wpsquared.site","*.wadl.top","remotewd.com","box.ca","pages.wiardweb.com","toolforge.org","wmcloud.org","wmflabs.org","wdh.app","panel.gg","daemon.panel.gg","wixsite.com","wixstudio.com","editorx.io","wixstudio.io","wix.run","messwithdns.com","woltlab-demo.com","myforum.community","community-pro.de","diskussionsbereich.de","community-pro.net","meinforum.net","affinitylottery.org.uk","raffleentry.org.uk","weeklylottery.org.uk","wpenginepowered.com","js.wpenginepowered.com","half.host","xnbay.com","u2.xnbay.com","u2-local.xnbay.com","cistron.nl","demon.nl","xs4all.space","yandexcloud.net","storage.yandexcloud.net","website.yandexcloud.net","official.academy","yolasite.com","yombo.me","ynh.fr","nohost.me","noho.st","za.net","za.org","zap.cloud","zeabur.app","bss.design","basicserver.io","virtualserver.io","enterprisecloud.nu"],Z=Y.reduce((e,s)=>{const c=s.replace(/^(\*\.|\!)/,""),o=A.toASCII(c),t=s.charAt(0);if(e.has(o))throw new Error(`Multiple rules found for ${s} (${o})`);return e.set(o,{rule:s,suffix:c,punySuffix:o,wildcard:t==="*",exception:t==="!"}),e},new Map),aa=e=>{const c=A.toASCII(e).split(".");for(let o=0;o<c.length;o++){const t=c.slice(o).join("."),d=Z.get(t);if(d)return d}return null},H={DOMAIN_TOO_SHORT:"Domain name too short.",DOMAIN_TOO_LONG:"Domain name too long. It should be no more than 255 chars.",LABEL_STARTS_WITH_DASH:"Domain name label can not start with a dash.",LABEL_ENDS_WITH_DASH:"Domain name label can not end with a dash.",LABEL_TOO_LONG:"Domain name label should be at most 63 chars long.",LABEL_TOO_SHORT:"Domain name label should be at least 1 character long.",LABEL_INVALID_CHARS:"Domain name label can only contain alphanumeric characters or dashes."},oa=e=>{const s=A.toASCII(e);if(s.length<1)return "DOMAIN_TOO_SHORT";if(s.length>255)return "DOMAIN_TOO_LONG";const c=s.split(".");let o;for(let t=0;t<c.length;++t){if(o=c[t],!o.length)return "LABEL_TOO_SHORT";if(o.length>63)return "LABEL_TOO_LONG";if(o.charAt(0)==="-")return "LABEL_STARTS_WITH_DASH";if(o.charAt(o.length-1)==="-")return "LABEL_ENDS_WITH_DASH";if(!/^[a-z0-9\-_]+$/.test(o))return "LABEL_INVALID_CHARS"}},_=e=>{if(typeof e!="string")throw new TypeError("Domain name must be a string.");let s=e.slice(0).toLowerCase();s.charAt(s.length-1)==="."&&(s=s.slice(0,s.length-1));const c=oa(s);if(c)return {input:e,error:{message:H[c],code:c}};const o={input:e,tld:null,sld:null,domain:null,subdomain:null,listed:false},t=s.split(".");if(t[t.length-1]==="local")return o;const d=()=>(/xn--/.test(s)&&(o.domain&&(o.domain=A.toASCII(o.domain)),o.subdomain&&(o.subdomain=A.toASCII(o.subdomain))),o),z=aa(s);if(!z)return t.length<2?o:(o.tld=t.pop(),o.sld=t.pop(),o.domain=[o.sld,o.tld].join("."),t.length&&(o.subdomain=t.pop()),d());o.listed=true;const y=z.suffix.split("."),g=t.slice(0,t.length-y.length);return z.exception&&g.push(y.shift()),o.tld=y.join("."),!g.length||(z.wildcard&&(y.unshift(g.pop()),o.tld=y.join(".")),!g.length)||(o.sld=g.pop(),o.domain=[o.sld,o.tld].join("."),g.length&&(o.subdomain=g.join("."))),d()},N=e=>e&&_(e).domain||null,R=e=>{const s=_(e);return !!(s.domain&&s.listed)},sa={parse:_,get:N,isValid:R};exports.default=sa;exports.errorCodes=H;exports.get=N;exports.isValid=R;exports.parse=_; 
    	} (psl));
    	return psl;
    }

    /*!
     * Copyright (c) 2018, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */

    var hasRequiredPubsuffixPsl;

    function requirePubsuffixPsl () {
    	if (hasRequiredPubsuffixPsl) return pubsuffixPsl;
    	hasRequiredPubsuffixPsl = 1;
    	const psl = requirePsl();

    	// RFC 6761
    	const SPECIAL_USE_DOMAINS = [
    	  "local",
    	  "example",
    	  "invalid",
    	  "localhost",
    	  "test"
    	];

    	const SPECIAL_TREATMENT_DOMAINS = ["localhost", "invalid"];

    	function getPublicSuffix(domain, options = {}) {
    	  const domainParts = domain.split(".");
    	  const topLevelDomain = domainParts[domainParts.length - 1];
    	  const allowSpecialUseDomain = !!options.allowSpecialUseDomain;
    	  const ignoreError = !!options.ignoreError;

    	  if (allowSpecialUseDomain && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
    	    if (domainParts.length > 1) {
    	      const secondLevelDomain = domainParts[domainParts.length - 2];
    	      // In aforementioned example, the eTLD/pubSuf will be apple.localhost
    	      return `${secondLevelDomain}.${topLevelDomain}`;
    	    } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {
    	      // For a single word special use domain, e.g. 'localhost' or 'invalid', per RFC 6761,
    	      // "Application software MAY recognize {localhost/invalid} names as special, or
    	      // MAY pass them to name resolution APIs as they would for other domain names."
    	      return `${topLevelDomain}`;
    	    }
    	  }

    	  if (!ignoreError && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
    	    throw new Error(
    	      `Cookie has domain set to the public suffix "${topLevelDomain}" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain:true, rejectPublicSuffixes: false}.`
    	    );
    	  }

    	  return psl.get(domain);
    	}

    	pubsuffixPsl.getPublicSuffix = getPublicSuffix;
    	return pubsuffixPsl;
    }

    var store = {};

    /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */

    var hasRequiredStore;

    function requireStore () {
    	if (hasRequiredStore) return store;
    	hasRequiredStore = 1;
    	/*jshint unused:false */

    	class Store {
    	  constructor() {
    	    this.synchronous = false;
    	  }

    	  findCookie(domain, path, key, cb) {
    	    throw new Error("findCookie is not implemented");
    	  }

    	  findCookies(domain, path, allowSpecialUseDomain, cb) {
    	    throw new Error("findCookies is not implemented");
    	  }

    	  putCookie(cookie, cb) {
    	    throw new Error("putCookie is not implemented");
    	  }

    	  updateCookie(oldCookie, newCookie, cb) {
    	    // recommended default implementation:
    	    // return this.putCookie(newCookie, cb);
    	    throw new Error("updateCookie is not implemented");
    	  }

    	  removeCookie(domain, path, key, cb) {
    	    throw new Error("removeCookie is not implemented");
    	  }

    	  removeCookies(domain, path, cb) {
    	    throw new Error("removeCookies is not implemented");
    	  }

    	  removeAllCookies(cb) {
    	    throw new Error("removeAllCookies is not implemented");
    	  }

    	  getAllCookies(cb) {
    	    throw new Error(
    	      "getAllCookies is not implemented (therefore jar cannot be serialized)"
    	    );
    	  }
    	}

    	store.Store = Store;
    	return store;
    }

    var memstore = {};

    var universalify = {};

    var hasRequiredUniversalify;

    function requireUniversalify () {
    	if (hasRequiredUniversalify) return universalify;
    	hasRequiredUniversalify = 1;

    	universalify.fromCallback = function (fn) {
    	  return Object.defineProperty(function () {
    	    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments);
    	    else {
    	      return new Promise((resolve, reject) => {
    	        arguments[arguments.length] = (err, res) => {
    	          if (err) return reject(err)
    	          resolve(res);
    	        };
    	        arguments.length++;
    	        fn.apply(this, arguments);
    	      })
    	    }
    	  }, 'name', { value: fn.name })
    	};

    	universalify.fromPromise = function (fn) {
    	  return Object.defineProperty(function () {
    	    const cb = arguments[arguments.length - 1];
    	    if (typeof cb !== 'function') return fn.apply(this, arguments)
    	    else {
    	      delete arguments[arguments.length - 1];
    	      arguments.length--;
    	      fn.apply(this, arguments).then(r => cb(null, r), cb);
    	    }
    	  }, 'name', { value: fn.name })
    	};
    	return universalify;
    }

    var permuteDomain = {};

    /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */

    var hasRequiredPermuteDomain;

    function requirePermuteDomain () {
    	if (hasRequiredPermuteDomain) return permuteDomain;
    	hasRequiredPermuteDomain = 1;
    	const pubsuffix = requirePubsuffixPsl();

    	// Gives the permutation of all possible domainMatch()es of a given domain. The
    	// array is in shortest-to-longest order.  Handy for indexing.

    	function permuteDomain$1(domain, allowSpecialUseDomain) {
    	  const pubSuf = pubsuffix.getPublicSuffix(domain, {
    	    allowSpecialUseDomain: allowSpecialUseDomain
    	  });

    	  if (!pubSuf) {
    	    return null;
    	  }
    	  if (pubSuf == domain) {
    	    return [domain];
    	  }

    	  // Nuke trailing dot
    	  if (domain.slice(-1) == ".") {
    	    domain = domain.slice(0, -1);
    	  }

    	  const prefix = domain.slice(0, -(pubSuf.length + 1)); // ".example.com"
    	  const parts = prefix.split(".").reverse();
    	  let cur = pubSuf;
    	  const permutations = [cur];
    	  while (parts.length) {
    	    cur = `${parts.shift()}.${cur}`;
    	    permutations.push(cur);
    	  }
    	  return permutations;
    	}

    	permuteDomain.permuteDomain = permuteDomain$1;
    	return permuteDomain;
    }

    var pathMatch = {};

    /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */

    var hasRequiredPathMatch;

    function requirePathMatch () {
    	if (hasRequiredPathMatch) return pathMatch;
    	hasRequiredPathMatch = 1;
    	/*
    	 * "A request-path path-matches a given cookie-path if at least one of the
    	 * following conditions holds:"
    	 */
    	function pathMatch$1(reqPath, cookiePath) {
    	  // "o  The cookie-path and the request-path are identical."
    	  if (cookiePath === reqPath) {
    	    return true;
    	  }

    	  const idx = reqPath.indexOf(cookiePath);
    	  if (idx === 0) {
    	    // "o  The cookie-path is a prefix of the request-path, and the last
    	    // character of the cookie-path is %x2F ("/")."
    	    if (cookiePath.substr(-1) === "/") {
    	      return true;
    	    }

    	    // " o  The cookie-path is a prefix of the request-path, and the first
    	    // character of the request-path that is not included in the cookie- path
    	    // is a %x2F ("/") character."
    	    if (reqPath.substr(cookiePath.length, 1) === "/") {
    	      return true;
    	    }
    	  }

    	  return false;
    	}

    	pathMatch.pathMatch = pathMatch$1;
    	return pathMatch;
    }

    var utilHelper = {};

    var hasRequiredUtilHelper;

    function requireUtilHelper () {
    	if (hasRequiredUtilHelper) return utilHelper;
    	hasRequiredUtilHelper = 1;
    	function requireUtil() {
    	  try {
    	    // eslint-disable-next-line no-restricted-modules
    	    return require("util");
    	  } catch (e) {
    	    return null;
    	  }
    	}

    	// for v10.12.0+
    	function lookupCustomInspectSymbol() {
    	  return Symbol.for("nodejs.util.inspect.custom");
    	}

    	// for older node environments
    	function tryReadingCustomSymbolFromUtilInspect(options) {
    	  const _requireUtil = options.requireUtil || requireUtil;
    	  const util = _requireUtil();
    	  return util ? util.inspect.custom : null;
    	}

    	utilHelper.getUtilInspect = function getUtilInspect(fallback, options = {}) {
    	  const _requireUtil = options.requireUtil || requireUtil;
    	  const util = _requireUtil();
    	  return function inspect(value, showHidden, depth) {
    	    return util ? util.inspect(value, showHidden, depth) : fallback(value);
    	  };
    	};

    	utilHelper.getCustomInspectSymbol = function getCustomInspectSymbol(options = {}) {
    	  const _lookupCustomInspectSymbol =
    	    options.lookupCustomInspectSymbol || lookupCustomInspectSymbol;

    	  // get custom inspect symbol for node environments
    	  return (
    	    _lookupCustomInspectSymbol() ||
    	    tryReadingCustomSymbolFromUtilInspect(options)
    	  );
    	};
    	return utilHelper;
    }

    /*!
     * Copyright (c) 2015, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */

    var hasRequiredMemstore;

    function requireMemstore () {
    	if (hasRequiredMemstore) return memstore;
    	hasRequiredMemstore = 1;
    	const { fromCallback } = requireUniversalify();
    	const Store = requireStore().Store;
    	const permuteDomain = requirePermuteDomain().permuteDomain;
    	const pathMatch = requirePathMatch().pathMatch;
    	const { getCustomInspectSymbol, getUtilInspect } = requireUtilHelper();

    	class MemoryCookieStore extends Store {
    	  constructor() {
    	    super();
    	    this.synchronous = true;
    	    this.idx = Object.create(null);
    	    const customInspectSymbol = getCustomInspectSymbol();
    	    if (customInspectSymbol) {
    	      this[customInspectSymbol] = this.inspect;
    	    }
    	  }

    	  inspect() {
    	    const util = { inspect: getUtilInspect(inspectFallback) };
    	    return `{ idx: ${util.inspect(this.idx, false, 2)} }`;
    	  }

    	  findCookie(domain, path, key, cb) {
    	    if (!this.idx[domain]) {
    	      return cb(null, undefined);
    	    }
    	    if (!this.idx[domain][path]) {
    	      return cb(null, undefined);
    	    }
    	    return cb(null, this.idx[domain][path][key] || null);
    	  }
    	  findCookies(domain, path, allowSpecialUseDomain, cb) {
    	    const results = [];
    	    if (typeof allowSpecialUseDomain === "function") {
    	      cb = allowSpecialUseDomain;
    	      allowSpecialUseDomain = true;
    	    }
    	    if (!domain) {
    	      return cb(null, []);
    	    }

    	    let pathMatcher;
    	    if (!path) {
    	      // null means "all paths"
    	      pathMatcher = function matchAll(domainIndex) {
    	        for (const curPath in domainIndex) {
    	          const pathIndex = domainIndex[curPath];
    	          for (const key in pathIndex) {
    	            results.push(pathIndex[key]);
    	          }
    	        }
    	      };
    	    } else {
    	      pathMatcher = function matchRFC(domainIndex) {
    	        //NOTE: we should use path-match algorithm from S5.1.4 here
    	        //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)
    	        Object.keys(domainIndex).forEach(cookiePath => {
    	          if (pathMatch(path, cookiePath)) {
    	            const pathIndex = domainIndex[cookiePath];
    	            for (const key in pathIndex) {
    	              results.push(pathIndex[key]);
    	            }
    	          }
    	        });
    	      };
    	    }

    	    const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];
    	    const idx = this.idx;
    	    domains.forEach(curDomain => {
    	      const domainIndex = idx[curDomain];
    	      if (!domainIndex) {
    	        return;
    	      }
    	      pathMatcher(domainIndex);
    	    });

    	    cb(null, results);
    	  }

    	  putCookie(cookie, cb) {
    	    if (!this.idx[cookie.domain]) {
    	      this.idx[cookie.domain] = Object.create(null);
    	    }
    	    if (!this.idx[cookie.domain][cookie.path]) {
    	      this.idx[cookie.domain][cookie.path] = Object.create(null);
    	    }
    	    this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
    	    cb(null);
    	  }
    	  updateCookie(oldCookie, newCookie, cb) {
    	    // updateCookie() may avoid updating cookies that are identical.  For example,
    	    // lastAccessed may not be important to some stores and an equality
    	    // comparison could exclude that field.
    	    this.putCookie(newCookie, cb);
    	  }
    	  removeCookie(domain, path, key, cb) {
    	    if (
    	      this.idx[domain] &&
    	      this.idx[domain][path] &&
    	      this.idx[domain][path][key]
    	    ) {
    	      delete this.idx[domain][path][key];
    	    }
    	    cb(null);
    	  }
    	  removeCookies(domain, path, cb) {
    	    if (this.idx[domain]) {
    	      if (path) {
    	        delete this.idx[domain][path];
    	      } else {
    	        delete this.idx[domain];
    	      }
    	    }
    	    return cb(null);
    	  }
    	  removeAllCookies(cb) {
    	    this.idx = Object.create(null);
    	    return cb(null);
    	  }
    	  getAllCookies(cb) {
    	    const cookies = [];
    	    const idx = this.idx;

    	    const domains = Object.keys(idx);
    	    domains.forEach(domain => {
    	      const paths = Object.keys(idx[domain]);
    	      paths.forEach(path => {
    	        const keys = Object.keys(idx[domain][path]);
    	        keys.forEach(key => {
    	          if (key !== null) {
    	            cookies.push(idx[domain][path][key]);
    	          }
    	        });
    	      });
    	    });

    	    // Sort by creationIndex so deserializing retains the creation order.
    	    // When implementing your own store, this SHOULD retain the order too
    	    cookies.sort((a, b) => {
    	      return (a.creationIndex || 0) - (b.creationIndex || 0);
    	    });

    	    cb(null, cookies);
    	  }
    	}

    	[
    	  "findCookie",
    	  "findCookies",
    	  "putCookie",
    	  "updateCookie",
    	  "removeCookie",
    	  "removeCookies",
    	  "removeAllCookies",
    	  "getAllCookies"
    	].forEach(name => {
    	  MemoryCookieStore.prototype[name] = fromCallback(
    	    MemoryCookieStore.prototype[name]
    	  );
    	});

    	memstore.MemoryCookieStore = MemoryCookieStore;

    	function inspectFallback(val) {
    	  const domains = Object.keys(val);
    	  if (domains.length === 0) {
    	    return "[Object: null prototype] {}";
    	  }
    	  let result = "[Object: null prototype] {\n";
    	  Object.keys(val).forEach((domain, i) => {
    	    result += formatDomain(domain, val[domain]);
    	    if (i < domains.length - 1) {
    	      result += ",";
    	    }
    	    result += "\n";
    	  });
    	  result += "}";
    	  return result;
    	}

    	function formatDomain(domainName, domainValue) {
    	  const indent = "  ";
    	  let result = `${indent}'${domainName}': [Object: null prototype] {\n`;
    	  Object.keys(domainValue).forEach((path, i, paths) => {
    	    result += formatPath(path, domainValue[path]);
    	    if (i < paths.length - 1) {
    	      result += ",";
    	    }
    	    result += "\n";
    	  });
    	  result += `${indent}}`;
    	  return result;
    	}

    	function formatPath(pathName, pathValue) {
    	  const indent = "    ";
    	  let result = `${indent}'${pathName}': [Object: null prototype] {\n`;
    	  Object.keys(pathValue).forEach((cookieName, i, cookieNames) => {
    	    const cookie = pathValue[cookieName];
    	    result += `      ${cookieName}: ${cookie.inspect()}`;
    	    if (i < cookieNames.length - 1) {
    	      result += ",";
    	    }
    	    result += "\n";
    	  });
    	  result += `${indent}}`;
    	  return result;
    	}

    	memstore.inspectFallback = inspectFallback;
    	return memstore;
    }

    var validators = {};

    /* ************************************************************************************
    Extracted from check-types.js
    https://gitlab.com/philbooth/check-types.js

    MIT License

    Copyright (c) 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019 Phil Booth

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

    ************************************************************************************ */

    var hasRequiredValidators;

    function requireValidators () {
    	if (hasRequiredValidators) return validators;
    	hasRequiredValidators = 1;

    	/* Validation functions copied from check-types package - https://www.npmjs.com/package/check-types */

    	const toString = Object.prototype.toString;

    	function isFunction(data) {
    	  return typeof data === "function";
    	}

    	function isNonEmptyString(data) {
    	  return isString(data) && data !== "";
    	}

    	function isDate(data) {
    	  return isInstanceStrict(data, Date) && isInteger(data.getTime());
    	}

    	function isEmptyString(data) {
    	  return data === "" || (data instanceof String && data.toString() === "");
    	}

    	function isString(data) {
    	  return typeof data === "string" || data instanceof String;
    	}

    	function isObject(data) {
    	  return toString.call(data) === "[object Object]";
    	}
    	function isInstanceStrict(data, prototype) {
    	  try {
    	    return data instanceof prototype;
    	  } catch (error) {
    	    return false;
    	  }
    	}

    	function isUrlStringOrObject(data) {
    	  return (
    	    isNonEmptyString(data) ||
    	    (isObject(data) &&
    	      "hostname" in data &&
    	      "pathname" in data &&
    	      "protocol" in data) ||
    	    isInstanceStrict(data, URL)
    	  );
    	}

    	function isInteger(data) {
    	  return typeof data === "number" && data % 1 === 0;
    	}
    	/* End validation functions */

    	function validate(bool, cb, options) {
    	  if (!isFunction(cb)) {
    	    options = cb;
    	    cb = null;
    	  }
    	  if (!isObject(options)) options = { Error: "Failed Check" };
    	  if (!bool) {
    	    if (cb) {
    	      cb(new ParameterError(options));
    	    } else {
    	      throw new ParameterError(options);
    	    }
    	  }
    	}

    	class ParameterError extends Error {
    	  constructor(...params) {
    	    super(...params);
    	  }
    	}

    	validators.ParameterError = ParameterError;
    	validators.isFunction = isFunction;
    	validators.isNonEmptyString = isNonEmptyString;
    	validators.isDate = isDate;
    	validators.isEmptyString = isEmptyString;
    	validators.isString = isString;
    	validators.isObject = isObject;
    	validators.isUrlStringOrObject = isUrlStringOrObject;
    	validators.validate = validate;
    	return validators;
    }

    var version;
    var hasRequiredVersion;

    function requireVersion () {
    	if (hasRequiredVersion) return version;
    	hasRequiredVersion = 1;
    	// generated by genversion
    	version = '4.1.4';
    	return version;
    }

    /*!
     * Copyright (c) 2015-2020, Salesforce.com, Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     * this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     * this list of conditions and the following disclaimer in the documentation
     * and/or other materials provided with the distribution.
     *
     * 3. Neither the name of Salesforce.com nor the names of its contributors may
     * be used to endorse or promote products derived from this software without
     * specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     */

    var hasRequiredCookie;

    function requireCookie () {
    	if (hasRequiredCookie) return cookie;
    	hasRequiredCookie = 1;
    	const punycode = require$$0;
    	const urlParse = requireUrlParse();
    	const pubsuffix = requirePubsuffixPsl();
    	const Store = requireStore().Store;
    	const MemoryCookieStore = requireMemstore().MemoryCookieStore;
    	const pathMatch = requirePathMatch().pathMatch;
    	const validators = requireValidators();
    	const VERSION = requireVersion();
    	const { fromCallback } = requireUniversalify();
    	const { getCustomInspectSymbol } = requireUtilHelper();

    	// From RFC6265 S4.1.1
    	// note that it excludes \x3B ";"
    	const COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;

    	const CONTROL_CHARS = /[\x00-\x1F]/;

    	// From Chromium // '\r', '\n' and '\0' should be treated as a terminator in
    	// the "relaxed" mode, see:
    	// https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60
    	const TERMINATORS = ["\n", "\r", "\0"];

    	// RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or ";"'
    	// Note ';' is \x3B
    	const PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;

    	// date-time parsing constants (RFC6265 S5.1.1)

    	const DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;

    	const MONTH_TO_NUM = {
    	  jan: 0,
    	  feb: 1,
    	  mar: 2,
    	  apr: 3,
    	  may: 4,
    	  jun: 5,
    	  jul: 6,
    	  aug: 7,
    	  sep: 8,
    	  oct: 9,
    	  nov: 10,
    	  dec: 11
    	};

    	const MAX_TIME = 2147483647000; // 31-bit max
    	const MIN_TIME = 0; // 31-bit min
    	const SAME_SITE_CONTEXT_VAL_ERR =
    	  'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';

    	function checkSameSiteContext(value) {
    	  validators.validate(validators.isNonEmptyString(value), value);
    	  const context = String(value).toLowerCase();
    	  if (context === "none" || context === "lax" || context === "strict") {
    	    return context;
    	  } else {
    	    return null;
    	  }
    	}

    	const PrefixSecurityEnum = Object.freeze({
    	  SILENT: "silent",
    	  STRICT: "strict",
    	  DISABLED: "unsafe-disabled"
    	});

    	// Dumped from ip-regex@4.0.0, with the following changes:
    	// * all capturing groups converted to non-capturing -- "(?:)"
    	// * support for IPv6 Scoped Literal ("%eth1") removed
    	// * lowercase hexadecimal only
    	const IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
    	const IP_V6_REGEX = `
\\[?(?:
(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|
(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|
(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|
(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|
(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:))
)(?:%[0-9a-zA-Z]{1,})?\\]?
`
    	  .replace(/\s*\/\/.*$/gm, "")
    	  .replace(/\n/g, "")
    	  .trim();
    	const IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);

    	/*
    	 * Parses a Natural number (i.e., non-negative integer) with either the
    	 *    <min>*<max>DIGIT ( non-digit *OCTET )
    	 * or
    	 *    <min>*<max>DIGIT
    	 * grammar (RFC6265 S5.1.1).
    	 *
    	 * The "trailingOK" boolean controls if the grammar accepts a
    	 * "( non-digit *OCTET )" trailer.
    	 */
    	function parseDigits(token, minDigits, maxDigits, trailingOK) {
    	  let count = 0;
    	  while (count < token.length) {
    	    const c = token.charCodeAt(count);
    	    // "non-digit = %x00-2F / %x3A-FF"
    	    if (c <= 0x2f || c >= 0x3a) {
    	      break;
    	    }
    	    count++;
    	  }

    	  // constrain to a minimum and maximum number of digits.
    	  if (count < minDigits || count > maxDigits) {
    	    return null;
    	  }

    	  if (!trailingOK && count != token.length) {
    	    return null;
    	  }

    	  return parseInt(token.substr(0, count), 10);
    	}

    	function parseTime(token) {
    	  const parts = token.split(":");
    	  const result = [0, 0, 0];

    	  /* RF6256 S5.1.1:
    	   *      time            = hms-time ( non-digit *OCTET )
    	   *      hms-time        = time-field ":" time-field ":" time-field
    	   *      time-field      = 1*2DIGIT
    	   */

    	  if (parts.length !== 3) {
    	    return null;
    	  }

    	  for (let i = 0; i < 3; i++) {
    	    // "time-field" must be strictly "1*2DIGIT", HOWEVER, "hms-time" can be
    	    // followed by "( non-digit *OCTET )" so therefore the last time-field can
    	    // have a trailer
    	    const trailingOK = i == 2;
    	    const num = parseDigits(parts[i], 1, 2, trailingOK);
    	    if (num === null) {
    	      return null;
    	    }
    	    result[i] = num;
    	  }

    	  return result;
    	}

    	function parseMonth(token) {
    	  token = String(token)
    	    .substr(0, 3)
    	    .toLowerCase();
    	  const num = MONTH_TO_NUM[token];
    	  return num >= 0 ? num : null;
    	}

    	/*
    	 * RFC6265 S5.1.1 date parser (see RFC for full grammar)
    	 */
    	function parseDate(str) {
    	  if (!str) {
    	    return;
    	  }

    	  /* RFC6265 S5.1.1:
    	   * 2. Process each date-token sequentially in the order the date-tokens
    	   * appear in the cookie-date
    	   */
    	  const tokens = str.split(DATE_DELIM);
    	  if (!tokens) {
    	    return;
    	  }

    	  let hour = null;
    	  let minute = null;
    	  let second = null;
    	  let dayOfMonth = null;
    	  let month = null;
    	  let year = null;

    	  for (let i = 0; i < tokens.length; i++) {
    	    const token = tokens[i].trim();
    	    if (!token.length) {
    	      continue;
    	    }

    	    let result;

    	    /* 2.1. If the found-time flag is not set and the token matches the time
    	     * production, set the found-time flag and set the hour- value,
    	     * minute-value, and second-value to the numbers denoted by the digits in
    	     * the date-token, respectively.  Skip the remaining sub-steps and continue
    	     * to the next date-token.
    	     */
    	    if (second === null) {
    	      result = parseTime(token);
    	      if (result) {
    	        hour = result[0];
    	        minute = result[1];
    	        second = result[2];
    	        continue;
    	      }
    	    }

    	    /* 2.2. If the found-day-of-month flag is not set and the date-token matches
    	     * the day-of-month production, set the found-day-of- month flag and set
    	     * the day-of-month-value to the number denoted by the date-token.  Skip
    	     * the remaining sub-steps and continue to the next date-token.
    	     */
    	    if (dayOfMonth === null) {
    	      // "day-of-month = 1*2DIGIT ( non-digit *OCTET )"
    	      result = parseDigits(token, 1, 2, true);
    	      if (result !== null) {
    	        dayOfMonth = result;
    	        continue;
    	      }
    	    }

    	    /* 2.3. If the found-month flag is not set and the date-token matches the
    	     * month production, set the found-month flag and set the month-value to
    	     * the month denoted by the date-token.  Skip the remaining sub-steps and
    	     * continue to the next date-token.
    	     */
    	    if (month === null) {
    	      result = parseMonth(token);
    	      if (result !== null) {
    	        month = result;
    	        continue;
    	      }
    	    }

    	    /* 2.4. If the found-year flag is not set and the date-token matches the
    	     * year production, set the found-year flag and set the year-value to the
    	     * number denoted by the date-token.  Skip the remaining sub-steps and
    	     * continue to the next date-token.
    	     */
    	    if (year === null) {
    	      // "year = 2*4DIGIT ( non-digit *OCTET )"
    	      result = parseDigits(token, 2, 4, true);
    	      if (result !== null) {
    	        year = result;
    	        /* From S5.1.1:
    	         * 3.  If the year-value is greater than or equal to 70 and less
    	         * than or equal to 99, increment the year-value by 1900.
    	         * 4.  If the year-value is greater than or equal to 0 and less
    	         * than or equal to 69, increment the year-value by 2000.
    	         */
    	        if (year >= 70 && year <= 99) {
    	          year += 1900;
    	        } else if (year >= 0 && year <= 69) {
    	          year += 2000;
    	        }
    	      }
    	    }
    	  }

    	  /* RFC 6265 S5.1.1
    	   * "5. Abort these steps and fail to parse the cookie-date if:
    	   *     *  at least one of the found-day-of-month, found-month, found-
    	   *        year, or found-time flags is not set,
    	   *     *  the day-of-month-value is less than 1 or greater than 31,
    	   *     *  the year-value is less than 1601,
    	   *     *  the hour-value is greater than 23,
    	   *     *  the minute-value is greater than 59, or
    	   *     *  the second-value is greater than 59.
    	   *     (Note that leap seconds cannot be represented in this syntax.)"
    	   *
    	   * So, in order as above:
    	   */
    	  if (
    	    dayOfMonth === null ||
    	    month === null ||
    	    year === null ||
    	    second === null ||
    	    dayOfMonth < 1 ||
    	    dayOfMonth > 31 ||
    	    year < 1601 ||
    	    hour > 23 ||
    	    minute > 59 ||
    	    second > 59
    	  ) {
    	    return;
    	  }

    	  return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
    	}

    	function formatDate(date) {
    	  validators.validate(validators.isDate(date), date);
    	  return date.toUTCString();
    	}

    	// S5.1.2 Canonicalized Host Names
    	function canonicalDomain(str) {
    	  if (str == null) {
    	    return null;
    	  }
    	  str = str.trim().replace(/^\./, ""); // S4.1.2.3 & S5.2.3: ignore leading .

    	  if (IP_V6_REGEX_OBJECT.test(str)) {
    	    str = str.replace("[", "").replace("]", "");
    	  }

    	  // convert to IDN if any non-ASCII characters
    	  if (punycode && /[^\u0001-\u007f]/.test(str)) {
    	    str = punycode.toASCII(str);
    	  }

    	  return str.toLowerCase();
    	}

    	// S5.1.3 Domain Matching
    	function domainMatch(str, domStr, canonicalize) {
    	  if (str == null || domStr == null) {
    	    return null;
    	  }
    	  if (canonicalize !== false) {
    	    str = canonicalDomain(str);
    	    domStr = canonicalDomain(domStr);
    	  }

    	  /*
    	   * S5.1.3:
    	   * "A string domain-matches a given domain string if at least one of the
    	   * following conditions hold:"
    	   *
    	   * " o The domain string and the string are identical. (Note that both the
    	   * domain string and the string will have been canonicalized to lower case at
    	   * this point)"
    	   */
    	  if (str == domStr) {
    	    return true;
    	  }

    	  /* " o All of the following [three] conditions hold:" */

    	  /* "* The domain string is a suffix of the string" */
    	  const idx = str.lastIndexOf(domStr);
    	  if (idx <= 0) {
    	    return false; // it's a non-match (-1) or prefix (0)
    	  }

    	  // next, check it's a proper suffix
    	  // e.g., "a.b.c".indexOf("b.c") === 2
    	  // 5 === 3+2
    	  if (str.length !== domStr.length + idx) {
    	    return false; // it's not a suffix
    	  }

    	  /* "  * The last character of the string that is not included in the
    	   * domain string is a %x2E (".") character." */
    	  if (str.substr(idx - 1, 1) !== ".") {
    	    return false; // doesn't align on "."
    	  }

    	  /* "  * The string is a host name (i.e., not an IP address)." */
    	  if (IP_REGEX_LOWERCASE.test(str)) {
    	    return false; // it's an IP address
    	  }

    	  return true;
    	}

    	// RFC6265 S5.1.4 Paths and Path-Match

    	/*
    	 * "The user agent MUST use an algorithm equivalent to the following algorithm
    	 * to compute the default-path of a cookie:"
    	 *
    	 * Assumption: the path (and not query part or absolute uri) is passed in.
    	 */
    	function defaultPath(path) {
    	  // "2. If the uri-path is empty or if the first character of the uri-path is not
    	  // a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
    	  if (!path || path.substr(0, 1) !== "/") {
    	    return "/";
    	  }

    	  // "3. If the uri-path contains no more than one %x2F ("/") character, output
    	  // %x2F ("/") and skip the remaining step."
    	  if (path === "/") {
    	    return path;
    	  }

    	  const rightSlash = path.lastIndexOf("/");
    	  if (rightSlash === 0) {
    	    return "/";
    	  }

    	  // "4. Output the characters of the uri-path from the first character up to,
    	  // but not including, the right-most %x2F ("/")."
    	  return path.slice(0, rightSlash);
    	}

    	function trimTerminator(str) {
    	  if (validators.isEmptyString(str)) return str;
    	  for (let t = 0; t < TERMINATORS.length; t++) {
    	    const terminatorIdx = str.indexOf(TERMINATORS[t]);
    	    if (terminatorIdx !== -1) {
    	      str = str.substr(0, terminatorIdx);
    	    }
    	  }

    	  return str;
    	}

    	function parseCookiePair(cookiePair, looseMode) {
    	  cookiePair = trimTerminator(cookiePair);
    	  validators.validate(validators.isString(cookiePair), cookiePair);

    	  let firstEq = cookiePair.indexOf("=");
    	  if (looseMode) {
    	    if (firstEq === 0) {
    	      // '=' is immediately at start
    	      cookiePair = cookiePair.substr(1);
    	      firstEq = cookiePair.indexOf("="); // might still need to split on '='
    	    }
    	  } else {
    	    // non-loose mode
    	    if (firstEq <= 0) {
    	      // no '=' or is at start
    	      return; // needs to have non-empty "cookie-name"
    	    }
    	  }

    	  let cookieName, cookieValue;
    	  if (firstEq <= 0) {
    	    cookieName = "";
    	    cookieValue = cookiePair.trim();
    	  } else {
    	    cookieName = cookiePair.substr(0, firstEq).trim();
    	    cookieValue = cookiePair.substr(firstEq + 1).trim();
    	  }

    	  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
    	    return;
    	  }

    	  const c = new Cookie();
    	  c.key = cookieName;
    	  c.value = cookieValue;
    	  return c;
    	}

    	function parse(str, options) {
    	  if (!options || typeof options !== "object") {
    	    options = {};
    	  }

    	  if (validators.isEmptyString(str) || !validators.isString(str)) {
    	    return null;
    	  }

    	  str = str.trim();

    	  // We use a regex to parse the "name-value-pair" part of S5.2
    	  const firstSemi = str.indexOf(";"); // S5.2 step 1
    	  const cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
    	  const c = parseCookiePair(cookiePair, !!options.loose);
    	  if (!c) {
    	    return;
    	  }

    	  if (firstSemi === -1) {
    	    return c;
    	  }

    	  // S5.2.3 "unparsed-attributes consist of the remainder of the set-cookie-string
    	  // (including the %x3B (";") in question)." plus later on in the same section
    	  // "discard the first ";" and trim".
    	  const unparsed = str.slice(firstSemi + 1).trim();

    	  // "If the unparsed-attributes string is empty, skip the rest of these
    	  // steps."
    	  if (unparsed.length === 0) {
    	    return c;
    	  }

    	  /*
    	   * S5.2 says that when looping over the items "[p]rocess the attribute-name
    	   * and attribute-value according to the requirements in the following
    	   * subsections" for every item.  Plus, for many of the individual attributes
    	   * in S5.3 it says to use the "attribute-value of the last attribute in the
    	   * cookie-attribute-list".  Therefore, in this implementation, we overwrite
    	   * the previous value.
    	   */
    	  const cookie_avs = unparsed.split(";");
    	  while (cookie_avs.length) {
    	    const av = cookie_avs.shift().trim();
    	    if (av.length === 0) {
    	      // happens if ";;" appears
    	      continue;
    	    }
    	    const av_sep = av.indexOf("=");
    	    let av_key, av_value;

    	    if (av_sep === -1) {
    	      av_key = av;
    	      av_value = null;
    	    } else {
    	      av_key = av.substr(0, av_sep);
    	      av_value = av.substr(av_sep + 1);
    	    }

    	    av_key = av_key.trim().toLowerCase();

    	    if (av_value) {
    	      av_value = av_value.trim();
    	    }

    	    switch (av_key) {
    	      case "expires": // S5.2.1
    	        if (av_value) {
    	          const exp = parseDate(av_value);
    	          // "If the attribute-value failed to parse as a cookie date, ignore the
    	          // cookie-av."
    	          if (exp) {
    	            // over and underflow not realistically a concern: V8's getTime() seems to
    	            // store something larger than a 32-bit time_t (even with 32-bit node)
    	            c.expires = exp;
    	          }
    	        }
    	        break;

    	      case "max-age": // S5.2.2
    	        if (av_value) {
    	          // "If the first character of the attribute-value is not a DIGIT or a "-"
    	          // character ...[or]... If the remainder of attribute-value contains a
    	          // non-DIGIT character, ignore the cookie-av."
    	          if (/^-?[0-9]+$/.test(av_value)) {
    	            const delta = parseInt(av_value, 10);
    	            // "If delta-seconds is less than or equal to zero (0), let expiry-time
    	            // be the earliest representable date and time."
    	            c.setMaxAge(delta);
    	          }
    	        }
    	        break;

    	      case "domain": // S5.2.3
    	        // "If the attribute-value is empty, the behavior is undefined.  However,
    	        // the user agent SHOULD ignore the cookie-av entirely."
    	        if (av_value) {
    	          // S5.2.3 "Let cookie-domain be the attribute-value without the leading %x2E
    	          // (".") character."
    	          const domain = av_value.trim().replace(/^\./, "");
    	          if (domain) {
    	            // "Convert the cookie-domain to lower case."
    	            c.domain = domain.toLowerCase();
    	          }
    	        }
    	        break;

    	      case "path": // S5.2.4
    	        /*
    	         * "If the attribute-value is empty or if the first character of the
    	         * attribute-value is not %x2F ("/"):
    	         *   Let cookie-path be the default-path.
    	         * Otherwise:
    	         *   Let cookie-path be the attribute-value."
    	         *
    	         * We'll represent the default-path as null since it depends on the
    	         * context of the parsing.
    	         */
    	        c.path = av_value && av_value[0] === "/" ? av_value : null;
    	        break;

    	      case "secure": // S5.2.5
    	        /*
    	         * "If the attribute-name case-insensitively matches the string "Secure",
    	         * the user agent MUST append an attribute to the cookie-attribute-list
    	         * with an attribute-name of Secure and an empty attribute-value."
    	         */
    	        c.secure = true;
    	        break;

    	      case "httponly": // S5.2.6 -- effectively the same as 'secure'
    	        c.httpOnly = true;
    	        break;

    	      case "samesite": // RFC6265bis-02 S5.3.7
    	        const enforcement = av_value ? av_value.toLowerCase() : "";
    	        switch (enforcement) {
    	          case "strict":
    	            c.sameSite = "strict";
    	            break;
    	          case "lax":
    	            c.sameSite = "lax";
    	            break;
    	          case "none":
    	            c.sameSite = "none";
    	            break;
    	          default:
    	            c.sameSite = undefined;
    	            break;
    	        }
    	        break;

    	      default:
    	        c.extensions = c.extensions || [];
    	        c.extensions.push(av);
    	        break;
    	    }
    	  }

    	  return c;
    	}

    	/**
    	 *  If the cookie-name begins with a case-sensitive match for the
    	 *  string "__Secure-", abort these steps and ignore the cookie
    	 *  entirely unless the cookie's secure-only-flag is true.
    	 * @param cookie
    	 * @returns boolean
    	 */
    	function isSecurePrefixConditionMet(cookie) {
    	  validators.validate(validators.isObject(cookie), cookie);
    	  return !cookie.key.startsWith("__Secure-") || cookie.secure;
    	}

    	/**
    	 *  If the cookie-name begins with a case-sensitive match for the
    	 *  string "__Host-", abort these steps and ignore the cookie
    	 *  entirely unless the cookie meets all the following criteria:
    	 *    1.  The cookie's secure-only-flag is true.
    	 *    2.  The cookie's host-only-flag is true.
    	 *    3.  The cookie-attribute-list contains an attribute with an
    	 *        attribute-name of "Path", and the cookie's path is "/".
    	 * @param cookie
    	 * @returns boolean
    	 */
    	function isHostPrefixConditionMet(cookie) {
    	  validators.validate(validators.isObject(cookie));
    	  return (
    	    !cookie.key.startsWith("__Host-") ||
    	    (cookie.secure &&
    	      cookie.hostOnly &&
    	      cookie.path != null &&
    	      cookie.path === "/")
    	  );
    	}

    	// avoid the V8 deoptimization monster!
    	function jsonParse(str) {
    	  let obj;
    	  try {
    	    obj = JSON.parse(str);
    	  } catch (e) {
    	    return e;
    	  }
    	  return obj;
    	}

    	function fromJSON(str) {
    	  if (!str || validators.isEmptyString(str)) {
    	    return null;
    	  }

    	  let obj;
    	  if (typeof str === "string") {
    	    obj = jsonParse(str);
    	    if (obj instanceof Error) {
    	      return null;
    	    }
    	  } else {
    	    // assume it's an Object
    	    obj = str;
    	  }

    	  const c = new Cookie();
    	  for (let i = 0; i < Cookie.serializableProperties.length; i++) {
    	    const prop = Cookie.serializableProperties[i];
    	    if (obj[prop] === undefined || obj[prop] === cookieDefaults[prop]) {
    	      continue; // leave as prototype default
    	    }

    	    if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
    	      if (obj[prop] === null) {
    	        c[prop] = null;
    	      } else {
    	        c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]);
    	      }
    	    } else {
    	      c[prop] = obj[prop];
    	    }
    	  }

    	  return c;
    	}

    	/* Section 5.4 part 2:
    	 * "*  Cookies with longer paths are listed before cookies with
    	 *     shorter paths.
    	 *
    	 *  *  Among cookies that have equal-length path fields, cookies with
    	 *     earlier creation-times are listed before cookies with later
    	 *     creation-times."
    	 */

    	function cookieCompare(a, b) {
    	  validators.validate(validators.isObject(a), a);
    	  validators.validate(validators.isObject(b), b);
    	  let cmp = 0;

    	  // descending for length: b CMP a
    	  const aPathLen = a.path ? a.path.length : 0;
    	  const bPathLen = b.path ? b.path.length : 0;
    	  cmp = bPathLen - aPathLen;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  // ascending for time: a CMP b
    	  const aTime = a.creation ? a.creation.getTime() : MAX_TIME;
    	  const bTime = b.creation ? b.creation.getTime() : MAX_TIME;
    	  cmp = aTime - bTime;
    	  if (cmp !== 0) {
    	    return cmp;
    	  }

    	  // break ties for the same millisecond (precision of JavaScript's clock)
    	  cmp = a.creationIndex - b.creationIndex;

    	  return cmp;
    	}

    	// Gives the permutation of all possible pathMatch()es of a given path. The
    	// array is in longest-to-shortest order.  Handy for indexing.
    	function permutePath(path) {
    	  validators.validate(validators.isString(path));
    	  if (path === "/") {
    	    return ["/"];
    	  }
    	  const permutations = [path];
    	  while (path.length > 1) {
    	    const lindex = path.lastIndexOf("/");
    	    if (lindex === 0) {
    	      break;
    	    }
    	    path = path.substr(0, lindex);
    	    permutations.push(path);
    	  }
    	  permutations.push("/");
    	  return permutations;
    	}

    	function getCookieContext(url) {
    	  if (url instanceof Object) {
    	    return url;
    	  }
    	  // NOTE: decodeURI will throw on malformed URIs (see GH-32).
    	  // Therefore, we will just skip decoding for such URIs.
    	  try {
    	    url = decodeURI(url);
    	  } catch (err) {
    	    // Silently swallow error
    	  }

    	  return urlParse(url);
    	}

    	const cookieDefaults = {
    	  // the order in which the RFC has them:
    	  key: "",
    	  value: "",
    	  expires: "Infinity",
    	  maxAge: null,
    	  domain: null,
    	  path: null,
    	  secure: false,
    	  httpOnly: false,
    	  extensions: null,
    	  // set by the CookieJar:
    	  hostOnly: null,
    	  pathIsDefault: null,
    	  creation: null,
    	  lastAccessed: null,
    	  sameSite: undefined
    	};

    	class Cookie {
    	  constructor(options = {}) {
    	    const customInspectSymbol = getCustomInspectSymbol();
    	    if (customInspectSymbol) {
    	      this[customInspectSymbol] = this.inspect;
    	    }

    	    Object.assign(this, cookieDefaults, options);
    	    this.creation = this.creation || new Date();

    	    // used to break creation ties in cookieCompare():
    	    Object.defineProperty(this, "creationIndex", {
    	      configurable: false,
    	      enumerable: false, // important for assert.deepEqual checks
    	      writable: true,
    	      value: ++Cookie.cookiesCreated
    	    });
    	  }

    	  inspect() {
    	    const now = Date.now();
    	    const hostOnly = this.hostOnly != null ? this.hostOnly : "?";
    	    const createAge = this.creation
    	      ? `${now - this.creation.getTime()}ms`
    	      : "?";
    	    const accessAge = this.lastAccessed
    	      ? `${now - this.lastAccessed.getTime()}ms`
    	      : "?";
    	    return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
    	  }

    	  toJSON() {
    	    const obj = {};

    	    for (const prop of Cookie.serializableProperties) {
    	      if (this[prop] === cookieDefaults[prop]) {
    	        continue; // leave as prototype default
    	      }

    	      if (
    	        prop === "expires" ||
    	        prop === "creation" ||
    	        prop === "lastAccessed"
    	      ) {
    	        if (this[prop] === null) {
    	          obj[prop] = null;
    	        } else {
    	          obj[prop] =
    	            this[prop] == "Infinity" // intentionally not ===
    	              ? "Infinity"
    	              : this[prop].toISOString();
    	        }
    	      } else if (prop === "maxAge") {
    	        if (this[prop] !== null) {
    	          // again, intentionally not ===
    	          obj[prop] =
    	            this[prop] == Infinity || this[prop] == -Infinity
    	              ? this[prop].toString()
    	              : this[prop];
    	        }
    	      } else {
    	        if (this[prop] !== cookieDefaults[prop]) {
    	          obj[prop] = this[prop];
    	        }
    	      }
    	    }

    	    return obj;
    	  }

    	  clone() {
    	    return fromJSON(this.toJSON());
    	  }

    	  validate() {
    	    if (!COOKIE_OCTETS.test(this.value)) {
    	      return false;
    	    }
    	    if (
    	      this.expires != Infinity &&
    	      !(this.expires instanceof Date) &&
    	      !parseDate(this.expires)
    	    ) {
    	      return false;
    	    }
    	    if (this.maxAge != null && this.maxAge <= 0) {
    	      return false; // "Max-Age=" non-zero-digit *DIGIT
    	    }
    	    if (this.path != null && !PATH_VALUE.test(this.path)) {
    	      return false;
    	    }

    	    const cdomain = this.cdomain();
    	    if (cdomain) {
    	      if (cdomain.match(/\.$/)) {
    	        return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
    	      }
    	      const suffix = pubsuffix.getPublicSuffix(cdomain);
    	      if (suffix == null) {
    	        // it's a public suffix
    	        return false;
    	      }
    	    }
    	    return true;
    	  }

    	  setExpires(exp) {
    	    if (exp instanceof Date) {
    	      this.expires = exp;
    	    } else {
    	      this.expires = parseDate(exp) || "Infinity";
    	    }
    	  }

    	  setMaxAge(age) {
    	    if (age === Infinity || age === -Infinity) {
    	      this.maxAge = age.toString(); // so JSON.stringify() works
    	    } else {
    	      this.maxAge = age;
    	    }
    	  }

    	  cookieString() {
    	    let val = this.value;
    	    if (val == null) {
    	      val = "";
    	    }
    	    if (this.key === "") {
    	      return val;
    	    }
    	    return `${this.key}=${val}`;
    	  }

    	  // gives Set-Cookie header format
    	  toString() {
    	    let str = this.cookieString();

    	    if (this.expires != Infinity) {
    	      if (this.expires instanceof Date) {
    	        str += `; Expires=${formatDate(this.expires)}`;
    	      } else {
    	        str += `; Expires=${this.expires}`;
    	      }
    	    }

    	    if (this.maxAge != null && this.maxAge != Infinity) {
    	      str += `; Max-Age=${this.maxAge}`;
    	    }

    	    if (this.domain && !this.hostOnly) {
    	      str += `; Domain=${this.domain}`;
    	    }
    	    if (this.path) {
    	      str += `; Path=${this.path}`;
    	    }

    	    if (this.secure) {
    	      str += "; Secure";
    	    }
    	    if (this.httpOnly) {
    	      str += "; HttpOnly";
    	    }
    	    if (this.sameSite && this.sameSite !== "none") {
    	      const ssCanon = Cookie.sameSiteCanonical[this.sameSite.toLowerCase()];
    	      str += `; SameSite=${ssCanon ? ssCanon : this.sameSite}`;
    	    }
    	    if (this.extensions) {
    	      this.extensions.forEach(ext => {
    	        str += `; ${ext}`;
    	      });
    	    }

    	    return str;
    	  }

    	  // TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
    	  // elsewhere)
    	  // S5.3 says to give the "latest representable date" for which we use Infinity
    	  // For "expired" we use 0
    	  TTL(now) {
    	    /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
    	     * attribute, the Max-Age attribute has precedence and controls the
    	     * expiration date of the cookie.
    	     * (Concurs with S5.3 step 3)
    	     */
    	    if (this.maxAge != null) {
    	      return this.maxAge <= 0 ? 0 : this.maxAge * 1000;
    	    }

    	    let expires = this.expires;
    	    if (expires != Infinity) {
    	      if (!(expires instanceof Date)) {
    	        expires = parseDate(expires) || Infinity;
    	      }

    	      if (expires == Infinity) {
    	        return Infinity;
    	      }

    	      return expires.getTime() - (now || Date.now());
    	    }

    	    return Infinity;
    	  }

    	  // expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
    	  // elsewhere)
    	  expiryTime(now) {
    	    if (this.maxAge != null) {
    	      const relativeTo = now || this.creation || new Date();
    	      const age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1000;
    	      return relativeTo.getTime() + age;
    	    }

    	    if (this.expires == Infinity) {
    	      return Infinity;
    	    }
    	    return this.expires.getTime();
    	  }

    	  // expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
    	  // elsewhere), except it returns a Date
    	  expiryDate(now) {
    	    const millisec = this.expiryTime(now);
    	    if (millisec == Infinity) {
    	      return new Date(MAX_TIME);
    	    } else if (millisec == -Infinity) {
    	      return new Date(MIN_TIME);
    	    } else {
    	      return new Date(millisec);
    	    }
    	  }

    	  // This replaces the "persistent-flag" parts of S5.3 step 3
    	  isPersistent() {
    	    return this.maxAge != null || this.expires != Infinity;
    	  }

    	  // Mostly S5.1.2 and S5.2.3:
    	  canonicalizedDomain() {
    	    if (this.domain == null) {
    	      return null;
    	    }
    	    return canonicalDomain(this.domain);
    	  }

    	  cdomain() {
    	    return this.canonicalizedDomain();
    	  }
    	}

    	Cookie.cookiesCreated = 0;
    	Cookie.parse = parse;
    	Cookie.fromJSON = fromJSON;
    	Cookie.serializableProperties = Object.keys(cookieDefaults);
    	Cookie.sameSiteLevel = {
    	  strict: 3,
    	  lax: 2,
    	  none: 1
    	};

    	Cookie.sameSiteCanonical = {
    	  strict: "Strict",
    	  lax: "Lax"
    	};

    	function getNormalizedPrefixSecurity(prefixSecurity) {
    	  if (prefixSecurity != null) {
    	    const normalizedPrefixSecurity = prefixSecurity.toLowerCase();
    	    /* The three supported options */
    	    switch (normalizedPrefixSecurity) {
    	      case PrefixSecurityEnum.STRICT:
    	      case PrefixSecurityEnum.SILENT:
    	      case PrefixSecurityEnum.DISABLED:
    	        return normalizedPrefixSecurity;
    	    }
    	  }
    	  /* Default is SILENT */
    	  return PrefixSecurityEnum.SILENT;
    	}

    	class CookieJar {
    	  constructor(store, options = { rejectPublicSuffixes: true }) {
    	    if (typeof options === "boolean") {
    	      options = { rejectPublicSuffixes: options };
    	    }
    	    validators.validate(validators.isObject(options), options);
    	    this.rejectPublicSuffixes = options.rejectPublicSuffixes;
    	    this.enableLooseMode = !!options.looseMode;
    	    this.allowSpecialUseDomain =
    	      typeof options.allowSpecialUseDomain === "boolean"
    	        ? options.allowSpecialUseDomain
    	        : true;
    	    this.store = store || new MemoryCookieStore();
    	    this.prefixSecurity = getNormalizedPrefixSecurity(options.prefixSecurity);
    	    this._cloneSync = syncWrap("clone");
    	    this._importCookiesSync = syncWrap("_importCookies");
    	    this.getCookiesSync = syncWrap("getCookies");
    	    this.getCookieStringSync = syncWrap("getCookieString");
    	    this.getSetCookieStringsSync = syncWrap("getSetCookieStrings");
    	    this.removeAllCookiesSync = syncWrap("removeAllCookies");
    	    this.setCookieSync = syncWrap("setCookie");
    	    this.serializeSync = syncWrap("serialize");
    	  }

    	  setCookie(cookie, url, options, cb) {
    	    validators.validate(validators.isUrlStringOrObject(url), cb, options);

    	    let err;

    	    if (validators.isFunction(url)) {
    	      cb = url;
    	      return cb(new Error("No URL was specified"));
    	    }

    	    const context = getCookieContext(url);
    	    if (validators.isFunction(options)) {
    	      cb = options;
    	      options = {};
    	    }

    	    validators.validate(validators.isFunction(cb), cb);

    	    if (
    	      !validators.isNonEmptyString(cookie) &&
    	      !validators.isObject(cookie) &&
    	      cookie instanceof String &&
    	      cookie.length == 0
    	    ) {
    	      return cb(null);
    	    }

    	    const host = canonicalDomain(context.hostname);
    	    const loose = options.loose || this.enableLooseMode;

    	    let sameSiteContext = null;
    	    if (options.sameSiteContext) {
    	      sameSiteContext = checkSameSiteContext(options.sameSiteContext);
    	      if (!sameSiteContext) {
    	        return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
    	      }
    	    }

    	    // S5.3 step 1
    	    if (typeof cookie === "string" || cookie instanceof String) {
    	      cookie = Cookie.parse(cookie, { loose: loose });
    	      if (!cookie) {
    	        err = new Error("Cookie failed to parse");
    	        return cb(options.ignoreError ? null : err);
    	      }
    	    } else if (!(cookie instanceof Cookie)) {
    	      // If you're seeing this error, and are passing in a Cookie object,
    	      // it *might* be a Cookie object from another loaded version of tough-cookie.
    	      err = new Error(
    	        "First argument to setCookie must be a Cookie object or string"
    	      );
    	      return cb(options.ignoreError ? null : err);
    	    }

    	    // S5.3 step 2
    	    const now = options.now || new Date(); // will assign later to save effort in the face of errors

    	    // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()

    	    // S5.3 step 4: NOOP; domain is null by default

    	    // S5.3 step 5: public suffixes
    	    if (this.rejectPublicSuffixes && cookie.domain) {
    	      const suffix = pubsuffix.getPublicSuffix(cookie.cdomain(), {
    	        allowSpecialUseDomain: this.allowSpecialUseDomain,
    	        ignoreError: options.ignoreError
    	      });
    	      if (suffix == null && !IP_V6_REGEX_OBJECT.test(cookie.domain)) {
    	        // e.g. "com"
    	        err = new Error("Cookie has domain set to a public suffix");
    	        return cb(options.ignoreError ? null : err);
    	      }
    	    }

    	    // S5.3 step 6:
    	    if (cookie.domain) {
    	      if (!domainMatch(host, cookie.cdomain(), false)) {
    	        err = new Error(
    	          `Cookie not in this host's domain. Cookie:${cookie.cdomain()} Request:${host}`
    	        );
    	        return cb(options.ignoreError ? null : err);
    	      }

    	      if (cookie.hostOnly == null) {
    	        // don't reset if already set
    	        cookie.hostOnly = false;
    	      }
    	    } else {
    	      cookie.hostOnly = true;
    	      cookie.domain = host;
    	    }

    	    //S5.2.4 If the attribute-value is empty or if the first character of the
    	    //attribute-value is not %x2F ("/"):
    	    //Let cookie-path be the default-path.
    	    if (!cookie.path || cookie.path[0] !== "/") {
    	      cookie.path = defaultPath(context.pathname);
    	      cookie.pathIsDefault = true;
    	    }

    	    // S5.3 step 8: NOOP; secure attribute
    	    // S5.3 step 9: NOOP; httpOnly attribute

    	    // S5.3 step 10
    	    if (options.http === false && cookie.httpOnly) {
    	      err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
    	      return cb(options.ignoreError ? null : err);
    	    }

    	    // 6252bis-02 S5.4 Step 13 & 14:
    	    if (
    	      cookie.sameSite !== "none" &&
    	      cookie.sameSite !== undefined &&
    	      sameSiteContext
    	    ) {
    	      // "If the cookie's "same-site-flag" is not "None", and the cookie
    	      //  is being set from a context whose "site for cookies" is not an
    	      //  exact match for request-uri's host's registered domain, then
    	      //  abort these steps and ignore the newly created cookie entirely."
    	      if (sameSiteContext === "none") {
    	        err = new Error(
    	          "Cookie is SameSite but this is a cross-origin request"
    	        );
    	        return cb(options.ignoreError ? null : err);
    	      }
    	    }

    	    /* 6265bis-02 S5.4 Steps 15 & 16 */
    	    const ignoreErrorForPrefixSecurity =
    	      this.prefixSecurity === PrefixSecurityEnum.SILENT;
    	    const prefixSecurityDisabled =
    	      this.prefixSecurity === PrefixSecurityEnum.DISABLED;
    	    /* If prefix checking is not disabled ...*/
    	    if (!prefixSecurityDisabled) {
    	      let errorFound = false;
    	      let errorMsg;
    	      /* Check secure prefix condition */
    	      if (!isSecurePrefixConditionMet(cookie)) {
    	        errorFound = true;
    	        errorMsg = "Cookie has __Secure prefix but Secure attribute is not set";
    	      } else if (!isHostPrefixConditionMet(cookie)) {
    	        /* Check host prefix condition */
    	        errorFound = true;
    	        errorMsg =
    	          "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'";
    	      }
    	      if (errorFound) {
    	        return cb(
    	          options.ignoreError || ignoreErrorForPrefixSecurity
    	            ? null
    	            : new Error(errorMsg)
    	        );
    	      }
    	    }

    	    const store = this.store;

    	    if (!store.updateCookie) {
    	      store.updateCookie = function(oldCookie, newCookie, cb) {
    	        this.putCookie(newCookie, cb);
    	      };
    	    }

    	    function withCookie(err, oldCookie) {
    	      if (err) {
    	        return cb(err);
    	      }

    	      const next = function(err) {
    	        if (err) {
    	          return cb(err);
    	        } else {
    	          cb(null, cookie);
    	        }
    	      };

    	      if (oldCookie) {
    	        // S5.3 step 11 - "If the cookie store contains a cookie with the same name,
    	        // domain, and path as the newly created cookie:"
    	        if (options.http === false && oldCookie.httpOnly) {
    	          // step 11.2
    	          err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
    	          return cb(options.ignoreError ? null : err);
    	        }
    	        cookie.creation = oldCookie.creation; // step 11.3
    	        cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker
    	        cookie.lastAccessed = now;
    	        // Step 11.4 (delete cookie) is implied by just setting the new one:
    	        store.updateCookie(oldCookie, cookie, next); // step 12
    	      } else {
    	        cookie.creation = cookie.lastAccessed = now;
    	        store.putCookie(cookie, next); // step 12
    	      }
    	    }

    	    store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
    	  }

    	  // RFC6365 S5.4
    	  getCookies(url, options, cb) {
    	    validators.validate(validators.isUrlStringOrObject(url), cb, url);

    	    const context = getCookieContext(url);
    	    if (validators.isFunction(options)) {
    	      cb = options;
    	      options = {};
    	    }
    	    validators.validate(validators.isObject(options), cb, options);
    	    validators.validate(validators.isFunction(cb), cb);

    	    const host = canonicalDomain(context.hostname);
    	    const path = context.pathname || "/";

    	    let secure = options.secure;
    	    if (
    	      secure == null &&
    	      context.protocol &&
    	      (context.protocol == "https:" || context.protocol == "wss:")
    	    ) {
    	      secure = true;
    	    }

    	    let sameSiteLevel = 0;
    	    if (options.sameSiteContext) {
    	      const sameSiteContext = checkSameSiteContext(options.sameSiteContext);
    	      sameSiteLevel = Cookie.sameSiteLevel[sameSiteContext];
    	      if (!sameSiteLevel) {
    	        return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
    	      }
    	    }

    	    let http = options.http;
    	    if (http == null) {
    	      http = true;
    	    }

    	    const now = options.now || Date.now();
    	    const expireCheck = options.expire !== false;
    	    const allPaths = !!options.allPaths;
    	    const store = this.store;

    	    function matchingCookie(c) {
    	      // "Either:
    	      //   The cookie's host-only-flag is true and the canonicalized
    	      //   request-host is identical to the cookie's domain.
    	      // Or:
    	      //   The cookie's host-only-flag is false and the canonicalized
    	      //   request-host domain-matches the cookie's domain."
    	      if (c.hostOnly) {
    	        if (c.domain != host) {
    	          return false;
    	        }
    	      } else {
    	        if (!domainMatch(host, c.domain, false)) {
    	          return false;
    	        }
    	      }

    	      // "The request-uri's path path-matches the cookie's path."
    	      if (!allPaths && !pathMatch(path, c.path)) {
    	        return false;
    	      }

    	      // "If the cookie's secure-only-flag is true, then the request-uri's
    	      // scheme must denote a "secure" protocol"
    	      if (c.secure && !secure) {
    	        return false;
    	      }

    	      // "If the cookie's http-only-flag is true, then exclude the cookie if the
    	      // cookie-string is being generated for a "non-HTTP" API"
    	      if (c.httpOnly && !http) {
    	        return false;
    	      }

    	      // RFC6265bis-02 S5.3.7
    	      if (sameSiteLevel) {
    	        const cookieLevel = Cookie.sameSiteLevel[c.sameSite || "none"];
    	        if (cookieLevel > sameSiteLevel) {
    	          // only allow cookies at or below the request level
    	          return false;
    	        }
    	      }

    	      // deferred from S5.3
    	      // non-RFC: allow retention of expired cookies by choice
    	      if (expireCheck && c.expiryTime() <= now) {
    	        store.removeCookie(c.domain, c.path, c.key, () => {}); // result ignored
    	        return false;
    	      }

    	      return true;
    	    }

    	    store.findCookies(
    	      host,
    	      allPaths ? null : path,
    	      this.allowSpecialUseDomain,
    	      (err, cookies) => {
    	        if (err) {
    	          return cb(err);
    	        }

    	        cookies = cookies.filter(matchingCookie);

    	        // sorting of S5.4 part 2
    	        if (options.sort !== false) {
    	          cookies = cookies.sort(cookieCompare);
    	        }

    	        // S5.4 part 3
    	        const now = new Date();
    	        for (const cookie of cookies) {
    	          cookie.lastAccessed = now;
    	        }
    	        // TODO persist lastAccessed

    	        cb(null, cookies);
    	      }
    	    );
    	  }

    	  getCookieString(...args) {
    	    const cb = args.pop();
    	    validators.validate(validators.isFunction(cb), cb);
    	    const next = function(err, cookies) {
    	      if (err) {
    	        cb(err);
    	      } else {
    	        cb(
    	          null,
    	          cookies
    	            .sort(cookieCompare)
    	            .map(c => c.cookieString())
    	            .join("; ")
    	        );
    	      }
    	    };
    	    args.push(next);
    	    this.getCookies.apply(this, args);
    	  }

    	  getSetCookieStrings(...args) {
    	    const cb = args.pop();
    	    validators.validate(validators.isFunction(cb), cb);
    	    const next = function(err, cookies) {
    	      if (err) {
    	        cb(err);
    	      } else {
    	        cb(
    	          null,
    	          cookies.map(c => {
    	            return c.toString();
    	          })
    	        );
    	      }
    	    };
    	    args.push(next);
    	    this.getCookies.apply(this, args);
    	  }

    	  serialize(cb) {
    	    validators.validate(validators.isFunction(cb), cb);
    	    let type = this.store.constructor.name;
    	    if (validators.isObject(type)) {
    	      type = null;
    	    }

    	    // update README.md "Serialization Format" if you change this, please!
    	    const serialized = {
    	      // The version of tough-cookie that serialized this jar. Generally a good
    	      // practice since future versions can make data import decisions based on
    	      // known past behavior. When/if this matters, use `semver`.
    	      version: `tough-cookie@${VERSION}`,

    	      // add the store type, to make humans happy:
    	      storeType: type,

    	      // CookieJar configuration:
    	      rejectPublicSuffixes: !!this.rejectPublicSuffixes,
    	      enableLooseMode: !!this.enableLooseMode,
    	      allowSpecialUseDomain: !!this.allowSpecialUseDomain,
    	      prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),

    	      // this gets filled from getAllCookies:
    	      cookies: []
    	    };

    	    if (
    	      !(
    	        this.store.getAllCookies &&
    	        typeof this.store.getAllCookies === "function"
    	      )
    	    ) {
    	      return cb(
    	        new Error(
    	          "store does not support getAllCookies and cannot be serialized"
    	        )
    	      );
    	    }

    	    this.store.getAllCookies((err, cookies) => {
    	      if (err) {
    	        return cb(err);
    	      }

    	      serialized.cookies = cookies.map(cookie => {
    	        // convert to serialized 'raw' cookies
    	        cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;

    	        // Remove the index so new ones get assigned during deserialization
    	        delete cookie.creationIndex;

    	        return cookie;
    	      });

    	      return cb(null, serialized);
    	    });
    	  }

    	  toJSON() {
    	    return this.serializeSync();
    	  }

    	  // use the class method CookieJar.deserialize instead of calling this directly
    	  _importCookies(serialized, cb) {
    	    let cookies = serialized.cookies;
    	    if (!cookies || !Array.isArray(cookies)) {
    	      return cb(new Error("serialized jar has no cookies array"));
    	    }
    	    cookies = cookies.slice(); // do not modify the original

    	    const putNext = err => {
    	      if (err) {
    	        return cb(err);
    	      }

    	      if (!cookies.length) {
    	        return cb(err, this);
    	      }

    	      let cookie;
    	      try {
    	        cookie = fromJSON(cookies.shift());
    	      } catch (e) {
    	        return cb(e);
    	      }

    	      if (cookie === null) {
    	        return putNext(null); // skip this cookie
    	      }

    	      this.store.putCookie(cookie, putNext);
    	    };

    	    putNext();
    	  }

    	  clone(newStore, cb) {
    	    if (arguments.length === 1) {
    	      cb = newStore;
    	      newStore = null;
    	    }

    	    this.serialize((err, serialized) => {
    	      if (err) {
    	        return cb(err);
    	      }
    	      CookieJar.deserialize(serialized, newStore, cb);
    	    });
    	  }

    	  cloneSync(newStore) {
    	    if (arguments.length === 0) {
    	      return this._cloneSync();
    	    }
    	    if (!newStore.synchronous) {
    	      throw new Error(
    	        "CookieJar clone destination store is not synchronous; use async API instead."
    	      );
    	    }
    	    return this._cloneSync(newStore);
    	  }

    	  removeAllCookies(cb) {
    	    validators.validate(validators.isFunction(cb), cb);
    	    const store = this.store;

    	    // Check that the store implements its own removeAllCookies(). The default
    	    // implementation in Store will immediately call the callback with a "not
    	    // implemented" Error.
    	    if (
    	      typeof store.removeAllCookies === "function" &&
    	      store.removeAllCookies !== Store.prototype.removeAllCookies
    	    ) {
    	      return store.removeAllCookies(cb);
    	    }

    	    store.getAllCookies((err, cookies) => {
    	      if (err) {
    	        return cb(err);
    	      }

    	      if (cookies.length === 0) {
    	        return cb(null);
    	      }

    	      let completedCount = 0;
    	      const removeErrors = [];

    	      function removeCookieCb(removeErr) {
    	        if (removeErr) {
    	          removeErrors.push(removeErr);
    	        }

    	        completedCount++;

    	        if (completedCount === cookies.length) {
    	          return cb(removeErrors.length ? removeErrors[0] : null);
    	        }
    	      }

    	      cookies.forEach(cookie => {
    	        store.removeCookie(
    	          cookie.domain,
    	          cookie.path,
    	          cookie.key,
    	          removeCookieCb
    	        );
    	      });
    	    });
    	  }

    	  static deserialize(strOrObj, store, cb) {
    	    if (arguments.length !== 3) {
    	      // store is optional
    	      cb = store;
    	      store = null;
    	    }
    	    validators.validate(validators.isFunction(cb), cb);

    	    let serialized;
    	    if (typeof strOrObj === "string") {
    	      serialized = jsonParse(strOrObj);
    	      if (serialized instanceof Error) {
    	        return cb(serialized);
    	      }
    	    } else {
    	      serialized = strOrObj;
    	    }

    	    const jar = new CookieJar(store, {
    	      rejectPublicSuffixes: serialized.rejectPublicSuffixes,
    	      looseMode: serialized.enableLooseMode,
    	      allowSpecialUseDomain: serialized.allowSpecialUseDomain,
    	      prefixSecurity: serialized.prefixSecurity
    	    });
    	    jar._importCookies(serialized, err => {
    	      if (err) {
    	        return cb(err);
    	      }
    	      cb(null, jar);
    	    });
    	  }

    	  static deserializeSync(strOrObj, store) {
    	    const serialized =
    	      typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
    	    const jar = new CookieJar(store, {
    	      rejectPublicSuffixes: serialized.rejectPublicSuffixes,
    	      looseMode: serialized.enableLooseMode
    	    });

    	    // catch this mistake early:
    	    if (!jar.store.synchronous) {
    	      throw new Error(
    	        "CookieJar store is not synchronous; use async API instead."
    	      );
    	    }

    	    jar._importCookiesSync(serialized);
    	    return jar;
    	  }
    	}
    	CookieJar.fromJSON = CookieJar.deserializeSync;

    	[
    	  "_importCookies",
    	  "clone",
    	  "getCookies",
    	  "getCookieString",
    	  "getSetCookieStrings",
    	  "removeAllCookies",
    	  "serialize",
    	  "setCookie"
    	].forEach(name => {
    	  CookieJar.prototype[name] = fromCallback(CookieJar.prototype[name]);
    	});
    	CookieJar.deserialize = fromCallback(CookieJar.deserialize);

    	// Use a closure to provide a true imperative API for synchronous stores.
    	function syncWrap(method) {
    	  return function(...args) {
    	    if (!this.store.synchronous) {
    	      throw new Error(
    	        "CookieJar store is not synchronous; use async API instead."
    	      );
    	    }

    	    let syncErr, syncResult;
    	    this[method](...args, (err, result) => {
    	      syncErr = err;
    	      syncResult = result;
    	    });

    	    if (syncErr) {
    	      throw syncErr;
    	    }
    	    return syncResult;
    	  };
    	}

    	cookie.version = VERSION;
    	cookie.CookieJar = CookieJar;
    	cookie.Cookie = Cookie;
    	cookie.Store = Store;
    	cookie.MemoryCookieStore = MemoryCookieStore;
    	cookie.parseDate = parseDate;
    	cookie.formatDate = formatDate;
    	cookie.parse = parse;
    	cookie.fromJSON = fromJSON;
    	cookie.domainMatch = domainMatch;
    	cookie.defaultPath = defaultPath;
    	cookie.pathMatch = pathMatch;
    	cookie.getPublicSuffix = pubsuffix.getPublicSuffix;
    	cookie.cookieCompare = cookieCompare;
    	cookie.permuteDomain = requirePermuteDomain().permuteDomain;
    	cookie.permutePath = permutePath;
    	cookie.canonicalDomain = canonicalDomain;
    	cookie.PrefixSecurityEnum = PrefixSecurityEnum;
    	cookie.ParameterError = validators.ParameterError;
    	return cookie;
    }

    var cookieExports = requireCookie();

    class ExtendedCookieJar extends cookieExports.CookieJar {
        async setFromSetCookieHeaders(setCookieHeader, url) {
            let cookies;
            // console.log("setFromSetCookieHeaders", setCookieHeader);
            if (typeof setCookieHeader === "undefined") ;
            else if (setCookieHeader instanceof Array) {
                cookies = setCookieHeader.map((header) => cookieExports.Cookie.parse(header));
            }
            else if (typeof setCookieHeader === "string") {
                cookies = [cookieExports.Cookie.parse(setCookieHeader)];
            }
            if (cookies)
                for (const cookie of cookies)
                    if (cookie instanceof cookieExports.Cookie) {
                        // console.log("setCookieSync", cookie, url);
                        await this.setCookie(cookie, url);
                    }
        }
    }

    const LoggerSchema = Type.Object({
        info: Type.Function([], Type.Void()),
        warn: Type.Function([], Type.Void()),
        error: Type.Function([], Type.Void()),
        debug: Type.Function([], Type.Void()),
    });
    const ValidationOptionsSchema = Type.Object({
        logErrors: Type.Optional(Type.Boolean()),
        logOptionsErrors: Type.Optional(Type.Boolean()),
        _internalThrowOnAdditionalProperties: Type.Optional(Type.Boolean({
            default: process.env.NODE_ENV === "test",
            description: "Use this property to throw when properties beyond what is explicitly specified in the schema are provided. It is an internal option and subject to change, use at your own risk",
        })),
    });
    const YahooFinanceOptionsSchema = Type.Object({
        YF_QUERY_HOST: Type.Optional(Type.String()),
        cookieJar: Type.Optional(Type.Any()),
        queue: Type.Optional(QueueOptionsSchema),
        validation: Type.Optional(ValidationOptionsSchema),
        logger: Type.Optional(LoggerSchema),
    }, { title: "YahooFinanceOptions" });
    const options$1 = {
        YF_QUERY_HOST: process.env.YF_QUERY_HOST || "query2.finance.yahoo.com",
        cookieJar: new ExtendedCookieJar(),
        queue: {
            concurrency: 4, // Min: 1, Max: Infinity
            timeout: 60,
        },
        validation: {
            logErrors: true,
            logOptionsErrors: true,
        },
        logger: {
            info: (...args) => console.log(...args),
            warn: (...args) => console.warn(...args),
            error: (...args) => console.error(...args),
            debug: (...args) => console.log(...args),
        },
    };

    const logger = options$1.logger || console;
    const notices = {
        yahooSurvey: {
            id: "yahooSurvey",
            text: "Please consider completing the survey at https://bit.ly/yahoo-finance-api-feedback " +
                "if you haven't already; for more info see " +
                "https://github.com/gadicc/node-yahoo-finance2/issues/764#issuecomment-2056623851.",
            onceOnly: true,
        },
        ripHistorical: {
            id: "ripHistorical",
            text: "[Deprecated] historical() relies on an API that Yahoo have removed.  We'll " +
                "map this request to chart() for convenience, but, please consider using " +
                "chart() directly instead; for more info see " +
                "https://github.com/gadicc/node-yahoo-finance2/issues/795.",
            level: "warn",
            onceOnly: true,
        },
    };
    function showNotice(id) {
        const n = notices[id];
        if (!n)
            throw new Error(`Unknown notice id: ${id}`);
        if (n.suppress)
            return;
        if (n.onceOnly)
            n.suppress = true;
        const text = n.text +
            (n.onceOnly ? "  This will only be shown once, but you" : "You") +
            " can suppress this message in future with `yahooFinance.suppressNotices(['" +
            id +
            "'])`.";
        const level = n.level || "info";
        logger[level](text);
    }
    function suppressNotices(noticeIds) {
        noticeIds.forEach((id) => {
            const n = notices[id];
            if (!n)
                logger.error(`Unknown notice id: ${id}`);
            n.suppress = true;
        });
    }

    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore: we have to ignore this for csm output.
    const CONFIG_FAKE_URL = "http://config.yf2/";
    let crumb = null;
    const parseHtmlEntities = (str) => str.replace(/&#x([0-9A-Fa-f]{1,3});/gi, (_, numStr) => String.fromCharCode(parseInt(numStr, 16)));
    async function _getCrumb(cookieJar, fetch, fetchOptionsBase, logger, url = "https://finance.yahoo.com/quote/AAPL", develOverride = "getCrumb-quote-AAPL.json", noCache = false) {
        if (!crumb) {
            const cookies = await cookieJar.getCookies(CONFIG_FAKE_URL);
            for (const cookie of cookies) {
                if (cookie.key === "crumb") {
                    crumb = cookie.value;
                    logger.debug("Retrieved crumb from cookie store: " + crumb);
                    break;
                }
            }
        }
        if (crumb && !noCache) {
            // If we still have a valid (non-expired) cookie, return the existing crumb.
            const existingCookies = await cookieJar.getCookies(url, { expire: true });
            if (existingCookies.length)
                return crumb;
        }
        async function processSetCookieHeader(header, url) {
            if (header) {
                await cookieJar.setFromSetCookieHeaders(header, url);
                return true;
            }
            return false;
        }
        logger.debug("Fetching crumb and cookies from " + url + "...");
        const fetchOptions = {
            ...fetchOptionsBase,
            headers: {
                ...fetchOptionsBase.headers,
                // NB, we won't get a set-cookie header back without this:
                accept: "text/html,application/xhtml+xml,application/xml",
                // This request will get our first cookies, so nothing to send.
                // cookie: await cookieJar.getCookieString(url),
            },
            redirect: "manual",
            devel: fetchOptionsBase.devel && develOverride,
        };
        const response = await fetch(url, fetchOptions);
        await processSetCookieHeader(response.headers.getSetCookie(), url);
        // logger.debug(response.headers.raw());
        // logger.debug(cookieJar);
        const location = response.headers.get("location");
        if (location) {
            if (location.match(/guce.yahoo/)) {
                const consentFetchOptions = {
                    ...fetchOptions,
                    headers: {
                        ...fetchOptions.headers,
                        // GUCS=XXXXXXXX; Max-Age=1800; Domain=.yahoo.com; Path=/; Secure
                        cookie: await cookieJar.getCookieString(location),
                    },
                    devel: "getCrumb-quote-AAPL-consent.html",
                };
                // Returns 302 to collectConsent?sessionId=XXX
                logger.debug("fetch", location /*, consentFetchOptions */);
                const consentResponse = await fetch(location, consentFetchOptions);
                const consentLocation = consentResponse.headers.get("location");
                if (consentLocation) {
                    if (!consentLocation.match(/collectConsent/))
                        throw new Error("Unexpected redirect to " + consentLocation);
                    const collectConsentFetchOptions = {
                        ...consentFetchOptions,
                        headers: {
                            ...fetchOptions.headers,
                            cookie: await cookieJar.getCookieString(consentLocation),
                        },
                        devel: "getCrumb-quote-AAPL-collectConsent.html",
                    };
                    logger.debug("fetch", consentLocation /*, collectConsentFetchOptions */);
                    const collectConsentResponse = await fetch(consentLocation, collectConsentFetchOptions);
                    const collectConsentBody = await collectConsentResponse.text();
                    const collectConsentResponseParams = [
                        ...collectConsentBody.matchAll(/<input type="hidden" name="([^"]+)" value="([^"]+)">/g),
                    ]
                        .map(([, name, value]) => `${name}=${encodeURIComponent(parseHtmlEntities(value))}&`)
                        .join("") + "agree=agree&agree=agree";
                    const collectConsentSubmitFetchOptions = {
                        ...consentFetchOptions,
                        headers: {
                            ...fetchOptions.headers,
                            cookie: await cookieJar.getCookieString(consentLocation),
                            "content-type": "application/x-www-form-urlencoded",
                        },
                        method: "POST",
                        // body: "csrfToken=XjJfOYU&sessionId=3_cc-session_bd9a3b0c-c1b4-4aa8-8c18-7a82ec68a5d5&originalDoneUrl=https%3A%2F%2Ffinance.yahoo.com%2Fquote%2FAAPL%3Fguccounter%3D1&namespace=yahoo&agree=agree&agree=agree",
                        body: collectConsentResponseParams,
                        devel: "getCrumb-quote-AAPL-collectConsentSubmit",
                    };
                    logger.debug("fetch", consentLocation /*, collectConsentSubmitFetchOptions */);
                    const collectConsentSubmitResponse = await fetch(consentLocation, collectConsentSubmitFetchOptions);
                    // Set-Cookie: CFC=AQABCAFkWkdkjEMdLwQ9&s=AQAAAClxdtC-&g=ZFj24w; Expires=Wed, 8 May 2024 01:18:54 GMT; Domain=consent.yahoo.com; Path=/; Secure
                    if (!(await processSetCookieHeader(collectConsentSubmitResponse.headers.getSetCookie(), consentLocation)))
                        throw new Error("No set-cookie header on collectConsentSubmitResponse, please report.");
                    // https://guce.yahoo.com/copyConsent?sessionId=3_cc-session_04da10ea-1025-4676-8175-60d2508bfc6c&lang=en-GB
                    const collectConsentSubmitResponseLocation = collectConsentSubmitResponse.headers.get("location");
                    if (!collectConsentSubmitResponseLocation)
                        throw new Error("collectConsentSubmitResponse unexpectedly did not return a Location header, please report.");
                    const copyConsentFetchOptions = {
                        ...consentFetchOptions,
                        headers: {
                            ...fetchOptions.headers,
                            cookie: await cookieJar.getCookieString(collectConsentSubmitResponseLocation),
                        },
                        devel: "getCrumb-quote-AAPL-copyConsent",
                    };
                    logger.debug("fetch", collectConsentSubmitResponseLocation /*, copyConsentFetchOptions */);
                    const copyConsentResponse = await fetch(collectConsentSubmitResponseLocation, copyConsentFetchOptions);
                    if (!(await processSetCookieHeader(copyConsentResponse.headers.getSetCookie(), collectConsentSubmitResponseLocation)))
                        throw new Error("No set-cookie header on copyConsentResponse, please report.");
                    const copyConsentResponseLocation = copyConsentResponse.headers.get("location");
                    if (!copyConsentResponseLocation)
                        throw new Error("collectConsentSubmitResponse unexpectedly did not return a Location header, please report.");
                    const finalResponseFetchOptions = {
                        ...fetchOptions,
                        headers: {
                            ...fetchOptions.headers,
                            cookie: await cookieJar.getCookieString(collectConsentSubmitResponseLocation),
                        },
                        devel: "getCrumb-quote-AAPL-consent-final-redirect.html",
                    };
                    return await _getCrumb(cookieJar, fetch, finalResponseFetchOptions, logger, copyConsentResponseLocation, "getCrumb-quote-AAPL-consent-final-redirect.html", noCache);
                }
            }
            else {
                console.error("We expected a redirect to guce.yahoo.com, but got " + location);
                console.error("We'll try to continue anyway - you can safely ignore this if the request succeeds");
                // throw new Error(
                // "Unsupported redirect to " + location + ", please report.");
                // )
            }
        }
        const cookie = (await cookieJar.getCookies(url, { expire: true }))[0];
        if (cookie) {
            logger.debug("Success. Cookie expires on " + cookie.expires);
        }
        else {
            /*
            logger.error(
              "No cookie was retreieved.  Probably the next request " +
                "will fail.  Please report."
            );
            */
            throw new Error("No set-cookie header present in Yahoo's response.  Something must have changed, please report.");
        }
        /*
        // This is the old way of getting the crumb, which is no longer working.
        // Instead we make use of the code block that follows this comment, which
        // uses the `/v1/test/getcrumb` endpoint.  However, the commented code
        // below may still be useful in the future, so it is left here for now.
      
        const source = await response.text();
      
        // Could also match on window.YAHOO.context = { /* multi-line JSON */ /* }
        const match = source.match(/\nwindow.YAHOO.context = ({[\s\S]+\n});\n/);
        if (!match) {
          throw new Error(
            "Could not find window.YAHOO.context.  This is usually caused by " +
              "temporary issues on Yahoo's servers that tend to resolve " +
              "themselves; however, if the error persists for more than 12 " +
              "hours, Yahoo's API may have changed, and you can help by reporting " +
              "the issue.  Thanks :)"
          );
        }
      
        let context;
        try {
          context = JSON.parse(match[1]);
        } catch (error) {
          logger.debug(match[1]);
          logger.error(error);
          throw new Error(
            "Could not parse window.YAHOO.context.  Yahoo's API may have changed; please report."
          );
        }
      
        crumb = context.crumb;
        */
        const GET_CRUMB_URL = "https://query1.finance.yahoo.com/v1/test/getcrumb";
        const getCrumbOptions = {
            ...fetchOptions,
            headers: {
                ...fetchOptions.headers,
                // Big thanks to @nocodehummel who figured out a User-Agent that both
                // works but still allows us to identify ourselves honestly.
                "User-Agent": `Mozilla/5.0 (compatible; ${pkg.name}/${pkg.version})`,
                cookie: await cookieJar.getCookieString(GET_CRUMB_URL),
                origin: "https://finance.yahoo.com",
                referer: url,
                accept: "*/*",
                "accept-encoding": "gzip, deflate, br",
                "accept-language": "en-US,en;q=0.9",
                "content-type": "text/plain",
            },
            devel: "getCrumb-getcrumb",
        };
        logger.debug("fetch", GET_CRUMB_URL /*, getCrumbOptions */);
        const getCrumbResponse = await fetch(GET_CRUMB_URL, getCrumbOptions);
        if (getCrumbResponse.status !== 200) {
            throw new Error("Failed to get crumb, status " +
                getCrumbResponse.status +
                ", statusText: " +
                getCrumbResponse.statusText);
        }
        const crumbFromGetCrumb = await getCrumbResponse.text();
        crumb = crumbFromGetCrumb;
        if (!crumb)
            throw new Error("Could not find crumb.  Yahoo's API may have changed; please report.");
        logger.debug("New crumb: " + crumb);
        await cookieJar.setCookie(new cookieExports.Cookie({
            key: "crumb",
            value: crumb,
        }), CONFIG_FAKE_URL);
        promise = null;
        return crumb;
    }
    let promise = null;
    function getCrumb(cookieJar, fetch, fetchOptionsBase, logger, url = "https://finance.yahoo.com/quote/AAPL", __getCrumb = _getCrumb) {
        showNotice("yahooSurvey");
        if (!promise)
            promise = __getCrumb(cookieJar, fetch, fetchOptionsBase, logger, url);
        return promise;
    }

    const userAgent = `${pkg.name}/${pkg.version} (+${pkg.repository})`;
    const _queue = new Queue();
    function assertQueueOptions(queue, opts) {
        if (typeof opts.concurrency === "number" &&
            queue.concurrency !== opts.concurrency)
            queue.concurrency = opts.concurrency;
        if (typeof opts.timeout === "number" && queue.timeout !== opts.timeout)
            queue.timeout = opts.timeout;
    }
    function substituteVariables(urlBase) {
        return urlBase.replace(/\$\{([^}]+)\}/g, (match, varName) => {
            if (varName === "YF_QUERY_HOST") {
                // const hosts = ["query1.finance.yahoo.com", "query2.finance.yahoo.com"];
                // return hosts[Math.floor(Math.random() * hosts.length)];
                return this._opts.YF_QUERY_HOST || "query2.finance.yahoo.com";
            }
            else {
                // i.e. return unsubstituted original variable expression ${VAR}
                return match;
            }
        });
    }
    async function yahooFinanceFetch(urlBase, params = {}, moduleOpts = {}, func = "json", needsCrumb = false) {
        var _a;
        if (!(this && this._env))
            throw new errors$1.NoEnvironmentError("yahooFinanceFetch called without this._env set");
        // TODO: adds func type to json schema which is not supported
        //const queue = moduleOpts.queue?._queue || _queue;
        const queue = _queue;
        assertQueueOptions(queue, { ...this._opts.queue, ...moduleOpts.queue });
        const { URLSearchParams, fetch, fetchDevel } = this._env;
        /* istanbul ignore next */
        // no need to force coverage on real network request.
        const fetchFunc = moduleOpts.devel ? await fetchDevel() : fetch;
        const fetchOptionsBase = {
            ...moduleOpts.fetchOptions,
            devel: moduleOpts.devel,
            headers: {
                "User-Agent": userAgent,
                ...(_a = moduleOpts.fetchOptions) === null || _a === void 0 ? void 0 : _a.headers,
            },
        };
        if (needsCrumb) {
            if (!this._opts.cookieJar)
                throw new Error("No cookieJar set");
            if (!this._opts.logger)
                throw new Error("Logger was unset.");
            const crumb = await getCrumb(this._opts.cookieJar, fetchFunc, fetchOptionsBase, this._opts.logger);
            if (crumb)
                params.crumb = crumb;
        }
        // @ts-expect-error: TODO copy interface? @types lib?
        const urlSearchParams = new URLSearchParams(params);
        const url = substituteVariables.call(this, urlBase) + "?" + urlSearchParams.toString();
        // console.log(url);
        // console.log(cookieJar.serializeSync());
        if (!this._opts.cookieJar)
            throw new Error("No cookieJar set");
        const fetchOptions = {
            ...fetchOptionsBase,
            headers: {
                ...fetchOptionsBase.headers,
                cookie: await this._opts.cookieJar.getCookieString(url, {
                    allPaths: true,
                }),
            },
        };
        // console.log("fetch", url, fetchOptions);
        // used in moduleExec.ts
        if (func === "csv")
            func = "text";
        const response = (await queue.add(() => fetchFunc(url, fetchOptions)));
        const setCookieHeaders = response.headers.getSetCookie();
        if (setCookieHeaders) {
            if (!this._opts.cookieJar)
                throw new Error("No cookieJar set");
            this._opts.cookieJar.setFromSetCookieHeaders(setCookieHeaders, url);
        }
        const result = await response[func]();
        /*
          {
            finance: {  // or quoteSummary, or any other single key
              result: null,
              error: {
                code: 'Bad Request',
                description: 'Missing required query parameter=q'
              }
            }
          }
         */
        if (func === "json") {
            const keys = Object.keys(result);
            if (keys.length === 1) {
                const errorObj = result[keys[0]].error;
                if (errorObj) {
                    const errorName = errorObj.code.replace(/ /g, "") + "Error";
                    const ErrorClass = errors$1[errorName] || Error;
                    throw new ErrorClass(errorObj.description);
                }
            }
        }
        // We do this last as it generally contains less information (e.g. no desc).
        if (!response.ok) {
            console.error(url);
            const error = new errors$1.HTTPError(response.statusText);
            error.code = response.status;
            throw error;
        }
        return result;
    }

    // --------------------------------------------------------------------------
    // Iterators
    // --------------------------------------------------------------------------
    /** Returns true if this value is an async iterator */
    function IsAsyncIterator(value) {
        return IsObject(value) && Symbol.asyncIterator in value;
    }
    /** Returns true if this value is an iterator */
    function IsIterator(value) {
        return IsObject(value) && Symbol.iterator in value;
    }
    // --------------------------------------------------------------------------
    // Object Instances
    // --------------------------------------------------------------------------
    /** Returns true if this value is not an instance of a class */
    function IsStandardObject(value) {
        return IsObject(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
    }
    // --------------------------------------------------------------------------
    // JavaScript
    // --------------------------------------------------------------------------
    /** Returns true if this value is a Promise */
    function IsPromise(value) {
        return value instanceof Promise;
    }
    /** Returns true if this value is a Date */
    function IsDate(value) {
        return value instanceof Date && Number.isFinite(value.getTime());
    }
    /** Returns true if the value is a Uint8Array */
    function IsUint8Array(value) {
        return value instanceof globalThis.Uint8Array;
    }
    /** Returns true of this value is an object type */
    function IsObject(value) {
        return value !== null && typeof value === 'object';
    }
    /** Returns true if this value is an array, but not a typed array */
    function IsArray(value) {
        return Array.isArray(value) && !ArrayBuffer.isView(value);
    }
    /** Returns true if this value is an undefined */
    function IsUndefined(value) {
        return value === undefined;
    }
    /** Returns true if this value is an null */
    function IsNull(value) {
        return value === null;
    }
    /** Returns true if this value is an boolean */
    function IsBoolean(value) {
        return typeof value === 'boolean';
    }
    /** Returns true if this value is an number */
    function IsNumber(value) {
        return typeof value === 'number';
    }
    /** Returns true if this value is an integer */
    function IsInteger(value) {
        return Number.isInteger(value);
    }
    /** Returns true if this value is bigint */
    function IsBigInt(value) {
        return typeof value === 'bigint';
    }
    /** Returns true if this value is string */
    function IsString(value) {
        return typeof value === 'string';
    }
    /** Returns true if this value is a function */
    function IsFunction(value) {
        return typeof value === 'function';
    }
    /** Returns true if this value is a symbol */
    function IsSymbol(value) {
        return typeof value === 'symbol';
    }
    /** Returns true if this value is a value type such as number, string, boolean */
    function IsValueType(value) {
        // prettier-ignore
        return (IsBigInt(value) ||
            IsBoolean(value) ||
            IsNull(value) ||
            IsNumber(value) ||
            IsString(value) ||
            IsSymbol(value) ||
            IsUndefined(value));
    }

    var TypeSystemPolicy;
    (function (TypeSystemPolicy) {
        // ------------------------------------------------------------------
        // TypeSystemPolicy
        // ------------------------------------------------------------------
        /** Shared assertion routines used by the value and errors modules */
        /** Sets whether TypeBox should assert optional properties using the TypeScript `exactOptionalPropertyTypes` assertion policy. The default is `false` */
        TypeSystemPolicy.ExactOptionalPropertyTypes = false;
        /** Sets whether arrays should be treated as a kind of objects. The default is `false` */
        TypeSystemPolicy.AllowArrayObject = false;
        /** Sets whether `NaN` or `Infinity` should be treated as valid numeric values. The default is `false` */
        TypeSystemPolicy.AllowNaN = false;
        /** Sets whether `null` should validate for void types. The default is `false` */
        TypeSystemPolicy.AllowNullVoid = false;
        /** Asserts this value using the ExactOptionalPropertyTypes policy */
        function IsExactOptionalProperty(value, key) {
            return TypeSystemPolicy.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
        }
        TypeSystemPolicy.IsExactOptionalProperty = IsExactOptionalProperty;
        /** Asserts this value using the AllowArrayObjects policy */
        function IsObjectLike(value) {
            const isObject = IsObject(value);
            return TypeSystemPolicy.AllowArrayObject ? isObject : isObject && !IsArray(value);
        }
        TypeSystemPolicy.IsObjectLike = IsObjectLike;
        /** Asserts this value as a record using the AllowArrayObjects policy */
        function IsRecordLike(value) {
            return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
        }
        TypeSystemPolicy.IsRecordLike = IsRecordLike;
        /** Asserts this value using the AllowNaN policy */
        function IsNumberLike(value) {
            return TypeSystemPolicy.AllowNaN ? IsNumber(value) : Number.isFinite(value);
        }
        TypeSystemPolicy.IsNumberLike = IsNumberLike;
        /** Asserts this value using the AllowVoidNull policy */
        function IsVoidLike(value) {
            const isUndefined = IsUndefined(value);
            return TypeSystemPolicy.AllowNullVoid ? isUndefined || value === null : isUndefined;
        }
        TypeSystemPolicy.IsVoidLike = IsVoidLike;
    })(TypeSystemPolicy || (TypeSystemPolicy = {}));

    // ------------------------------------------------------------------
    // Errors
    // ------------------------------------------------------------------
    class TypeSystemDuplicateTypeKind extends TypeBoxError {
        constructor(kind) {
            super(`Duplicate type kind '${kind}' detected`);
        }
    }
    class TypeSystemDuplicateFormat extends TypeBoxError {
        constructor(kind) {
            super(`Duplicate string format '${kind}' detected`);
        }
    }
    /** Creates user defined types and formats and provides overrides for value checking behaviours */
    var TypeSystem;
    (function (TypeSystem) {
        /** Creates a new type */
        function Type(kind, check) {
            if (Has(kind))
                throw new TypeSystemDuplicateTypeKind(kind);
            Set$1(kind, check);
            return (options = {}) => Unsafe({ ...options, [Kind]: kind });
        }
        TypeSystem.Type = Type;
        /** Creates a new string format */
        function Format(format, check) {
            if (Has$1(format))
                throw new TypeSystemDuplicateFormat(format);
            Set$2(format, check);
            return format;
        }
        TypeSystem.Format = Format;
    })(TypeSystem || (TypeSystem = {}));

    /** Creates an error message using en-US as the default locale */
    function DefaultErrorFunction(error) {
        switch (error.errorType) {
            case ValueErrorType.ArrayContains:
                return 'Expected array to contain at least one matching value';
            case ValueErrorType.ArrayMaxContains:
                return `Expected array to contain no more than ${error.schema.maxContains} matching values`;
            case ValueErrorType.ArrayMinContains:
                return `Expected array to contain at least ${error.schema.minContains} matching values`;
            case ValueErrorType.ArrayMaxItems:
                return `Expected array length to be less or equal to ${error.schema.maxItems}`;
            case ValueErrorType.ArrayMinItems:
                return `Expected array length to be greater or equal to ${error.schema.minItems}`;
            case ValueErrorType.ArrayUniqueItems:
                return 'Expected array elements to be unique';
            case ValueErrorType.Array:
                return 'Expected array';
            case ValueErrorType.AsyncIterator:
                return 'Expected AsyncIterator';
            case ValueErrorType.BigIntExclusiveMaximum:
                return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;
            case ValueErrorType.BigIntExclusiveMinimum:
                return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;
            case ValueErrorType.BigIntMaximum:
                return `Expected bigint to be less or equal to ${error.schema.maximum}`;
            case ValueErrorType.BigIntMinimum:
                return `Expected bigint to be greater or equal to ${error.schema.minimum}`;
            case ValueErrorType.BigIntMultipleOf:
                return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;
            case ValueErrorType.BigInt:
                return 'Expected bigint';
            case ValueErrorType.Boolean:
                return 'Expected boolean';
            case ValueErrorType.DateExclusiveMinimumTimestamp:
                return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;
            case ValueErrorType.DateExclusiveMaximumTimestamp:
                return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;
            case ValueErrorType.DateMinimumTimestamp:
                return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;
            case ValueErrorType.DateMaximumTimestamp:
                return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;
            case ValueErrorType.DateMultipleOfTimestamp:
                return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;
            case ValueErrorType.Date:
                return 'Expected Date';
            case ValueErrorType.Function:
                return 'Expected function';
            case ValueErrorType.IntegerExclusiveMaximum:
                return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;
            case ValueErrorType.IntegerExclusiveMinimum:
                return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;
            case ValueErrorType.IntegerMaximum:
                return `Expected integer to be less or equal to ${error.schema.maximum}`;
            case ValueErrorType.IntegerMinimum:
                return `Expected integer to be greater or equal to ${error.schema.minimum}`;
            case ValueErrorType.IntegerMultipleOf:
                return `Expected integer to be a multiple of ${error.schema.multipleOf}`;
            case ValueErrorType.Integer:
                return 'Expected integer';
            case ValueErrorType.IntersectUnevaluatedProperties:
                return 'Unexpected property';
            case ValueErrorType.Intersect:
                return 'Expected all values to match';
            case ValueErrorType.Iterator:
                return 'Expected Iterator';
            case ValueErrorType.Literal:
                return `Expected ${typeof error.schema.const === 'string' ? `'${error.schema.const}'` : error.schema.const}`;
            case ValueErrorType.Never:
                return 'Never';
            case ValueErrorType.Not:
                return 'Value should not match';
            case ValueErrorType.Null:
                return 'Expected null';
            case ValueErrorType.NumberExclusiveMaximum:
                return `Expected number to be less than ${error.schema.exclusiveMaximum}`;
            case ValueErrorType.NumberExclusiveMinimum:
                return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;
            case ValueErrorType.NumberMaximum:
                return `Expected number to be less or equal to ${error.schema.maximum}`;
            case ValueErrorType.NumberMinimum:
                return `Expected number to be greater or equal to ${error.schema.minimum}`;
            case ValueErrorType.NumberMultipleOf:
                return `Expected number to be a multiple of ${error.schema.multipleOf}`;
            case ValueErrorType.Number:
                return 'Expected number';
            case ValueErrorType.Object:
                return 'Expected object';
            case ValueErrorType.ObjectAdditionalProperties:
                return 'Unexpected property';
            case ValueErrorType.ObjectMaxProperties:
                return `Expected object to have no more than ${error.schema.maxProperties} properties`;
            case ValueErrorType.ObjectMinProperties:
                return `Expected object to have at least ${error.schema.minProperties} properties`;
            case ValueErrorType.ObjectRequiredProperty:
                return 'Expected required property';
            case ValueErrorType.Promise:
                return 'Expected Promise';
            case ValueErrorType.RegExp:
                return 'Expected string to match regular expression';
            case ValueErrorType.StringFormatUnknown:
                return `Unknown format '${error.schema.format}'`;
            case ValueErrorType.StringFormat:
                return `Expected string to match '${error.schema.format}' format`;
            case ValueErrorType.StringMaxLength:
                return `Expected string length less or equal to ${error.schema.maxLength}`;
            case ValueErrorType.StringMinLength:
                return `Expected string length greater or equal to ${error.schema.minLength}`;
            case ValueErrorType.StringPattern:
                return `Expected string to match '${error.schema.pattern}'`;
            case ValueErrorType.String:
                return 'Expected string';
            case ValueErrorType.Symbol:
                return 'Expected symbol';
            case ValueErrorType.TupleLength:
                return `Expected tuple to have ${error.schema.maxItems || 0} elements`;
            case ValueErrorType.Tuple:
                return 'Expected tuple';
            case ValueErrorType.Uint8ArrayMaxByteLength:
                return `Expected byte length less or equal to ${error.schema.maxByteLength}`;
            case ValueErrorType.Uint8ArrayMinByteLength:
                return `Expected byte length greater or equal to ${error.schema.minByteLength}`;
            case ValueErrorType.Uint8Array:
                return 'Expected Uint8Array';
            case ValueErrorType.Undefined:
                return 'Expected undefined';
            case ValueErrorType.Union:
                return 'Expected union value';
            case ValueErrorType.Void:
                return 'Expected void';
            case ValueErrorType.Kind:
                return `Expected kind '${error.schema[Kind]}'`;
            default:
                return 'Unknown error type';
        }
    }
    /** Manages error message providers */
    let errorFunction = DefaultErrorFunction;
    /** Gets the error function used to generate error messages */
    function GetErrorFunction() {
        return errorFunction;
    }

    class TypeDereferenceError extends TypeBoxError {
        constructor(schema) {
            super(`Unable to dereference schema with $id '${schema.$id}'`);
            this.schema = schema;
        }
    }
    function Resolve(schema, references) {
        const target = references.find((target) => target.$id === schema.$ref);
        if (target === undefined)
            throw new TypeDereferenceError(schema);
        return Deref(target, references);
    }
    /** Dereferences a schema from the references array or throws if not found */
    function Deref(schema, references) {
        // prettier-ignore
        return (schema[Kind] === 'This' || schema[Kind] === 'Ref')
            ? Resolve(schema, references)
            : schema;
    }

    // ------------------------------------------------------------------
    // Errors
    // ------------------------------------------------------------------
    class ValueHashError extends TypeBoxError {
        constructor(value) {
            super(`Unable to hash value`);
            this.value = value;
        }
    }
    // ------------------------------------------------------------------
    // ByteMarker
    // ------------------------------------------------------------------
    var ByteMarker;
    (function (ByteMarker) {
        ByteMarker[ByteMarker["Undefined"] = 0] = "Undefined";
        ByteMarker[ByteMarker["Null"] = 1] = "Null";
        ByteMarker[ByteMarker["Boolean"] = 2] = "Boolean";
        ByteMarker[ByteMarker["Number"] = 3] = "Number";
        ByteMarker[ByteMarker["String"] = 4] = "String";
        ByteMarker[ByteMarker["Object"] = 5] = "Object";
        ByteMarker[ByteMarker["Array"] = 6] = "Array";
        ByteMarker[ByteMarker["Date"] = 7] = "Date";
        ByteMarker[ByteMarker["Uint8Array"] = 8] = "Uint8Array";
        ByteMarker[ByteMarker["Symbol"] = 9] = "Symbol";
        ByteMarker[ByteMarker["BigInt"] = 10] = "BigInt";
    })(ByteMarker || (ByteMarker = {}));
    // ------------------------------------------------------------------
    // State
    // ------------------------------------------------------------------
    let Accumulator = BigInt('14695981039346656037');
    const [Prime, Size] = [BigInt('1099511628211'), BigInt('2') ** BigInt('64')];
    const Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
    const F64 = new Float64Array(1);
    const F64In = new DataView(F64.buffer);
    const F64Out = new Uint8Array(F64.buffer);
    // ------------------------------------------------------------------
    // NumberToBytes
    // ------------------------------------------------------------------
    function* NumberToBytes(value) {
        const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
        for (let i = 0; i < byteCount; i++) {
            yield (value >> (8 * (byteCount - 1 - i))) & 0xff;
        }
    }
    // ------------------------------------------------------------------
    // Hashing Functions
    // ------------------------------------------------------------------
    function ArrayType(value) {
        FNV1A64(ByteMarker.Array);
        for (const item of value) {
            Visit$5(item);
        }
    }
    function BooleanType(value) {
        FNV1A64(ByteMarker.Boolean);
        FNV1A64(value ? 1 : 0);
    }
    function BigIntType(value) {
        FNV1A64(ByteMarker.BigInt);
        F64In.setBigInt64(0, value);
        for (const byte of F64Out) {
            FNV1A64(byte);
        }
    }
    function DateType(value) {
        FNV1A64(ByteMarker.Date);
        Visit$5(value.getTime());
    }
    function NullType(value) {
        FNV1A64(ByteMarker.Null);
    }
    function NumberType(value) {
        FNV1A64(ByteMarker.Number);
        F64In.setFloat64(0, value);
        for (const byte of F64Out) {
            FNV1A64(byte);
        }
    }
    function ObjectType(value) {
        FNV1A64(ByteMarker.Object);
        for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
            Visit$5(key);
            Visit$5(value[key]);
        }
    }
    function StringType(value) {
        FNV1A64(ByteMarker.String);
        for (let i = 0; i < value.length; i++) {
            for (const byte of NumberToBytes(value.charCodeAt(i))) {
                FNV1A64(byte);
            }
        }
    }
    function SymbolType(value) {
        FNV1A64(ByteMarker.Symbol);
        Visit$5(value.description);
    }
    function Uint8ArrayType(value) {
        FNV1A64(ByteMarker.Uint8Array);
        for (let i = 0; i < value.length; i++) {
            FNV1A64(value[i]);
        }
    }
    function UndefinedType(value) {
        return FNV1A64(ByteMarker.Undefined);
    }
    function Visit$5(value) {
        if (IsArray(value))
            return ArrayType(value);
        if (IsBoolean(value))
            return BooleanType(value);
        if (IsBigInt(value))
            return BigIntType(value);
        if (IsDate(value))
            return DateType(value);
        if (IsNull(value))
            return NullType();
        if (IsNumber(value))
            return NumberType(value);
        if (IsStandardObject(value))
            return ObjectType(value);
        if (IsString(value))
            return StringType(value);
        if (IsSymbol(value))
            return SymbolType(value);
        if (IsUint8Array(value))
            return Uint8ArrayType(value);
        if (IsUndefined(value))
            return UndefinedType();
        throw new ValueHashError(value);
    }
    function FNV1A64(byte) {
        Accumulator = Accumulator ^ Bytes[byte];
        Accumulator = (Accumulator * Prime) % Size;
    }
    // ------------------------------------------------------------------
    // Hash
    // ------------------------------------------------------------------
    /** Creates a FNV1A-64 non cryptographic hash of the given value */
    function Hash(value) {
        Accumulator = BigInt('14695981039346656037');
        Visit$5(value);
        return Accumulator;
    }

    // ------------------------------------------------------------------
    // ValueErrorType
    // ------------------------------------------------------------------
    var ValueErrorType;
    (function (ValueErrorType) {
        ValueErrorType[ValueErrorType["ArrayContains"] = 0] = "ArrayContains";
        ValueErrorType[ValueErrorType["ArrayMaxContains"] = 1] = "ArrayMaxContains";
        ValueErrorType[ValueErrorType["ArrayMaxItems"] = 2] = "ArrayMaxItems";
        ValueErrorType[ValueErrorType["ArrayMinContains"] = 3] = "ArrayMinContains";
        ValueErrorType[ValueErrorType["ArrayMinItems"] = 4] = "ArrayMinItems";
        ValueErrorType[ValueErrorType["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
        ValueErrorType[ValueErrorType["Array"] = 6] = "Array";
        ValueErrorType[ValueErrorType["AsyncIterator"] = 7] = "AsyncIterator";
        ValueErrorType[ValueErrorType["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
        ValueErrorType[ValueErrorType["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
        ValueErrorType[ValueErrorType["BigIntMaximum"] = 10] = "BigIntMaximum";
        ValueErrorType[ValueErrorType["BigIntMinimum"] = 11] = "BigIntMinimum";
        ValueErrorType[ValueErrorType["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
        ValueErrorType[ValueErrorType["BigInt"] = 13] = "BigInt";
        ValueErrorType[ValueErrorType["Boolean"] = 14] = "Boolean";
        ValueErrorType[ValueErrorType["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
        ValueErrorType[ValueErrorType["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
        ValueErrorType[ValueErrorType["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
        ValueErrorType[ValueErrorType["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
        ValueErrorType[ValueErrorType["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
        ValueErrorType[ValueErrorType["Date"] = 20] = "Date";
        ValueErrorType[ValueErrorType["Function"] = 21] = "Function";
        ValueErrorType[ValueErrorType["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
        ValueErrorType[ValueErrorType["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
        ValueErrorType[ValueErrorType["IntegerMaximum"] = 24] = "IntegerMaximum";
        ValueErrorType[ValueErrorType["IntegerMinimum"] = 25] = "IntegerMinimum";
        ValueErrorType[ValueErrorType["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
        ValueErrorType[ValueErrorType["Integer"] = 27] = "Integer";
        ValueErrorType[ValueErrorType["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
        ValueErrorType[ValueErrorType["Intersect"] = 29] = "Intersect";
        ValueErrorType[ValueErrorType["Iterator"] = 30] = "Iterator";
        ValueErrorType[ValueErrorType["Kind"] = 31] = "Kind";
        ValueErrorType[ValueErrorType["Literal"] = 32] = "Literal";
        ValueErrorType[ValueErrorType["Never"] = 33] = "Never";
        ValueErrorType[ValueErrorType["Not"] = 34] = "Not";
        ValueErrorType[ValueErrorType["Null"] = 35] = "Null";
        ValueErrorType[ValueErrorType["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
        ValueErrorType[ValueErrorType["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
        ValueErrorType[ValueErrorType["NumberMaximum"] = 38] = "NumberMaximum";
        ValueErrorType[ValueErrorType["NumberMinimum"] = 39] = "NumberMinimum";
        ValueErrorType[ValueErrorType["NumberMultipleOf"] = 40] = "NumberMultipleOf";
        ValueErrorType[ValueErrorType["Number"] = 41] = "Number";
        ValueErrorType[ValueErrorType["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
        ValueErrorType[ValueErrorType["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
        ValueErrorType[ValueErrorType["ObjectMinProperties"] = 44] = "ObjectMinProperties";
        ValueErrorType[ValueErrorType["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
        ValueErrorType[ValueErrorType["Object"] = 46] = "Object";
        ValueErrorType[ValueErrorType["Promise"] = 47] = "Promise";
        ValueErrorType[ValueErrorType["RegExp"] = 48] = "RegExp";
        ValueErrorType[ValueErrorType["StringFormatUnknown"] = 49] = "StringFormatUnknown";
        ValueErrorType[ValueErrorType["StringFormat"] = 50] = "StringFormat";
        ValueErrorType[ValueErrorType["StringMaxLength"] = 51] = "StringMaxLength";
        ValueErrorType[ValueErrorType["StringMinLength"] = 52] = "StringMinLength";
        ValueErrorType[ValueErrorType["StringPattern"] = 53] = "StringPattern";
        ValueErrorType[ValueErrorType["String"] = 54] = "String";
        ValueErrorType[ValueErrorType["Symbol"] = 55] = "Symbol";
        ValueErrorType[ValueErrorType["TupleLength"] = 56] = "TupleLength";
        ValueErrorType[ValueErrorType["Tuple"] = 57] = "Tuple";
        ValueErrorType[ValueErrorType["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
        ValueErrorType[ValueErrorType["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
        ValueErrorType[ValueErrorType["Uint8Array"] = 60] = "Uint8Array";
        ValueErrorType[ValueErrorType["Undefined"] = 61] = "Undefined";
        ValueErrorType[ValueErrorType["Union"] = 62] = "Union";
        ValueErrorType[ValueErrorType["Void"] = 63] = "Void";
    })(ValueErrorType || (ValueErrorType = {}));
    // ------------------------------------------------------------------
    // ValueErrors
    // ------------------------------------------------------------------
    class ValueErrorsUnknownTypeError extends TypeBoxError {
        constructor(schema) {
            super('Unknown type');
            this.schema = schema;
        }
    }
    // ------------------------------------------------------------------
    // EscapeKey
    // ------------------------------------------------------------------
    function EscapeKey(key) {
        return key.replace(/~/g, '~0').replace(/\//g, '~1'); // RFC6901 Path
    }
    // ------------------------------------------------------------------
    // Guards
    // ------------------------------------------------------------------
    function IsDefined$1(value) {
        return value !== undefined;
    }
    // ------------------------------------------------------------------
    // ValueErrorIterator
    // ------------------------------------------------------------------
    class ValueErrorIterator {
        constructor(iterator) {
            this.iterator = iterator;
        }
        [Symbol.iterator]() {
            return this.iterator;
        }
        /** Returns the first value error or undefined if no errors */
        First() {
            const next = this.iterator.next();
            return next.done ? undefined : next.value;
        }
    }
    // --------------------------------------------------------------------------
    // Create
    // --------------------------------------------------------------------------
    function Create(errorType, schema, path, value) {
        return { type: errorType, schema, path, value, message: GetErrorFunction()({ errorType, path, schema, value }) };
    }
    // --------------------------------------------------------------------------
    // Types
    // --------------------------------------------------------------------------
    function* FromAny$1(schema, references, path, value) { }
    function* FromArray$4(schema, references, path, value) {
        if (!IsArray(value)) {
            return yield Create(ValueErrorType.Array, schema, path, value);
        }
        if (IsDefined$1(schema.minItems) && !(value.length >= schema.minItems)) {
            yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
        }
        if (IsDefined$1(schema.maxItems) && !(value.length <= schema.maxItems)) {
            yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
        }
        for (let i = 0; i < value.length; i++) {
            yield* Visit$4(schema.items, references, `${path}/${i}`, value[i]);
        }
        // prettier-ignore
        if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {
            const hashed = Hash(element);
            if (set.has(hashed)) {
                return false;
            }
            else {
                set.add(hashed);
            }
        } return true; })())) {
            yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
        }
        // contains
        if (!(IsDefined$1(schema.contains) || IsDefined$1(schema.minContains) || IsDefined$1(schema.maxContains))) {
            return;
        }
        const containsSchema = IsDefined$1(schema.contains) ? schema.contains : Never();
        const containsCount = value.reduce((acc, value, index) => (Visit$4(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc), 0);
        if (containsCount === 0) {
            yield Create(ValueErrorType.ArrayContains, schema, path, value);
        }
        if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
            yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
        }
        if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
            yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
        }
    }
    function* FromAsyncIterator$2(schema, references, path, value) {
        if (!IsAsyncIterator(value))
            yield Create(ValueErrorType.AsyncIterator, schema, path, value);
    }
    function* FromBigInt$1(schema, references, path, value) {
        if (!IsBigInt(value))
            return yield Create(ValueErrorType.BigInt, schema, path, value);
        if (IsDefined$1(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
            yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
        }
        if (IsDefined$1(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
            yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
        }
        if (IsDefined$1(schema.maximum) && !(value <= schema.maximum)) {
            yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
        }
        if (IsDefined$1(schema.minimum) && !(value >= schema.minimum)) {
            yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
        }
        if (IsDefined$1(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
            yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
        }
    }
    function* FromBoolean$1(schema, references, path, value) {
        if (!IsBoolean(value))
            yield Create(ValueErrorType.Boolean, schema, path, value);
    }
    function* FromConstructor$2(schema, references, path, value) {
        yield* Visit$4(schema.returns, references, path, value.prototype);
    }
    function* FromDate$1(schema, references, path, value) {
        if (!IsDate(value))
            return yield Create(ValueErrorType.Date, schema, path, value);
        if (IsDefined$1(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
            yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
        }
        if (IsDefined$1(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
            yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
        }
        if (IsDefined$1(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
            yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
        }
        if (IsDefined$1(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
            yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
        }
        if (IsDefined$1(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
            yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
        }
    }
    function* FromFunction$2(schema, references, path, value) {
        if (!IsFunction(value))
            yield Create(ValueErrorType.Function, schema, path, value);
    }
    function* FromInteger$1(schema, references, path, value) {
        if (!IsInteger(value))
            return yield Create(ValueErrorType.Integer, schema, path, value);
        if (IsDefined$1(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
            yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
        }
        if (IsDefined$1(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
            yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
        }
        if (IsDefined$1(schema.maximum) && !(value <= schema.maximum)) {
            yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
        }
        if (IsDefined$1(schema.minimum) && !(value >= schema.minimum)) {
            yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
        }
        if (IsDefined$1(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
            yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
        }
    }
    function* FromIntersect$4(schema, references, path, value) {
        for (const inner of schema.allOf) {
            const next = Visit$4(inner, references, path, value).next();
            if (!next.done) {
                yield Create(ValueErrorType.Intersect, schema, path, value);
                yield next.value;
            }
        }
        if (schema.unevaluatedProperties === false) {
            const keyCheck = new RegExp(KeyOfPattern(schema));
            for (const valueKey of Object.getOwnPropertyNames(value)) {
                if (!keyCheck.test(valueKey)) {
                    yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
                }
            }
        }
        if (typeof schema.unevaluatedProperties === 'object') {
            const keyCheck = new RegExp(KeyOfPattern(schema));
            for (const valueKey of Object.getOwnPropertyNames(value)) {
                if (!keyCheck.test(valueKey)) {
                    const next = Visit$4(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
                    if (!next.done)
                        yield next.value; // yield interior
                }
            }
        }
    }
    function* FromIterator$2(schema, references, path, value) {
        if (!IsIterator(value))
            yield Create(ValueErrorType.Iterator, schema, path, value);
    }
    function* FromLiteral$1(schema, references, path, value) {
        if (!(value === schema.const))
            yield Create(ValueErrorType.Literal, schema, path, value);
    }
    function* FromNever$1(schema, references, path, value) {
        yield Create(ValueErrorType.Never, schema, path, value);
    }
    function* FromNot$4(schema, references, path, value) {
        if (Visit$4(schema.not, references, path, value).next().done === true)
            yield Create(ValueErrorType.Not, schema, path, value);
    }
    function* FromNull$1(schema, references, path, value) {
        if (!IsNull(value))
            yield Create(ValueErrorType.Null, schema, path, value);
    }
    function* FromNumber$1(schema, references, path, value) {
        if (!TypeSystemPolicy.IsNumberLike(value))
            return yield Create(ValueErrorType.Number, schema, path, value);
        if (IsDefined$1(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
            yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
        }
        if (IsDefined$1(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
            yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
        }
        if (IsDefined$1(schema.maximum) && !(value <= schema.maximum)) {
            yield Create(ValueErrorType.NumberMaximum, schema, path, value);
        }
        if (IsDefined$1(schema.minimum) && !(value >= schema.minimum)) {
            yield Create(ValueErrorType.NumberMinimum, schema, path, value);
        }
        if (IsDefined$1(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
            yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
        }
    }
    function* FromObject$4(schema, references, path, value) {
        if (!TypeSystemPolicy.IsObjectLike(value))
            return yield Create(ValueErrorType.Object, schema, path, value);
        if (IsDefined$1(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
            yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
        }
        if (IsDefined$1(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
            yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
        }
        const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
        const knownKeys = Object.getOwnPropertyNames(schema.properties);
        const unknownKeys = Object.getOwnPropertyNames(value);
        for (const requiredKey of requiredKeys) {
            if (unknownKeys.includes(requiredKey))
                continue;
            yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
        }
        if (schema.additionalProperties === false) {
            for (const valueKey of unknownKeys) {
                if (!knownKeys.includes(valueKey)) {
                    yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
                }
            }
        }
        if (typeof schema.additionalProperties === 'object') {
            for (const valueKey of unknownKeys) {
                if (knownKeys.includes(valueKey))
                    continue;
                yield* Visit$4(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
            }
        }
        for (const knownKey of knownKeys) {
            const property = schema.properties[knownKey];
            if (schema.required && schema.required.includes(knownKey)) {
                yield* Visit$4(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
                if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
                    yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
                }
            }
            else {
                if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
                    yield* Visit$4(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
                }
            }
        }
    }
    function* FromPromise$2(schema, references, path, value) {
        if (!IsPromise(value))
            yield Create(ValueErrorType.Promise, schema, path, value);
    }
    function* FromRecord$4(schema, references, path, value) {
        if (!TypeSystemPolicy.IsRecordLike(value))
            return yield Create(ValueErrorType.Object, schema, path, value);
        if (IsDefined$1(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
            yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
        }
        if (IsDefined$1(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
            yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
        }
        const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
        const regex = new RegExp(patternKey);
        for (const [propertyKey, propertyValue] of Object.entries(value)) {
            if (regex.test(propertyKey))
                yield* Visit$4(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
        }
        if (typeof schema.additionalProperties === 'object') {
            for (const [propertyKey, propertyValue] of Object.entries(value)) {
                if (!regex.test(propertyKey))
                    yield* Visit$4(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
            }
        }
        if (schema.additionalProperties === false) {
            for (const [propertyKey, propertyValue] of Object.entries(value)) {
                if (regex.test(propertyKey))
                    continue;
                return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
            }
        }
    }
    function* FromRef$4(schema, references, path, value) {
        yield* Visit$4(Deref(schema, references), references, path, value);
    }
    function* FromRegExp$1(schema, references, path, value) {
        if (!IsString(value))
            return yield Create(ValueErrorType.String, schema, path, value);
        if (IsDefined$1(schema.minLength) && !(value.length >= schema.minLength)) {
            yield Create(ValueErrorType.StringMinLength, schema, path, value);
        }
        if (IsDefined$1(schema.maxLength) && !(value.length <= schema.maxLength)) {
            yield Create(ValueErrorType.StringMaxLength, schema, path, value);
        }
        const regex = new RegExp(schema.source, schema.flags);
        if (!regex.test(value)) {
            return yield Create(ValueErrorType.RegExp, schema, path, value);
        }
    }
    function* FromString$1(schema, references, path, value) {
        if (!IsString(value))
            return yield Create(ValueErrorType.String, schema, path, value);
        if (IsDefined$1(schema.minLength) && !(value.length >= schema.minLength)) {
            yield Create(ValueErrorType.StringMinLength, schema, path, value);
        }
        if (IsDefined$1(schema.maxLength) && !(value.length <= schema.maxLength)) {
            yield Create(ValueErrorType.StringMaxLength, schema, path, value);
        }
        if (IsString(schema.pattern)) {
            const regex = new RegExp(schema.pattern);
            if (!regex.test(value)) {
                yield Create(ValueErrorType.StringPattern, schema, path, value);
            }
        }
        if (IsString(schema.format)) {
            if (!Has$1(schema.format)) {
                yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
            }
            else {
                const format = Get$1(schema.format);
                if (!format(value)) {
                    yield Create(ValueErrorType.StringFormat, schema, path, value);
                }
            }
        }
    }
    function* FromSymbol$1(schema, references, path, value) {
        if (!IsSymbol(value))
            yield Create(ValueErrorType.Symbol, schema, path, value);
    }
    function* FromTemplateLiteral$1(schema, references, path, value) {
        if (!IsString(value))
            return yield Create(ValueErrorType.String, schema, path, value);
        const regex = new RegExp(schema.pattern);
        if (!regex.test(value)) {
            yield Create(ValueErrorType.StringPattern, schema, path, value);
        }
    }
    function* FromThis$4(schema, references, path, value) {
        yield* Visit$4(Deref(schema, references), references, path, value);
    }
    function* FromTuple$4(schema, references, path, value) {
        if (!IsArray(value))
            return yield Create(ValueErrorType.Tuple, schema, path, value);
        if (schema.items === undefined && !(value.length === 0)) {
            return yield Create(ValueErrorType.TupleLength, schema, path, value);
        }
        if (!(value.length === schema.maxItems)) {
            return yield Create(ValueErrorType.TupleLength, schema, path, value);
        }
        if (!schema.items) {
            return;
        }
        for (let i = 0; i < schema.items.length; i++) {
            yield* Visit$4(schema.items[i], references, `${path}/${i}`, value[i]);
        }
    }
    function* FromUndefined$1(schema, references, path, value) {
        if (!IsUndefined(value))
            yield Create(ValueErrorType.Undefined, schema, path, value);
    }
    function* FromUnion$4(schema, references, path, value) {
        let count = 0;
        for (const subschema of schema.anyOf) {
            const errors = [...Visit$4(subschema, references, path, value)];
            if (errors.length === 0)
                return; // matched
            count += errors.length;
        }
        if (count > 0) {
            yield Create(ValueErrorType.Union, schema, path, value);
        }
    }
    function* FromUint8Array$1(schema, references, path, value) {
        if (!IsUint8Array(value))
            return yield Create(ValueErrorType.Uint8Array, schema, path, value);
        if (IsDefined$1(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
            yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
        }
        if (IsDefined$1(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
            yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
        }
    }
    function* FromUnknown$1(schema, references, path, value) { }
    function* FromVoid$1(schema, references, path, value) {
        if (!TypeSystemPolicy.IsVoidLike(value))
            yield Create(ValueErrorType.Void, schema, path, value);
    }
    function* FromKind$1(schema, references, path, value) {
        const check = Get(schema[Kind]);
        if (!check(schema, value))
            yield Create(ValueErrorType.Kind, schema, path, value);
    }
    function* Visit$4(schema, references, path, value) {
        const references_ = IsDefined$1(schema.$id) ? [...references, schema] : references;
        const schema_ = schema;
        switch (schema_[Kind]) {
            case 'Any':
                return yield* FromAny$1();
            case 'Array':
                return yield* FromArray$4(schema_, references_, path, value);
            case 'AsyncIterator':
                return yield* FromAsyncIterator$2(schema_, references_, path, value);
            case 'BigInt':
                return yield* FromBigInt$1(schema_, references_, path, value);
            case 'Boolean':
                return yield* FromBoolean$1(schema_, references_, path, value);
            case 'Constructor':
                return yield* FromConstructor$2(schema_, references_, path, value);
            case 'Date':
                return yield* FromDate$1(schema_, references_, path, value);
            case 'Function':
                return yield* FromFunction$2(schema_, references_, path, value);
            case 'Integer':
                return yield* FromInteger$1(schema_, references_, path, value);
            case 'Intersect':
                return yield* FromIntersect$4(schema_, references_, path, value);
            case 'Iterator':
                return yield* FromIterator$2(schema_, references_, path, value);
            case 'Literal':
                return yield* FromLiteral$1(schema_, references_, path, value);
            case 'Never':
                return yield* FromNever$1(schema_, references_, path, value);
            case 'Not':
                return yield* FromNot$4(schema_, references_, path, value);
            case 'Null':
                return yield* FromNull$1(schema_, references_, path, value);
            case 'Number':
                return yield* FromNumber$1(schema_, references_, path, value);
            case 'Object':
                return yield* FromObject$4(schema_, references_, path, value);
            case 'Promise':
                return yield* FromPromise$2(schema_, references_, path, value);
            case 'Record':
                return yield* FromRecord$4(schema_, references_, path, value);
            case 'Ref':
                return yield* FromRef$4(schema_, references_, path, value);
            case 'RegExp':
                return yield* FromRegExp$1(schema_, references_, path, value);
            case 'String':
                return yield* FromString$1(schema_, references_, path, value);
            case 'Symbol':
                return yield* FromSymbol$1(schema_, references_, path, value);
            case 'TemplateLiteral':
                return yield* FromTemplateLiteral$1(schema_, references_, path, value);
            case 'This':
                return yield* FromThis$4(schema_, references_, path, value);
            case 'Tuple':
                return yield* FromTuple$4(schema_, references_, path, value);
            case 'Undefined':
                return yield* FromUndefined$1(schema_, references_, path, value);
            case 'Union':
                return yield* FromUnion$4(schema_, references_, path, value);
            case 'Uint8Array':
                return yield* FromUint8Array$1(schema_, references_, path, value);
            case 'Unknown':
                return yield* FromUnknown$1();
            case 'Void':
                return yield* FromVoid$1(schema_, references_, path, value);
            default:
                if (!Has(schema_[Kind]))
                    throw new ValueErrorsUnknownTypeError(schema);
                return yield* FromKind$1(schema_, references_, path, value);
        }
    }
    /** Returns an iterator for each error in this value. */
    function Errors$1(...args) {
        const iterator = args.length === 3 ? Visit$4(args[0], args[1], '', args[2]) : Visit$4(args[0], [], '', args[1]);
        return new ValueErrorIterator(iterator);
    }

    // ------------------------------------------------------------------
    // Errors
    // ------------------------------------------------------------------
    class ValueCheckUnknownTypeError extends TypeBoxError {
        constructor(schema) {
            super(`Unknown type`);
            this.schema = schema;
        }
    }
    // ------------------------------------------------------------------
    // TypeGuards
    // ------------------------------------------------------------------
    function IsAnyOrUnknown(schema) {
        return schema[Kind] === 'Any' || schema[Kind] === 'Unknown';
    }
    // ------------------------------------------------------------------
    // Guards
    // ------------------------------------------------------------------
    function IsDefined(value) {
        return value !== undefined;
    }
    // ------------------------------------------------------------------
    // Types
    // ------------------------------------------------------------------
    function FromAny(schema, references, value) {
        return true;
    }
    function FromArray$3(schema, references, value) {
        if (!IsArray(value))
            return false;
        if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
            return false;
        }
        if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
            return false;
        }
        if (!value.every((value) => Visit$3(schema.items, references, value))) {
            return false;
        }
        // prettier-ignore
        if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {
            const hashed = Hash(element);
            if (set.has(hashed)) {
                return false;
            }
            else {
                set.add(hashed);
            }
        } return true; })())) {
            return false;
        }
        // contains
        if (!(IsDefined(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
            return true; // exit
        }
        const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
        const containsCount = value.reduce((acc, value) => (Visit$3(containsSchema, references, value) ? acc + 1 : acc), 0);
        if (containsCount === 0) {
            return false;
        }
        if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
            return false;
        }
        if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
            return false;
        }
        return true;
    }
    function FromAsyncIterator$1(schema, references, value) {
        return IsAsyncIterator(value);
    }
    function FromBigInt(schema, references, value) {
        if (!IsBigInt(value))
            return false;
        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
            return false;
        }
        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
            return false;
        }
        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
            return false;
        }
        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
            return false;
        }
        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
            return false;
        }
        return true;
    }
    function FromBoolean(schema, references, value) {
        return IsBoolean(value);
    }
    function FromConstructor$1(schema, references, value) {
        return Visit$3(schema.returns, references, value.prototype);
    }
    function FromDate(schema, references, value) {
        if (!IsDate(value))
            return false;
        if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
            return false;
        }
        if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
            return false;
        }
        if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
            return false;
        }
        if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
            return false;
        }
        if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
            return false;
        }
        return true;
    }
    function FromFunction$1(schema, references, value) {
        return IsFunction(value);
    }
    function FromInteger(schema, references, value) {
        if (!IsInteger(value)) {
            return false;
        }
        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
            return false;
        }
        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
            return false;
        }
        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
            return false;
        }
        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
            return false;
        }
        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
            return false;
        }
        return true;
    }
    function FromIntersect$3(schema, references, value) {
        const check1 = schema.allOf.every((schema) => Visit$3(schema, references, value));
        if (schema.unevaluatedProperties === false) {
            const keyPattern = new RegExp(KeyOfPattern(schema));
            const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
            return check1 && check2;
        }
        else if (IsSchema(schema.unevaluatedProperties)) {
            const keyCheck = new RegExp(KeyOfPattern(schema));
            const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit$3(schema.unevaluatedProperties, references, value[key]));
            return check1 && check2;
        }
        else {
            return check1;
        }
    }
    function FromIterator$1(schema, references, value) {
        return IsIterator(value);
    }
    function FromLiteral(schema, references, value) {
        return value === schema.const;
    }
    function FromNever(schema, references, value) {
        return false;
    }
    function FromNot$3(schema, references, value) {
        return !Visit$3(schema.not, references, value);
    }
    function FromNull(schema, references, value) {
        return IsNull(value);
    }
    function FromNumber(schema, references, value) {
        if (!TypeSystemPolicy.IsNumberLike(value))
            return false;
        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
            return false;
        }
        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
            return false;
        }
        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
            return false;
        }
        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
            return false;
        }
        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
            return false;
        }
        return true;
    }
    function FromObject$3(schema, references, value) {
        if (!TypeSystemPolicy.IsObjectLike(value))
            return false;
        if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
            return false;
        }
        if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
            return false;
        }
        const knownKeys = Object.getOwnPropertyNames(schema.properties);
        for (const knownKey of knownKeys) {
            const property = schema.properties[knownKey];
            if (schema.required && schema.required.includes(knownKey)) {
                if (!Visit$3(property, references, value[knownKey])) {
                    return false;
                }
                if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
                    return false;
                }
            }
            else {
                if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit$3(property, references, value[knownKey])) {
                    return false;
                }
            }
        }
        if (schema.additionalProperties === false) {
            const valueKeys = Object.getOwnPropertyNames(value);
            // optimization: value is valid if schemaKey length matches the valueKey length
            if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
                return true;
            }
            else {
                return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
            }
        }
        else if (typeof schema.additionalProperties === 'object') {
            const valueKeys = Object.getOwnPropertyNames(value);
            return valueKeys.every((key) => knownKeys.includes(key) || Visit$3(schema.additionalProperties, references, value[key]));
        }
        else {
            return true;
        }
    }
    function FromPromise$1(schema, references, value) {
        return IsPromise(value);
    }
    function FromRecord$3(schema, references, value) {
        if (!TypeSystemPolicy.IsRecordLike(value)) {
            return false;
        }
        if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
            return false;
        }
        if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
            return false;
        }
        const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
        const regex = new RegExp(patternKey);
        // prettier-ignore
        const check1 = Object.entries(value).every(([key, value]) => {
            return (regex.test(key)) ? Visit$3(patternSchema, references, value) : true;
        });
        // prettier-ignore
        const check2 = typeof schema.additionalProperties === 'object' ? Object.entries(value).every(([key, value]) => {
            return (!regex.test(key)) ? Visit$3(schema.additionalProperties, references, value) : true;
        }) : true;
        const check3 = schema.additionalProperties === false
            ? Object.getOwnPropertyNames(value).every((key) => {
                return regex.test(key);
            })
            : true;
        return check1 && check2 && check3;
    }
    function FromRef$3(schema, references, value) {
        return Visit$3(Deref(schema, references), references, value);
    }
    function FromRegExp(schema, references, value) {
        const regex = new RegExp(schema.source, schema.flags);
        if (IsDefined(schema.minLength)) {
            if (!(value.length >= schema.minLength))
                return false;
        }
        if (IsDefined(schema.maxLength)) {
            if (!(value.length <= schema.maxLength))
                return false;
        }
        return regex.test(value);
    }
    function FromString(schema, references, value) {
        if (!IsString(value)) {
            return false;
        }
        if (IsDefined(schema.minLength)) {
            if (!(value.length >= schema.minLength))
                return false;
        }
        if (IsDefined(schema.maxLength)) {
            if (!(value.length <= schema.maxLength))
                return false;
        }
        if (IsDefined(schema.pattern)) {
            const regex = new RegExp(schema.pattern);
            if (!regex.test(value))
                return false;
        }
        if (IsDefined(schema.format)) {
            if (!Has$1(schema.format))
                return false;
            const func = Get$1(schema.format);
            return func(value);
        }
        return true;
    }
    function FromSymbol(schema, references, value) {
        return IsSymbol(value);
    }
    function FromTemplateLiteral(schema, references, value) {
        return IsString(value) && new RegExp(schema.pattern).test(value);
    }
    function FromThis$3(schema, references, value) {
        return Visit$3(Deref(schema, references), references, value);
    }
    function FromTuple$3(schema, references, value) {
        if (!IsArray(value)) {
            return false;
        }
        if (schema.items === undefined && !(value.length === 0)) {
            return false;
        }
        if (!(value.length === schema.maxItems)) {
            return false;
        }
        if (!schema.items) {
            return true;
        }
        for (let i = 0; i < schema.items.length; i++) {
            if (!Visit$3(schema.items[i], references, value[i]))
                return false;
        }
        return true;
    }
    function FromUndefined(schema, references, value) {
        return IsUndefined(value);
    }
    function FromUnion$3(schema, references, value) {
        return schema.anyOf.some((inner) => Visit$3(inner, references, value));
    }
    function FromUint8Array(schema, references, value) {
        if (!IsUint8Array(value)) {
            return false;
        }
        if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
            return false;
        }
        if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
            return false;
        }
        return true;
    }
    function FromUnknown(schema, references, value) {
        return true;
    }
    function FromVoid(schema, references, value) {
        return TypeSystemPolicy.IsVoidLike(value);
    }
    function FromKind(schema, references, value) {
        if (!Has(schema[Kind]))
            return false;
        const func = Get(schema[Kind]);
        return func(schema, value);
    }
    function Visit$3(schema, references, value) {
        const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
        const schema_ = schema;
        switch (schema_[Kind]) {
            case 'Any':
                return FromAny();
            case 'Array':
                return FromArray$3(schema_, references_, value);
            case 'AsyncIterator':
                return FromAsyncIterator$1(schema_, references_, value);
            case 'BigInt':
                return FromBigInt(schema_, references_, value);
            case 'Boolean':
                return FromBoolean(schema_, references_, value);
            case 'Constructor':
                return FromConstructor$1(schema_, references_, value);
            case 'Date':
                return FromDate(schema_, references_, value);
            case 'Function':
                return FromFunction$1(schema_, references_, value);
            case 'Integer':
                return FromInteger(schema_, references_, value);
            case 'Intersect':
                return FromIntersect$3(schema_, references_, value);
            case 'Iterator':
                return FromIterator$1(schema_, references_, value);
            case 'Literal':
                return FromLiteral(schema_, references_, value);
            case 'Never':
                return FromNever();
            case 'Not':
                return FromNot$3(schema_, references_, value);
            case 'Null':
                return FromNull(schema_, references_, value);
            case 'Number':
                return FromNumber(schema_, references_, value);
            case 'Object':
                return FromObject$3(schema_, references_, value);
            case 'Promise':
                return FromPromise$1(schema_, references_, value);
            case 'Record':
                return FromRecord$3(schema_, references_, value);
            case 'Ref':
                return FromRef$3(schema_, references_, value);
            case 'RegExp':
                return FromRegExp(schema_, references_, value);
            case 'String':
                return FromString(schema_, references_, value);
            case 'Symbol':
                return FromSymbol(schema_, references_, value);
            case 'TemplateLiteral':
                return FromTemplateLiteral(schema_, references_, value);
            case 'This':
                return FromThis$3(schema_, references_, value);
            case 'Tuple':
                return FromTuple$3(schema_, references_, value);
            case 'Undefined':
                return FromUndefined(schema_, references_, value);
            case 'Union':
                return FromUnion$3(schema_, references_, value);
            case 'Uint8Array':
                return FromUint8Array(schema_, references_, value);
            case 'Unknown':
                return FromUnknown();
            case 'Void':
                return FromVoid(schema_, references_, value);
            default:
                if (!Has(schema_[Kind]))
                    throw new ValueCheckUnknownTypeError(schema_);
                return FromKind(schema_, references_, value);
        }
    }
    /** Returns true if the value matches the given type. */
    function Check$1(...args) {
        return args.length === 3 ? Visit$3(args[0], args[1], args[2]) : Visit$3(args[0], [], args[1]);
    }

    const Insert = Object$1({
        type: Literal('insert'),
        path: String$1(),
        value: Unknown(),
    });
    const Update = Object$1({
        type: Literal('update'),
        path: String$1(),
        value: Unknown(),
    });
    const Delete = Object$1({
        type: Literal('delete'),
        path: String$1(),
    });
    Union$1([Insert, Update, Delete]);

    // ------------------------------------------------------------------
    // Errors
    // ------------------------------------------------------------------
    // thrown externally
    // prettier-ignore
    class TransformDecodeCheckError extends TypeBoxError {
        constructor(schema, value, error) {
            super(`Unable to decode value as it does not match the expected schema`);
            this.schema = schema;
            this.value = value;
            this.error = error;
        }
    }
    // prettier-ignore
    class TransformDecodeError extends TypeBoxError {
        constructor(schema, path, value, error) {
            super(error instanceof Error ? error.message : 'Unknown error');
            this.schema = schema;
            this.path = path;
            this.value = value;
            this.error = error;
        }
    }
    // ------------------------------------------------------------------
    // Decode
    // ------------------------------------------------------------------
    // prettier-ignore
    function Default$1(schema, path, value) {
        try {
            return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;
        }
        catch (error) {
            throw new TransformDecodeError(schema, path, value, error);
        }
    }
    // prettier-ignore
    function FromArray$2(schema, references, path, value) {
        return (IsArray(value))
            ? Default$1(schema, path, value.map((value, index) => Visit$2(schema.items, references, `${path}/${index}`, value)))
            : Default$1(schema, path, value);
    }
    // prettier-ignore
    function FromIntersect$2(schema, references, path, value) {
        if (!IsStandardObject(value) || IsValueType(value))
            return Default$1(schema, path, value);
        const knownEntries = KeyOfPropertyEntries(schema);
        const knownKeys = knownEntries.map(entry => entry[0]);
        const knownProperties = { ...value };
        for (const [knownKey, knownSchema] of knownEntries)
            if (knownKey in knownProperties) {
                knownProperties[knownKey] = Visit$2(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
            }
        if (!IsTransform(schema.unevaluatedProperties)) {
            return Default$1(schema, path, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const unevaluatedProperties = schema.unevaluatedProperties;
        const unknownProperties = { ...knownProperties };
        for (const key of unknownKeys)
            if (!knownKeys.includes(key)) {
                unknownProperties[key] = Default$1(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
            }
        return Default$1(schema, path, unknownProperties);
    }
    function FromNot$2(schema, references, path, value) {
        return Default$1(schema, path, Visit$2(schema.not, references, path, value));
    }
    // prettier-ignore
    function FromObject$2(schema, references, path, value) {
        if (!IsStandardObject(value))
            return Default$1(schema, path, value);
        const knownKeys = KeyOfPropertyKeys(schema);
        const knownProperties = { ...value };
        for (const key of knownKeys)
            if (key in knownProperties) {
                knownProperties[key] = Visit$2(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
            }
        if (!IsSchema(schema.additionalProperties)) {
            return Default$1(schema, path, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const additionalProperties = schema.additionalProperties;
        const unknownProperties = { ...knownProperties };
        for (const key of unknownKeys)
            if (!knownKeys.includes(key)) {
                unknownProperties[key] = Default$1(additionalProperties, `${path}/${key}`, unknownProperties[key]);
            }
        return Default$1(schema, path, unknownProperties);
    }
    // prettier-ignore
    function FromRecord$2(schema, references, path, value) {
        if (!IsStandardObject(value))
            return Default$1(schema, path, value);
        const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
        const knownKeys = new RegExp(pattern);
        const knownProperties = { ...value };
        for (const key of Object.getOwnPropertyNames(value))
            if (knownKeys.test(key)) {
                knownProperties[key] = Visit$2(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
            }
        if (!IsSchema(schema.additionalProperties)) {
            return Default$1(schema, path, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const additionalProperties = schema.additionalProperties;
        const unknownProperties = { ...knownProperties };
        for (const key of unknownKeys)
            if (!knownKeys.test(key)) {
                unknownProperties[key] = Default$1(additionalProperties, `${path}/${key}`, unknownProperties[key]);
            }
        return Default$1(schema, path, unknownProperties);
    }
    // prettier-ignore
    function FromRef$2(schema, references, path, value) {
        const target = Deref(schema, references);
        return Default$1(schema, path, Visit$2(target, references, path, value));
    }
    // prettier-ignore
    function FromThis$2(schema, references, path, value) {
        const target = Deref(schema, references);
        return Default$1(schema, path, Visit$2(target, references, path, value));
    }
    // prettier-ignore
    function FromTuple$2(schema, references, path, value) {
        return (IsArray(value) && IsArray(schema.items))
            ? Default$1(schema, path, schema.items.map((schema, index) => Visit$2(schema, references, `${path}/${index}`, value[index])))
            : Default$1(schema, path, value);
    }
    // prettier-ignore
    function FromUnion$2(schema, references, path, value) {
        for (const subschema of schema.anyOf) {
            if (!Check$1(subschema, references, value))
                continue;
            // note: ensure interior is decoded first
            const decoded = Visit$2(subschema, references, path, value);
            return Default$1(schema, path, decoded);
        }
        return Default$1(schema, path, value);
    }
    // prettier-ignore
    function Visit$2(schema, references, path, value) {
        const references_ = typeof schema.$id === 'string' ? [...references, schema] : references;
        const schema_ = schema;
        switch (schema[Kind]) {
            case 'Array':
                return FromArray$2(schema_, references_, path, value);
            case 'Intersect':
                return FromIntersect$2(schema_, references_, path, value);
            case 'Not':
                return FromNot$2(schema_, references_, path, value);
            case 'Object':
                return FromObject$2(schema_, references_, path, value);
            case 'Record':
                return FromRecord$2(schema_, references_, path, value);
            case 'Ref':
                return FromRef$2(schema_, references_, path, value);
            case 'Symbol':
                return Default$1(schema_, path, value);
            case 'This':
                return FromThis$2(schema_, references_, path, value);
            case 'Tuple':
                return FromTuple$2(schema_, references_, path, value);
            case 'Union':
                return FromUnion$2(schema_, references_, path, value);
            default:
                return Default$1(schema_, path, value);
        }
    }
    /**
     * `[Internal]` Decodes the value and returns the result. This function requires that
     * the caller `Check` the value before use. Passing unchecked values may result in
     * undefined behavior. Refer to the `Value.Decode()` for implementation details.
     */
    function TransformDecode(schema, references, value) {
        return Visit$2(schema, references, '', value);
    }

    // ------------------------------------------------------------------
    // Errors
    // ------------------------------------------------------------------
    // prettier-ignore
    class TransformEncodeCheckError extends TypeBoxError {
        constructor(schema, value, error) {
            super(`The encoded value does not match the expected schema`);
            this.schema = schema;
            this.value = value;
            this.error = error;
        }
    }
    // prettier-ignore
    class TransformEncodeError extends TypeBoxError {
        constructor(schema, path, value, error) {
            super(`${error instanceof Error ? error.message : 'Unknown error'}`);
            this.schema = schema;
            this.path = path;
            this.value = value;
            this.error = error;
        }
    }
    // ------------------------------------------------------------------
    // Encode
    // ------------------------------------------------------------------
    // prettier-ignore
    function Default(schema, path, value) {
        try {
            return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;
        }
        catch (error) {
            throw new TransformEncodeError(schema, path, value, error);
        }
    }
    // prettier-ignore
    function FromArray$1(schema, references, path, value) {
        const defaulted = Default(schema, path, value);
        return IsArray(defaulted)
            ? defaulted.map((value, index) => Visit$1(schema.items, references, `${path}/${index}`, value))
            : defaulted;
    }
    // prettier-ignore
    function FromIntersect$1(schema, references, path, value) {
        const defaulted = Default(schema, path, value);
        if (!IsStandardObject(value) || IsValueType(value))
            return defaulted;
        const knownEntries = KeyOfPropertyEntries(schema);
        const knownKeys = knownEntries.map(entry => entry[0]);
        const knownProperties = { ...defaulted };
        for (const [knownKey, knownSchema] of knownEntries)
            if (knownKey in knownProperties) {
                knownProperties[knownKey] = Visit$1(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
            }
        if (!IsTransform(schema.unevaluatedProperties)) {
            return Default(schema, path, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const unevaluatedProperties = schema.unevaluatedProperties;
        const properties = { ...knownProperties };
        for (const key of unknownKeys)
            if (!knownKeys.includes(key)) {
                properties[key] = Default(unevaluatedProperties, `${path}/${key}`, properties[key]);
            }
        return properties;
    }
    // prettier-ignore
    function FromNot$1(schema, references, path, value) {
        return Default(schema.not, path, Default(schema, path, value));
    }
    // prettier-ignore
    function FromObject$1(schema, references, path, value) {
        const defaulted = Default(schema, path, value);
        if (!IsStandardObject(defaulted))
            return defaulted;
        const knownKeys = KeyOfPropertyKeys(schema);
        const knownProperties = { ...defaulted };
        for (const key of knownKeys)
            if (key in knownProperties) {
                knownProperties[key] = Visit$1(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
            }
        if (!IsSchema(schema.additionalProperties)) {
            return knownProperties;
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const additionalProperties = schema.additionalProperties;
        const properties = { ...knownProperties };
        for (const key of unknownKeys)
            if (!knownKeys.includes(key)) {
                properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);
            }
        return properties;
    }
    // prettier-ignore
    function FromRecord$1(schema, references, path, value) {
        const defaulted = Default(schema, path, value);
        if (!IsStandardObject(value))
            return defaulted;
        const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
        const knownKeys = new RegExp(pattern);
        const knownProperties = { ...defaulted };
        for (const key of Object.getOwnPropertyNames(value))
            if (knownKeys.test(key)) {
                knownProperties[key] = Visit$1(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
            }
        if (!IsSchema(schema.additionalProperties)) {
            return Default(schema, path, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const additionalProperties = schema.additionalProperties;
        const properties = { ...knownProperties };
        for (const key of unknownKeys)
            if (!knownKeys.test(key)) {
                properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);
            }
        return properties;
    }
    // prettier-ignore
    function FromRef$1(schema, references, path, value) {
        const target = Deref(schema, references);
        const resolved = Visit$1(target, references, path, value);
        return Default(schema, path, resolved);
    }
    // prettier-ignore
    function FromThis$1(schema, references, path, value) {
        const target = Deref(schema, references);
        const resolved = Visit$1(target, references, path, value);
        return Default(schema, path, resolved);
    }
    // prettier-ignore
    function FromTuple$1(schema, references, path, value) {
        const value1 = Default(schema, path, value);
        return IsArray(schema.items) ? schema.items.map((schema, index) => Visit$1(schema, references, `${path}/${index}`, value1[index])) : [];
    }
    // prettier-ignore
    function FromUnion$1(schema, references, path, value) {
        // test value against union variants
        for (const subschema of schema.anyOf) {
            if (!Check$1(subschema, references, value))
                continue;
            const value1 = Visit$1(subschema, references, path, value);
            return Default(schema, path, value1);
        }
        // test transformed value against union variants
        for (const subschema of schema.anyOf) {
            const value1 = Visit$1(subschema, references, path, value);
            if (!Check$1(schema, references, value1))
                continue;
            return Default(schema, path, value1);
        }
        return Default(schema, path, value);
    }
    // prettier-ignore
    function Visit$1(schema, references, path, value) {
        const references_ = typeof schema.$id === 'string' ? [...references, schema] : references;
        const schema_ = schema;
        switch (schema[Kind]) {
            case 'Array':
                return FromArray$1(schema_, references_, path, value);
            case 'Intersect':
                return FromIntersect$1(schema_, references_, path, value);
            case 'Not':
                return FromNot$1(schema_, references_, path, value);
            case 'Object':
                return FromObject$1(schema_, references_, path, value);
            case 'Record':
                return FromRecord$1(schema_, references_, path, value);
            case 'Ref':
                return FromRef$1(schema_, references_, path, value);
            case 'This':
                return FromThis$1(schema_, references_, path, value);
            case 'Tuple':
                return FromTuple$1(schema_, references_, path, value);
            case 'Union':
                return FromUnion$1(schema_, references_, path, value);
            default:
                return Default(schema_, path, value);
        }
    }
    /**
     * `[Internal]` Encodes the value and returns the result. This function expects the
     * caller to pass a statically checked value. This function does not check the encoded
     * result, meaning the result should be passed to `Check` before use. Refer to the
     * `Value.Encode()` function for implementation details.
     */
    function TransformEncode(schema, references, value) {
        return Visit$1(schema, references, '', value);
    }

    // prettier-ignore
    function FromArray(schema, references) {
        return IsTransform(schema) || Visit(schema.items, references);
    }
    // prettier-ignore
    function FromAsyncIterator(schema, references) {
        return IsTransform(schema) || Visit(schema.items, references);
    }
    // prettier-ignore
    function FromConstructor(schema, references) {
        return IsTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema) => Visit(schema, references));
    }
    // prettier-ignore
    function FromFunction(schema, references) {
        return IsTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema) => Visit(schema, references));
    }
    // prettier-ignore
    function FromIntersect(schema, references) {
        return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema) => Visit(schema, references));
    }
    // prettier-ignore
    function FromIterator(schema, references) {
        return IsTransform(schema) || Visit(schema.items, references);
    }
    // prettier-ignore
    function FromNot(schema, references) {
        return IsTransform(schema) || Visit(schema.not, references);
    }
    // prettier-ignore
    function FromObject(schema, references) {
        return (IsTransform(schema) ||
            Object.values(schema.properties).some((schema) => Visit(schema, references)) ||
            (IsSchema(schema.additionalProperties) && Visit(schema.additionalProperties, references)));
    }
    // prettier-ignore
    function FromPromise(schema, references) {
        return IsTransform(schema) || Visit(schema.item, references);
    }
    // prettier-ignore
    function FromRecord(schema, references) {
        const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
        const property = schema.patternProperties[pattern];
        return IsTransform(schema) || Visit(property, references) || (IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties));
    }
    // prettier-ignore
    function FromRef(schema, references) {
        if (IsTransform(schema))
            return true;
        return Visit(Deref(schema, references), references);
    }
    // prettier-ignore
    function FromThis(schema, references) {
        if (IsTransform(schema))
            return true;
        return Visit(Deref(schema, references), references);
    }
    // prettier-ignore
    function FromTuple(schema, references) {
        return IsTransform(schema) || (!IsUndefined(schema.items) && schema.items.some((schema) => Visit(schema, references)));
    }
    // prettier-ignore
    function FromUnion(schema, references) {
        return IsTransform(schema) || schema.anyOf.some((schema) => Visit(schema, references));
    }
    // prettier-ignore
    function Visit(schema, references) {
        const references_ = IsString(schema.$id) ? [...references, schema] : references;
        const schema_ = schema;
        if (schema.$id && visited.has(schema.$id))
            return false;
        if (schema.$id)
            visited.add(schema.$id);
        switch (schema[Kind]) {
            case 'Array':
                return FromArray(schema_, references_);
            case 'AsyncIterator':
                return FromAsyncIterator(schema_, references_);
            case 'Constructor':
                return FromConstructor(schema_, references_);
            case 'Function':
                return FromFunction(schema_, references_);
            case 'Intersect':
                return FromIntersect(schema_, references_);
            case 'Iterator':
                return FromIterator(schema_, references_);
            case 'Not':
                return FromNot(schema_, references_);
            case 'Object':
                return FromObject(schema_, references_);
            case 'Promise':
                return FromPromise(schema_, references_);
            case 'Record':
                return FromRecord(schema_, references_);
            case 'Ref':
                return FromRef(schema_, references_);
            case 'This':
                return FromThis(schema_, references_);
            case 'Tuple':
                return FromTuple(schema_, references_);
            case 'Union':
                return FromUnion(schema_, references_);
            default:
                return IsTransform(schema);
        }
    }
    const visited = new Set();
    /** Returns true if this schema contains a transform codec */
    function HasTransform(schema, references) {
        visited.clear();
        return Visit(schema, references);
    }

    /** Returns true if the value matches the given type */
    function Check(...args) {
        return Check$1.apply(Check$1, args);
    }
    /** Decodes a value or throws if error */
    function Decode(...args) {
        const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
        if (!Check(schema, references, value))
            throw new TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
        return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
    }
    /** Encodes a value or throws if error */
    function Encode(...args) {
        const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
        const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
        if (!Check(schema, references, encoded))
            throw new TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());
        return encoded;
    }
    /** Returns an iterator for each error in this value. */
    function Errors(...args) {
        return Errors$1.apply(Errors$1, args);
    }

    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore: we have to ignore this for csm output.
    function logRelevantErrorInfo(e) {
        const { /* schema, */ error /* , value */ } = e;
        console.log(JSON.stringify(error, null, 2));
    }
    const handleResultError = (e, options) => {
        const title = e.schema.title;
        if (options.logErrors) {
            logRelevantErrorInfo(e);
            console.log(`
    This may happen intermittently and you should catch errors appropriately.
    However:  1) if this recently started happening on every request for a symbol
    that used to work, Yahoo may have changed their API.  2) If this happens on
    every request for a symbol you've never used before, but not for other
    symbols, you've found an edge-case (OR, we may just be protecting you from
    "bad" data sometimes stored for e.g. misspelt symbols on Yahoo's side).
    Please see if anyone has reported this previously:
    
      ${pkg.repository}/issues?q=is%3Aissue+${title}
    
    or open a new issue (and mention the symbol):  ${pkg.name} v${pkg.version}
    
      ${pkg.repository}/issues/new?labels=bug%2C+validation&template=validation.md&title=${title}
    
    For information on how to turn off the above logging or skip these errors,
    see https://github.com/gadicc/node-yahoo-finance2/tree/devel/docs/validation.md.
    
    At the end of the doc, there's also a section on how to
    [Help Fix Validation Errors](https://github.com/gadicc/node-yahoo-finance2/blob/devel/docs/validation.md#help-fix)
    in case you'd like to contribute to the project.  Most of the time, these
    fixes are very quick and easy; it's just hard for our small core team to keep up,
    so help is always appreciated!
    `);
        }
        throw new FailedYahooValidationError("Failed Yahoo Schema validation", {
            result: e.value,
            errors: [e],
        });
    };
    const handleOptionsError = (e, { logOptionsErrors }) => {
        if (logOptionsErrors) {
            console.error(`[yahooFinance] Invalid options ("${JSON.stringify(e.error, null, 2)}")`);
        }
        throw new InvalidOptionsError("Validation called with invalid options");
    };
    const validateAndCoerceTypebox = ({ type, data, schema, options, }) => {
        try {
            const validationSchema = options._internalThrowOnAdditionalProperties
                ? { ...schema, additionalProperties: false }
                : schema;
            return Decode(validationSchema, data);
        }
        catch (e) {
            if (e instanceof TransformDecodeError ||
                e instanceof TransformDecodeCheckError) {
                // TODO: The existing implementation of 'validate' assumes that the `type` parameter may not be provided
                // and defaults to validating the options if it is not.
                // We should probably explore validating this further up in the call chain.
                // It'd be nice to do this in the body of a module (e.g. search) so that we can avoid
                // polluting core code with type checks and edge cases
                type === "result"
                    ? handleResultError(e, options)
                    : handleOptionsError(e, options);
            }
            throw e;
        }
    };

    function setGlobalConfig(_config) {
        const parsed = validateAndCoerceTypebox({
            data: _config,
            type: "options",
            options: this._opts.validation,
            schema: YahooFinanceOptionsSchema,
        });
        // Instances (e.g. cookieJar) don't validate well :)
        const { cookieJar, ...config } = parsed;
        mergeObjects(this._opts, config);
        if (cookieJar) {
            if (!(cookieJar instanceof ExtendedCookieJar))
                throw new Error("cookieJar must be an instance of ExtendedCookieJar");
            this._opts.cookieJar = cookieJar;
        }
    }
    function mergeObjects(original, objToMerge) {
        const ownKeys = Reflect.ownKeys(objToMerge);
        for (const key of ownKeys) {
            if (typeof objToMerge[key] === "object") {
                mergeObjects(original[key], objToMerge[key]);
            }
            else {
                original[key] = objToMerge[key];
            }
        }
    }

    // Partial implementation that covers everything we need
    const DELIMITER = ",";
    function camelize(str) {
        return str
            .split(" ")
            .map((str, i) => i === 0
            ? str.toLowerCase()
            : str[0].toUpperCase() + str.substr(1).toLowerCase())
            .join("");
    }
    function convert(input) {
        if (input.match(/\d{4,4}-\d{2,2}-\d{2,2}/))
            return new Date(input);
        if (input.match(/^[0-9\.]+$/))
            return parseFloat(input);
        if (input === "null")
            return null;
        return input;
    }
    function csv2json(csv) {
        const lines = csv.split("\n");
        // Actually we should handle this case, i.e. headers but no data.
        // if (lines.length === 1)
        //  throw new Error("No newlines in: " + csv);
        const headers = lines.shift().split(DELIMITER).map(camelize);
        const out = new Array(lines.length);
        for (let i = 0; i < lines.length; i++) {
            const inRow = lines[i].split(DELIMITER);
            const outRow = (out[i] = {});
            for (let j = 0; j < inRow.length; j++) {
                outRow[headers[j]] = convert(inRow[j]);
            }
        }
        return out;
    }

    /*
     * moduleExec(options: ModuleExecOptions)
     *
     * 1. Query Stage
     *   1. Validate user-supplied module params, e.g. { period: '1d' }
     *   2. Merge query params: (module defaults, user-supplied overrides, etc)
     *   3. Optionally transform query params
     *
     * 2. Call lib/yahooFinanceFetch
     *
     * 3. Result Stage
     *   1. Optional transform the result
     *   2. Validate the result and coerce types
     *
     * Further info below, inline.
     */
    async function moduleExec(opts) {
        var _a, _b;
        const queryOpts = opts.query;
        const moduleOpts = opts.moduleOptions;
        const moduleName = opts.moduleName;
        const resultOpts = opts.result;
        if (queryOpts.assertSymbol) {
            const symbol = queryOpts.assertSymbol;
            if (typeof symbol !== "string")
                throw new Error(`yahooFinance.${moduleName}() expects a single string symbol as its ` +
                    `query, not a(n) ${typeof symbol}: ${JSON.stringify(symbol)}`);
        }
        // Check that query options passed by the user are valid for this module
        validateAndCoerceTypebox({
            type: "options",
            data: (_a = queryOpts.overrides) !== null && _a !== void 0 ? _a : {},
            schema: queryOpts.schema,
            options: this._opts.validation,
        });
        let queryOptions = {
            ...queryOpts.defaults, // Module defaults e.g. { period: '1wk', lang: 'en' }
            ...queryOpts.runtime, // Runtime params e.g. { q: query }
            ...queryOpts.overrides, // User supplied options that override above
        };
        /*
         * Called with the merged (defaults,runtime,overrides) before running
         * the query.  Useful to transform options we allow but not Yahoo, e.g.
         * allow a "2020-01-01" date but transform this to a UNIX epoch.
         */
        if (queryOpts.transformWith) {
            queryOptions = queryOpts.transformWith(queryOptions);
        }
        // this._fetch is lib/yahooFinanceFetch
        let result = await this._fetch(queryOpts.url, queryOptions, moduleOpts, queryOpts.fetchType, (_b = queryOpts.needsCrumb) !== null && _b !== void 0 ? _b : false);
        if (queryOpts.fetchType === "csv") {
            result = csv2json(result);
        }
        /*
         * Mutate the Yahoo result *before* validating and coercion.  Mostly used
         * to e.g. throw if no (result.returnField) and return result.returnField.
         */
        if (resultOpts.transformWith) {
            result = resultOpts.transformWith(result);
        }
        const validateResult = !moduleOpts ||
            moduleOpts.validateResult === undefined ||
            moduleOpts.validateResult === true;
        const validationOpts = {
            ...this._opts.validation,
            // Set logErrors=false if validateResult=false
            logErrors: validateResult ? this._opts.validation.logErrors : false,
        };
        /*
         * Validate the returned result (after transforming, above) and coerce types.
         *
         * The coersion works as follows: if we're expecting a "Date" type, but Yahoo
         * gives us { raw: 1231421524, fmt: "2020-01-01" }, we'll return that as
         * `new Date(1231421524 * 1000)`.
         *
         * Beyond that, ensures that user won't process unexpected data, in two
         * cases:
         *
         * a) Missing required properties or unexpected additional properties
         * b) A total new change in format that we really have no idea what to do
         *    with, e.g. a new kind of Date that we've never seen before and
         *
         * The idea is that if you receive a result, it's safe to use / store in
         * database, etc.  Otherwise you'll receive an error.
         */
        try {
            return validateAndCoerceTypebox({
                type: "result",
                data: result,
                schema: resultOpts.schema,
                options: validationOpts,
            });
        }
        catch (error) {
            if (validateResult)
                throw error;
        }
        return result;
    }

    async function autoc() {
        throw new Error("Yahoo decomissioned their autoc server sometime before 20 Nov 2021 " +
            "(see https://github.com/gadicc/node-yahoo-finance2/issues/337])). " +
            "Use `search` instead (just like they do).");
    }

    /*
    The contents of this file are copied from:
    * https://github.com/sinclairzx81/typebox/blob/7a42aeef5bb989c07bbfc9acdbd9d74b3febed05/example/formats/date.ts
    * https://github.com/sinclairzx81/typebox/blob/7a42aeef5bb989c07bbfc9acdbd9d74b3febed05/example/formats/date-time.ts
    * https://github.com/sinclairzx81/typebox/blob/7a42aeef5bb989c07bbfc9acdbd9d74b3febed05/example/formats/time.ts
    *
    * License info:
    *
    * The MIT License (MIT)

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    */
    const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    const YEAR = /^(\d\d\d\d)$/;
    const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    const DATE_TIME_SEPARATOR = /t|\s/i;
    function IsLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    const isYear = (value) => {
        const matches = YEAR.exec(value);
        return !!matches;
    };
    /**
     * `[ajv-formats]` ISO8601 Date component
     * @example `2020-12-12`
     */
    const isDate = (value) => {
        const matches = DATE.exec(value);
        if (!matches)
            return false;
        const year = +matches[1];
        const month = +matches[2];
        const day = +matches[3];
        return (month >= 1 &&
            month <= 12 &&
            day >= 1 &&
            day <= (month === 2 && IsLeapYear(year) ? 29 : DAYS[month]));
    };
    /**
     * `[ajv-formats]` ISO8601 Time component
     * @example `20:20:39+00:00`
     */
    const isTime = (value, strictTimeZone) => {
        const matches = TIME.exec(value);
        if (!matches)
            return false;
        const hr = +matches[1];
        const min = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || (strictTimeZone && !tz))
            return false;
        if (hr <= 23 && min <= 59 && sec < 60)
            return true;
        const utcMin = min - tzM * tzSign;
        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return ((utcHr === 23 || utcHr === -1) &&
            (utcMin === 59 || utcMin === -1) &&
            sec < 61);
    };
    /**
     * `[ajv-formats]` ISO8601 DateTime
     * @example `2020-12-12T20:20:40+00:00`
     */
    const isDateTime = (value, strictTimeZone) => {
        const dateTime = value.split(DATE_TIME_SEPARATOR);
        return (dateTime.length === 2 &&
            isDate(dateTime[0]) &&
            isTime(dateTime[1], strictTimeZone));
    };

    Set$2("date", isDate);
    Set$2("date-time", isDateTime);
    Set$2("year", isYear);
    // Strictly must be empty
    const EmptyObjectCoerceToNull = Type.Transform(Type.Object({}, { maxProperties: 0, title: "EmptyObjectCoerceToNull" }))
        .Decode(() => null)
        .Encode(() => ({}));
    // Technically this will also contain a string 'fmt' key but we don't care because we don't use it
    const RawNumber = Type.Transform(Type.Object({
        raw: Type.Number(),
    }, {
        title: "RawNumber",
    }))
        .Decode((v) => v.raw)
        .Encode((v) => ({ raw: v }));
    const TwoNumberRangeString = Type.Transform(Type.RegExp(/^(-?\d+(?:\.\d+)?) - (-?\d+(?:\.\d+)?)$/g, {
        title: "TwoNumberRangeString",
    }))
        .Decode((value) => {
        // Split the two numbers allowing for negatives on either side
        const validatedNumbers = value.match(/-?\d+(?:\.\d+)?/g);
        if (!validatedNumbers) {
            throw new Error(`Unable to decode number range from: ${value}`);
        }
        const [low, high] = validatedNumbers.map((number) => parseFloat(number));
        if (isNaN(low) || isNaN(high)) {
            throw new Error(`Unable to decode number range from: ${value}. Decoded value for low is: ${low}, decoded value for high is: ${high}`);
        }
        return { low, high };
    })
        .Encode(({ low, high }) => `${low} - ${high}`);
    const TwoNumberRange = Type.Object({
        low: Type.Number(),
        high: Type.Number(),
    }, { title: "TwoNumberRange" });
    const EpochTimestamp = Type.Transform(Type.Number())
        .Decode((v) => new Date(v * 1000))
        .Encode((v) => +v / 1000);
    const RawDateObject = Type.Transform(Type.Object({
        raw: EpochTimestamp,
    }, { title: "RawDateObject" }))
        .Decode((v) => v.raw)
        .Encode((v) => ({
        raw: Encode(EpochTimestamp, v),
    }));
    const ISOStringDate = Type.Transform(Type.Union([
        Type.String({ format: "date" }),
        Type.String({ format: "year" }),
        Type.String({ format: "date-time" }),
    ], { title: "ISOStringDate" }))
        .Decode((v) => new Date(v))
        .Encode((v) => v.toISOString());
    const YahooFinanceDate = Type.Union([Type.Date(), EpochTimestamp, RawDateObject, ISOStringDate], { title: "YahooFinanceDate" });
    /**
     * Validates and decodes all nullable date representations produced by Yahoo
     * e.g. accepted inputs include:
     * - 1612313997
     * - { raw: 1612313997 }
     * - "2024-02-29"
     * - "2024-05-04T13:24:41.100Z"
     * - {} (coerces to null)
     */
    const NullableYahooFinanceDate = Type.Union([YahooFinanceDate, Type.Null(), EmptyObjectCoerceToNull], {
        title: "NullableYahooFinanceDate",
    });
    /**
     * Validates and decodes all number types and coerces to a number
     * e.g. accepted inputs include:
     * - 10.54
     * - {raw: 10.54, fmt: "%6f"}
     */
    const YahooNumber = Type.Union([RawNumber, Type.Number()], {
        title: "YahooNumber",
    });
    /**
     * Validates and decodes dates represented as milliseconds since the unix epoch to Date objects
     * e.g. accepted inputs include:
     * - 1612313997000
     */
    const YahooDateInMs = Type.Transform(Type.Number({ title: "YahooDateInMs" }))
        .Decode((v) => new Date(v))
        .Encode((v) => +v);
    /**
     * Validates and decodes all nullable number types and coerces to a number or null
     * e.g. accepted inputs include:
     * - 10.54
     * - {raw: 10.54, fmt: "%6f"}
     * - null
     * - {} (coerces to null)
     */
    const NullableYahooNumber = Type.Union([RawNumber, EmptyObjectCoerceToNull, Type.Number(), Type.Null()], {
        title: "NullableYahooNumber",
    });
    /**
     * Validates and decodes 2 number ranges to a consistent object format of { low: <number>, high: <number> }
     * e.g. accepted inputs include:
     * - { low: 103, high: 10043 }
     * - "-32432 - 453"
     */
    const YahooTwoNumberRange = Type.Union([TwoNumberRange, TwoNumberRangeString], {
        title: "YahooTwoNumberRange",
    });

    // Co-authored by @gadicc, @PythonCreator27 and @huned.
    const ChartMetaTradingPeriod = Type.Object({
        timezone: Type.String(), // "EST",
        start: YahooFinanceDate, // new Date(1637355600 * 1000),
        end: YahooFinanceDate, // new Date(1637370000 * 10000),
        gmtoffset: YahooNumber, // -18000
    }, {
        additionalProperties: Type.Any(),
        title: "ChartMetaTradingPeriod",
    });
    const ChartMetaTradingPeriods = Type.Object({
        pre: Type.Optional(Type.Array(Type.Array(ChartMetaTradingPeriod))),
        post: Type.Optional(Type.Array(Type.Array(ChartMetaTradingPeriod))),
        regular: Type.Optional(Type.Array(Type.Array(ChartMetaTradingPeriod))),
    }, {
        additionalProperties: Type.Any(),
        title: "ChartMetaTradingPeriods",
    });
    const ChartResultArrayQuote = Type.Object({
        date: YahooFinanceDate,
        high: Type.Union([YahooNumber, Type.Null()]),
        low: Type.Union([YahooNumber, Type.Null()]),
        open: Type.Union([YahooNumber, Type.Null()]),
        close: Type.Union([YahooNumber, Type.Null()]),
        volume: Type.Union([YahooNumber, Type.Null()]),
        adjclose: Type.Optional(Type.Union([YahooNumber, Type.Null()])),
    }, {
        additionalProperties: Type.Any(),
        title: "ChartResultArrayQuote",
    });
    const ChartEventDividend = Type.Object({
        amount: YahooNumber,
        date: YahooFinanceDate,
    }, {
        additionalProperties: Type.Any(),
        title: "ChartEventDividend",
    });
    const ChartEventDividends = Type.Object({}, {
        additionalProperties: ChartEventDividend,
        title: "ChartEventDividends",
    });
    const ChartEventSplit = Type.Object({
        date: YahooFinanceDate, // new Date(1598880600 * 1000)
        numerator: YahooNumber, // 4
        denominator: YahooNumber, // 1
        splitRatio: Type.String(), // "4:1"
    }, {
        additionalProperties: Type.Any(),
    });
    const ChartEventsArray = Type.Object({
        dividends: Type.Optional(Type.Array(ChartEventDividend)),
        splits: Type.Optional(Type.Array(ChartEventSplit)),
    }, {
        additionalProperties: Type.Any(),
        title: "ChartEventsArray",
    });
    const ChartMeta = Type.Object({
        currency: Type.String(), // "USD"
        symbol: Type.String(), // "AAPL",
        exchangeName: Type.String(), // "NMS",
        instrumentType: Type.String(), // "EQUITY",
        firstTradeDate: Type.Union([YahooFinanceDate, Type.Null()]), // new Date(345479400 * 1000); null in e.g. "APS.AX"
        regularMarketTime: YahooFinanceDate, // new Date(1637355602 * 1000),
        gmtoffset: YahooNumber, // -18000,
        timezone: Type.String(), /// "EST",
        exchangeTimezoneName: Type.String(), // "America/New_York",
        regularMarketPrice: YahooNumber, // 160.55,
        chartPreviousClose: Type.Optional(YahooNumber), // 79.75; missing in e.g. "APS.AX"
        previousClose: Type.Optional(YahooNumber), // 1137.06
        scale: Type.Optional(YahooNumber), // 3,
        priceHint: YahooNumber, // 2,
        currentTradingPeriod: Type.Object({
            pre: ChartMetaTradingPeriod,
            regular: ChartMetaTradingPeriod,
            post: ChartMetaTradingPeriod,
        }, {
            additionalProperties: Type.Any(),
        }),
        tradingPeriods: Type.Optional(
        // TODO, would be great to use correct type as a generic based on
        // `includePrePost` and `interval`, see #812.
        Type.Union([
            ChartMetaTradingPeriods,
            Type.Array(Type.Array(ChartMetaTradingPeriod)),
        ])),
        dataGranularity: Type.String(), // "1d",
        range: Type.String(), // ""
        validRanges: Type.Array(Type.String()), // ["1d", "5d", "1mo", "3mo", "6mo", "1y", "2y", "5y", "10y", "ytd", "max"]
    }, {
        additionalProperties: Type.Any(),
        title: "ChartMeta",
    });
    Type.Object({
        meta: ChartMeta,
        events: Type.Optional(ChartEventsArray),
        quotes: Type.Array(ChartResultArrayQuote),
    }, { title: "ChartResultArray" });
    const ChartEventSplits = Type.Object({}, {
        additionalProperties: ChartEventSplit,
        title: "ChartEventSplits",
    });
    const ChartIndicatorQuote = Type.Object({
        high: Type.Array(Type.Union([YahooNumber, Type.Null()])),
        low: Type.Array(Type.Union([YahooNumber, Type.Null()])),
        open: Type.Array(Type.Union([YahooNumber, Type.Null()])),
        close: Type.Array(Type.Union([YahooNumber, Type.Null()])),
        volume: Type.Array(Type.Union([YahooNumber, Type.Null()])),
    }, {
        additionalProperties: Type.Any(),
        title: "ChartIndicatorQuote",
    });
    const ChartIndicatorAdjclose = Type.Object({
        adjclose: Type.Optional(Type.Array(Type.Union([YahooNumber, Type.Null()]))), // Missing in e.g. "APS.AX"
    }, {
        additionalProperties: Type.Any(),
        title: "ChartIndicatorAdjClose",
    });
    const ChartEventsObject = Type.Object({
        dividends: Type.Optional(ChartEventDividends),
        splits: Type.Optional(ChartEventSplits),
    }, {
        additionalProperties: Type.Any(),
    });
    const ChartIndicatorsObject = Type.Object({
        quote: Type.Array(ChartIndicatorQuote),
        adjclose: Type.Optional(Type.Array(ChartIndicatorAdjclose)),
    }, {
        additionalProperties: Type.Any(),
        title: "ChartIndicatorObject",
    });
    const ChartResultObjectSchema = Type.Object({
        meta: ChartMeta,
        timestamp: Type.Optional(Type.Array(YahooNumber)),
        events: Type.Optional(ChartEventsObject),
        indicators: ChartIndicatorsObject,
    }, {
        additionalProperties: Type.Any(),
        title: "ChartResultObject",
    });
    const ChartOptionsSchema = Type.Object({
        period1: Type.Union([Type.Date(), Type.String(), YahooNumber]),
        period2: Type.Optional(Type.Union([Type.Date(), Type.String(), YahooNumber])),
        useYfid: Type.Optional(Type.Boolean()), // true
        interval: Type.Optional(Type.Union([
            Type.Literal("1m"),
            Type.Literal("2m"),
            Type.Literal("5m"),
            Type.Literal("15m"),
            Type.Literal("30m"),
            Type.Literal("60m"),
            Type.Literal("90m"),
            Type.Literal("1h"),
            Type.Literal("1d"),
            Type.Literal("5d"),
            Type.Literal("1wk"),
            Type.Literal("1mo"),
            Type.Literal("3mo"),
        ])),
        includePrePost: Type.Optional(Type.Boolean()), // true
        events: Type.Optional(Type.String()), // 'history',
        lang: Type.Optional(Type.String()), // "en-US"
        return: Type.Optional(Type.Union([Type.Literal("array"), Type.Literal("object")])),
    }, {
        title: "ChartOptions",
    });
    Type.Composite([
        ChartOptionsSchema,
        Type.Object({
            return: Type.Optional(Type.Literal("array")),
        }),
    ], {
        title: "ChartOptionsWithReturnArray",
    });
    Type.Composite([
        ChartOptionsSchema,
        Type.Object({
            return: Type.Literal("object"),
        }),
    ], {
        title: "ChartOptionsWithReturnObject",
    });
    const queryOptionsDefaults$b = {
        useYfid: true,
        interval: "1d",
        includePrePost: true,
        events: "div|split|earn",
        lang: "en-US",
        return: "array",
    };
    /* --- array input, typed output, honor "return" param --- */
    // TODO: make this a deprecration passthrough
    const _chart = chart;
    async function chart(symbol, queryOptionsOverrides, moduleOptions) {
        var _a, _b, _c;
        const returnAs = (queryOptionsOverrides === null || queryOptionsOverrides === void 0 ? void 0 : queryOptionsOverrides.return) || "array";
        const result = (await this._moduleExec({
            moduleName: "chart",
            query: {
                assertSymbol: symbol,
                url: "https://${YF_QUERY_HOST}/v8/finance/chart/" + symbol,
                schema: ChartOptionsSchema,
                defaults: queryOptionsDefaults$b,
                overrides: queryOptionsOverrides,
                transformWith(queryOptions) {
                    if (!queryOptions.period2)
                        queryOptions.period2 = new Date();
                    const dates = ["period1", "period2"];
                    for (const fieldName of dates) {
                        const value = queryOptions[fieldName];
                        if (value instanceof Date) {
                            queryOptions[fieldName] = Math.floor(value.getTime() / 1000);
                        }
                        else if (typeof value === "string") {
                            const timestamp = new Date(value).getTime();
                            if (isNaN(timestamp))
                                throw new Error("yahooFinance.chart() option '" +
                                    fieldName +
                                    "' invalid date provided: '" +
                                    value +
                                    "'");
                            queryOptions[fieldName] = Math.floor(timestamp / 1000);
                        }
                    }
                    if (queryOptions.period1 === queryOptions.period2) {
                        throw new Error("yahooFinance.chart() options `period1` and `period2` " +
                            "cannot share the same value.");
                    }
                    // Don't pass this on to Yahoo
                    delete queryOptions.return;
                    return queryOptions;
                },
            },
            result: {
                schema: ChartResultObjectSchema,
                transformWith(result) {
                    if (!result.chart)
                        throw new Error("Unexpected result: " + JSON.stringify(result));
                    const chart = result.chart.result[0];
                    // If there are no quotes, chart.timestamp will be empty, but Yahoo also
                    // gives us chart.indicators.quotes = [{}].  Let's clean that up and
                    // deliver an empty array rather than an invalid ChartIndicatorQuote/
                    if (!chart.timestamp) {
                        if (chart.indicators.quote.length !== 1)
                            throw new Error("No timestamp with quotes.length !== 1, please report with your query");
                        if (Object.keys(chart.indicators.quote[0]).length !== 0)
                            // i.e. {}
                            throw new Error("No timestamp with unexpected quote, please report with your query" +
                                JSON.stringify(chart.indicators.quote[0]));
                        chart.indicators.quote.pop();
                    }
                    return chart;
                },
            },
            moduleOptions,
        }));
        if (returnAs === "object") {
            return result;
        }
        else if (returnAs === "array") {
            const timestamp = result.timestamp;
            /*
            seems as though yahoo inserts extra quotes at the event times, so no need.
            if (result.events) {
              for (let event of ["dividends", "splits"]) {
                // @ts-ignore
                if (result.events[event])
                  // @ts-ignore
                  timestamp = timestamp.filter((ts) => !result.events[event][ts]);
              }
            }
            */
            // istanbul ignore next
            if (timestamp &&
                ((_a = result === null || result === void 0 ? void 0 : result.indicators) === null || _a === void 0 ? void 0 : _a.quote) &&
                result.indicators.quote[0].high.length !== timestamp.length) {
                console.log({
                    origTimestampSize: result.timestamp && result.timestamp.length,
                    filteredSize: timestamp.length,
                    quoteSize: result.indicators.quote[0].high.length,
                });
                throw new Error("Timestamp count mismatch, please report this with the query you used");
            }
            const result2 = {
                meta: result.meta,
                quotes: timestamp ? new Array(timestamp.length) : [],
            };
            const adjclose = (_c = (_b = result === null || result === void 0 ? void 0 : result.indicators) === null || _b === void 0 ? void 0 : _b.adjclose) === null || _c === void 0 ? void 0 : _c[0].adjclose;
            if (timestamp)
                for (let i = 0; i < timestamp.length; i++) {
                    result2.quotes[i] = {
                        date: new Date(timestamp[i] * 1000),
                        high: result.indicators.quote[0].high[i],
                        volume: result.indicators.quote[0].volume[i],
                        open: result.indicators.quote[0].open[i],
                        low: result.indicators.quote[0].low[i],
                        close: result.indicators.quote[0].close[i],
                    };
                    if (adjclose)
                        result2.quotes[i].adjclose = adjclose[i];
                }
            if (result.events) {
                result2.events = {};
                for (const event of ["dividends", "splits"]) {
                    // @ts-expect-error (eatkinson): Fix up type in follow up
                    if (result.events[event])
                        // @ts-expect-error (eatkinson): Fix up type in follow up
                        result2.events[event] = Object.values(result.events[event]);
                }
            }
            return result2;
        }
        // TypeScript runtime validation ensures no other values for
        // "returnAs" are possible.
    }

    const HistoricalRowHistorySchema = Type.Object({
        date: YahooFinanceDate,
        open: YahooNumber,
        high: YahooNumber,
        low: YahooNumber,
        close: YahooNumber,
        adjClose: Type.Optional(YahooNumber),
        volume: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "HistoricalRowHistory",
    });
    const HistoricalRowDividendSchema = Type.Object({
        date: YahooFinanceDate,
        dividends: YahooNumber,
    }, { title: "HistoricalRowDividend" });
    const HistoricalRowStockSplitSchema = Type.Object({
        date: YahooFinanceDate,
        stockSplits: Type.String(),
    }, { title: "HistoricalRowStockSplit" });
    const HistoricalOptionsSchema = Type.Object({
        period1: Type.Union([Type.Date(), Type.String(), Type.Number()]),
        period2: Type.Optional(Type.Union([Type.Date(), Type.String(), Type.Number()])),
        interval: Type.Optional(Type.Union([
            Type.Literal("1d"),
            Type.Literal("1wk"),
            Type.Literal("1mo"),
        ])),
        // events: Type.Optional(Type.String()),
        events: Type.Optional(Type.Union([
            Type.Literal("history"),
            Type.Literal("dividends"),
            Type.Literal("split"),
        ])),
        includeAdjustedClose: Type.Optional(Type.Boolean()),
    }, { title: "HistoricalOptions" });
    Type.Composite([
        HistoricalOptionsSchema,
        Type.Object({
            events: Type.Optional(Type.Literal("history")),
        }),
    ], { title: "HistoricalOptionsEventsHistory" });
    Type.Composite([
        HistoricalOptionsSchema,
        Type.Object({
            events: Type.Literal("dividends"),
        }),
    ], { title: "HistoricalOptionsEventsDividends" });
    Type.Composite([
        HistoricalOptionsSchema,
        Type.Object({
            events: Type.Literal("split"),
        }),
    ], { title: "HistoricalOptionsEventsSplit" });
    const HistoricalHistoryResultSchema = Type.Array(HistoricalRowHistorySchema, {
        title: "HistoricalHistoryResult",
    });
    const HistoricalDividendsResultSchema = Type.Array(HistoricalRowDividendSchema, {
        title: "HistoricalDividendsResult",
    });
    const HistoricalStockSplitsResultSchema = Type.Array(HistoricalRowStockSplitSchema, {
        title: "HistoricalRowStockSplit",
    });
    const queryOptionsDefaults$a = {
        interval: "1d",
        events: "history",
        includeAdjustedClose: true,
    };
    // Count number of null values in object (1-level deep)
    function nullFieldCount(object) {
        if (object == null) {
            return;
        }
        let nullCount = 0;
        for (const val of Object.values(object))
            if (val === null)
                nullCount++;
        return nullCount;
    }
    async function historical(symbol, queryOptionsOverrides, moduleOptions) {
        var _a, _b, _c, _d, _e;
        showNotice("ripHistorical");
        validateAndCoerceTypebox({
            type: "options",
            data: queryOptionsOverrides !== null && queryOptionsOverrides !== void 0 ? queryOptionsOverrides : {},
            schema: HistoricalOptionsSchema,
            options: this._opts.validation,
        });
        let schema;
        if (!queryOptionsOverrides.events ||
            queryOptionsOverrides.events === "history")
            schema = HistoricalHistoryResultSchema;
        else if (queryOptionsOverrides.events === "dividends")
            schema = HistoricalDividendsResultSchema;
        else if (queryOptionsOverrides.events === "split")
            schema = HistoricalStockSplitsResultSchema;
        else
            throw new Error("No such event type:" + queryOptionsOverrides.events);
        const queryOpts = { ...queryOptionsDefaults$a, ...queryOptionsOverrides };
        if (!Check(HistoricalOptionsSchema, queryOpts))
            throw new Error("Internal error, please report.  Overrides validated but not defaults?");
        // Don't forget that queryOpts are already validated and safe-safe.
        const eventsMap = { history: "", dividends: "div", split: "split" };
        const chartQueryOpts = {
            period1: queryOpts.period1,
            period2: queryOpts.period2,
            interval: queryOpts.interval,
            events: eventsMap[queryOpts.events || "history"],
        };
        if (!Check(ChartOptionsSchema, chartQueryOpts))
            throw new Error("Internal error, please report.  historical() provided invalid chart() query options.");
        // TODO: do we even care?
        if (queryOpts.includeAdjustedClose === false) ;
        const result = await this.chart(symbol, chartQueryOpts, {
            ...moduleOptions,
            validateResult: true,
        });
        let out;
        if (queryOpts.events === "dividends") {
            out = ((_b = (_a = result.events) === null || _a === void 0 ? void 0 : _a.dividends) !== null && _b !== void 0 ? _b : []).map((d) => ({
                date: d.date,
                dividends: d.amount,
            }));
        }
        else if (queryOpts.events === "split") {
            out = ((_d = (_c = result.events) === null || _c === void 0 ? void 0 : _c.splits) !== null && _d !== void 0 ? _d : []).map((s) => ({
                date: s.date,
                stockSplits: s.splitRatio,
            }));
        }
        else {
            out = ((_e = result.quotes) !== null && _e !== void 0 ? _e : [])
                .filter((quote) => {
                const fieldCount = Object.keys(quote).length;
                const nullCount = nullFieldCount(quote);
                if (nullCount === 0) {
                    // No nulls is a legit (regular) result
                    return true;
                }
                else if (nullCount !== fieldCount - 1 /* skip "date" */) {
                    // Unhandled case: some but not all values are null.
                    // Note: no need to check for null "date", validation does it for us
                    console.error(nullCount, quote);
                    throw new Error("Historical returned a result with SOME (but not " +
                        "all) null values.  Please report this, and provide the " +
                        "query that caused it.");
                }
                else {
                    // All fields (except "date") are null
                    return false;
                }
            })
                .map((quote) => {
                if (!quote.adjclose)
                    return quote;
                const { adjclose, ...rest } = quote;
                return { ...rest, adjClose: adjclose };
            });
        }
        const validateResult = !moduleOptions ||
            moduleOptions.validateResult === undefined ||
            moduleOptions.validateResult === true;
        const validationOpts = {
            ...this._opts.validation,
            // Set logErrors=false if validateResult=false
            logErrors: validateResult ? this._opts.validation.logErrors : false,
        };
        try {
            return validateAndCoerceTypebox({
                type: "result",
                data: out,
                schema,
                options: validationOpts,
            });
        }
        catch (error) {
            if (validateResult)
                throw error;
        }
        return out;
        /*
        // Original historical() retrieval code when Yahoo API still existed.
        return this._moduleExec({
          moduleName: "historical",
      
          query: {
            assertSymbol: symbol,
            url: "https://${YF_QUERY_HOST}/v7/finance/download/" + symbol,
            schema: HistoricalOptionsSchema,
            defaults: queryOptionsDefaults,
            overrides: queryOptionsOverrides,
            fetchType: "csv",
            transformWith(queryOptions: HistoricalOptions) {
              if (!queryOptions.period2) queryOptions.period2 = new Date();
      
              const dates = ["period1", "period2"] as const;
              for (const fieldName of dates) {
                const value = queryOptions[fieldName];
                if (value instanceof Date)
                  queryOptions[fieldName] = Math.floor(value.getTime() / 1000);
                else if (typeof value === "string") {
                  const timestamp = new Date(value as string).getTime();
      
                  if (isNaN(timestamp))
                    throw new Error(
                      "yahooFinance.historical() option '" +
                        fieldName +
                        "' invalid date provided: '" +
                        value +
                        "'",
                    );
      
                  queryOptions[fieldName] = Math.floor(timestamp / 1000);
                }
              }
      
              if (queryOptions.period1 === queryOptions.period2) {
                throw new Error(
                  "yahooFinance.historical() options `period1` and `period2` " +
                    "cannot share the same value.",
                );
              }
      
              return queryOptions;
            },
          },
      
          result: {
            schema,
            transformWith(result: any) {
              if (result.length === 0) return result;
      
              const filteredResults = [];
              const fieldCount = Object.keys(result[0]).length;
      
              // Count number of null values in object (1-level deep)
              function nullFieldCount(object: unknown) {
                if (object == null) {
                  return;
                }
                let nullCount = 0;
                for (const val of Object.values(object))
                  if (val === null) nullCount++;
                return nullCount;
              }
      
              for (const row of result) {
                const nullCount = nullFieldCount(row);
      
                if (nullCount === 0) {
                  // No nulls is a legit (regular) result
                  filteredResults.push(row);
                } else if (nullCount !== fieldCount - 1 /* skip "date" */ /*) {
          // Unhandled case: some but not all values are null.
          // Note: no need to check for null "date", validation does it for us
          console.error(nullCount, row);
          throw new Error(
            "Historical returned a result with SOME (but not " +
              "all) null values.  Please report this, and provide the " +
              "query that caused it.",
          );
        } else {
          // All fields (except "date") are null: silently skip (no-op)
        }
      }

      /*
       * We may consider, for future optimization, to count rows and create
       * new array in advance, and skip consecutive blocks of null results.
       * Of doubtful utility.
       */ /*
       return filteredResults;
     },
    },

    moduleOptions,
    });
    */
    }

    const InsightsDirection = Type.Union([Type.Literal("Bearish"), Type.Literal("Bullish"), Type.Literal("Neutral")], { title: "InsightsDirection" });
    const InsightsOutlookSchema = Type.Object({
        stateDescription: Type.String(),
        direction: InsightsDirection,
        score: YahooNumber,
        scoreDescription: Type.String(),
        sectorDirection: Type.Optional(InsightsDirection),
        sectorScore: Type.Optional(YahooNumber),
        sectorScoreDescription: Type.Optional(Type.String()),
        indexDirection: InsightsDirection,
        indexScore: YahooNumber,
        indexScoreDescription: Type.String(),
    }, {
        additionalProperties: Type.Any(),
        title: "InsightsOutlook",
    });
    const InsightsInstrumentInfo = Type.Object({
        keyTechnicals: Type.Object({
            provider: Type.String(),
            support: Type.Optional(YahooNumber),
            resistance: Type.Optional(YahooNumber),
            stopLoss: Type.Optional(YahooNumber),
        }, {
            additionalProperties: Type.Any(),
        }),
        technicalEvents: Type.Object({
            provider: Type.String(),
            sector: Type.Optional(Type.String()),
            shortTermOutlook: InsightsOutlookSchema,
            intermediateTermOutlook: InsightsOutlookSchema,
            longTermOutlook: InsightsOutlookSchema,
        }, {
            additionalProperties: Type.Any(),
        }),
        valuation: Type.Object({
            color: Type.Optional(YahooNumber),
            description: Type.Optional(Type.String()),
            discount: Type.Optional(Type.String()),
            provider: Type.String(),
            relativeValue: Type.Optional(Type.String()),
        }, {
            additionalProperties: Type.Any(),
        }),
    }, {
        additionalProperties: Type.Any(),
        title: "InsightsInstrumentInfo",
    });
    const InsightsCompanySnapshot = Type.Object({
        sectorInfo: Type.Optional(Type.String()),
        company: Type.Object({
            innovativeness: Type.Optional(YahooNumber),
            hiring: Type.Optional(YahooNumber),
            sustainability: Type.Optional(YahooNumber),
            insiderSentiments: Type.Optional(YahooNumber),
            earningsReports: Type.Optional(YahooNumber),
            dividends: Type.Optional(YahooNumber),
        }, {
            additionalProperties: Type.Any(),
        }),
        sector: Type.Object({
            innovativeness: YahooNumber,
            hiring: YahooNumber,
            sustainability: Type.Optional(YahooNumber),
            insiderSentiments: YahooNumber,
            earningsReports: Type.Optional(YahooNumber),
            dividends: YahooNumber,
        }, {
            additionalProperties: Type.Any(),
        }),
    }, { title: "InsightsCompanySnapshot", additionalProperties: Type.Any() });
    const InsightsEventSchema = Type.Object({
        eventType: Type.String(),
        pricePeriod: Type.String(),
        tradingHorizon: Type.String(),
        tradeType: Type.String(),
        imageUrl: Type.String(),
        startDate: YahooFinanceDate,
        endDate: YahooFinanceDate,
    }, { title: "InsightsEvent", additionalProperties: Type.Any() });
    const InsightsReport = Type.Object({
        id: Type.String(),
        headHtml: Type.String(),
        provider: Type.String(),
        reportDate: YahooFinanceDate,
        reportTitle: Type.String(),
        reportType: Type.String(),
        targetPrice: Type.Optional(YahooNumber),
        targetPriceStatus: Type.Optional(Type.Union([
            Type.Literal("Increased"),
            Type.Literal("Maintained"),
            Type.Literal("Decreased"),
            Type.Literal("-"),
        ])),
        investmentRating: Type.Optional(Type.Union([
            Type.Literal("Bullish"),
            Type.Literal("Neutral"),
            Type.Literal("Bearish"),
        ])),
        tickers: Type.Optional(Type.Array(Type.String())),
    }, { title: "InsightsReport", additionalProperties: Type.Any() });
    const InsightsSigDev = Type.Object({
        headline: Type.String(),
        date: YahooFinanceDate,
    }, { title: "InsightsSigDev", additionalProperties: Type.Any() });
    const InsightsUpsell = Type.Object({
        msBullishSummary: Type.Optional(Type.Array(Type.String())),
        msBearishSummary: Type.Optional(Type.Array(Type.String())),
        msBullishBearishSummariesPublishDate: Type.Optional(YahooDateInMs),
        companyName: Type.Optional(Type.String()),
        upsellReportType: Type.Optional(Type.String()),
    }, { title: "InsightsUpsell", additionalProperties: Type.Any() });
    const InsightsResearchReport = Type.Object({
        reportId: Type.String(),
        provider: Type.String(),
        title: Type.String(),
        reportDate: YahooFinanceDate,
        summary: Type.String(),
        investmentRating: Type.Optional(Type.Union([
            Type.Literal("Bullish"),
            Type.Literal("Neutral"),
            Type.Literal("Bearish"),
        ])),
    }, { title: "InsightsResearchReport" });
    const InsightsSecReport = Type.Object({
        id: Type.String(),
        type: Type.String(),
        title: Type.String(),
        description: Type.String(),
        filingDate: YahooDateInMs,
        snapshotUrl: Type.String(),
        formType: Type.String(),
    }, {
        title: "InsightsSecReport",
        additionalProperties: Type.Any(),
    });
    const InsightsResultSchema = Type.Object({
        symbol: Type.String(),
        instrumentInfo: Type.Optional(InsightsInstrumentInfo),
        companySnapshot: Type.Optional(InsightsCompanySnapshot),
        recommendation: Type.Optional(Type.Object({
            targetPrice: Type.Optional(YahooNumber),
            provider: Type.String(),
            rating: Type.Union([
                Type.Literal("BUY"),
                Type.Literal("SELL"),
                Type.Literal("HOLD"),
            ]),
        })),
        events: Type.Optional(Type.Array(InsightsEventSchema)),
        reports: Type.Optional(Type.Array(InsightsReport)),
        sigDevs: Type.Optional(Type.Array(InsightsSigDev)),
        upsell: Type.Optional(InsightsUpsell),
        upsellSearchDD: Type.Optional(Type.Object({
            researchReports: InsightsResearchReport,
        })),
        secReports: Type.Optional(Type.Array(InsightsSecReport)),
    }, {
        additionalProperties: Type.Any(),
        title: "InsightsResult",
    });
    const InsightsOptionsSchema = Type.Object({
        lang: Type.Optional(Type.String()),
        region: Type.Optional(Type.String()),
        reportsCount: Type.Optional(YahooNumber),
    }, { title: "InsightsOptions" });
    const queryOptionsDefaults$9 = {
        lang: "en-US",
        region: "US",
        getAllResearchReports: true,
        reportsCount: 2,
    };
    function trendingSymbols$1(symbol, queryOptionsOverrides, moduleOptions) {
        return this._moduleExec({
            moduleName: "insights",
            query: {
                assertSymbol: symbol,
                url: "https://${YF_QUERY_HOST}/ws/insights/v2/finance/insights",
                schema: InsightsOptionsSchema,
                defaults: queryOptionsDefaults$9,
                overrides: queryOptionsOverrides,
                runtime: { symbol },
            },
            result: {
                schema: InsightsResultSchema,
                transformWith(result) {
                    if (!result.finance)
                        throw new Error("Unexpected result: " + JSON.stringify(result));
                    return result.finance.result;
                },
            },
            moduleOptions,
        });
    }

    const QuoteBase = Type.Object({
        language: Type.String(), // "en-US",
        region: Type.String(), // "US",
        quoteType: Type.String(), // "EQUITY" | "ETF" | "MUTUALFUND";
        typeDisp: Type.Optional(Type.String()), // "Equity", not always present.
        quoteSourceName: Type.Optional(Type.String()), // "Delayed Quote",
        triggerable: Type.Boolean(), // true,
        currency: Type.Optional(Type.String()), // "USD",
        // Seems to appear / disappear based not on symbol but network load (#445)
        customPriceAlertConfidence: Type.Optional(Type.String()), // "HIGH" | "LOW"; TODO: anything else?
        marketState: Type.Union([
            Type.Literal("REGULAR"),
            Type.Literal("CLOSED"),
            Type.Literal("PRE"),
            Type.Literal("PREPRE"),
            Type.Literal("POST"),
            Type.Literal("POSTPOST"),
        ]),
        tradeable: Type.Boolean(), // false,
        cryptoTradeable: Type.Optional(Type.Boolean()), // false
        exchange: Type.String(), // "NMS",
        shortName: Type.Optional(Type.String()), // "NVIDIA Corporation",
        longName: Type.Optional(Type.String()), // "NVIDIA Corporation",
        messageBoardId: Type.Optional(Type.String()), // "finmb_32307",
        exchangeTimezoneName: Type.String(), // "America/New_York",
        exchangeTimezoneShortName: Type.String(), // "EST",
        gmtOffSetMilliseconds: YahooNumber, // -18000000,
        market: Type.String(), // "us_market",
        esgPopulated: Type.Boolean(), // false,
        fiftyTwoWeekLowChange: Type.Optional(YahooNumber), // 362.96002,
        fiftyTwoWeekLowChangePercent: Type.Optional(YahooNumber), // 2.0088556,
        fiftyTwoWeekRange: Type.Optional(YahooTwoNumberRange), // "180.68 - 589.07" -> { low, high }
        fiftyTwoWeekHighChange: Type.Optional(YahooNumber), // -45.429993,
        fiftyTwoWeekHighChangePercent: Type.Optional(YahooNumber), // -0.07712155,
        fiftyTwoWeekLow: Type.Optional(YahooNumber), // 180.68,
        fiftyTwoWeekHigh: Type.Optional(YahooNumber), // 589.07,
        fiftyTwoWeekChangePercent: Type.Optional(YahooNumber), // 22.604025
        dividendDate: Type.Optional(YahooFinanceDate), // 1609200000,
        // maybe always present on EQUITY?
        earningsTimestamp: Type.Optional(YahooFinanceDate), // 1614200400,
        earningsTimestampStart: Type.Optional(YahooFinanceDate), // 1614200400,
        earningsTimestampEnd: Type.Optional(YahooFinanceDate), // 1614200400,
        trailingAnnualDividendRate: Type.Optional(YahooNumber), // 0.64,
        trailingPE: Type.Optional(YahooNumber), // 88.873634,
        trailingAnnualDividendYield: Type.Optional(YahooNumber), // 0.0011709387,
        epsTrailingTwelveMonths: Type.Optional(YahooNumber), // 6.117,
        epsForward: Type.Optional(YahooNumber), // 11.68,
        epsCurrentYear: Type.Optional(YahooNumber), // 9.72,
        priceEpsCurrentYear: Type.Optional(YahooNumber), // 55.930042,
        sharesOutstanding: Type.Optional(YahooNumber), // 619000000,
        bookValue: Type.Optional(YahooNumber), // 24.772,
        fiftyDayAverage: Type.Optional(YahooNumber), // 530.8828,
        fiftyDayAverageChange: Type.Optional(YahooNumber), // 12.757202,
        fiftyDayAverageChangePercent: Type.Optional(YahooNumber), // 0.024030166,
        twoHundredDayAverage: Type.Optional(YahooNumber), // 515.8518,
        twoHundredDayAverageChange: Type.Optional(YahooNumber), // 27.788208,
        twoHundredDayAverageChangePercent: Type.Optional(YahooNumber), // 0.053868588,
        marketCap: Type.Optional(YahooNumber), // 336513171456,
        forwardPE: Type.Optional(YahooNumber), // 46.54452,
        priceToBook: Type.Optional(YahooNumber), // 21.945745,
        sourceInterval: YahooNumber, // 15,
        exchangeDataDelayedBy: YahooNumber, // 0,
        firstTradeDateMilliseconds: Type.Optional(YahooDateInMs), // 917015400000 -> Date
        priceHint: YahooNumber, // 2,
        postMarketChangePercent: Type.Optional(YahooNumber), // 0.093813874,
        postMarketTime: Type.Optional(YahooFinanceDate), // 1612573179 -> new Date()
        postMarketPrice: Type.Optional(YahooNumber), // 544.15,
        postMarketChange: Type.Optional(YahooNumber), // 0.51000977,
        regularMarketChange: Type.Optional(YahooNumber), // -2.9299927,
        regularMarketChangePercent: Type.Optional(YahooNumber), // -0.53606904,
        regularMarketTime: Type.Optional(YahooFinanceDate), // 1612558802 -> new Date()
        regularMarketPrice: Type.Optional(YahooNumber), // 543.64,
        regularMarketDayHigh: Type.Optional(YahooNumber), // 549.19,
        regularMarketDayRange: Type.Optional(YahooTwoNumberRange), // "541.867 - 549.19" -> { low, high }
        regularMarketDayLow: Type.Optional(YahooNumber), // 541.867,
        regularMarketVolume: Type.Optional(YahooNumber), // 4228841,
        regularMarketPreviousClose: Type.Optional(YahooNumber), // 546.57,
        preMarketChange: Type.Optional(YahooNumber), // -2.9299927,
        preMarketChangePercent: Type.Optional(YahooNumber), // -0.53606904,
        preMarketTime: Type.Optional(YahooFinanceDate), // 1612558802 -> new Date()
        preMarketPrice: Type.Optional(YahooNumber), // 543.64,
        bid: Type.Optional(YahooNumber), // 543.84,
        ask: Type.Optional(YahooNumber), // 544.15,
        bidSize: Type.Optional(YahooNumber), // 18,
        askSize: Type.Optional(YahooNumber), // 8,
        fullExchangeName: Type.String(), // "NasdaqGS",
        financialCurrency: Type.Optional(Type.String()), // "USD",
        regularMarketOpen: Type.Optional(YahooNumber), // 549.0,
        averageDailyVolume3Month: Type.Optional(YahooNumber), // 7475022,
        averageDailyVolume10Day: Type.Optional(YahooNumber), // 5546385,
        displayName: Type.Optional(Type.String()), // "NVIDIA",
        symbol: Type.String(), // "NVDA"
        underlyingSymbol: Type.Optional(Type.String()), // "LD.MI" (for LDO.MI, #363)
        // only on ETF?  not on EQUITY?
        ytdReturn: Type.Optional(YahooNumber), // 0.31
        trailingThreeMonthReturns: Type.Optional(YahooNumber), // 16.98
        trailingThreeMonthNavReturns: Type.Optional(YahooNumber), // 17.08
        ipoExpectedDate: Type.Optional(YahooFinanceDate), // "2020-08-13",
        newListingDate: Type.Optional(YahooFinanceDate), // "2021-02-16",
        nameChangeDate: Type.Optional(YahooFinanceDate),
        prevName: Type.Optional(Type.String()),
        averageAnalystRating: Type.Optional(Type.String()),
        pageViewGrowthWeekly: Type.Optional(YahooNumber), // Since 2021-11-11 (#326)
        openInterest: Type.Optional(YahooNumber), // SOHO (#248)
        beta: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
    });
    /*
     * [TODO] Fields seen in a query but not in this module yet:
     *
     *   - extendedMarketChange
     *   - extendedMarketChangePercent
     *   - extendedMarketPrice
     *   - extendedMarketTime
     *   - dayHigh (separate to regularMarketDayHigh, etc)
     *   - dayLow (separate to regularMarketDayLow, etc)
     *   - volume (separaet to regularMarketVolume, etc)
     *
     * i.e. on yahoo site, with ?fields=dayHigh,dayLow,etc.
     */
    /*
     * Guaranteed fields, even we don't ask for them
     */
    const QuoteCryptoCurrency = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("CRYPTOCURRENCY"),
            circulatingSupply: YahooNumber,
            fromCurrency: Type.String(), // 'BTC'
            toCurrency: Type.String(), // 'USD=X'
            lastMarket: Type.String(), // 'CoinMarketCap'
            coinImageUrl: Type.Optional(Type.String()), // 'https://s.yimg.com/uc/fin/img/reports-thumbnails/1.png'
            volume24Hr: Type.Optional(YahooNumber), // 62631043072
            volumeAllCurrencies: Type.Optional(YahooNumber), // 62631043072
            startDate: Type.Optional(YahooFinanceDate), // new Date(1367103600 * 1000)
        }),
    ]);
    const QuoteCurrency = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("CURRENCY"),
        }),
    ]);
    const QuoteEtf = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("ETF"),
        }),
    ]);
    const QuoteEquity = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("EQUITY"),
            dividendRate: Type.Optional(Type.Number()),
            dividendYield: Type.Optional(Type.Number()),
        }),
    ]);
    const QuoteFuture = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("FUTURE"),
            headSymbolAsString: Type.String(),
            contractSymbol: Type.Boolean(),
            underlyingExchangeSymbol: Type.String(),
            expireDate: YahooFinanceDate,
            expireIsoDate: YahooFinanceDate,
        }),
    ]);
    const QuoteIndex = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("INDEX"),
        }),
    ]);
    const QuoteOption = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("OPTION"),
            strike: YahooNumber,
            openInterest: YahooNumber,
            expireDate: YahooNumber,
            expireIsoDate: YahooNumber,
            underlyingSymbol: Type.String(),
        }),
    ]);
    const QuoteMutualfund = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("MUTUALFUND"),
        }),
    ]);
    const QuoteSchema$1 = Type.Union([
        QuoteCryptoCurrency,
        QuoteCurrency,
        QuoteEtf,
        QuoteEquity,
        QuoteFuture,
        QuoteIndex,
        QuoteMutualfund,
        QuoteOption,
    ]);
    const QuoteFieldSchema = Type.KeyOf(QuoteSchema$1);
    const ResultType = Type.Union([
        Type.Literal("array"),
        Type.Literal("object"),
        Type.Literal("map"),
    ]);
    const QuoteResponseArraySchema = Type.Array(QuoteSchema$1);
    const QuoteOptionsSchema = Type.Object({
        fields: Type.Optional(Type.Array(QuoteFieldSchema)),
        return: Type.Optional(ResultType),
    });
    Type.Composite([
        QuoteOptionsSchema,
        Type.Object({
            return: Type.Optional(Type.Literal("array")),
        }),
    ]);
    Type.Composite([
        QuoteOptionsSchema,
        Type.Object({
            return: Type.Literal("map"),
        }),
    ]);
    Type.Composite([
        QuoteOptionsSchema,
        Type.Object({
            return: Type.Literal("object"),
        }),
    ]);
    const queryOptionsDefaults$8 = {};
    async function quote(query, queryOptionsOverrides, moduleOptions) {
        const symbols = typeof query === "string" ? query : query.join(",");
        const returnAs = queryOptionsOverrides && queryOptionsOverrides.return;
        const results = await this._moduleExec({
            moduleName: "quote",
            query: {
                url: "https://${YF_QUERY_HOST}/v7/finance/quote",
                needsCrumb: true,
                schema: QuoteOptionsSchema,
                defaults: queryOptionsDefaults$8,
                runtime: { symbols },
                overrides: queryOptionsOverrides,
                transformWith(queryOptions) {
                    // Options validation ensures this is a string[]
                    if (queryOptions.fields)
                        queryOptions.fields.join(",");
                    // Don't pass this on to Yahoo
                    delete queryOptions.return;
                    return queryOptions;
                },
            },
            result: {
                schema: QuoteResponseArraySchema,
                transformWith(rawResult) {
                    var _a;
                    // console.log({ rawResult: JSON.stringify(rawResult, null, 2) });
                    let results = (_a = rawResult === null || rawResult === void 0 ? void 0 : rawResult.quoteResponse) === null || _a === void 0 ? void 0 : _a.result;
                    if (!results || !Array.isArray(results))
                        throw new Error("Unexpected result: " + JSON.stringify(rawResult));
                    // Filter out quoteType==='NONE'
                    // So that delisted stocks will be undefined just like symbol-not-found
                    results = results.filter((quote) => (quote === null || quote === void 0 ? void 0 : quote.quoteType) !== "NONE");
                    return results;
                },
            },
            moduleOptions,
        });
        if (returnAs) {
            switch (returnAs) {
                case "array":
                    return results;
                case "object": {
                    const object = {};
                    for (const result of results)
                        object[result.symbol] = result;
                    return object; // TODO: type
                }
                case "map": {
                    const map = new Map();
                    for (const result of results)
                        map.set(result.symbol, result);
                    return map; // TODO: type
                }
            }
        }
        else {
            // By default, match the query input shape (string or string[]).
            return typeof query === "string"
                ? results[0]
                : results;
        }
    }

    /*
     * [TODO] Fields seen in a query but not in this module yet:
     *
     *   - extendedMarketChange
     *   - extendedMarketChangePercent
     *   - extendedMarketPrice
     *   - extendedMarketTime
     *   - dayHigh (separate to regularMarketDayHigh, etc)
     *   - dayLow (separate to regularMarketDayLow, etc)
     *   - volume (separate to regularMarketVolume, etc)
     *
     * i.e. on yahoo site, with ?fields=dayHigh,dayLow,etc.
     */
    /*
     * Guaranteed fields, even we don't ask for them
     */
    const QuoteCryptoCurrencySchema = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("CRYPTOCURRENCY"),
            circulatingSupply: YahooNumber,
            fromCurrency: Type.String(), // 'BTC'
            toCurrency: Type.String(), // 'USD=X'
            lastMarket: Type.String(), // 'CoinMarketCap'
            coinImageUrl: Type.Optional(Type.String()), // 'https://s.yimg.com/uc/fin/img/reports-thumbnails/1.png'
            volume24Hr: Type.Optional(YahooNumber), // 62631043072
            volumeAllCurrencies: Type.Optional(YahooNumber), // 62631043072
            startDate: Type.Optional(YahooFinanceDate), // new Date(1367103600 * 1000)
        }),
    ], { title: "QuoteCryptoCurrency" });
    const QuoteCurrencySchema = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("CURRENCY"),
        }),
    ], { title: "QuoteCurrency" });
    const QuoteEtfSchema = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("ETF"),
        }),
    ]);
    const QuoteEquitySchema = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("EQUITY"),
            dividendRate: Type.Optional(Type.Number()),
            dividendYield: Type.Optional(Type.Number()),
        }),
    ], { title: "QuoteEquity" });
    const QuoteFutureSchema = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("FUTURE"),
            headSymbolAsString: Type.String(),
            contractSymbol: Type.Boolean(),
            underlyingExchangeSymbol: Type.String(),
            expireDate: YahooFinanceDate,
            expireIsoDate: YahooFinanceDate,
        }),
    ], {
        title: "QuoteFuture",
    });
    const QuoteIndexSchema = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("INDEX"),
        }),
    ], {
        title: "QuoteIndex",
    });
    const QuoteOptionSchema = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("OPTION"),
            strike: YahooNumber,
            openInterest: YahooNumber,
            expireDate: YahooNumber,
            expireIsoDate: YahooNumber,
            underlyingSymbol: Type.String(),
        }),
    ], {
        title: "QuoteOption",
    });
    const QuoteMutualfundSchema = Type.Composite([
        QuoteBase,
        Type.Object({
            quoteType: Type.Literal("MUTUALFUND"),
        }),
    ], {
        title: "QuoteMutualFund",
    });
    const QuoteSchema = Type.Union([
        QuoteCryptoCurrencySchema,
        QuoteCurrencySchema,
        QuoteEtfSchema,
        QuoteEquitySchema,
        QuoteFutureSchema,
        QuoteIndexSchema,
        QuoteMutualfundSchema,
        QuoteOptionSchema,
    ], {
        title: "Quote",
    });
    const CallOrPutSchema = Type.Object({
        contractSymbol: Type.String(),
        strike: YahooNumber,
        currency: Type.Optional(Type.String()),
        lastPrice: YahooNumber,
        change: YahooNumber,
        percentChange: Type.Optional(YahooNumber),
        volume: Type.Optional(YahooNumber),
        openInterest: Type.Optional(YahooNumber),
        bid: Type.Optional(YahooNumber),
        ask: Type.Optional(YahooNumber),
        contractSize: Type.Literal("REGULAR"),
        expiration: YahooFinanceDate,
        lastTradeDate: YahooFinanceDate,
        impliedVolatility: YahooNumber,
        inTheMoney: Type.Boolean(),
    }, {
        additionalProperties: Type.Any(),
        title: "CallOrPut",
    });
    const OptionSchema = Type.Object({
        expirationDate: YahooFinanceDate,
        hasMiniOptions: Type.Boolean(),
        calls: Type.Array(CallOrPutSchema),
        puts: Type.Array(CallOrPutSchema),
    }, {
        additionalProperties: Type.Any(),
        title: "Option",
    });
    const OptionsResultSchema = Type.Object({
        underlyingSymbol: Type.String(),
        expirationDates: Type.Array(YahooFinanceDate),
        strikes: Type.Array(YahooNumber),
        hasMiniOptions: Type.Boolean(),
        quote: QuoteSchema,
        options: Type.Array(OptionSchema),
    }, {
        additionalProperties: Type.Any(),
        title: "OptionsResult",
    });
    const OptionsOptionsSchema = Type.Object({
        formatted: Type.Optional(Type.Boolean()),
        lang: Type.Optional(Type.String()),
        region: Type.Optional(Type.String()),
        date: Type.Optional(YahooFinanceDate),
    }, {
        title: "OptionsOptions",
    });
    const queryOptionsDefaults$7 = {
        formatted: false,
        lang: "en-US",
        region: "US",
    };
    function options(symbol, queryOptionsOverrides, moduleOptions) {
        return this._moduleExec({
            moduleName: "options",
            query: {
                assertSymbol: symbol,
                url: "https://${YF_QUERY_HOST}/v7/finance/options/" + symbol,
                needsCrumb: true,
                schema: OptionsOptionsSchema,
                defaults: queryOptionsDefaults$7,
                overrides: queryOptionsOverrides,
                transformWith(queryOptions) {
                    // This is honestly the easiest way to coerce the date properly
                    const parsed = Decode(OptionsOptionsSchema, queryOptions);
                    const transformed = parsed.date
                        ? {
                            ...parsed,
                            date: Math.floor(parsed.date.getTime() / 1000),
                        }
                        : parsed;
                    return transformed;
                },
            },
            result: {
                schema: OptionsResultSchema,
                transformWith(result) {
                    if (!result.optionChain)
                        throw new Error("Unexpected result: " + JSON.stringify(result));
                    return result.optionChain.result[0];
                },
            },
            moduleOptions,
        });
    }

    /*
     * To generate the initial file, we took the output of all submodules for
     * 'AAPL', 'OCDO.L', '0700.HK' and '^IXIC' and ran the results through
     * the awesome https://app.quicktype.io/
     * and then the smashing https://sinclairzx81.github.io/typebox-workbench
     *
     * Manual cleanup afterwards:
     *
     *  1) Spaces: 4 to 2
     *  ~~2) Wrapped in a module~~ <--- undid this after tooling issues.
     *  3) Alphabeticalize QuoteSummaryResult
     */
    var EnumGrade;
    (function (EnumGrade) {
        EnumGrade["Accumulate"] = "Accumulate";
        EnumGrade["Add"] = "Add";
        EnumGrade["Average"] = "Average";
        EnumGrade["BelowAverage"] = "Below Average";
        EnumGrade["Buy"] = "Buy";
        EnumGrade["ConvictionBuy"] = "Conviction Buy";
        EnumGrade["Empty"] = "";
        EnumGrade["EqualWeight"] = "Equal-Weight";
        EnumGrade["FairValue"] = "Fair Value";
        EnumGrade["GradeEqualWeight"] = "Equal-weight";
        EnumGrade["GradeLongTermBuy"] = "Long-term Buy";
        EnumGrade["Hold"] = "Hold";
        EnumGrade["LongTermBuy"] = "Long-Term Buy";
        EnumGrade["MarketOutperform"] = "Market Outperform";
        EnumGrade["MarketPerform"] = "Market Perform";
        EnumGrade["Mixed"] = "Mixed";
        EnumGrade["Negative"] = "Negative";
        EnumGrade["Neutral"] = "Neutral";
        EnumGrade["InLine"] = "In-Line";
        EnumGrade["Outperform"] = "Outperform";
        EnumGrade["Overweight"] = "Overweight";
        EnumGrade["PeerPerform"] = "Peer Perform";
        EnumGrade["Perform"] = "Perform";
        EnumGrade["Positive"] = "Positive";
        EnumGrade["Reduce"] = "Reduce";
        EnumGrade["SectorOutperform"] = "Sector Outperform";
        EnumGrade["SectorPerform"] = "Sector Perform";
        EnumGrade["SectorWeight"] = "Sector Weight";
        EnumGrade["Sell"] = "Sell";
        EnumGrade["StrongBuy"] = "Strong Buy";
        EnumGrade["TopPick"] = "Top Pick";
        EnumGrade["Underperform"] = "Underperform";
        EnumGrade["Underperformer"] = "Underperformer";
        EnumGrade["Underweight"] = "Underweight";
        EnumGrade["Trim"] = "Trim";
        EnumGrade["AboveAverage"] = "Above Average";
        EnumGrade["Inline"] = "In-line";
        EnumGrade["Outperformer"] = "Outperformer";
        EnumGrade["OVerweight"] = "OVerweight";
        EnumGrade["Cautious"] = "Cautious";
        EnumGrade["MarketWeight"] = "Market Weight";
        EnumGrade["SectorUnderperform"] = "Sector Underperform";
        EnumGrade["MarketUnderperform"] = "Market Underperform";
        EnumGrade["Peerperform"] = "Peer perform";
        EnumGrade["GraduallyAccumulate"] = "Gradually Accumulate";
        EnumGrade["ActionListBuy"] = "Action List Buy";
        EnumGrade["Performer"] = "Performer";
        EnumGrade["SectorPerformer"] = "Sector Performer";
        EnumGrade["SpeculativeBuy"] = "Speculative Buy";
        EnumGrade["StrongSell"] = "Strong Sell";
        EnumGrade["SpeculativeHold"] = "Speculative Hold";
        EnumGrade["NotRated"] = "Not Rated";
        EnumGrade["HoldNeutral"] = "Hold Neutral";
        EnumGrade["Developing"] = "Developing";
        EnumGrade["buy"] = "buy";
        EnumGrade["HOld"] = "HOld";
        EnumGrade["TradingSell"] = "Trading Sell";
        EnumGrade["Tender"] = "Tender";
        EnumGrade["marketperform"] = "market perform";
        EnumGrade["BUy"] = "BUy";
    })(EnumGrade || (EnumGrade = {}));
    var Action;
    (function (Action) {
        Action["Down"] = "down";
        Action["Init"] = "init";
        Action["Main"] = "main";
        Action["Reit"] = "reit";
        Action["Up"] = "up";
    })(Action || (Action = {}));
    const Grade = Type.Enum(EnumGrade, { title: "QuoteSummaryEnumGrade" });
    const ActionSchema = Type.Enum(Action, { title: "QuoteSummaryAction" });
    const UpgradeDowngradeHistoryHistorySchema = Type.Object({
        epochGradeDate: YahooFinanceDate,
        firm: Type.String(),
        toGrade: Grade,
        fromGrade: Type.Optional(Grade),
        action: ActionSchema,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryUpgradeDowngradeHistoryHistory",
    });
    const UpgradeDowngradeHistorySchema = Type.Object({
        history: Type.Array(UpgradeDowngradeHistoryHistorySchema),
        maxAge: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryUpgradeDowngradeHistory",
    });
    const TopHoldingsSectorWeightingSchema = Type.Object({
        realestate: Type.Optional(YahooNumber),
        consumer_cyclical: Type.Optional(YahooNumber),
        basic_materials: Type.Optional(YahooNumber),
        consumer_defensive: Type.Optional(YahooNumber),
        technology: Type.Optional(YahooNumber),
        communication_services: Type.Optional(YahooNumber),
        financial_services: Type.Optional(YahooNumber),
        utilities: Type.Optional(YahooNumber),
        industrials: Type.Optional(YahooNumber),
        energy: Type.Optional(YahooNumber),
        healthcare: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryTopHoldingsSectorWeighting",
    });
    const TopHoldingsBondRatingSchema = Type.Object({
        a: Type.Optional(YahooNumber),
        aa: Type.Optional(YahooNumber),
        aaa: Type.Optional(YahooNumber),
        other: Type.Optional(YahooNumber),
        b: Type.Optional(YahooNumber),
        bb: Type.Optional(YahooNumber),
        bbb: Type.Optional(YahooNumber),
        below_b: Type.Optional(YahooNumber),
        us_government: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryTopHoldingsBondRating",
    });
    const TopHoldingsEquityHoldingsSchema = Type.Object({
        medianMarketCap: Type.Optional(YahooNumber),
        medianMarketCapCat: Type.Optional(YahooNumber),
        priceToBook: YahooNumber,
        priceToBookCat: Type.Optional(YahooNumber),
        priceToCashflow: YahooNumber,
        priceToCashflowCat: Type.Optional(YahooNumber),
        priceToEarnings: YahooNumber,
        priceToEarningsCat: Type.Optional(YahooNumber),
        priceToSales: YahooNumber,
        priceToSalesCat: Type.Optional(YahooNumber),
        threeYearEarningsGrowth: Type.Optional(YahooNumber),
        threeYearEarningsGrowthCat: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryTopHoldingsEquityHoldings",
    });
    const TopHoldingsHoldingSchema = Type.Object({
        symbol: Type.String(),
        holdingName: Type.String(),
        holdingPercent: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryTopHoldingsHolding",
    });
    const TopHoldingsSchema = Type.Object({
        maxAge: YahooNumber,
        stockPosition: Type.Optional(YahooNumber),
        bondPosition: Type.Optional(YahooNumber),
        holdings: Type.Array(TopHoldingsHoldingSchema),
        equityHoldings: TopHoldingsEquityHoldingsSchema,
        bondHoldings: Type.Object({}),
        bondRatings: Type.Array(TopHoldingsBondRatingSchema),
        sectorWeightings: Type.Array(TopHoldingsSectorWeightingSchema),
        cashPosition: Type.Optional(YahooNumber),
        otherPosition: Type.Optional(YahooNumber),
        preferredPosition: Type.Optional(YahooNumber),
        convertiblePosition: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryTopHoldings",
    });
    const SummaryProfileSchema = Type.Object({
        address1: Type.Optional(Type.String()),
        address2: Type.Optional(Type.String()),
        address3: Type.Optional(Type.String()),
        city: Type.Optional(Type.String()),
        state: Type.Optional(Type.String()),
        zip: Type.Optional(Type.String()),
        country: Type.Optional(Type.String()),
        phone: Type.Optional(Type.String()),
        fax: Type.Optional(Type.String()),
        website: Type.Optional(Type.String()),
        industry: Type.Optional(Type.String()),
        industryDisp: Type.Optional(Type.String()),
        sector: Type.Optional(Type.String()),
        sectorDisp: Type.Optional(Type.String()),
        longBusinessSummary: Type.Optional(Type.String()),
        fullTimeEmployees: Type.Optional(YahooNumber),
        companyOfficers: Type.Array(Type.Any()),
        maxAge: YahooNumber,
        twitter: Type.Optional(Type.String()), // in e.g. "ADA-USD" (#418)
        // seems like for cryptocurency only
        // TODO: how does this relate to Quote type.  Common base?
        name: Type.Optional(Type.String()), // 'Bitcoin'
        startDate: Type.Optional(YahooFinanceDate), // new Date('2013-04-28')
        description: Type.Optional(Type.String()), // 'Bitcoin (BTC) is a cryptocurrency...'
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummarySummaryProfile",
    });
    const SummaryDetailSchema = Type.Object({
        maxAge: YahooNumber,
        priceHint: YahooNumber,
        previousClose: Type.Optional(YahooNumber), // missing in e.g. "APS.AX"
        open: Type.Optional(YahooNumber),
        dayLow: Type.Optional(YahooNumber),
        dayHigh: Type.Optional(YahooNumber),
        regularMarketPreviousClose: Type.Optional(YahooNumber), // missing in e.g. "APS.AX"
        regularMarketOpen: Type.Optional(YahooNumber),
        regularMarketDayLow: Type.Optional(YahooNumber),
        regularMarketDayHigh: Type.Optional(YahooNumber),
        regularMarketVolume: Type.Optional(YahooNumber),
        dividendRate: Type.Optional(YahooNumber),
        dividendYield: Type.Optional(YahooNumber),
        exDividendDate: Type.Optional(YahooFinanceDate),
        payoutRatio: Type.Optional(YahooNumber),
        fiveYearAvgDividendYield: Type.Optional(YahooNumber),
        beta: Type.Optional(YahooNumber),
        trailingPE: Type.Optional(YahooNumber),
        forwardPE: Type.Optional(YahooNumber),
        volume: Type.Optional(YahooNumber),
        averageVolume: Type.Optional(YahooNumber),
        averageVolume10days: Type.Optional(YahooNumber),
        averageDailyVolume10Day: Type.Optional(YahooNumber),
        bid: Type.Optional(YahooNumber),
        ask: Type.Optional(YahooNumber),
        bidSize: Type.Optional(YahooNumber),
        askSize: Type.Optional(YahooNumber),
        marketCap: Type.Optional(YahooNumber),
        fiftyDayAverage: Type.Optional(YahooNumber),
        fiftyTwoWeekLow: Type.Optional(YahooNumber),
        fiftyTwoWeekHigh: Type.Optional(YahooNumber),
        twoHundredDayAverage: Type.Optional(YahooNumber),
        priceToSalesTrailing12Months: Type.Optional(YahooNumber),
        trailingAnnualDividendRate: Type.Optional(YahooNumber),
        trailingAnnualDividendYield: Type.Optional(YahooNumber),
        currency: Type.String(),
        algorithm: Type.Null(),
        tradeable: Type.Boolean(),
        yield: Type.Optional(YahooNumber),
        totalAssets: Type.Optional(YahooNumber),
        navPrice: Type.Optional(YahooNumber),
        ytdReturn: Type.Optional(YahooNumber),
        // crypto only (optional, or null in other types)
        // TODO: how does Price / SummaryDetail compare? common base?
        fromCurrency: Type.Union([Type.String(), Type.Null()]), // 'BTC'
        toCurrency: Type.Optional(Type.Union([Type.String(), Type.Null()])), // 'USD-X'
        lastMarket: Type.Union([Type.String(), Type.Null()]), // 'CoinMarketCap'
        volume24Hr: Type.Optional(YahooNumber), // 62650314752
        volumeAllCurrencies: Type.Optional(YahooNumber), // 62650314752
        circulatingSupply: Type.Optional(YahooNumber), // 18638932
        startDate: Type.Optional(YahooFinanceDate), // new Date(1367107200 * 1000)
        coinMarketCapLink: Type.Optional(Type.Union([Type.String(), Type.Null()])), // "https://coinmarketcap.com/currencies/cardano"
        // futures
        expireDate: Type.Optional(YahooFinanceDate), // 1656374400,
        openInterest: Type.Optional(YahooNumber), // 444411,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummarySummaryDetail",
    });
    // May consider switching this to string, as we keep finding more and more.
    const FilingType = Type.Union([
        Type.Literal("10-K"),
        Type.Literal("10-Q"),
        Type.Literal("8-K"),
        Type.Literal("8-K/A"),
        Type.Literal("10-K/A"),
        Type.Literal("10-Q/A"),
        Type.Literal("SD"),
        Type.Literal("PX14A6G"),
        Type.Literal("SC 13G/A"),
        Type.Literal("DEFA14A"),
        Type.Literal("25-NSE"),
        Type.Literal("S-8 POS"),
        Type.Literal("6-K"),
        Type.Literal("F-3ASR"),
        Type.Literal("SC 13D/A"),
        Type.Literal("20-F"),
        Type.Literal("425"),
        Type.Literal("SC14D9C"),
        Type.Literal("SC 13G"),
        Type.Literal("S-8"),
        Type.Literal("DEF 14A"),
        Type.Literal("F-10"),
    ], {
        title: "QuoteSummaryFilingType",
    });
    const FilingSchema = Type.Object({
        date: Type.String(),
        epochDate: YahooFinanceDate,
        type: FilingType,
        title: Type.String(),
        edgarUrl: Type.String(),
        maxAge: YahooNumber,
        url: Type.Optional(Type.String()),
        exhibits: Type.Optional(Type.Array(Type.Object({
            type: Type.String(),
            url: Type.String(),
            downloadUrl: Type.Optional(Type.String()),
        }))),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFiling",
    });
    const SECFilingsSchema = Type.Object({
        filings: Type.Array(FilingSchema),
        maxAge: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummarySECFilings",
    });
    const RecommendationTrendTrendSchema = Type.Object({
        period: Type.String(),
        strongBuy: YahooNumber,
        buy: YahooNumber,
        hold: YahooNumber,
        sell: YahooNumber,
        strongSell: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryRecommendationTrendTrend",
    });
    const RecommendationTrendSchema = Type.Object({
        trend: Type.Array(RecommendationTrendTrendSchema),
        maxAge: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryRecommendationTrend",
    });
    const QuoteTypeSchema = Type.Object({
        exchange: Type.String(),
        quoteType: Type.String(),
        symbol: Type.String(),
        underlyingSymbol: Type.String(),
        shortName: Type.Union([Type.Null(), Type.String()]),
        longName: Type.Union([Type.Null(), Type.String()]),
        firstTradeDateEpochUtc: NullableYahooFinanceDate,
        timeZoneFullName: Type.String(),
        timeZoneShortName: Type.String(),
        uuid: Type.String(),
        messageBoardId: Type.Optional(Type.Union([Type.Null(), Type.String()])),
        gmtOffSetMilliseconds: YahooNumber,
        maxAge: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryQuoteType",
    });
    const PriceSchema = Type.Object({
        averageDailyVolume10Day: Type.Optional(YahooNumber),
        averageDailyVolume3Month: Type.Optional(YahooNumber),
        exchange: Type.Optional(Type.String()),
        exchangeName: Type.Optional(Type.String()),
        exchangeDataDelayedBy: Type.Optional(YahooNumber),
        maxAge: YahooNumber,
        postMarketChangePercent: Type.Optional(YahooNumber),
        postMarketChange: Type.Optional(YahooNumber),
        postMarketTime: Type.Optional(YahooFinanceDate),
        postMarketPrice: Type.Optional(YahooNumber),
        postMarketSource: Type.Optional(Type.String()),
        preMarketChangePercent: Type.Optional(YahooNumber),
        preMarketChange: Type.Optional(YahooNumber),
        preMarketTime: Type.Optional(YahooFinanceDate),
        preMarketPrice: Type.Optional(YahooNumber),
        preMarketSource: Type.Optional(Type.String()),
        priceHint: YahooNumber,
        regularMarketChangePercent: Type.Optional(YahooNumber),
        regularMarketChange: Type.Optional(YahooNumber),
        regularMarketTime: Type.Optional(YahooFinanceDate),
        regularMarketPrice: Type.Optional(YahooNumber),
        regularMarketDayHigh: Type.Optional(YahooNumber),
        regularMarketDayLow: Type.Optional(YahooNumber),
        regularMarketVolume: Type.Optional(YahooNumber),
        regularMarketPreviousClose: Type.Optional(YahooNumber),
        regularMarketSource: Type.Optional(Type.String()),
        regularMarketOpen: Type.Optional(YahooNumber),
        quoteSourceName: Type.Optional(Type.String()),
        quoteType: Type.String(),
        symbol: Type.String(),
        underlyingSymbol: Type.Union([Type.Null(), Type.String()]),
        shortName: Type.Union([Type.Null(), Type.String()]),
        longName: Type.Union([Type.Null(), Type.String()]),
        lastMarket: Type.Union([Type.Null(), Type.String()]),
        marketState: Type.Optional(Type.String()),
        marketCap: Type.Optional(YahooNumber),
        currency: Type.Optional(Type.String()),
        currencySymbol: Type.Optional(Type.String()),
        fromCurrency: Type.Union([Type.String(), Type.Null()]),
        toCurrency: Type.Optional(Type.Union([Type.String(), Type.Null()])),
        volume24Hr: Type.Optional(YahooNumber),
        volumeAllCurrencies: Type.Optional(YahooNumber),
        circulatingSupply: Type.Optional(YahooNumber),
        expireDate: Type.Optional(YahooFinanceDate),
        openInterest: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryPrice",
    });
    const NetSharePurchaseActivitySchema = Type.Object({
        maxAge: YahooNumber,
        period: Type.String(),
        buyInfoCount: YahooNumber,
        buyInfoShares: YahooNumber,
        buyPercentInsiderShares: Type.Optional(YahooNumber),
        sellInfoCount: YahooNumber,
        sellInfoShares: Type.Optional(YahooNumber),
        sellPercentInsiderShares: Type.Optional(YahooNumber),
        netInfoCount: YahooNumber,
        netInfoShares: YahooNumber,
        netPercentInsiderShares: Type.Optional(YahooNumber),
        totalInsiderShares: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryNetSharePurchaseActivity",
    });
    const MajorHoldersBreakdownSchema = Type.Object({
        maxAge: YahooNumber,
        insidersPercentHeld: Type.Optional(YahooNumber),
        institutionsPercentHeld: Type.Optional(YahooNumber),
        institutionsFloatPercentHeld: Type.Optional(YahooNumber),
        institutionsCount: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryMajorHoldersBreakdown",
    });
    var EnumOwnership;
    (function (EnumOwnership) {
        EnumOwnership["D"] = "D";
        EnumOwnership["I"] = "I";
    })(EnumOwnership || (EnumOwnership = {}));
    var EnumRelation;
    (function (EnumRelation) {
        EnumRelation["ChairmanOfTheBoard"] = "Chairman of the Board";
        EnumRelation["ChiefExecutiveOfficer"] = "Chief Executive Officer";
        EnumRelation["ChiefFinancialOfficer"] = "Chief Financial Officer";
        EnumRelation["ChiefOperatingOfficer"] = "Chief Operating Officer";
        EnumRelation["ChiefTechnologyOfficer"] = "Chief Technology Officer";
        EnumRelation["Director"] = "Director";
        EnumRelation["DirectorIndependent"] = "Director (Independent)";
        EnumRelation["Empty"] = "";
        EnumRelation["GeneralCounsel"] = "General Counsel";
        EnumRelation["IndependentNonExecutiveDirector"] = "Independent Non-Executive Director";
        EnumRelation["Officer"] = "Officer";
        EnumRelation["President"] = "President";
    })(EnumRelation || (EnumRelation = {}));
    const Relation = Type.Enum(EnumRelation, { title: "QuoteSummaryRelation" });
    const OwnershipEnumSchema = Type.Enum(EnumOwnership, {
        title: "QuoteSummaryOwnershipEnum",
    });
    const TransactionSchema = Type.Object({
        maxAge: YahooNumber,
        shares: YahooNumber,
        filerUrl: Type.String(),
        transactionText: Type.String(),
        filerName: Type.String(),
        filerRelation: Type.Union([Relation, Type.String()]),
        moneyText: Type.String(),
        startDate: YahooFinanceDate,
        ownership: Type.Union([OwnershipEnumSchema, Type.String()]),
        value: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryTransaction",
    });
    Type.Object({
        transactions: Type.Array(TransactionSchema),
        maxAge: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryInsiderTransactions",
    });
    const HolderSchema = Type.Object({
        maxAge: YahooNumber,
        name: Type.String(),
        relation: Type.Union([Relation, Type.String()]),
        url: Type.String(),
        transactionDescription: Type.String(),
        latestTransDate: YahooFinanceDate,
        positionDirect: Type.Optional(YahooNumber),
        positionDirectDate: Type.Optional(YahooFinanceDate),
        positionIndirect: Type.Optional(YahooNumber),
        positionIndirectDate: Type.Optional(YahooFinanceDate),
        positionSummaryDate: Type.Optional(YahooFinanceDate),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryHolder",
    });
    const HoldersSchema = Type.Object({
        holders: Type.Array(HolderSchema),
        maxAge: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryHolders",
    });
    const TrendSchema = Type.Object({
        maxAge: YahooNumber,
        symbol: Type.Null(),
        estimates: Type.Array(Type.Any()),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryTrend",
    });
    const EstimateSchema = Type.Object({
        period: Type.String(),
        growth: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryEstimate",
    });
    const IndexTrendSchema = Type.Object({
        maxAge: YahooNumber,
        symbol: Type.String(),
        peRatio: YahooNumber,
        pegRatio: YahooNumber,
        estimates: Type.Array(EstimateSchema),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryIndexTrend",
    });
    const IncomeStatementHistoryElementSchema = Type.Object({
        maxAge: NullableYahooNumber,
        endDate: YahooFinanceDate,
        totalRevenue: NullableYahooNumber,
        costOfRevenue: NullableYahooNumber,
        grossProfit: NullableYahooNumber,
        researchDevelopment: NullableYahooNumber,
        sellingGeneralAdministrative: NullableYahooNumber,
        nonRecurring: NullableYahooNumber,
        otherOperatingExpenses: NullableYahooNumber,
        totalOperatingExpenses: NullableYahooNumber,
        operatingIncome: NullableYahooNumber,
        totalOtherIncomeExpenseNet: NullableYahooNumber,
        ebit: NullableYahooNumber,
        interestExpense: NullableYahooNumber,
        incomeBeforeTax: NullableYahooNumber,
        incomeTaxExpense: NullableYahooNumber,
        minorityInterest: NullableYahooNumber,
        netIncomeFromContinuingOps: NullableYahooNumber,
        discontinuedOperations: NullableYahooNumber,
        extraordinaryItems: NullableYahooNumber,
        effectOfAccountingCharges: NullableYahooNumber,
        otherItems: NullableYahooNumber,
        netIncome: NullableYahooNumber,
        netIncomeApplicableToCommonShares: NullableYahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryIncomeStatementHistoryElement",
    });
    const IncomeStatementHistorySchema = Type.Object({
        incomeStatementHistory: Type.Array(IncomeStatementHistoryElementSchema),
        maxAge: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryIncomeStatementHistory",
    });
    const FundProfileBrokerageSchema = Type.Object({}, {
        title: "QuoteSummaryFundProfileBrokerage",
    });
    const FundProfileFeesExpensesInvestmentSchema = Type.Object({
        annualHoldingsTurnover: Type.Optional(YahooNumber),
        annualReportExpenseRatio: Type.Optional(YahooNumber),
        grossExpRatio: Type.Optional(YahooNumber),
        netExpRatio: Type.Optional(YahooNumber),
        projectionValues: Type.Object({}),
        totalNetAssets: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFundProfileFeesExpensesInvestment",
    });
    const FundProfileFeesExpensesInvestmentCatSchema = Type.Composite([
        Type.Omit(FundProfileFeesExpensesInvestmentSchema, ["projectionValues"]),
        Type.Object({
            projectionValuesCat: Type.Object({}),
        }),
    ], {
        title: "QuoteSummaryFundProfileFeesExpensesInvestmentCat",
        additionalProperties: Type.Any(),
    });
    const FundProfileManagementInfoSchema = Type.Object({
        managerName: Type.Union([Type.Null(), Type.String()]),
        managerBio: Type.Union([Type.Null(), Type.String()]),
        startdate: Type.Optional(YahooFinanceDate),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFundProfileManagementInfo",
    });
    const FundProfileSchema = Type.Object({
        maxAge: YahooNumber,
        styleBoxUrl: Type.Optional(Type.Union([Type.Null(), Type.String()])),
        family: Type.Union([Type.Null(), Type.String()]),
        categoryName: Type.Union([Type.Null(), Type.String()]),
        legalType: Type.Union([Type.Null(), Type.String()]),
        managementInfo: Type.Optional(FundProfileManagementInfoSchema),
        feesExpensesInvestment: Type.Optional(FundProfileFeesExpensesInvestmentSchema),
        feesExpensesInvestmentCat: Type.Optional(FundProfileFeesExpensesInvestmentCatSchema),
        brokerages: Type.Optional(Type.Array(FundProfileBrokerageSchema)),
        initInvestment: Type.Optional(YahooNumber),
        initIraInvestment: Type.Optional(YahooNumber),
        initAipInvestment: Type.Optional(YahooNumber),
        subseqInvestment: Type.Optional(YahooNumber),
        subseqIraInvestment: Type.Optional(YahooNumber),
        subseqAipInvestment: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFundProfile",
    });
    const FundPerformanceRiskOverviewStatsRowSchema = Type.Object({
        year: Type.String(), // "5y" | "3y" | "10y" | anything else?
        alpha: YahooNumber, // 7.76
        beta: YahooNumber, // 1.04
        meanAnnualReturn: YahooNumber, // 2.05
        rSquared: YahooNumber, // 84.03
        stdDev: Type.Optional(YahooNumber), // 17.12
        sharpeRatio: YahooNumber, // 1.37
        treynorRatio: YahooNumber, // 23.61
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFundPerformanceRiskOverviewStatsRow",
    });
    const FundPerformanceRiskOverviewStatsCatSchema = Type.Object({
        riskStatisticsCat: Type.Array(FundPerformanceRiskOverviewStatsRowSchema),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFundPerformanceRiskOverviewStatsCat",
    });
    const FundPerformanceRiskOverviewStatsSchema = Type.Object({
        riskStatistics: Type.Array(FundPerformanceRiskOverviewStatsRowSchema),
        riskRating: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFundPerformanceRiskOverviewStats",
    });
    const FundPerformanceReturnsRowSchema = Type.Object({
        year: YahooFinanceDate,
        annualValue: Type.Optional(YahooNumber),
        q1: Type.Optional(YahooNumber),
        q2: Type.Optional(YahooNumber),
        q3: Type.Optional(YahooNumber),
        q4: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFundPerformanceReturnsRow",
    });
    const FundPerformanceReturnsSchema = Type.Object({
        returns: Type.Array(FundPerformanceReturnsRowSchema),
        returnsCat: Type.Optional(Type.Array(FundPerformanceReturnsRowSchema)),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFundPerformanceReturns",
    });
    const FundPerformancePerformanceOverviewCatSchema = Type.Object({
        ytdReturnPct: Type.Optional(YahooNumber),
        fiveYrAvgReturnPct: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFundPerformancePerformanceOverviewCat",
    });
    const FundPerformancePerformanceOverviewSchema = Type.Object({
        asOfDate: Type.Optional(YahooFinanceDate),
        ytdReturnPct: Type.Optional(YahooNumber),
        oneYearTotalReturn: Type.Optional(YahooNumber),
        threeYearTotalReturn: Type.Optional(YahooNumber),
        fiveYrAvgReturnPct: Type.Optional(YahooNumber),
        morningStarReturnRating: Type.Optional(YahooNumber),
        numYearsUp: Type.Optional(YahooNumber),
        numYearsDown: Type.Optional(YahooNumber),
        bestOneYrTotalReturn: Type.Optional(YahooNumber),
        worstOneYrTotalReturn: Type.Optional(YahooNumber),
        bestThreeYrTotalReturn: Type.Optional(YahooNumber),
        worstThreeYrTotalReturn: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFundPerformancePerformanceOverview",
    });
    const PeriodRangeSchema = Type.Object({
        asOfDate: Type.Optional(YahooFinanceDate),
        ytd: Type.Optional(YahooNumber),
        oneMonth: Type.Optional(YahooNumber),
        threeMonth: Type.Optional(YahooNumber),
        oneYear: Type.Optional(YahooNumber),
        threeYear: Type.Optional(YahooNumber),
        fiveYear: Type.Optional(YahooNumber),
        tenYear: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryPeriodRange",
    });
    const FundPerformanceTrailingReturnsSchema = Type.Composite([
        PeriodRangeSchema,
        Type.Object({
            lastBullMkt: Type.Optional(YahooNumber),
            lastBearMkt: Type.Optional(YahooNumber),
        }, {
            additionalProperties: Type.Any(),
        }),
    ], {
        title: "QuoteSummaryFundPerformanceTrailingReturns",
    });
    const FundPerformanceSchema = Type.Object({
        maxAge: YahooNumber,
        loadAdjustedReturns: Type.Optional(PeriodRangeSchema),
        rankInCategory: Type.Optional(PeriodRangeSchema),
        performanceOverview: FundPerformancePerformanceOverviewSchema,
        performanceOverviewCat: FundPerformancePerformanceOverviewCatSchema,
        trailingReturns: FundPerformanceTrailingReturnsSchema,
        trailingReturnsNav: FundPerformanceTrailingReturnsSchema,
        trailingReturnsCat: FundPerformanceTrailingReturnsSchema,
        annualTotalReturns: FundPerformanceReturnsSchema,
        pastQuarterlyReturns: FundPerformanceReturnsSchema,
        riskOverviewStatistics: FundPerformanceRiskOverviewStatsSchema,
        riskOverviewStatisticsCat: FundPerformanceRiskOverviewStatsCatSchema,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFundPerformance",
    });
    const OwnershipListSchema = Type.Object({
        maxAge: YahooNumber,
        reportDate: YahooFinanceDate,
        organization: Type.String(),
        pctHeld: YahooNumber,
        position: YahooNumber,
        value: YahooNumber,
        pctChange: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryOwnershipList",
    });
    const OwnershipSchema = Type.Object({
        maxAge: YahooNumber,
        ownershipList: Type.Array(OwnershipListSchema),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryOwnership",
    });
    const FinancialDataSchema = Type.Object({
        maxAge: YahooNumber,
        currentPrice: Type.Optional(YahooNumber),
        targetHighPrice: Type.Optional(YahooNumber),
        targetLowPrice: Type.Optional(YahooNumber),
        targetMeanPrice: Type.Optional(YahooNumber),
        targetMedianPrice: Type.Optional(YahooNumber),
        recommendationMean: Type.Optional(YahooNumber),
        recommendationKey: Type.String(),
        numberOfAnalystOpinions: Type.Optional(YahooNumber),
        totalCash: Type.Optional(YahooNumber),
        totalCashPerShare: Type.Optional(YahooNumber),
        ebitda: Type.Optional(YahooNumber),
        totalDebt: Type.Optional(YahooNumber),
        quickRatio: Type.Optional(YahooNumber),
        currentRatio: Type.Optional(YahooNumber),
        totalRevenue: Type.Optional(YahooNumber),
        debtToEquity: Type.Optional(YahooNumber),
        revenuePerShare: Type.Optional(YahooNumber),
        returnOnAssets: Type.Optional(YahooNumber),
        returnOnEquity: Type.Optional(YahooNumber),
        grossProfits: Type.Optional(YahooNumber),
        freeCashflow: Type.Optional(YahooNumber),
        operatingCashflow: Type.Optional(YahooNumber),
        earningsGrowth: Type.Optional(YahooNumber),
        revenueGrowth: Type.Optional(YahooNumber),
        grossMargins: Type.Optional(YahooNumber),
        ebitdaMargins: Type.Optional(YahooNumber),
        operatingMargins: Type.Optional(YahooNumber),
        profitMargins: Type.Optional(YahooNumber),
        financialCurrency: Type.Union([Type.String(), Type.Null()]),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFinancialData",
    });
    const RevenueEstimateSchema = Type.Object({
        avg: NullableYahooNumber,
        low: NullableYahooNumber,
        high: NullableYahooNumber,
        numberOfAnalysts: NullableYahooNumber,
        yearAgoRevenue: NullableYahooNumber,
        growth: NullableYahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryRevenueEstimate",
    });
    const EpsTrendSchema = Type.Object({
        current: NullableYahooNumber,
        "7daysAgo": NullableYahooNumber,
        "30daysAgo": NullableYahooNumber,
        "60daysAgo": NullableYahooNumber,
        "90daysAgo": NullableYahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryEpsTrend",
    });
    const EpsRevisionsSchema = Type.Object({
        upLast7days: NullableYahooNumber,
        upLast30days: NullableYahooNumber,
        downLast30days: NullableYahooNumber,
        downLast90days: NullableYahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryEpsRevisions",
    });
    const EarningsEstimateSchema = Type.Object({
        avg: NullableYahooNumber,
        low: NullableYahooNumber,
        high: NullableYahooNumber,
        yearAgoEps: NullableYahooNumber,
        numberOfAnalysts: NullableYahooNumber,
        growth: NullableYahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryEarningsEstimate",
    });
    const EarningsTrendTrendSchema = Type.Object({
        maxAge: YahooNumber,
        period: Type.String(),
        endDate: NullableYahooFinanceDate,
        growth: NullableYahooNumber,
        earningsEstimate: EarningsEstimateSchema,
        revenueEstimate: RevenueEstimateSchema,
        epsTrend: EpsTrendSchema,
        epsRevisions: EpsRevisionsSchema,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryEarningsTrendTrend",
    });
    const EarningsTrendSchema = Type.Object({
        trend: Type.Array(EarningsTrendTrendSchema),
        maxAge: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryEarningsTrend",
    });
    const EarningsHistoryHistorySchema = Type.Object({
        maxAge: YahooNumber,
        epsActual: NullableYahooNumber,
        epsEstimate: NullableYahooNumber,
        epsDifference: NullableYahooNumber,
        surprisePercent: NullableYahooNumber,
        quarter: NullableYahooFinanceDate,
        period: Type.String(),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryEarningsHistoryHistory",
    });
    const EarningsHistorySchema = Type.Object({
        history: Type.Array(EarningsHistoryHistorySchema),
        maxAge: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryEarningsHistory",
    });
    const YearlySchema = Type.Object({
        date: YahooNumber,
        revenue: YahooNumber,
        earnings: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryYearly",
    });
    const FinancialsChartQuarterlySchema = Type.Object({
        date: Type.String(),
        revenue: YahooNumber,
        earnings: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFinancialsChartQuarterly",
    });
    const FinancialsChartSchema = Type.Object({
        yearly: Type.Array(YearlySchema),
        quarterly: Type.Array(FinancialsChartQuarterlySchema),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryFinancialsChart",
    });
    const EarningsChartQuarterlySchema = Type.Object({
        date: Type.String(),
        actual: YahooNumber,
        estimate: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryEarningsChartQuarterly",
    });
    const EarningsChartSchema = Type.Object({
        quarterly: Type.Array(EarningsChartQuarterlySchema),
        currentQuarterEstimate: Type.Optional(YahooNumber),
        currentQuarterEstimateDate: Type.Optional(Type.String()),
        currentQuarterEstimateYear: Type.Optional(YahooNumber),
        earningsDate: Type.Array(YahooFinanceDate),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryEarningsChart",
    });
    const QuoteSummaryEarningsSchema = Type.Object({
        maxAge: YahooNumber,
        earningsChart: EarningsChartSchema,
        financialsChart: FinancialsChartSchema,
        financialCurrency: Type.Optional(Type.String()),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryEarnings",
    });
    const DefaultKeyStatisticsSchema = Type.Object({
        maxAge: YahooNumber,
        priceHint: YahooNumber,
        enterpriseValue: Type.Optional(YahooNumber),
        forwardPE: Type.Optional(YahooNumber),
        profitMargins: Type.Optional(YahooNumber),
        floatShares: Type.Optional(YahooNumber),
        sharesOutstanding: Type.Optional(YahooNumber),
        sharesShort: Type.Optional(YahooNumber),
        sharesShortPriorMonth: Type.Optional(YahooFinanceDate),
        sharesShortPreviousMonthDate: Type.Optional(YahooFinanceDate),
        dateShortInterest: Type.Optional(YahooNumber),
        sharesPercentSharesOut: Type.Optional(YahooNumber),
        heldPercentInsiders: Type.Optional(YahooNumber),
        heldPercentInstitutions: Type.Optional(YahooNumber),
        shortRatio: Type.Optional(YahooNumber),
        shortPercentOfFloat: Type.Optional(YahooNumber),
        beta: Type.Optional(YahooNumber),
        impliedSharesOutstanding: Type.Optional(YahooNumber),
        category: Type.Union([Type.Null(), Type.String()]),
        bookValue: Type.Optional(YahooNumber),
        priceToBook: Type.Optional(YahooNumber),
        fundFamily: Type.Union([Type.Null(), Type.String()]),
        legalType: Type.Union([Type.Null(), Type.String()]),
        lastFiscalYearEnd: Type.Optional(YahooFinanceDate),
        nextFiscalYearEnd: Type.Optional(YahooFinanceDate),
        mostRecentQuarter: Type.Optional(YahooFinanceDate),
        earningsQuarterlyGrowth: Type.Optional(YahooNumber),
        netIncomeToCommon: Type.Optional(YahooNumber),
        trailingEps: Type.Optional(YahooNumber),
        forwardEps: Type.Optional(YahooNumber),
        pegRatio: Type.Optional(YahooNumber),
        lastSplitFactor: Type.Union([Type.Null(), Type.String()]),
        lastSplitDate: Type.Optional(YahooNumber),
        enterpriseToRevenue: Type.Optional(YahooNumber),
        enterpriseToEbitda: Type.Optional(YahooNumber),
        "52WeekChange": Type.Optional(YahooNumber),
        SandP52WeekChange: Type.Optional(YahooNumber),
        lastDividendValue: Type.Optional(YahooNumber),
        lastDividendDate: Type.Optional(YahooFinanceDate),
        ytdReturn: Type.Optional(YahooNumber),
        beta3Year: Type.Optional(YahooNumber),
        totalAssets: Type.Optional(YahooNumber),
        yield: Type.Optional(YahooNumber),
        fundInceptionDate: Type.Optional(YahooFinanceDate),
        threeYearAverageReturn: Type.Optional(YahooNumber),
        fiveYearAverageReturn: Type.Optional(YahooNumber),
        morningStarOverallRating: Type.Optional(YahooNumber),
        morningStarRiskRating: Type.Optional(YahooNumber),
        annualReportExpenseRatio: Type.Optional(YahooNumber),
        lastCapGain: Type.Optional(YahooNumber),
        annualHoldingsTurnover: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryDefaultKeyStatistics",
    });
    const CashflowStatementSchema = Type.Object({
        maxAge: YahooNumber,
        endDate: YahooFinanceDate,
        netIncome: YahooNumber,
        depreciation: Type.Optional(YahooNumber),
        changeToNetincome: Type.Optional(YahooNumber),
        changeToAccountReceivables: Type.Optional(YahooNumber),
        changeToLiabilities: Type.Optional(YahooNumber),
        changeToInventory: Type.Optional(YahooNumber),
        changeToOperatingActivities: Type.Optional(YahooNumber),
        totalCashFromOperatingActivities: Type.Optional(YahooNumber),
        capitalExpenditures: Type.Optional(YahooNumber),
        investments: Type.Optional(YahooNumber),
        otherCashflowsFromInvestingActivities: Type.Optional(YahooNumber),
        totalCashflowsFromInvestingActivities: Type.Optional(YahooNumber),
        dividendsPaid: Type.Optional(YahooNumber),
        netBorrowings: Type.Optional(YahooNumber),
        otherCashflowsFromFinancingActivities: Type.Optional(YahooNumber),
        totalCashFromFinancingActivities: Type.Optional(YahooNumber),
        changeInCash: Type.Optional(YahooNumber),
        repurchaseOfStock: Type.Optional(YahooNumber),
        issuanceOfStock: Type.Optional(YahooNumber),
        effectOfExchangeRate: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryCashflowStatement",
    });
    const CashflowStatementHistorySchema = Type.Object({
        cashflowStatements: Type.Array(CashflowStatementSchema),
        maxAge: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryCashflowStatementHistory",
    });
    const CalendarEventsEarningsSchema = Type.Object({
        earningsDate: Type.Array(YahooFinanceDate),
        earningsAverage: Type.Optional(YahooNumber),
        earningsLow: Type.Optional(YahooNumber),
        earningsHigh: Type.Optional(YahooNumber),
        revenueAverage: Type.Optional(YahooNumber),
        revenueLow: Type.Optional(YahooNumber),
        revenueHigh: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSumamryCalendarEventsEarnings",
    });
    const CalendarEventsSchema = Type.Object({
        maxAge: YahooNumber,
        earnings: CalendarEventsEarningsSchema,
        exDividendDate: Type.Optional(YahooFinanceDate),
        dividendDate: Type.Optional(YahooFinanceDate),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryCalendarEvents",
    });
    const BalanceSheetStatementSchema = Type.Object({
        maxAge: YahooNumber,
        endDate: YahooFinanceDate,
        cash: Type.Optional(YahooNumber),
        shortTermInvestments: Type.Optional(YahooNumber),
        netReceivables: Type.Optional(YahooNumber),
        inventory: Type.Optional(YahooNumber),
        otherCurrentAssets: Type.Optional(YahooNumber),
        totalCurrentAssets: Type.Optional(YahooNumber),
        longTermInvestments: Type.Optional(YahooNumber),
        propertyPlantEquipment: Type.Optional(YahooNumber),
        otherAssets: Type.Optional(YahooNumber),
        totalAssets: Type.Optional(YahooNumber),
        accountsPayable: Type.Optional(YahooNumber),
        shortLongTermDebt: Type.Optional(YahooNumber),
        otherCurrentLiab: Type.Optional(YahooNumber),
        longTermDebt: Type.Optional(YahooNumber),
        otherLiab: Type.Optional(YahooNumber),
        totalCurrentLiabilities: Type.Optional(YahooNumber),
        totalLiab: Type.Optional(YahooNumber),
        commonStock: Type.Optional(YahooNumber),
        retainedEarnings: Type.Optional(YahooNumber),
        treasuryStock: Type.Optional(YahooNumber),
        otherStockholderEquity: Type.Optional(YahooNumber),
        totalStockholderEquity: Type.Optional(YahooNumber),
        netTangibleAssets: Type.Optional(YahooNumber),
        goodWill: Type.Optional(YahooNumber),
        intangibleAssets: Type.Optional(YahooNumber),
        deferredLongTermAssetCharges: Type.Optional(YahooNumber),
        deferredLongTermLiab: Type.Optional(YahooNumber),
        minorityInterest: Type.Optional(NullableYahooNumber),
        capitalSurplus: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryBalanceSheetStatement",
    });
    const BalanceSheetHistorySchema = Type.Object({
        balanceSheetStatements: Type.Array(BalanceSheetStatementSchema),
        maxAge: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryBalanceSheetHistory",
    });
    const CompanyOfficerSchema = Type.Object({
        maxAge: YahooNumber,
        name: Type.String(),
        age: Type.Optional(YahooNumber),
        title: Type.String(),
        yearBorn: Type.Optional(YahooNumber),
        fiscalYear: Type.Optional(YahooNumber),
        totalPay: Type.Optional(YahooNumber),
        exercisedValue: Type.Optional(YahooNumber),
        unexercisedValue: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryCompanyOfficer",
    });
    const AssetProfileSchema = Type.Object({
        maxAge: YahooNumber,
        address1: Type.Optional(Type.String()),
        address2: Type.Optional(Type.String()),
        address3: Type.Optional(Type.String()),
        city: Type.Optional(Type.String()),
        state: Type.Optional(Type.String()),
        zip: Type.Optional(Type.String()),
        country: Type.Optional(Type.String()),
        phone: Type.Optional(Type.String()),
        fax: Type.Optional(Type.String()),
        website: Type.Optional(Type.String()),
        industry: Type.Optional(Type.String()),
        industryDisp: Type.Optional(Type.String()),
        industryKey: Type.Optional(Type.String()),
        industrySymbol: Type.Optional(Type.String()),
        sector: Type.Optional(Type.String()),
        sectorDisp: Type.Optional(Type.String()),
        sectorKey: Type.Optional(Type.String()),
        longBusinessSummary: Type.Optional(Type.String()),
        fullTimeEmployees: Type.Optional(YahooNumber),
        companyOfficers: Type.Array(CompanyOfficerSchema),
        auditRisk: Type.Optional(YahooNumber),
        boardRisk: Type.Optional(YahooNumber),
        compensationRisk: Type.Optional(YahooNumber),
        shareHolderRightsRisk: Type.Optional(YahooNumber),
        overallRisk: Type.Optional(YahooNumber),
        governanceEpochDate: Type.Optional(YahooFinanceDate),
        compensationAsOfEpochDate: Type.Optional(YahooFinanceDate),
        name: Type.Optional(Type.String()), // 'Bitcoin';
        startDate: Type.Optional(YahooFinanceDate), // new Date('2013-04-28')
        description: Type.Optional(Type.String()), // 'Bitcoin (BTC) is a cryptocurrency...'
        twitter: Type.Optional(Type.String()), // in e.g. "ADA-USD" (#418)
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryAssetProfile",
    });
    const QuoteSummaryResultSchema = Type.Object({
        assetProfile: Type.Optional(AssetProfileSchema),
        balanceSheetHistory: Type.Optional(BalanceSheetHistorySchema),
        balanceSheetHistoryQuarterly: Type.Optional(BalanceSheetHistorySchema),
        calendarEvents: Type.Optional(CalendarEventsSchema),
        cashflowStatementHistory: Type.Optional(CashflowStatementHistorySchema),
        cashflowStatementHistoryQuarterly: Type.Optional(CashflowStatementHistorySchema),
        defaultKeyStatistics: Type.Optional(DefaultKeyStatisticsSchema),
        earnings: Type.Optional(QuoteSummaryEarningsSchema),
        earningsHistory: Type.Optional(EarningsHistorySchema),
        earningsTrend: Type.Optional(EarningsTrendSchema),
        financialData: Type.Optional(FinancialDataSchema),
        fundOwnership: Type.Optional(OwnershipSchema),
        fundPerformance: Type.Optional(FundPerformanceSchema),
        fundProfile: Type.Optional(FundProfileSchema),
        incomeStatementHistory: Type.Optional(IncomeStatementHistorySchema),
        incomeStatementHistoryQuarterly: Type.Optional(IncomeStatementHistorySchema),
        indexTrend: Type.Optional(IndexTrendSchema),
        industryTrend: Type.Optional(TrendSchema),
        // insiderHolders: Type.Optional(InsiderTransactionsSchema), // <--
        institutionOwnership: Type.Optional(OwnershipSchema),
        majorDirectHolders: Type.Optional(HoldersSchema),
        majorHoldersBreakdown: Type.Optional(MajorHoldersBreakdownSchema),
        netSharePurchaseActivity: Type.Optional(NetSharePurchaseActivitySchema),
        price: Type.Optional(PriceSchema),
        quoteType: Type.Optional(QuoteTypeSchema),
        recommendationTrend: Type.Optional(RecommendationTrendSchema),
        secFilings: Type.Optional(SECFilingsSchema),
        sectorTrend: Type.Optional(TrendSchema),
        summaryDetail: Type.Optional(SummaryDetailSchema),
        summaryProfile: Type.Optional(SummaryProfileSchema),
        topHoldings: Type.Optional(TopHoldingsSchema),
        upgradeDowngradeHistory: Type.Optional(UpgradeDowngradeHistorySchema),
    }, {
        additionalProperties: Type.Any(),
        title: "QuoteSummaryResult",
    });

    const QuoteSummaryModules = Type.Union([
        Type.Literal("assetProfile"),
        Type.Literal("balanceSheetHistory"),
        Type.Literal("balanceSheetHistoryQuarterly"),
        Type.Literal("calendarEvents"),
        Type.Literal("cashflowStatementHistory"),
        Type.Literal("cashflowStatementHistoryQuarterly"),
        Type.Literal("defaultKeyStatistics"),
        Type.Literal("earnings"),
        Type.Literal("earningsHistory"),
        Type.Literal("earningsTrend"),
        Type.Literal("financialData"),
        Type.Literal("fundOwnership"),
        Type.Literal("fundPerformance"),
        Type.Literal("fundProfile"),
        Type.Literal("incomeStatementHistory"),
        Type.Literal("incomeStatementHistoryQuarterly"),
        Type.Literal("indexTrend"),
        Type.Literal("industryTrend"),
        Type.Literal("insiderHolders"),
        Type.Literal("insiderTransactions"),
        Type.Literal("institutionOwnership"),
        Type.Literal("majorDirectHolders"),
        Type.Literal("majorHoldersBreakdown"),
        Type.Literal("netSharePurchaseActivity"),
        Type.Literal("price"),
        Type.Literal("quoteType"),
        Type.Literal("recommendationTrend"),
        Type.Literal("secFilings"),
        Type.Literal("sectorTrend"),
        Type.Literal("summaryDetail"),
        Type.Literal("summaryProfile"),
        Type.Literal("topHoldings"),
        Type.Literal("upgradeDowngradeHistory"),
    ]);
    const quoteSummaryModules = [
        "assetProfile",
        "balanceSheetHistory",
        "balanceSheetHistoryQuarterly",
        "calendarEvents",
        "cashflowStatementHistory",
        "cashflowStatementHistoryQuarterly",
        "defaultKeyStatistics",
        "earnings",
        "earningsHistory",
        "earningsTrend",
        "financialData",
        "fundOwnership",
        "fundPerformance",
        "fundProfile",
        "incomeStatementHistory",
        "incomeStatementHistoryQuarterly",
        "indexTrend",
        "industryTrend",
        "insiderHolders",
        "insiderTransactions",
        "institutionOwnership",
        "majorDirectHolders",
        "majorHoldersBreakdown",
        "netSharePurchaseActivity",
        "price",
        "quoteType",
        "recommendationTrend",
        "secFilings",
        "sectorTrend",
        "summaryDetail",
        "summaryProfile",
        "topHoldings",
        "upgradeDowngradeHistory",
    ];
    const QuoteSummaryOptionsSchema = Type.Object({
        formatted: Type.Optional(Type.Boolean()),
        modules: Type.Optional(Type.Union([Type.Array(QuoteSummaryModules), Type.Literal("all")])),
    });
    const queryOptionsDefaults$6 = {
        formatted: false,
        modules: ["price", "summaryDetail"],
    };
    function quoteSummary(symbol, queryOptionsOverrides, moduleOptions) {
        return this._moduleExec({
            moduleName: "quoteSummary",
            query: {
                assertSymbol: symbol,
                url: "https://${YF_QUERY_HOST}/v10/finance/quoteSummary/" + symbol,
                needsCrumb: true,
                schema: QuoteSummaryOptionsSchema,
                defaults: queryOptionsDefaults$6,
                overrides: queryOptionsOverrides,
                transformWith(options) {
                    if (typeof options === "object" &&
                        options != null &&
                        "modules" in options &&
                        options.modules === "all")
                        options.modules =
                            quoteSummaryModules;
                    return options;
                },
            },
            result: {
                schema: QuoteSummaryResultSchema,
                transformWith(result) {
                    if (!result.quoteSummary)
                        throw new Error("Unexpected result: " + JSON.stringify(result));
                    return result.quoteSummary.result[0];
                },
            },
            moduleOptions,
        });
    }

    var financials = [
    	"TotalRevenue",
    	"OperatingRevenue",
    	"CostOfRevenue",
    	"GrossProfit",
    	"SellingGeneralAndAdministration",
    	"SellingAndMarketingExpense",
    	"GeneralAndAdministrativeExpense",
    	"OtherGandA",
    	"ResearchAndDevelopment",
    	"DepreciationAmortizationDepletionIncomeStatement",
    	"DepletionIncomeStatement",
    	"DepreciationAndAmortizationInIncomeStatement",
    	"Amortization",
    	"AmortizationOfIntangiblesIncomeStatement",
    	"DepreciationIncomeStatement",
    	"OtherOperatingExpenses",
    	"OperatingExpense",
    	"OperatingIncome",
    	"InterestExpenseNonOperating",
    	"InterestIncomeNonOperating",
    	"TotalOtherFinanceCost",
    	"NetNonOperatingInterestIncomeExpense",
    	"WriteOff",
    	"SpecialIncomeCharges",
    	"GainOnSaleOfPPE",
    	"GainOnSaleOfBusiness",
    	"GainOnSaleOfSecurity",
    	"OtherSpecialCharges",
    	"OtherIncomeExpense",
    	"OtherNonOperatingIncomeExpenses",
    	"TotalExpenses",
    	"PretaxIncome",
    	"TaxProvision",
    	"NetIncomeContinuousOperations",
    	"NetIncomeIncludingNoncontrollingInterests",
    	"MinorityInterests",
    	"NetIncomeFromTaxLossCarryforward",
    	"NetIncomeExtraordinary",
    	"NetIncomeDiscontinuousOperations",
    	"PreferredStockDividends",
    	"OtherunderPreferredStockDividend",
    	"NetIncomeCommonStockholders",
    	"NetIncome",
    	"BasicAverageShares",
    	"DilutedAverageShares",
    	"DividendPerShare",
    	"ReportedNormalizedBasicEPS",
    	"ContinuingAndDiscontinuedBasicEPS",
    	"BasicEPSOtherGainsLosses",
    	"TaxLossCarryforwardBasicEPS",
    	"NormalizedBasicEPS",
    	"BasicEPS",
    	"BasicAccountingChange",
    	"BasicExtraordinary",
    	"BasicDiscontinuousOperations",
    	"BasicContinuousOperations",
    	"ReportedNormalizedDilutedEPS",
    	"ContinuingAndDiscontinuedDilutedEPS",
    	"TaxLossCarryforwardDilutedEPS",
    	"AverageDilutionEarnings",
    	"NormalizedDilutedEPS",
    	"DilutedEPS",
    	"DilutedAccountingChange",
    	"DilutedExtraordinary",
    	"DilutedContinuousOperations",
    	"DilutedDiscontinuousOperations",
    	"DilutedNIAvailtoComStockholders",
    	"DilutedEPSOtherGainsLosses",
    	"TotalOperatingIncomeAsReported",
    	"NetIncomeFromContinuingAndDiscontinuedOperation",
    	"NormalizedIncome",
    	"NetInterestIncome",
    	"EBIT",
    	"EBITDA",
    	"ReconciledCostOfRevenue",
    	"ReconciledDepreciation",
    	"NetIncomeFromContinuingOperationNetMinorityInterest",
    	"TotalUnusualItemsExcludingGoodwill",
    	"TotalUnusualItems",
    	"NormalizedEBITDA",
    	"TaxRateForCalcs",
    	"TaxEffectOfUnusualItems",
    	"RentExpenseSupplemental",
    	"EarningsFromEquityInterestNetOfTax",
    	"ImpairmentOfCapitalAssets",
    	"RestructuringAndMergernAcquisition",
    	"SecuritiesAmortization",
    	"EarningsFromEquityInterest",
    	"OtherTaxes",
    	"ProvisionForDoubtfulAccounts",
    	"InsuranceAndClaims",
    	"RentAndLandingFees",
    	"SalariesAndWages",
    	"ExciseTaxes",
    	"InterestExpense",
    	"InterestIncome",
    	"TotalMoneyMarketInvestments",
    	"InterestIncomeAfterProvisionForLoanLoss",
    	"OtherThanPreferredStockDividend",
    	"LossonExtinguishmentofDebt",
    	"IncomefromAssociatesandOtherParticipatingInterests",
    	"NonInterestExpense",
    	"OtherNonInterestExpense",
    	"ProfessionalExpenseAndContractServicesExpense",
    	"OccupancyAndEquipment",
    	"Equipment",
    	"NetOccupancyExpense",
    	"CreditLossesProvision",
    	"NonInterestIncome",
    	"OtherNonInterestIncome",
    	"GainLossonSaleofAssets",
    	"GainonSaleofInvestmentProperty",
    	"GainonSaleofLoans",
    	"ForeignExchangeTradingGains",
    	"TradingGainLoss",
    	"InvestmentBankingProfit",
    	"DividendIncome",
    	"FeesAndCommissions",
    	"FeesandCommissionExpense",
    	"FeesandCommissionIncome",
    	"OtherCustomerServices",
    	"CreditCard",
    	"SecuritiesActivities",
    	"TrustFeesbyCommissions",
    	"ServiceChargeOnDepositorAccounts",
    	"TotalPremiumsEarned",
    	"OtherInterestExpense",
    	"InterestExpenseForFederalFundsSoldAndSecuritiesPurchaseUnderAgreementsToResell",
    	"InterestExpenseForLongTermDebtAndCapitalSecurities",
    	"InterestExpenseForShortTermDebt",
    	"InterestExpenseForDeposit",
    	"OtherInterestIncome",
    	"InterestIncomeFromFederalFundsSoldAndSecuritiesPurchaseUnderAgreementsToResell",
    	"InterestIncomeFromDeposits",
    	"InterestIncomeFromSecurities",
    	"InterestIncomeFromLoansAndLease",
    	"InterestIncomeFromLeases",
    	"InterestIncomeFromLoans",
    	"DepreciationDepreciationIncomeStatement",
    	"OperationAndMaintenance",
    	"OtherCostofRevenue",
    	"ExplorationDevelopmentAndMineralPropertyLeaseExpenses"
    ];
    var Timeseries_Keys = {
    	financials: financials,
    	"balance-sheet": [
    	"NetDebt",
    	"TreasurySharesNumber",
    	"PreferredSharesNumber",
    	"OrdinarySharesNumber",
    	"ShareIssued",
    	"TotalDebt",
    	"TangibleBookValue",
    	"InvestedCapital",
    	"WorkingCapital",
    	"NetTangibleAssets",
    	"CapitalLeaseObligations",
    	"CommonStockEquity",
    	"PreferredStockEquity",
    	"TotalCapitalization",
    	"TotalEquityGrossMinorityInterest",
    	"MinorityInterest",
    	"StockholdersEquity",
    	"OtherEquityInterest",
    	"GainsLossesNotAffectingRetainedEarnings",
    	"OtherEquityAdjustments",
    	"FixedAssetsRevaluationReserve",
    	"ForeignCurrencyTranslationAdjustments",
    	"MinimumPensionLiabilities",
    	"UnrealizedGainLoss",
    	"TreasuryStock",
    	"RetainedEarnings",
    	"AdditionalPaidInCapital",
    	"CapitalStock",
    	"OtherCapitalStock",
    	"CommonStock",
    	"PreferredStock",
    	"TotalPartnershipCapital",
    	"GeneralPartnershipCapital",
    	"LimitedPartnershipCapital",
    	"TotalLiabilitiesNetMinorityInterest",
    	"TotalNonCurrentLiabilitiesNetMinorityInterest",
    	"OtherNonCurrentLiabilities",
    	"LiabilitiesHeldforSaleNonCurrent",
    	"RestrictedCommonStock",
    	"PreferredSecuritiesOutsideStockEquity",
    	"DerivativeProductLiabilities",
    	"EmployeeBenefits",
    	"NonCurrentPensionAndOtherPostretirementBenefitPlans",
    	"NonCurrentAccruedExpenses",
    	"DuetoRelatedPartiesNonCurrent",
    	"TradeandOtherPayablesNonCurrent",
    	"NonCurrentDeferredLiabilities",
    	"NonCurrentDeferredRevenue",
    	"NonCurrentDeferredTaxesLiabilities",
    	"LongTermDebtAndCapitalLeaseObligation",
    	"LongTermCapitalLeaseObligation",
    	"LongTermDebt",
    	"LongTermProvisions",
    	"CurrentLiabilities",
    	"OtherCurrentLiabilities",
    	"CurrentDeferredLiabilities",
    	"CurrentDeferredRevenue",
    	"CurrentDeferredTaxesLiabilities",
    	"CurrentDebtAndCapitalLeaseObligation",
    	"CurrentCapitalLeaseObligation",
    	"CurrentDebt",
    	"OtherCurrentBorrowings",
    	"LineOfCredit",
    	"CommercialPaper",
    	"CurrentNotesPayable",
    	"PensionandOtherPostRetirementBenefitPlansCurrent",
    	"CurrentProvisions",
    	"PayablesAndAccruedExpenses",
    	"CurrentAccruedExpenses",
    	"InterestPayable",
    	"Payables",
    	"OtherPayable",
    	"DuetoRelatedPartiesCurrent",
    	"DividendsPayable",
    	"TotalTaxPayable",
    	"IncomeTaxPayable",
    	"AccountsPayable",
    	"TotalAssets",
    	"TotalNonCurrentAssets",
    	"OtherNonCurrentAssets",
    	"DefinedPensionBenefit",
    	"NonCurrentPrepaidAssets",
    	"NonCurrentDeferredAssets",
    	"NonCurrentDeferredTaxesAssets",
    	"DuefromRelatedPartiesNonCurrent",
    	"NonCurrentNoteReceivables",
    	"NonCurrentAccountsReceivable",
    	"FinancialAssets",
    	"InvestmentsAndAdvances",
    	"OtherInvestments",
    	"InvestmentinFinancialAssets",
    	"HeldToMaturitySecurities",
    	"AvailableForSaleSecurities",
    	"FinancialAssetsDesignatedasFairValueThroughProfitorLossTotal",
    	"TradingSecurities",
    	"LongTermEquityInvestment",
    	"InvestmentsinJointVenturesatCost",
    	"InvestmentsInOtherVenturesUnderEquityMethod",
    	"InvestmentsinAssociatesatCost",
    	"InvestmentsinSubsidiariesatCost",
    	"InvestmentProperties",
    	"GoodwillAndOtherIntangibleAssets",
    	"OtherIntangibleAssets",
    	"Goodwill",
    	"NetPPE",
    	"AccumulatedDepreciation",
    	"GrossPPE",
    	"Leases",
    	"ConstructionInProgress",
    	"OtherProperties",
    	"MachineryFurnitureEquipment",
    	"BuildingsAndImprovements",
    	"LandAndImprovements",
    	"Properties",
    	"CurrentAssets",
    	"OtherCurrentAssets",
    	"HedgingAssetsCurrent",
    	"AssetsHeldForSaleCurrent",
    	"CurrentDeferredAssets",
    	"CurrentDeferredTaxesAssets",
    	"RestrictedCash",
    	"PrepaidAssets",
    	"Inventory",
    	"InventoriesAdjustmentsAllowances",
    	"OtherInventories",
    	"FinishedGoods",
    	"WorkInProcess",
    	"RawMaterials",
    	"Receivables",
    	"ReceivablesAdjustmentsAllowances",
    	"OtherReceivables",
    	"DuefromRelatedPartiesCurrent",
    	"TaxesReceivable",
    	"AccruedInterestReceivable",
    	"NotesReceivable",
    	"LoansReceivable",
    	"AccountsReceivable",
    	"AllowanceForDoubtfulAccountsReceivable",
    	"GrossAccountsReceivable",
    	"CashCashEquivalentsAndShortTermInvestments",
    	"OtherShortTermInvestments",
    	"CashAndCashEquivalents",
    	"CashEquivalents",
    	"CashFinancial",
    	"OtherLiabilities",
    	"LiabilitiesOfDiscontinuedOperations",
    	"SubordinatedLiabilities",
    	"AdvanceFromFederalHomeLoanBanks",
    	"TradingLiabilities",
    	"DuetoRelatedParties",
    	"SecuritiesLoaned",
    	"FederalFundsPurchasedAndSecuritiesSoldUnderAgreementToRepurchase",
    	"FinancialInstrumentsSoldUnderAgreementsToRepurchase",
    	"FederalFundsPurchased",
    	"TotalDeposits",
    	"NonInterestBearingDeposits",
    	"InterestBearingDepositsLiabilities",
    	"CustomerAccounts",
    	"DepositsbyBank",
    	"OtherAssets",
    	"AssetsHeldForSale",
    	"DeferredAssets",
    	"DeferredTaxAssets",
    	"DueFromRelatedParties",
    	"AllowanceForNotesReceivable",
    	"GrossNotesReceivable",
    	"NetLoan",
    	"UnearnedIncome",
    	"AllowanceForLoansAndLeaseLosses",
    	"GrossLoan",
    	"OtherLoanAssets",
    	"MortgageLoan",
    	"ConsumerLoan",
    	"CommercialLoan",
    	"LoansHeldForSale",
    	"DerivativeAssets",
    	"SecuritiesAndInvestments",
    	"BankOwnedLifeInsurance",
    	"OtherRealEstateOwned",
    	"ForeclosedAssets",
    	"CustomerAcceptances",
    	"FederalHomeLoanBankStock",
    	"SecurityBorrowed",
    	"CashCashEquivalentsAndFederalFundsSold",
    	"MoneyMarketInvestments",
    	"FederalFundsSoldAndSecuritiesPurchaseUnderAgreementsToResell",
    	"SecurityAgreeToBeResell",
    	"FederalFundsSold",
    	"RestrictedCashAndInvestments",
    	"RestrictedInvestments",
    	"RestrictedCashAndCashEquivalents",
    	"InterestBearingDepositsAssets",
    	"CashAndDueFromBanks",
    	"BankIndebtedness",
    	"MineralProperties"
    ],
    	"cash-flow": [
    	"FreeCashFlow",
    	"ForeignSales",
    	"DomesticSales",
    	"AdjustedGeographySegmentData",
    	"RepurchaseOfCapitalStock",
    	"RepaymentOfDebt",
    	"IssuanceOfDebt",
    	"IssuanceOfCapitalStock",
    	"CapitalExpenditure",
    	"InterestPaidSupplementalData",
    	"IncomeTaxPaidSupplementalData",
    	"EndCashPosition",
    	"OtherCashAdjustmentOutsideChangeinCash",
    	"BeginningCashPosition",
    	"EffectOfExchangeRateChanges",
    	"ChangesInCash",
    	"OtherCashAdjustmentInsideChangeinCash",
    	"CashFlowFromDiscontinuedOperation",
    	"FinancingCashFlow",
    	"CashFromDiscontinuedFinancingActivities",
    	"CashFlowFromContinuingFinancingActivities",
    	"NetOtherFinancingCharges",
    	"InterestPaidCFF",
    	"ProceedsFromStockOptionExercised",
    	"CashDividendsPaid",
    	"PreferredStockDividendPaid",
    	"CommonStockDividendPaid",
    	"NetPreferredStockIssuance",
    	"PreferredStockPayments",
    	"PreferredStockIssuance",
    	"NetCommonStockIssuance",
    	"CommonStockPayments",
    	"CommonStockIssuance",
    	"NetIssuancePaymentsOfDebt",
    	"NetShortTermDebtIssuance",
    	"ShortTermDebtPayments",
    	"ShortTermDebtIssuance",
    	"NetLongTermDebtIssuance",
    	"LongTermDebtPayments",
    	"LongTermDebtIssuance",
    	"InvestingCashFlow",
    	"CashFromDiscontinuedInvestingActivities",
    	"CashFlowFromContinuingInvestingActivities",
    	"NetOtherInvestingChanges",
    	"InterestReceivedCFI",
    	"DividendsReceivedCFI",
    	"NetInvestmentPurchaseAndSale",
    	"SaleOfInvestment",
    	"PurchaseOfInvestment",
    	"NetInvestmentPropertiesPurchaseAndSale",
    	"SaleOfInvestmentProperties",
    	"PurchaseOfInvestmentProperties",
    	"NetBusinessPurchaseAndSale",
    	"SaleOfBusiness",
    	"PurchaseOfBusiness",
    	"NetIntangiblesPurchaseAndSale",
    	"SaleOfIntangibles",
    	"PurchaseOfIntangibles",
    	"NetPPEPurchaseAndSale",
    	"SaleOfPPE",
    	"PurchaseOfPPE",
    	"CapitalExpenditureReported",
    	"OperatingCashFlow",
    	"CashFromDiscontinuedOperatingActivities",
    	"CashFlowFromContinuingOperatingActivities",
    	"TaxesRefundPaid",
    	"InterestReceivedCFO",
    	"InterestPaidCFO",
    	"DividendReceivedCFO",
    	"DividendPaidCFO",
    	"ChangeInWorkingCapital",
    	"ChangeInOtherWorkingCapital",
    	"ChangeInOtherCurrentLiabilities",
    	"ChangeInOtherCurrentAssets",
    	"ChangeInPayablesAndAccruedExpense",
    	"ChangeInAccruedExpense",
    	"ChangeInInterestPayable",
    	"ChangeInPayable",
    	"ChangeInDividendPayable",
    	"ChangeInAccountPayable",
    	"ChangeInTaxPayable",
    	"ChangeInIncomeTaxPayable",
    	"ChangeInPrepaidAssets",
    	"ChangeInInventory",
    	"ChangeInReceivables",
    	"ChangesInAccountReceivables",
    	"OtherNonCashItems",
    	"ExcessTaxBenefitFromStockBasedCompensation",
    	"StockBasedCompensation",
    	"UnrealizedGainLossOnInvestmentSecurities",
    	"ProvisionandWriteOffofAssets",
    	"AssetImpairmentCharge",
    	"AmortizationOfSecurities",
    	"DeferredTax",
    	"DeferredIncomeTax",
    	"Depletion",
    	"DepreciationAndAmortization",
    	"AmortizationCashFlow",
    	"AmortizationOfIntangibles",
    	"Depreciation",
    	"OperatingGainsLosses",
    	"PensionAndEmployeeBenefitExpense",
    	"EarningsLossesFromEquityInvestments",
    	"GainLossOnInvestmentSecurities",
    	"NetForeignCurrencyExchangeGainLoss",
    	"GainLossOnSaleOfPPE",
    	"GainLossOnSaleOfBusiness",
    	"NetIncomeFromContinuingOperations",
    	"CashFlowsfromusedinOperatingActivitiesDirect",
    	"TaxesRefundPaidDirect",
    	"InterestReceivedDirect",
    	"InterestPaidDirect",
    	"DividendsReceivedDirect",
    	"DividendsPaidDirect",
    	"ClassesofCashPayments",
    	"OtherCashPaymentsfromOperatingActivities",
    	"PaymentsonBehalfofEmployees",
    	"PaymentstoSuppliersforGoodsandServices",
    	"ClassesofCashReceiptsfromOperatingActivities",
    	"OtherCashReceiptsfromOperatingActivities",
    	"ReceiptsfromGovernmentGrants",
    	"ReceiptsfromCustomers",
    	"IncreaseDecreaseInDeposit",
    	"ChangeInFederalFundsAndSecuritiesSoldForRepurchase",
    	"NetProceedsPaymentForLoan",
    	"PaymentForLoans",
    	"ProceedsFromLoans",
    	"ProceedsPaymentInInterestBearingDepositsInBank",
    	"IncreaseinInterestBearingDepositsinBank",
    	"DecreaseinInterestBearingDepositsinBank",
    	"ProceedsPaymentFederalFundsSoldAndSecuritiesPurchasedUnderAgreementToResell",
    	"ChangeInLoans",
    	"ChangeInDeferredCharges",
    	"ProvisionForLoanLeaseAndOtherLosses",
    	"AmortizationOfFinancingCostsAndDiscounts",
    	"DepreciationAmortizationDepletion",
    	"RealizedGainLossOnSaleOfLoansAndLease",
    	"AllTaxesPaid",
    	"InterestandCommissionPaid",
    	"CashPaymentsforLoans",
    	"CashPaymentsforDepositsbyBanksandCustomers",
    	"CashReceiptsfromFeesandCommissions",
    	"CashReceiptsfromSecuritiesRelatedActivities",
    	"CashReceiptsfromLoans",
    	"CashReceiptsfromDepositsbyBanksandCustomers",
    	"CashReceiptsfromTaxRefunds",
    	"AmortizationAmortizationCashFlow"
    ]
    };

    const FundamentalsTimeSeries_Types = ["quarterly", "annual", "trailing"];
    const FundamentalsTimeSeries_Modules = [
        "financials",
        "balance-sheet",
        "cash-flow",
        "all",
    ];
    const FundamentalsTimeSeriesResultSchema = Type.Object({
        date: YahooFinanceDate,
    }, {
        additionalProperties: Type.Unknown(),
        title: "FundamentalsTimeSeriesResult",
    });
    const FundamentalsTimeSeriesOptionsSchema = Type.Object({
        period1: Type.Union([YahooFinanceDate, YahooNumber, Type.String()]),
        period2: Type.Optional(Type.Union([YahooFinanceDate, YahooNumber, Type.String()])),
        type: Type.Optional(Type.String()),
        merge: Type.Optional(Type.Boolean()), // This returns a completely different format that will break the transformer
        padTimeSeries: Type.Optional(Type.Boolean()), // Not exactly sure what this does, assume it pads p1 and p2???
        lang: Type.Optional(Type.String()),
        region: Type.Optional(Type.String()),
        module: Type.String(),
    }, {
        title: "FundamentalsTimeSeriesOptions",
    });
    const FundamentalsTimeSeriesResultsSchema = Type.Array(FundamentalsTimeSeriesResultSchema);
    const queryOptionsDefaults$5 = {
        merge: false,
        padTimeSeries: true,
        lang: "en-US",
        region: "US",
        type: "quarterly",
    };
    function fundamentalsTimeSeries(symbol, queryOptionsOverrides, moduleOptions) {
        return this._moduleExec({
            moduleName: "options",
            query: {
                assertSymbol: symbol,
                url: `https://query1.finance.yahoo.com/ws/fundamentals-timeseries/v1/finance/timeseries/${symbol}`,
                needsCrumb: false,
                schema: FundamentalsTimeSeriesOptionsSchema,
                defaults: queryOptionsDefaults$5,
                overrides: queryOptionsOverrides,
                transformWith: processQuery,
            },
            result: {
                schema: FundamentalsTimeSeriesResultsSchema,
                transformWith(response) {
                    if (!response || !response.timeseries)
                        throw new Error(`Unexpected result: ${JSON.stringify(response)}`);
                    return processResponse(response);
                },
            },
            moduleOptions,
        });
    }
    /**
     * Transform the input options into query parameters.
     * The options module defines which keys that are used in the query.
     * The keys are joined together into the query parameter type and
     * pre-fixed with the options type (e.g. annualTotalRevenue).
     * @param queryOptions Input query options.
     * @returns Query parameters.
     */
    const processQuery = function (queryOptions) {
        // Convert dates
        if (!queryOptions.period2)
            queryOptions.period2 = new Date();
        const dates = ["period1", "period2"];
        for (const fieldName of dates) {
            const value = queryOptions[fieldName];
            if (value instanceof Date)
                queryOptions[fieldName] = Math.floor(value.getTime() / 1000);
            else if (typeof value === "string") {
                const timestamp = new Date(value).getTime();
                if (isNaN(timestamp))
                    throw new Error("yahooFinance.fundamentalsTimeSeries() option '" +
                        fieldName +
                        "' invalid date provided: '" +
                        value +
                        "'");
                queryOptions[fieldName] = Math.floor(timestamp / 1000);
            }
        }
        // Validate query parameters.
        if (queryOptions.period1 === queryOptions.period2) {
            throw new Error("yahooFinance.fundamentalsTimeSeries() options `period1` and `period2` " +
                "cannot share the same value.");
        }
        else if (!FundamentalsTimeSeries_Types.includes(queryOptions.type || "")) {
            throw new Error("yahooFinance.fundamentalsTimeSeries() option type invalid.");
        }
        else if (!FundamentalsTimeSeries_Modules.includes(queryOptions.module || "")) {
            throw new Error("yahooFinance.fundamentalsTimeSeries() option module invalid.");
        }
        // Join the keys for the module into query types.
        const keys = Object.entries(Timeseries_Keys).reduce((previous, [module, keys]) => {
            if (queryOptions.module == "all") {
                return previous.concat(keys);
            }
            else if (module == queryOptions.module) {
                return previous.concat(keys);
            }
            else
                return previous;
        }, []);
        const queryType = queryOptions.type + keys.join(`,${queryOptions.type}`);
        return {
            period1: queryOptions.period1,
            period2: queryOptions.period2,
            type: queryType,
        };
    };
    /**
     * Transforms the time-series into an array with reported values per period.
     * Each object represents a period and its properties are the data points.
     * Financial statement content variates and keys are skipped when empty.
     * The query keys include the option type  (e.g. annualTotalRevenue).
     * In the response the type is removed (e.g. totalRevenue) for
     * easier mapping by the client.
     * @param response Query response.
     * @returns Formatted response.
     */
    const processResponse = function (response) {
        const keyedByTimestamp = {};
        const replace = new RegExp(FundamentalsTimeSeries_Types.join("|"));
        for (let ct = 0; ct < response.timeseries.result.length; ct++) {
            const result = response.timeseries.result[ct];
            if (!result.timestamp || !result.timestamp.length) {
                continue;
            }
            for (let ct = 0; ct < result.timestamp.length; ct++) {
                const timestamp = result.timestamp[ct];
                const dataKey = Object.keys(result)[2];
                if (!keyedByTimestamp[timestamp]) {
                    keyedByTimestamp[timestamp] = { date: timestamp };
                }
                if (!result[dataKey][ct] ||
                    !result[dataKey][ct].reportedValue ||
                    !result[dataKey][ct].reportedValue.raw) {
                    continue;
                }
                const short = dataKey.replace(replace, "");
                const key = short == short.toUpperCase()
                    ? short
                    : short[0].toLowerCase() + short.slice(1);
                keyedByTimestamp[timestamp][key] = result[dataKey][ct].reportedValue.raw;
            }
        }
        return Object.keys(keyedByTimestamp).map((k) => keyedByTimestamp[k]);
    };

    const RecommendationsBySymbolResponse = Type.Object({
        recommendedSymbols: Type.Array(Type.Object({
            score: YahooNumber, // 0.1927
            symbol: Type.String(), // "BMW.DE"
        }, {
            additionalProperties: Type.Any(),
        })),
        symbol: Type.String(),
    }, {
        additionalProperties: Type.Any(),
    });
    const RecommendationsBySymbolResponseArray = Type.Array(RecommendationsBySymbolResponse);
    const RecommendationsBySymbolOptions = Type.Object({});
    const queryOptionsDefaults$4 = {};
    function recommendationsBySymbol(query, queryOptionsOverrides, moduleOptions) {
        const symbols = typeof query === "string" ? query : query.join(",");
        return this._moduleExec({
            moduleName: "recommendationsBySymbol",
            query: {
                url: "https://${YF_QUERY_HOST}/v6/finance/recommendationsbysymbol/" +
                    symbols,
                schema: RecommendationsBySymbolOptions,
                defaults: queryOptionsDefaults$4,
                overrides: queryOptionsOverrides,
            },
            result: {
                schema: RecommendationsBySymbolResponseArray,
                transformWith(result) {
                    if (!result.finance)
                        throw new Error("Unexpected result: " + JSON.stringify(result));
                    return result.finance.result;
                },
            },
            moduleOptions,
        }).then((results) => {
            return typeof query === "string"
                ? results[0]
                : results;
        });
    }

    const SearchQuoteYahoo = Type.Object({
        symbol: Type.String(), // "BABA"
        isYahooFinance: Type.Literal(true), // true
        exchange: Type.String(), // "NYQ"
        exchDisp: Type.Optional(Type.String()), // "London", e.g. with BJ0CDD2
        shortname: Type.Optional(Type.String()), // "Alibaba Group Holding Limited"
        longname: Type.Optional(Type.String()), // "Alibaba Group Holding Limited"
        index: Type.Literal("quotes"), // "quotes"
        score: YahooNumber, // 1111958.0
        newListingDate: Type.Optional(YahooFinanceDate), // "2021-02-16"
        prevName: Type.Optional(Type.String()),
        nameChangeDate: Type.Optional(YahooFinanceDate),
        sector: Type.Optional(Type.String()), // "Industrials"
        industry: Type.Optional(Type.String()), // "Building Products & Equipment"
        dispSecIndFlag: Type.Optional(Type.Boolean()), // true
    }, {
        additionalProperties: Type.Any(),
    });
    const SearchQuoteYahooEquity = Type.Composite([
        SearchQuoteYahoo,
        Type.Object({
            quoteType: Type.Literal("EQUITY"),
            typeDisp: Type.Literal("Equity"),
        }),
    ], {
        title: "SearchQuoteYahooEntity",
    });
    const SearchQuoteYahooOption = Type.Composite([
        SearchQuoteYahoo,
        Type.Object({
            quoteType: Type.Literal("OPTION"),
            typeDisp: Type.Literal("Option"),
        }),
    ], {
        title: "SearchQuoteYahooOption",
    });
    const SearchQuoteYahooETF = Type.Composite([
        SearchQuoteYahoo,
        Type.Object({
            quoteType: Type.Literal("ETF"),
            typeDisp: Type.Literal("ETF"),
        }),
    ], {
        title: "SearchQuoteYahooETF",
    });
    const SearchQuoteYahooFund = Type.Composite([
        SearchQuoteYahoo,
        Type.Object({
            quoteType: Type.Literal("MUTUALFUND"),
            typeDisp: Type.Literal("Fund"),
        }),
    ], {
        title: "SearchQuoteYahooFund",
    });
    const SearchQuoteYahooIndex = Type.Composite([
        SearchQuoteYahoo,
        Type.Object({
            quoteType: Type.Literal("INDEX"),
            typeDisp: Type.Literal("Index"),
        }),
    ], {
        title: "SearchQuoteYahooIndex",
    });
    const SearchQuoteYahooCurrency = Type.Composite([
        SearchQuoteYahoo,
        Type.Object({
            quoteType: Type.Literal("CURRENCY"),
            typeDisp: Type.Literal("Currency"),
        }),
    ], {
        title: "SearchQuoteYahooCurrency",
    });
    const SearchQuoteYahooCryptocurrency = Type.Composite([
        SearchQuoteYahoo,
        Type.Object({
            quoteType: Type.Literal("CRYPTOCURRENCY"),
            typeDisp: Type.Literal("Cryptocurrency"),
        }),
    ]);
    const SearchQuoteYahooFuture = Type.Composite([
        SearchQuoteYahoo,
        Type.Object({
            quoteType: Type.Literal("FUTURE"),
            typeDisp: Type.Union([Type.Literal("Future"), Type.Literal("Futures")]),
        }),
    ], {
        title: "SearchQuoteYahooFuture",
    });
    const SearchQuoteNonYahoo = Type.Object({
        index: Type.String(), // '78ddc07626ff4bbcae663e88514c23a0'
        name: Type.String(), // 'AAPlasma'
        permalink: Type.String(), // 'aaplasma'
        isYahooFinance: Type.Literal(false), // false
    }, {
        additionalProperties: Type.Any(),
        title: "SearchQuoteNonYahoo",
    });
    const SearchNewsThumbnailResolution = Type.Object({
        url: Type.String(),
        width: YahooNumber,
        height: YahooNumber,
        tag: Type.String(),
    }, {
        title: "SearchNewsThumbnailResolution",
    });
    const SearchNews = Type.Object({
        uuid: Type.String(), // "9aff624a-e84c-35f3-9c23-db39852006dc"
        title: Type.String(), // "Analyst Report: Alibaba Group Holding Limited"
        publisher: Type.String(), // "Morningstar Research"
        link: Type.String(), // "https://finance.yahoo.com/m/9aff624a-e84c-35f3-9c23-db39852006dc/analyst-report%3A-alibaba-group.html"
        providerPublishTime: YahooFinanceDate, // coerced to New Date(1611285342 * 1000)
        type: Type.String(), // "STORY"   TODO "STORY" | ???
        thumbnail: Type.Optional(Type.Object({
            resolutions: Type.Array(SearchNewsThumbnailResolution),
        })),
        relatedTickers: Type.Optional(Type.Array(Type.String())), // [ "AAPL" ]
    }, {
        additionalProperties: Type.Any(),
        title: "SearchNews",
    });
    const SearchResultSchema = Type.Object({
        explains: Type.Array(Type.Any()),
        count: YahooNumber,
        quotes: Type.Array(Type.Union([
            SearchQuoteYahooEquity,
            SearchQuoteYahooOption,
            SearchQuoteYahooETF,
            SearchQuoteYahooFund,
            SearchQuoteYahooIndex,
            SearchQuoteYahooCurrency,
            SearchQuoteYahooCryptocurrency,
            SearchQuoteNonYahoo,
            SearchQuoteYahooFuture,
        ])),
        news: Type.Array(SearchNews),
        nav: Type.Array(Type.Any()),
        lists: Type.Array(Type.Any()),
        researchReports: Type.Array(Type.Any()),
        totalTime: YahooNumber,
        // ALWAYS present, but TEMPORARILY marked optional ("?") since its
        // sudden appearance, let's make sure it doesn't get suddenly removed.
        // Array<any> until we can find some examples of what it actually looks
        // like (#255).
        screenerFieldResults: Type.Optional(Type.Array(Type.Any())),
        // ALWAYS present, but TEMPORARILY marked optional ("?") since its
        // sudden appearance, let's make sure it doesn't get suddenly removed.
        // Array<any> until we can find some examples of what it actually looks
        // like (#399).
        culturalAssets: Type.Optional(Type.Array(Type.Any())),
        timeTakenForQuotes: YahooNumber, // 26
        timeTakenForNews: YahooNumber, // 419
        timeTakenForAlgowatchlist: YahooNumber, // 700
        timeTakenForPredefinedScreener: YahooNumber, // 400
        timeTakenForCrunchbase: YahooNumber, // 400
        timeTakenForNav: YahooNumber, // 400
        timeTakenForResearchReports: YahooNumber, // 0
        // ALWAYS present, but TEMPORARILY marked optional ("?") since its
        // sudden appearance, let's make sure it doesn't get suddenly removed.
        timeTakenForScreenerField: Type.Optional(YahooNumber),
        // ALWAYS present, but TEMPORARILY marked optional ("?") since its
        // sudden appearance, let's make sure it doesn't get suddenly removed.
        timeTakenForCulturalAssets: Type.Optional(YahooNumber),
    }, {
        additionalProperties: Type.Any(),
        title: "SearchResults",
    });
    const SearchOptionsSchema = Type.Object({
        lang: Type.Optional(Type.String()),
        region: Type.Optional(Type.String()),
        quotesCount: Type.Optional(YahooNumber),
        newsCount: Type.Optional(YahooNumber),
        enableFuzzyQuery: Type.Optional(Type.Boolean()),
        quotesQueryId: Type.Optional(Type.String()),
        multiQuoteQueryId: Type.Optional(Type.String()),
        newsQueryId: Type.Optional(Type.String()),
        enableCb: Type.Optional(Type.Boolean()),
        enableNavLinks: Type.Optional(Type.Boolean()),
        enableEnhancedTrivialQuery: Type.Optional(Type.Boolean()),
    }, {
        title: "SearchOptions",
        additionalProperties: false,
    });
    const queryOptionsDefaults$3 = {
        lang: "en-US",
        region: "US",
        quotesCount: 6,
        newsCount: 4,
        enableFuzzyQuery: false,
        quotesQueryId: "tss_match_phrase_query",
        multiQuoteQueryId: "multi_quote_single_token_query",
        newsQueryId: "news_cie_vespa",
        enableCb: true,
        enableNavLinks: true,
        enableEnhancedTrivialQuery: true,
    };
    function search(query, queryOptionsOverrides, moduleOptions) {
        return this._moduleExec({
            moduleName: "searchTypebox",
            query: {
                url: "https://${YF_QUERY_HOST}/v1/finance/search",
                schema: SearchOptionsSchema,
                defaults: queryOptionsDefaults$3,
                runtime: { q: query },
                overrides: queryOptionsOverrides,
                needsCrumb: false,
            },
            result: {
                schema: SearchResultSchema,
            },
            moduleOptions,
        });
    }

    const TrendingSymbol = Type.Object({
        symbol: Type.String(),
    }, {
        additionalProperties: Type.Any(),
    });
    const TrendingSymbolsResult = Type.Object({
        count: YahooNumber,
        quotes: Type.Array(TrendingSymbol),
        jobTimestamp: YahooNumber,
        startInterval: YahooNumber,
    }, {
        additionalProperties: Type.Any(),
        title: "TrendingSymbolsResult",
    });
    const TrendingSymbolsOptions = Type.Optional(Type.Object({
        lang: Type.Optional(Type.String()),
        region: Type.Optional(Type.String()),
        count: Type.Optional(YahooNumber),
    }, {
        title: "TrendingSymbolsOptions",
    }));
    const queryOptionsDefaults$2 = {
        lang: "en-US",
        count: 5,
    };
    function trendingSymbols(query, queryOptionsOverrides, moduleOptions) {
        return this._moduleExec({
            moduleName: "trendingSymbols",
            query: {
                url: "https://${YF_QUERY_HOST}/v1/finance/trending/" + query,
                schema: TrendingSymbolsOptions,
                defaults: queryOptionsDefaults$2,
                overrides: queryOptionsOverrides,
            },
            result: {
                schema: TrendingSymbolsResult,
                transformWith(result) {
                    if (!result.finance)
                        throw new Error("Unexpected result: " + JSON.stringify(result));
                    return result.finance.result[0];
                },
            },
            moduleOptions,
        });
    }

    const DailyGainersCriterum = Type.Object({
        field: Type.String(),
        operators: Type.Array(Type.String()),
        values: Type.Array(YahooNumber),
        labelsSelected: Type.Array(YahooNumber),
        dependentValues: Type.Array(Type.Any()),
    }, { title: "DailyGainersCriterium" });
    const DailyGainersQuote = Type.Object({
        language: Type.String(),
        region: Type.String(),
        quoteType: Type.String(),
        typeDisp: Type.String(),
        quoteSourceName: Type.String(),
        triggerable: Type.Boolean(),
        customPriceAlertConfidence: Type.String(),
        lastCloseTevEbitLtm: Type.Optional(YahooNumber),
        lastClosePriceToNNWCPerShare: Type.Optional(YahooNumber),
        firstTradeDateMilliseconds: YahooNumber,
        priceHint: YahooNumber,
        postMarketChangePercent: Type.Optional(YahooNumber),
        postMarketTime: Type.Optional(YahooNumber),
        postMarketPrice: Type.Optional(YahooNumber),
        postMarketChange: Type.Optional(YahooNumber),
        regularMarketChange: YahooNumber,
        regularMarketTime: YahooNumber,
        regularMarketPrice: YahooNumber,
        regularMarketDayHigh: YahooNumber,
        regularMarketDayRange: Type.String(),
        currency: Type.String(),
        regularMarketDayLow: YahooNumber,
        regularMarketVolume: YahooNumber,
        regularMarketPreviousClose: YahooNumber,
        bid: Type.Optional(YahooNumber),
        ask: Type.Optional(YahooNumber),
        bidSize: Type.Optional(YahooNumber),
        askSize: Type.Optional(YahooNumber),
        market: Type.String(),
        messageBoardId: Type.String(),
        fullExchangeName: Type.String(),
        longName: Type.String(),
        financialCurrency: Type.Optional(Type.String()),
        regularMarketOpen: YahooNumber,
        averageDailyVolume3Month: YahooNumber,
        averageDailyVolume10Day: YahooNumber,
        fiftyTwoWeekLowChange: YahooNumber,
        fiftyTwoWeekLowChangePercent: YahooNumber,
        fiftyTwoWeekRange: Type.String(),
        fiftyTwoWeekHighChange: YahooNumber,
        fiftyTwoWeekHighChangePercent: YahooNumber,
        fiftyTwoWeekChangePercent: YahooNumber,
        earningsTimestamp: Type.Optional(YahooNumber),
        earningsTimestampStart: Type.Optional(YahooNumber),
        earningsTimestampEnd: Type.Optional(YahooNumber),
        trailingAnnualDividendRate: YahooNumber,
        trailingAnnualDividendYield: YahooNumber,
        marketState: Type.String(),
        epsTrailingTwelveMonths: Type.Optional(YahooNumber),
        epsForward: Type.Optional(YahooNumber),
        epsCurrentYear: Type.Optional(YahooNumber),
        priceEpsCurrentYear: Type.Optional(YahooNumber),
        sharesOutstanding: YahooNumber,
        bookValue: Type.Optional(YahooNumber),
        fiftyDayAverage: YahooNumber,
        fiftyDayAverageChange: YahooNumber,
        fiftyDayAverageChangePercent: YahooNumber,
        twoHundredDayAverage: YahooNumber,
        twoHundredDayAverageChange: YahooNumber,
        twoHundredDayAverageChangePercent: YahooNumber,
        marketCap: YahooNumber,
        forwardPE: Type.Optional(YahooNumber),
        priceToBook: Type.Optional(YahooNumber),
        sourceInterval: YahooNumber,
        exchangeDataDelayedBy: YahooNumber,
        exchangeTimezoneName: Type.String(),
        exchangeTimezoneShortName: Type.String(),
        gmtOffSetMilliseconds: YahooNumber,
        esgPopulated: Type.Boolean(),
        tradeable: Type.Boolean(),
        cryptoTradeable: Type.Boolean(),
        exchange: Type.String(),
        fiftyTwoWeekLow: YahooNumber,
        fiftyTwoWeekHigh: YahooNumber,
        shortName: Type.String(),
        averageAnalystRating: Type.Optional(Type.String()),
        regularMarketChangePercent: YahooNumber,
        symbol: Type.String(),
        dividendDate: Type.Optional(YahooNumber),
        displayName: Type.Optional(Type.String()),
        trailingPE: Type.Optional(YahooNumber),
        prevName: Type.Optional(Type.String()),
        nameChangeDate: Type.Optional(YahooNumber),
        ipoExpectedDate: Type.Optional(YahooNumber),
        dividendYield: Type.Optional(YahooNumber),
        dividendRate: Type.Optional(YahooNumber),
    }, { title: "DailyGainersQuote" });
    const DailyGainersOptionsSchema = Type.Object({
        lang: Type.Optional(Type.String()),
        region: Type.Optional(Type.String()),
        count: Type.Optional(YahooNumber),
    }, { title: "DailyGainersOptions" });
    const DailyGainersCriteriaMeta = Type.Object({
        size: YahooNumber,
        offset: YahooNumber,
        sortField: Type.String(),
        sortType: Type.String(),
        quoteType: Type.String(),
        criteria: Type.Array(DailyGainersCriterum),
        topOperator: Type.String(),
    }, { title: "DailyGainersCriteriaMeta" });
    const DailyGainersResultSchema = Type.Object({
        id: Type.String(),
        title: Type.String(),
        description: Type.String(),
        canonicalName: Type.String(),
        criteriaMeta: DailyGainersCriteriaMeta,
        rawCriteria: Type.String(),
        start: YahooNumber,
        count: YahooNumber,
        total: YahooNumber,
        quotes: Type.Array(DailyGainersQuote),
        useRecords: Type.Boolean(),
        predefinedScr: Type.Boolean(),
        versionId: YahooNumber,
        creationDate: YahooNumber,
        lastUpdated: YahooNumber,
        isPremium: Type.Boolean(),
        iconUrl: Type.String(),
    }, { title: "DailyGainersResult" });
    const queryOptionsDefaults$1 = {
        lang: "en-US",
        region: "US",
        scrIds: "day_gainers",
        count: 5,
    };
    function dailyGainers(queryOptionsOverrides, moduleOptions) {
        return this._moduleExec({
            moduleName: "dailyGainers",
            query: {
                url: "https://${YF_QUERY_HOST}/v1/finance/screener/predefined/saved",
                schema: DailyGainersOptionsSchema,
                defaults: queryOptionsDefaults$1,
                overrides: queryOptionsOverrides,
                needsCrumb: true,
            },
            result: {
                schema: DailyGainersResultSchema,
                transformWith(result) {
                    if (!result.finance)
                        throw new Error("Unexpected result: " + JSON.stringify(result));
                    return result.finance.result[0];
                },
            },
            moduleOptions,
        });
    }

    const ScreenerCriterum = Type.Object({
        field: Type.String(),
        operators: Type.Array(Type.String()),
        values: Type.Array(YahooNumber),
        labelsSelected: Type.Array(YahooNumber),
        dependentValues: Type.Array(Type.Any()),
    }, {
        title: "ScreenerCriterum",
    });
    const ScreenerCriteriaMeta = Type.Object({
        size: YahooNumber,
        offset: YahooNumber,
        sortField: Type.String(),
        sortType: Type.String(),
        quoteType: Type.String(),
        criteria: Type.Array(ScreenerCriterum),
        topOperator: Type.String(),
    }, {
        title: "ScreenerCriteriaMeta",
    });
    const ScreenerQuote = Type.Object({
        language: Type.String(),
        region: Type.String(),
        quoteType: Type.String(),
        typeDisp: Type.String(),
        quoteSourceName: Type.String(),
        triggerable: Type.Boolean(),
        customPriceAlertConfidence: Type.String(),
        lastCloseTevEbitLtm: Type.Optional(YahooNumber),
        lastClosePriceToNNWCPerShare: Type.Optional(YahooNumber),
        firstTradeDateMilliseconds: YahooNumber,
        priceHint: YahooNumber,
        postMarketChangePercent: Type.Optional(YahooNumber),
        postMarketTime: Type.Optional(YahooNumber),
        postMarketPrice: Type.Optional(YahooNumber),
        postMarketChange: Type.Optional(YahooNumber),
        regularMarketChange: YahooNumber,
        regularMarketTime: YahooNumber,
        regularMarketPrice: YahooNumber,
        regularMarketDayHigh: Type.Optional(YahooNumber),
        regularMarketDayRange: YahooTwoNumberRange,
        currency: Type.String(),
        regularMarketDayLow: Type.Optional(YahooNumber),
        regularMarketVolume: Type.Optional(YahooNumber),
        regularMarketPreviousClose: YahooNumber,
        bid: Type.Optional(YahooNumber),
        ask: Type.Optional(YahooNumber),
        bidSize: Type.Optional(YahooNumber),
        askSize: Type.Optional(YahooNumber),
        market: Type.String(),
        messageBoardId: Type.String(),
        fullExchangeName: Type.String(),
        longName: Type.String(),
        financialCurrency: Type.Optional(Type.String()),
        regularMarketOpen: Type.Optional(YahooNumber),
        averageDailyVolume3Month: YahooNumber,
        averageDailyVolume10Day: YahooNumber,
        fiftyTwoWeekLowChange: YahooNumber,
        fiftyTwoWeekLowChangePercent: YahooNumber,
        fiftyTwoWeekRange: YahooTwoNumberRange,
        fiftyTwoWeekHighChange: YahooNumber,
        fiftyTwoWeekHighChangePercent: YahooNumber,
        fiftyTwoWeekChangePercent: YahooNumber,
        earningsTimestamp: Type.Optional(YahooNumber),
        earningsTimestampStart: Type.Optional(YahooNumber),
        earningsTimestampEnd: Type.Optional(YahooNumber),
        trailingAnnualDividendRate: Type.Optional(YahooNumber),
        trailingAnnualDividendYield: Type.Optional(YahooNumber),
        marketState: Type.String(),
        epsTrailingTwelveMonths: Type.Optional(YahooNumber),
        epsForward: Type.Optional(YahooNumber),
        epsCurrentYear: Type.Optional(YahooNumber),
        priceEpsCurrentYear: Type.Optional(YahooNumber),
        sharesOutstanding: Type.Optional(YahooNumber),
        bookValue: Type.Optional(YahooNumber),
        fiftyDayAverage: YahooNumber,
        fiftyDayAverageChange: YahooNumber,
        fiftyDayAverageChangePercent: YahooNumber,
        twoHundredDayAverage: YahooNumber,
        twoHundredDayAverageChange: YahooNumber,
        twoHundredDayAverageChangePercent: YahooNumber,
        marketCap: Type.Optional(YahooNumber),
        forwardPE: Type.Optional(YahooNumber),
        priceToBook: Type.Optional(YahooNumber),
        sourceInterval: YahooNumber,
        exchangeDataDelayedBy: YahooNumber,
        exchangeTimezoneName: Type.String(),
        exchangeTimezoneShortName: Type.String(),
        gmtOffSetMilliseconds: YahooNumber,
        esgPopulated: Type.Boolean(),
        tradeable: Type.Boolean(),
        cryptoTradeable: Type.Boolean(),
        exchange: Type.String(),
        fiftyTwoWeekLow: YahooNumber,
        fiftyTwoWeekHigh: YahooNumber,
        shortName: Type.String(),
        averageAnalystRating: Type.Optional(Type.String()),
        regularMarketChangePercent: YahooNumber,
        symbol: Type.String(),
        dividendDate: Type.Optional(YahooFinanceDate),
        displayName: Type.Optional(Type.String()),
        trailingPE: Type.Optional(YahooNumber),
        prevName: Type.Optional(Type.String()),
        nameChangeDate: Type.Optional(YahooFinanceDate),
        ipoExpectedDate: Type.Optional(YahooFinanceDate),
        dividendYield: Type.Optional(YahooNumber),
        dividendRate: Type.Optional(YahooNumber),
        yieldTTM: Type.Optional(YahooNumber),
        peTTM: Type.Optional(YahooNumber),
        annualReturnNavY3: Type.Optional(YahooNumber),
        annualReturnNavY5: Type.Optional(YahooNumber),
        ytdReturn: Type.Optional(YahooNumber),
        trailingThreeMonthReturns: Type.Optional(YahooNumber),
        netAssets: Type.Optional(YahooNumber),
        netExpenseRatio: Type.Optional(YahooNumber),
    }, {
        title: "ScreenerQuote",
    });
    const ScreenerResult = Type.Object({
        id: Type.String(),
        title: Type.String(),
        description: Type.String(),
        canonicalName: Type.String(),
        criteriaMeta: ScreenerCriteriaMeta,
        rawCriteria: Type.String(),
        start: YahooNumber,
        count: YahooNumber,
        total: YahooNumber,
        quotes: Type.Array(ScreenerQuote),
        useRecords: Type.Boolean(),
        predefinedScr: Type.Boolean(),
        versionId: YahooNumber,
        creationDate: YahooFinanceDate,
        lastUpdated: YahooFinanceDate,
        isPremium: Type.Boolean(),
        iconUrl: Type.String(),
    }, {
        title: "ScreenerResult",
    });
    const PredefinedScreenerModules = Type.Union([
        Type.Literal("aggressive_small_caps"),
        Type.Literal("conservative_foreign_funds"),
        Type.Literal("day_gainers"),
        Type.Literal("day_losers"),
        Type.Literal("growth_technology_stocks"),
        Type.Literal("high_yield_bond"),
        Type.Literal("most_actives"),
        Type.Literal("most_shorted_stocks"),
        Type.Literal("portfolio_anchors"),
        Type.Literal("small_cap_gainers"),
        Type.Literal("solid_large_growth_funds"),
        Type.Literal("solid_midcap_growth_funds"),
        Type.Literal("top_mutual_funds"),
        Type.Literal("undervalued_growth_stocks"),
        Type.Literal("undervalued_large_caps"),
    ], {
        title: "ScreenerPredefinedScreenerModules",
    });
    const queryOptionsDefaults = {
        lang: "en-US",
        region: "US",
        scrIds: "day_gainers",
        count: 5,
    };
    const ScreenerOptions = Type.Object({
        lang: Type.Optional(Type.String()),
        region: Type.Optional(Type.String()),
        scrIds: PredefinedScreenerModules,
        count: Type.Optional(Type.Number()),
    });
    function screener(queryOptionsOverrides, moduleOptions) {
        return this._moduleExec({
            moduleName: "screener",
            query: {
                url: "https://${YF_QUERY_HOST}/v1/finance/screener/predefined/saved",
                schema: ScreenerOptions,
                defaults: queryOptionsDefaults,
                overrides: queryOptionsOverrides,
                needsCrumb: true,
            },
            result: {
                schema: ScreenerResult,
                transformWith(result) {
                    // console.log(result);
                    if (!result.finance)
                        throw new Error("Unexpected result: " + JSON.stringify(result));
                    return result.finance.result[0];
                },
            },
            moduleOptions,
        });
    }

    const DEBOUNCE_TIME = 50;
    const slugMap = new Map();
    function quoteCombine(query, queryOptionsOverrides = {}, moduleOptions) {
        const symbol = query;
        if (typeof symbol !== "string")
            throw new Error("quoteCombine expects a string query parameter, received: " +
                JSON.stringify(symbol, null, 2));
        validateAndCoerceTypebox({
            type: "options",
            data: queryOptionsOverrides,
            schema: QuoteOptionsSchema,
            options: this._opts.validation,
        });
        // Make sure we only combine requests with same options
        const slug = JSON.stringify(queryOptionsOverrides);
        let entry = slugMap.get(slug);
        if (!entry) {
            entry = {
                timeout: null,
                queryOptionsOverrides,
                symbols: new Map(),
            };
            slugMap.set(slug, entry);
        }
        if (entry.timeout)
            clearTimeout(entry.timeout);
        const thisQuote = quote.bind(this);
        return new Promise((resolve, reject) => {
            let symbolPromiseCallbacks = entry.symbols.get(symbol);
            /* istanbul ignore else */
            if (!symbolPromiseCallbacks) {
                symbolPromiseCallbacks = [];
                entry.symbols.set(symbol, symbolPromiseCallbacks);
            }
            symbolPromiseCallbacks.push({ resolve, reject });
            entry.timeout = setTimeout(() => {
                slugMap.delete(slug);
                const symbols = Array.from(entry.symbols.keys());
                // @ts-ignore
                thisQuote(symbols, queryOptionsOverrides, moduleOptions)
                    .then((results) => {
                    for (const result of results) {
                        for (const promise of entry.symbols.get(result.symbol)) {
                            promise.resolve(result);
                            promise.resolved = true;
                        }
                    }
                    // Check for symbols we asked for and didn't get back,
                    // e.g. non-existent symbols (#150)
                    for (const [_, promises] of entry.symbols) {
                        for (const promise of promises) {
                            if (!promise.resolved) {
                                promise.resolve(undefined);
                            }
                        }
                    }
                })
                    .catch((error) => {
                    for (const symbolPromiseCallbacks of entry.symbols.values())
                        for (const promise of symbolPromiseCallbacks)
                            promise.reject(error);
                });
            }, DEBOUNCE_TIME);
        });
    }

    // libs
    var yahooFinance = {
        // internal
        _env: {},
        _fetch: yahooFinanceFetch,
        _moduleExec: moduleExec,
        _opts: options$1,
        // common
        errors: errors$1,
        setGlobalConfig,
        suppressNotices,
        // modules,
        autoc,
        chart,
        _chart,
        historical,
        insights: trendingSymbols$1,
        options: options,
        quote,
        quoteSummary,
        fundamentalsTimeSeries,
        recommendationsBySymbol,
        search,
        trendingSymbols,
        dailyGainers,
        screener,
        // other
        quoteCombine,
    };

    var nodeEnvironment = {
        fetch,
        URLSearchParams: url.URLSearchParams,
    };

    yahooFinance._env = nodeEnvironment;

    var __defProp$8 = Object.defineProperty;
    var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$8 = (obj, key, value) => __defNormalProp$8(obj, typeof key !== "symbol" ? key + "" : key, value);
    class ScopeManager {
      constructor() {
        __publicField$8(this, "scopes", []);
        __publicField$8(this, "scopeTypes", []);
        __publicField$8(this, "scopeCounts", /* @__PURE__ */ new Map());
        __publicField$8(this, "contextBoundVars", /* @__PURE__ */ new Set());
        __publicField$8(this, "arrayPatternElements", /* @__PURE__ */ new Set());
        __publicField$8(this, "rootParams", /* @__PURE__ */ new Set());
        __publicField$8(this, "varKinds", /* @__PURE__ */ new Map());
        __publicField$8(this, "loopVars", /* @__PURE__ */ new Set());
        __publicField$8(this, "loopVarNames", /* @__PURE__ */ new Map());
        // Map original names to transformed names
        __publicField$8(this, "paramIdCounter", 0);
        __publicField$8(this, "cacheIdCounter", 0);
        __publicField$8(this, "tempVarCounter", 0);
        this.pushScope("glb");
      }
      get nextParamIdArg() {
        return {
          type: "Identifier",
          name: `'p${this.paramIdCounter++}'`
        };
      }
      get nextCacheIdArg() {
        return {
          type: "Identifier",
          name: `'cache_${this.cacheIdCounter++}'`
        };
      }
      pushScope(type) {
        this.scopes.push(/* @__PURE__ */ new Map());
        this.scopeTypes.push(type);
        this.scopeCounts.set(type, (this.scopeCounts.get(type) || 0) + 1);
      }
      popScope() {
        this.scopes.pop();
        this.scopeTypes.pop();
      }
      getCurrentScopeType() {
        return this.scopeTypes[this.scopeTypes.length - 1];
      }
      getCurrentScopeCount() {
        return this.scopeCounts.get(this.getCurrentScopeType()) || 1;
      }
      addContextBoundVar(name, isRootParam = false) {
        this.contextBoundVars.add(name);
        if (isRootParam) {
          this.rootParams.add(name);
        }
      }
      addArrayPatternElement(name) {
        this.arrayPatternElements.add(name);
      }
      isContextBound(name) {
        return this.contextBoundVars.has(name);
      }
      isArrayPatternElement(name) {
        return this.arrayPatternElements.has(name);
      }
      isRootParam(name) {
        return this.rootParams.has(name);
      }
      addLoopVariable(originalName, transformedName) {
        this.loopVars.add(originalName);
        this.loopVarNames.set(originalName, transformedName);
      }
      getLoopVariableName(name) {
        return this.loopVarNames.get(name);
      }
      isLoopVariable(name) {
        return this.loopVars.has(name);
      }
      addVariable(name, kind) {
        if (this.isContextBound(name)) {
          return name;
        }
        const currentScope = this.scopes[this.scopes.length - 1];
        const scopeType = this.scopeTypes[this.scopeTypes.length - 1];
        const scopeCount = this.scopeCounts.get(scopeType) || 1;
        const newName = `${scopeType}${scopeCount}_${name}`;
        currentScope.set(name, newName);
        this.varKinds.set(newName, kind);
        return newName;
      }
      getVariable(name) {
        if (this.loopVars.has(name)) {
          const transformedName = this.loopVarNames.get(name);
          if (transformedName) {
            return [transformedName, "let"];
          }
        }
        if (this.isContextBound(name)) {
          return [name, "let"];
        }
        for (let i = this.scopes.length - 1; i >= 0; i--) {
          const scope = this.scopes[i];
          if (scope.has(name)) {
            const scopedName = scope.get(name);
            const kind = this.varKinds.get(scopedName) || "let";
            return [scopedName, kind];
          }
        }
        return [name, "let"];
      }
      generateTempVar() {
        return `temp_${++this.tempVarCounter}`;
      }
    }

    //!!!Warning!!! this code is not clean, it was initially written as a PoC then used as transpiler for PineTS
    const CONTEXT_NAME = "$";
    const UNDEFINED_ARG = {
      type: "Identifier",
      name: "undefined"
    };
    function transformArrayIndex(node, scopeManager) {
      if (node.computed && node.property.type === "Identifier") {
        if (scopeManager.isLoopVariable(node.property.name)) {
          return;
        }
        if (!scopeManager.isContextBound(node.property.name)) {
          const [scopedName, kind] = scopeManager.getVariable(node.property.name);
          node.property = {
            type: "MemberExpression",
            object: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: CONTEXT_NAME
              },
              property: {
                type: "Identifier",
                name: kind
              },
              computed: false
            },
            property: {
              type: "Identifier",
              name: scopedName
            },
            computed: false
          };
          node.property = {
            type: "MemberExpression",
            object: node.property,
            property: {
              type: "Literal",
              value: 0
            },
            computed: true
          };
        }
      }
      if (node.computed && node.object.type === "Identifier") {
        if (scopeManager.isLoopVariable(node.object.name)) {
          return;
        }
        if (!scopeManager.isContextBound(node.object.name)) {
          const [scopedName, kind] = scopeManager.getVariable(node.object.name);
          node.object = {
            type: "MemberExpression",
            object: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: CONTEXT_NAME
              },
              property: {
                type: "Identifier",
                name: kind
              },
              computed: false
            },
            property: {
              type: "Identifier",
              name: scopedName
            },
            computed: false
          };
        }
        if (node.property.type === "MemberExpression") {
          const memberNode = node.property;
          if (!memberNode._indexTransformed) {
            transformArrayIndex(memberNode, scopeManager);
            memberNode._indexTransformed = true;
          }
        }
      }
    }
    function transformMemberExpression(memberNode, originalParamName, scopeManager) {
      if (memberNode.object && memberNode.object.type === "Identifier" && memberNode.object.name === "Math") {
        return;
      }
      const isIfStatement = scopeManager.getCurrentScopeType() == "if";
      const isElseStatement = scopeManager.getCurrentScopeType() == "els";
      const isForStatement = scopeManager.getCurrentScopeType() == "for";
      if (!isIfStatement && !isElseStatement && !isForStatement && memberNode.object && memberNode.object.type === "Identifier" && scopeManager.isContextBound(memberNode.object.name) && !scopeManager.isRootParam(memberNode.object.name)) {
        return;
      }
      if (!memberNode._indexTransformed) {
        transformArrayIndex(memberNode, scopeManager);
        memberNode._indexTransformed = true;
      }
    }
    function transformVariableDeclaration(varNode, scopeManager) {
      varNode.declarations.forEach((decl) => {
        if (decl.init.name == "na") {
          decl.init.name = "NaN";
        }
        const isContextProperty = decl.init && decl.init.type === "MemberExpression" && decl.init.object && (decl.init.object.name === "context" || decl.init.object.name === CONTEXT_NAME || decl.init.object.name === "context2");
        const isSubContextProperty = decl.init && decl.init.type === "MemberExpression" && decl.init.object?.object && (decl.init.object.object.name === "context" || decl.init.object.object.name === CONTEXT_NAME || decl.init.object.object.name === "context2");
        const isArrowFunction = decl.init && decl.init.type === "ArrowFunctionExpression";
        if (isContextProperty) {
          if (decl.id.name) {
            scopeManager.addContextBoundVar(decl.id.name);
          }
          if (decl.id.properties) {
            decl.id.properties.forEach((property) => {
              if (property.key.name) {
                scopeManager.addContextBoundVar(property.key.name);
              }
            });
          }
          decl.init.object.name = CONTEXT_NAME;
          return;
        }
        if (isSubContextProperty) {
          if (decl.id.name) {
            scopeManager.addContextBoundVar(decl.id.name);
          }
          if (decl.id.properties) {
            decl.id.properties.forEach((property) => {
              if (property.key.name) {
                scopeManager.addContextBoundVar(property.key.name);
              }
            });
          }
          decl.init.object.object.name = CONTEXT_NAME;
          return;
        }
        if (isArrowFunction) {
          decl.init.params.forEach((param) => {
            if (param.type === "Identifier") {
              scopeManager.addContextBoundVar(param.name);
            }
          });
        }
        const newName = scopeManager.addVariable(decl.id.name, varNode.kind);
        const kind = varNode.kind;
        if (decl.init && !isArrowFunction) {
          if (decl.init.type === "CallExpression" && decl.init.callee.type === "MemberExpression" && decl.init.callee.object && decl.init.callee.object.type === "Identifier" && scopeManager.isContextBound(decl.init.callee.object.name)) {
            transformCallExpression(decl.init, scopeManager);
          } else {
            recursive(
              decl.init,
              { parent: decl.init },
              {
                Identifier(node, state) {
                  node.parent = state.parent;
                  transformIdentifier(node, scopeManager);
                  const isBinaryOperation = node.parent && node.parent.type === "BinaryExpression";
                  const isConditional = node.parent && node.parent.type === "ConditionalExpression";
                  if (node.type === "Identifier" && (isBinaryOperation || isConditional)) {
                    Object.assign(node, {
                      type: "MemberExpression",
                      object: {
                        type: "Identifier",
                        name: node.name
                      },
                      property: {
                        type: "Literal",
                        value: 0
                      },
                      computed: true
                    });
                  }
                },
                CallExpression(node, state, c) {
                  if (node.callee.type === "Identifier") {
                    node.callee.parent = node;
                  }
                  node.arguments.forEach((arg) => {
                    if (arg.type === "Identifier") {
                      arg.parent = node;
                    }
                  });
                  transformCallExpression(node, scopeManager);
                  node.arguments.forEach((arg) => c(arg, { parent: node }));
                },
                BinaryExpression(node, state, c) {
                  if (node.left.type === "Identifier") {
                    node.left.parent = node;
                  }
                  if (node.right.type === "Identifier") {
                    node.right.parent = node;
                  }
                  c(node.left, { parent: node });
                  c(node.right, { parent: node });
                },
                MemberExpression(node, state, c) {
                  if (node.object.type === "Identifier") {
                    node.object.parent = node;
                  }
                  if (node.property.type === "Identifier") {
                    node.property.parent = node;
                  }
                  transformArrayIndex(node, scopeManager);
                  if (node.object) {
                    c(node.object, { parent: node });
                  }
                }
              }
            );
          }
        }
        const targetVarRef = {
          type: "MemberExpression",
          object: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: CONTEXT_NAME
            },
            property: {
              type: "Identifier",
              name: kind
            },
            computed: false
          },
          property: {
            type: "Identifier",
            name: newName
          },
          computed: false
        };
        const isArrayPatternVar = scopeManager.isArrayPatternElement(decl.id.name);
        const isArrayInit = !isArrayPatternVar && decl.init && decl.init.type === "MemberExpression" && decl.init.computed && decl.init.property && (decl.init.property.type === "Literal" || decl.init.property.type === "MemberExpression");
        if (decl.init?.property?.type === "MemberExpression") {
          if (!decl.init.property._indexTransformed) {
            transformArrayIndex(decl.init.property, scopeManager);
            decl.init.property._indexTransformed = true;
          }
        }
        const assignmentExpr = {
          type: "ExpressionStatement",
          expression: {
            type: "AssignmentExpression",
            operator: "=",
            left: targetVarRef,
            right: decl.init ? isArrowFunction || isArrayPatternVar ? decl.init : {
              type: "CallExpression",
              callee: {
                type: "MemberExpression",
                object: {
                  type: "Identifier",
                  name: CONTEXT_NAME
                },
                property: {
                  type: "Identifier",
                  name: "init"
                },
                computed: false
              },
              arguments: isArrayInit ? [targetVarRef, decl.init.object, decl.init.property] : [targetVarRef, decl.init]
            } : {
              type: "Identifier",
              name: "undefined"
            }
          }
        };
        if (isArrayPatternVar) {
          assignmentExpr.expression.right.object.property.name += `?.[0][${decl.init.property.value}]`;
          const obj = assignmentExpr.expression.right.object;
          assignmentExpr.expression.right = {
            type: "CallExpression",
            callee: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: CONTEXT_NAME
              },
              property: {
                type: "Identifier",
                name: "init"
              },
              computed: false
            },
            arguments: [
              targetVarRef,
              obj
              /*, decl.init.property.value*/
            ]
          };
        }
        if (isArrowFunction) {
          scopeManager.pushScope("fn");
          recursive(decl.init.body, scopeManager, {
            BlockStatement(node, state, c) {
              node.body.forEach((stmt) => c(stmt, state));
            },
            IfStatement(node, state, c) {
              state.pushScope("if");
              c(node.consequent, state);
              if (node.alternate) {
                state.pushScope("els");
                c(node.alternate, state);
                state.popScope();
              }
              state.popScope();
            },
            VariableDeclaration(node, state) {
              transformVariableDeclaration(node, state);
            },
            Identifier(node, state) {
              transformIdentifier(node, state);
            },
            AssignmentExpression(node, state) {
              transformAssignmentExpression(node, state);
            }
          });
          scopeManager.popScope();
        }
        Object.assign(varNode, assignmentExpr);
      });
    }
    function transformIdentifier(node, scopeManager) {
      if (node.name !== CONTEXT_NAME) {
        if (node.name === "Math" || node.name === "NaN" || node.name === "undefined" || node.name === "Infinity" || node.name === "null" || node.name.startsWith("'") && node.name.endsWith("'") || node.name.startsWith('"') && node.name.endsWith('"') || node.name.startsWith("`") && node.name.endsWith("`")) {
          return;
        }
        if (scopeManager.isLoopVariable(node.name)) {
          return;
        }
        if (scopeManager.isContextBound(node.name) && !scopeManager.isRootParam(node.name)) {
          return;
        }
        const isNamespaceMember = node.parent && node.parent.type === "MemberExpression" && node.parent.object === node && scopeManager.isContextBound(node.name);
        const isParamCall = node.parent && node.parent.type === "CallExpression" && node.parent.callee && node.parent.callee.type === "MemberExpression" && node.parent.callee.property.name === "param";
        node.parent && node.parent.type === "AssignmentExpression" && node.parent.left === node;
        const isNamespaceFunctionArg = node.parent && node.parent.type === "CallExpression" && node.parent.callee && node.parent.callee.type === "MemberExpression" && scopeManager.isContextBound(node.parent.callee.object.name);
        const isArrayAccess = node.parent && node.parent.type === "MemberExpression" && node.parent.computed;
        const isArrayIndexInNamespaceCall = node.parent && node.parent.type === "MemberExpression" && node.parent.computed && node.parent.property === node && node.parent.parent && node.parent.parent.type === "CallExpression" && node.parent.parent.callee && node.parent.parent.callee.type === "MemberExpression" && scopeManager.isContextBound(node.parent.parent.callee.object.name);
        const isFunctionCall = node.parent && node.parent.type === "CallExpression" && node.parent.callee === node;
        if (isNamespaceMember || isParamCall || isNamespaceFunctionArg || isArrayIndexInNamespaceCall || isFunctionCall) {
          if (isFunctionCall) {
            return;
          }
          const [scopedName2, kind2] = scopeManager.getVariable(node.name);
          Object.assign(node, {
            type: "MemberExpression",
            object: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: CONTEXT_NAME
              },
              property: {
                type: "Identifier",
                name: kind2
              },
              computed: false
            },
            property: {
              type: "Identifier",
              name: scopedName2
            },
            computed: false
          });
          return;
        }
        const [scopedName, kind] = scopeManager.getVariable(node.name);
        const memberExpr = {
          type: "MemberExpression",
          object: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: CONTEXT_NAME
            },
            property: {
              type: "Identifier",
              name: kind
            },
            computed: false
          },
          property: {
            type: "Identifier",
            name: scopedName
          },
          computed: false
        };
        const hasArrayAccess = node.parent && node.parent.type === "MemberExpression" && node.parent.computed && node.parent.object === node;
        if (!hasArrayAccess && !isArrayAccess) {
          Object.assign(node, {
            type: "MemberExpression",
            object: memberExpr,
            property: {
              type: "Literal",
              value: 0
            },
            computed: true
          });
        } else {
          Object.assign(node, memberExpr);
        }
      }
    }
    function transformAssignmentExpression(node, scopeManager) {
      if (node.left.type === "Identifier") {
        const [varName, kind] = scopeManager.getVariable(node.left.name);
        const memberExpr = {
          type: "MemberExpression",
          object: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: CONTEXT_NAME
            },
            property: {
              type: "Identifier",
              name: kind
            },
            computed: false
          },
          property: {
            type: "Identifier",
            name: varName
          },
          computed: false
        };
        node.left = {
          type: "MemberExpression",
          object: memberExpr,
          property: {
            type: "Literal",
            value: 0
          },
          computed: true
        };
      }
      recursive(
        node.right,
        { parent: node.right, inNamespaceCall: false },
        {
          Identifier(node2, state, c) {
            if (node2.name == "na") {
              node2.name = "NaN";
            }
            node2.parent = state.parent;
            transformIdentifier(node2, scopeManager);
            const isBinaryOperation = node2.parent && node2.parent.type === "BinaryExpression";
            const isConditional = node2.parent && node2.parent.type === "ConditionalExpression";
            const isContextBound = scopeManager.isContextBound(node2.name) && !scopeManager.isRootParam(node2.name);
            const hasArrayAccess = node2.parent && node2.parent.type === "MemberExpression" && node2.parent.computed && node2.parent.object === node2;
            const isParamCall = node2.parent && node2.parent._isParamCall;
            const isMemberExpression = node2.parent && node2.parent.type === "MemberExpression";
            const isReserved = node2.name === "NaN";
            if (isContextBound || isConditional || isBinaryOperation) {
              if (node2.type === "MemberExpression") {
                transformArrayIndex(node2, scopeManager);
              } else if (node2.type === "Identifier" && !isMemberExpression && !hasArrayAccess && !isParamCall && !isReserved) {
                addArrayAccess(node2);
              }
            }
          },
          MemberExpression(node2, state, c) {
            transformArrayIndex(node2, scopeManager);
            if (node2.object) {
              c(node2.object, { parent: node2, inNamespaceCall: state.inNamespaceCall });
            }
          },
          CallExpression(node2, state, c) {
            const isNamespaceCall = node2.callee && node2.callee.type === "MemberExpression" && node2.callee.object && node2.callee.object.type === "Identifier" && scopeManager.isContextBound(node2.callee.object.name);
            transformCallExpression(node2, scopeManager);
            node2.arguments.forEach((arg) => c(arg, { parent: node2, inNamespaceCall: isNamespaceCall || state.inNamespaceCall }));
          }
        }
      );
    }
    function transformArrowFunctionParams(node, scopeManager, isRootFunction = false) {
      node.params.forEach((param) => {
        if (param.type === "Identifier") {
          scopeManager.addContextBoundVar(param.name, isRootFunction);
        }
      });
    }
    function transformReturnStatement(node, scopeManager) {
      const curScope = scopeManager.getCurrentScopeType();
      if (node.argument) {
        if (node.argument.type === "ArrayExpression") {
          node.argument.elements = node.argument.elements.map((element) => {
            if (element.type === "Identifier") {
              if (scopeManager.isContextBound(element.name) && !scopeManager.isRootParam(element.name)) {
                return {
                  type: "MemberExpression",
                  object: element,
                  property: {
                    type: "Literal",
                    value: 0
                  },
                  computed: true
                };
              }
              const [scopedName, kind] = scopeManager.getVariable(element.name);
              return {
                type: "MemberExpression",
                object: {
                  type: "MemberExpression",
                  object: {
                    type: "MemberExpression",
                    object: {
                      type: "Identifier",
                      name: CONTEXT_NAME
                    },
                    property: {
                      type: "Identifier",
                      name: kind
                    },
                    computed: false
                  },
                  property: {
                    type: "Identifier",
                    name: scopedName
                  },
                  computed: false
                },
                property: {
                  type: "Literal",
                  value: 0
                },
                computed: true
              };
            } else if (element.type === "MemberExpression") {
              if (element.computed && element.object.type === "Identifier" && scopeManager.isContextBound(element.object.name) && !scopeManager.isRootParam(element.object.name)) {
                return element;
              }
              transformMemberExpression(element, "", scopeManager);
              return element;
            }
            return element;
          });
          node.argument = {
            type: "ArrayExpression",
            elements: [node.argument]
          };
        } else if (node.argument.type === "BinaryExpression") {
          recursive(node.argument, scopeManager, {
            Identifier(node2, state) {
              transformIdentifier(node2, state);
              if (node2.type === "Identifier") {
                addArrayAccess(node2);
              }
            },
            MemberExpression(node2) {
              transformMemberExpression(node2, "", scopeManager);
            }
          });
        } else if (node.argument.type === "ObjectExpression") {
          node.argument.properties = node.argument.properties.map((prop) => {
            if (prop.shorthand) {
              const [scopedName, kind] = scopeManager.getVariable(prop.value.name);
              return {
                type: "Property",
                key: {
                  type: "Identifier",
                  name: prop.key.name
                },
                value: {
                  type: "MemberExpression",
                  object: {
                    type: "MemberExpression",
                    object: {
                      type: "Identifier",
                      name: CONTEXT_NAME
                    },
                    property: {
                      type: "Identifier",
                      name: kind
                    },
                    computed: false
                  },
                  property: {
                    type: "Identifier",
                    name: scopedName
                  },
                  computed: false
                },
                kind: "init",
                method: false,
                shorthand: false,
                computed: false
              };
            }
            return prop;
          });
        } else if (node.argument.type === "Identifier") {
          const [scopedName, kind] = scopeManager.getVariable(node.argument.name);
          node.argument = {
            type: "MemberExpression",
            object: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: CONTEXT_NAME
              },
              property: {
                type: "Identifier",
                name: kind
              },
              computed: false
            },
            property: {
              type: "Identifier",
              name: scopedName
            },
            computed: false
          };
          node.argument = {
            type: "MemberExpression",
            object: node.argument,
            property: {
              type: "Literal",
              value: 0
            },
            computed: true
          };
        }
        if (curScope === "fn") {
          node.argument = {
            type: "CallExpression",
            callee: {
              type: "MemberExpression",
              object: { type: "Identifier", name: CONTEXT_NAME },
              property: { type: "Identifier", name: "precision" }
            },
            arguments: [node.argument]
          };
        }
      }
    }
    function transformIdentifierForParam(node, scopeManager) {
      if (node.type === "Identifier") {
        if (node.name === "na") {
          node.name = "NaN";
          return node;
        }
        if (scopeManager.isLoopVariable(node.name)) {
          return node;
        }
        if (scopeManager.isRootParam(node.name)) {
          const [scopedName2, kind2] = scopeManager.getVariable(node.name);
          return {
            type: "MemberExpression",
            object: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: CONTEXT_NAME
              },
              property: {
                type: "Identifier",
                name: kind2
              },
              computed: false
            },
            property: {
              type: "Identifier",
              name: scopedName2
            },
            computed: false
          };
        }
        if (scopeManager.isContextBound(node.name)) {
          return node;
        }
        const [scopedName, kind] = scopeManager.getVariable(node.name);
        return {
          type: "MemberExpression",
          object: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: CONTEXT_NAME
            },
            property: {
              type: "Identifier",
              name: kind
            },
            computed: false
          },
          property: {
            type: "Identifier",
            name: scopedName
          },
          computed: false
        };
      }
      return node;
    }
    function getParamFromUnaryExpression(node, scopeManager, namespace) {
      const transformedArgument = transformOperand(node.argument, scopeManager, namespace);
      const unaryExpr = {
        type: "UnaryExpression",
        operator: node.operator,
        prefix: node.prefix,
        argument: transformedArgument,
        start: node.start,
        end: node.end
      };
      return unaryExpr;
    }
    function transformOperand(node, scopeManager, namespace = "") {
      switch (node.type) {
        case "BinaryExpression": {
          return getParamFromBinaryExpression(node, scopeManager, namespace);
        }
        case "MemberExpression": {
          const transformedObject = node.object.type === "Identifier" ? transformIdentifierForParam(node.object, scopeManager) : node.object;
          return {
            type: "MemberExpression",
            object: transformedObject,
            property: node.property,
            computed: node.computed
          };
        }
        case "Identifier": {
          if (scopeManager.isLoopVariable(node.name)) {
            return node;
          }
          const isMemberExprProperty = node.parent && node.parent.type === "MemberExpression" && node.parent.property === node;
          if (isMemberExprProperty) {
            return node;
          }
          const transformedObject = transformIdentifierForParam(node, scopeManager);
          return {
            type: "MemberExpression",
            object: transformedObject,
            property: {
              type: "Literal",
              value: 0
            },
            computed: true
          };
        }
        case "UnaryExpression": {
          return getParamFromUnaryExpression(node, scopeManager, namespace);
        }
      }
      return node;
    }
    function getParamFromBinaryExpression(node, scopeManager, namespace) {
      const transformedLeft = transformOperand(node.left, scopeManager, namespace);
      const transformedRight = transformOperand(node.right, scopeManager, namespace);
      const binaryExpr = {
        type: "BinaryExpression",
        operator: node.operator,
        left: transformedLeft,
        right: transformedRight,
        start: node.start,
        end: node.end
      };
      recursive(binaryExpr, scopeManager, {
        CallExpression(node2, scopeManager2) {
          if (!node2._transformed) {
            transformCallExpression(node2, scopeManager2);
          }
        },
        MemberExpression(node2) {
          transformMemberExpression(node2, "", scopeManager);
        }
      });
      return binaryExpr;
    }
    function getParamFromLogicalExpression(node, scopeManager, namespace) {
      const transformedLeft = transformOperand(node.left, scopeManager, namespace);
      const transformedRight = transformOperand(node.right, scopeManager, namespace);
      const logicalExpr = {
        type: "LogicalExpression",
        operator: node.operator,
        left: transformedLeft,
        right: transformedRight,
        start: node.start,
        end: node.end
      };
      recursive(logicalExpr, scopeManager, {
        CallExpression(node2, scopeManager2) {
          if (!node2._transformed) {
            transformCallExpression(node2, scopeManager2);
          }
        }
      });
      return logicalExpr;
    }
    function getParamFromConditionalExpression(node, scopeManager, namespace) {
      recursive(
        node,
        { parent: node, inNamespaceCall: false },
        {
          Identifier(node2, state, c) {
            if (node2.name == "NaN") return;
            if (node2.name == "na") {
              node2.name = "NaN";
              return;
            }
            node2.parent = state.parent;
            transformIdentifier(node2, scopeManager);
            const isBinaryOperation = node2.parent && node2.parent.type === "BinaryExpression";
            const isConditional = node2.parent && node2.parent.type === "ConditionalExpression";
            if (isConditional || isBinaryOperation) {
              if (node2.type === "MemberExpression") {
                transformArrayIndex(node2, scopeManager);
              } else if (node2.type === "Identifier") {
                addArrayAccess(node2);
              }
            }
          },
          MemberExpression(node2, state, c) {
            transformArrayIndex(node2, scopeManager);
            if (node2.object) {
              c(node2.object, { parent: node2, inNamespaceCall: state.inNamespaceCall });
            }
          },
          CallExpression(node2, state, c) {
            const isNamespaceCall = node2.callee && node2.callee.type === "MemberExpression" && node2.callee.object && node2.callee.object.type === "Identifier" && scopeManager.isContextBound(node2.callee.object.name);
            transformCallExpression(node2, scopeManager);
            node2.arguments.forEach((arg) => c(arg, { parent: node2, inNamespaceCall: isNamespaceCall || state.inNamespaceCall }));
          }
        }
      );
      return {
        type: "CallExpression",
        callee: {
          type: "MemberExpression",
          object: { type: "Identifier", name: namespace },
          property: { type: "Identifier", name: "param" }
        },
        arguments: [node, UNDEFINED_ARG, scopeManager.nextParamIdArg],
        _transformed: true,
        _isParamCall: true
      };
    }
    function transformFunctionArgument(arg, namespace, scopeManager) {
      switch (arg?.type) {
        case "BinaryExpression":
          arg = getParamFromBinaryExpression(arg, scopeManager, namespace);
          break;
        case "LogicalExpression":
          arg = getParamFromLogicalExpression(arg, scopeManager, namespace);
          break;
        case "ConditionalExpression":
          return getParamFromConditionalExpression(arg, scopeManager, namespace);
        case "UnaryExpression":
          arg = getParamFromUnaryExpression(arg, scopeManager, namespace);
          break;
      }
      const isArrayAccess = arg.type === "MemberExpression" && arg.computed && arg.property;
      if (isArrayAccess) {
        const transformedObject = arg.object.type === "Identifier" && scopeManager.isContextBound(arg.object.name) && !scopeManager.isRootParam(arg.object.name) ? arg.object : transformIdentifierForParam(arg.object, scopeManager);
        const transformedProperty = arg.property.type === "Identifier" && !scopeManager.isContextBound(arg.property.name) && !scopeManager.isLoopVariable(arg.property.name) ? transformIdentifierForParam(arg.property, scopeManager) : arg.property;
        return {
          type: "CallExpression",
          callee: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: namespace
            },
            property: {
              type: "Identifier",
              name: "param"
            },
            computed: false
          },
          arguments: [transformedObject, transformedProperty, scopeManager.nextParamIdArg],
          _transformed: true,
          _isParamCall: true
        };
      }
      if (arg.type === "ObjectExpression") {
        arg.properties = arg.properties.map((prop) => {
          if (prop.value.name) {
            const [scopedName, kind] = scopeManager.getVariable(prop.value.name);
            return {
              type: "Property",
              key: {
                type: "Identifier",
                name: prop.key.name
              },
              value: {
                type: "MemberExpression",
                object: {
                  type: "MemberExpression",
                  object: {
                    type: "Identifier",
                    name: CONTEXT_NAME
                  },
                  property: {
                    type: "Identifier",
                    name: kind
                  },
                  computed: false
                },
                property: {
                  type: "Identifier",
                  name: scopedName
                },
                computed: false
              },
              kind: "init",
              method: false,
              shorthand: false,
              computed: false
            };
          }
          return prop;
        });
      }
      if (arg.type === "Identifier") {
        if (arg.name === "na") {
          arg.name = "NaN";
          return arg;
        }
        if (scopeManager.isContextBound(arg.name) && !scopeManager.isRootParam(arg.name)) {
          return {
            type: "CallExpression",
            callee: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: namespace
              },
              property: {
                type: "Identifier",
                name: "param"
              },
              computed: false
            },
            arguments: [arg, UNDEFINED_ARG, scopeManager.nextParamIdArg],
            _transformed: true,
            _isParamCall: true
          };
        }
      }
      if (arg?.type === "CallExpression") {
        transformCallExpression(arg, scopeManager);
      }
      return {
        type: "CallExpression",
        callee: {
          type: "MemberExpression",
          object: {
            type: "Identifier",
            name: namespace
          },
          property: {
            type: "Identifier",
            name: "param"
          },
          computed: false
        },
        arguments: [arg.type === "Identifier" ? transformIdentifierForParam(arg, scopeManager) : arg, UNDEFINED_ARG, scopeManager.nextParamIdArg],
        _transformed: true,
        _isParamCall: true
      };
    }
    function transformCallExpression(node, scopeManager, namespace) {
      if (node._transformed) {
        return;
      }
      const isNamespaceCall = node.callee && node.callee.type === "MemberExpression" && node.callee.object && node.callee.object.type === "Identifier" && (scopeManager.isContextBound(node.callee.object.name) || node.callee.object.name === "math" || node.callee.object.name === "ta");
      if (isNamespaceCall) {
        const namespace2 = node.callee.object.name;
        node.arguments = node.arguments.map((arg) => {
          if (arg._isParamCall) {
            return arg;
          }
          return transformFunctionArgument(arg, namespace2, scopeManager);
        });
        node._transformed = true;
      } else if (node.callee && node.callee.type === "Identifier") {
        node.arguments = node.arguments.map((arg) => {
          if (arg._isParamCall) {
            return arg;
          }
          return transformFunctionArgument(arg, CONTEXT_NAME, scopeManager);
        });
        node._transformed = true;
      }
      node.arguments.forEach((arg) => {
        recursive(arg, scopeManager, {
          Identifier(node2, state, c) {
            node2.parent = state.parent;
            transformIdentifier(node2, scopeManager);
            const isBinaryOperation = node2.parent && node2.parent.type === "BinaryExpression";
            const isConditional = node2.parent && node2.parent.type === "ConditionalExpression";
            if (isConditional || isBinaryOperation) {
              if (node2.type === "MemberExpression") {
                transformArrayIndex(node2, scopeManager);
              } else if (node2.type === "Identifier") {
                addArrayAccess(node2);
              }
            }
          },
          CallExpression(node2, state, c) {
            if (!node2._transformed) {
              transformCallExpression(node2, state);
            }
          },
          MemberExpression(node2, state, c) {
            transformMemberExpression(node2, "", scopeManager);
            if (node2.object) {
              c(node2.object, { parent: node2, inNamespaceCall: state.inNamespaceCall });
            }
          }
        });
      });
    }
    function transformFunctionDeclaration(node, scopeManager) {
      node.params.forEach((param) => {
        if (param.type === "Identifier") {
          scopeManager.addContextBoundVar(param.name, false);
        }
      });
      if (node.body && node.body.type === "BlockStatement") {
        scopeManager.pushScope("fn");
        recursive(node.body, scopeManager, {
          BlockStatement(node2, state, c) {
            node2.body.forEach((stmt) => c(stmt, state));
          },
          ReturnStatement(node2, state) {
            transformReturnStatement(node2, state);
          },
          VariableDeclaration(node2, state) {
            transformVariableDeclaration(node2, state);
          },
          Identifier(node2, state) {
            transformIdentifier(node2, state);
          },
          CallExpression(node2, state) {
            transformCallExpression(node2, state);
            node2.arguments.forEach((arg) => {
              if (arg.type === "BinaryExpression") {
                recursive(arg, state, {
                  CallExpression(node3, state2) {
                    transformCallExpression(node3, state2);
                  },
                  MemberExpression(node3) {
                    transformMemberExpression(node3, "", state);
                  }
                });
              }
            });
          },
          MemberExpression(node2) {
            transformMemberExpression(node2, "", scopeManager);
          },
          AssignmentExpression(node2, state) {
            transformAssignmentExpression(node2, state);
          },
          ForStatement(node2, state, c) {
            transformForStatement(node2, state, c);
          },
          IfStatement(node2, state, c) {
            transformIfStatement(node2, state, c);
          },
          BinaryExpression(node2, state, c) {
            recursive(node2, state, {
              CallExpression(node3, state2) {
                transformCallExpression(node3, state2);
              },
              MemberExpression(node3) {
                transformMemberExpression(node3, "", state);
              }
            });
          }
        });
        scopeManager.popScope();
      }
    }
    function addArrayAccess(node, scopeManager) {
      Object.assign(node, {
        type: "MemberExpression",
        object: {
          type: "Identifier",
          name: node.name,
          start: node.start,
          end: node.end
        },
        property: {
          type: "Literal",
          value: 0
        },
        computed: true,
        _indexTransformed: true
      });
    }
    function transformForStatement(node, scopeManager, c) {
      if (node.init && node.init.type === "VariableDeclaration") {
        const decl = node.init.declarations[0];
        const originalName = decl.id.name;
        scopeManager.addLoopVariable(originalName, originalName);
        node.init = {
          type: "VariableDeclaration",
          kind: node.init.kind,
          declarations: [
            {
              type: "VariableDeclarator",
              id: {
                type: "Identifier",
                name: originalName
              },
              init: decl.init
            }
          ]
        };
        if (decl.init) {
          recursive(decl.init, scopeManager, {
            Identifier(node2, state) {
              if (!scopeManager.isLoopVariable(node2.name)) {
                scopeManager.pushScope("for");
                transformIdentifier(node2, state);
                scopeManager.popScope();
              }
            },
            MemberExpression(node2) {
              scopeManager.pushScope("for");
              transformMemberExpression(node2, "", scopeManager);
              scopeManager.popScope();
            }
          });
        }
      }
      if (node.test) {
        recursive(node.test, scopeManager, {
          Identifier(node2, state) {
            if (!scopeManager.isLoopVariable(node2.name) && !node2.computed) {
              scopeManager.pushScope("for");
              transformIdentifier(node2, state);
              if (node2.type === "Identifier") {
                node2.computed = true;
                addArrayAccess(node2);
              }
              scopeManager.popScope();
            }
          },
          MemberExpression(node2) {
            scopeManager.pushScope("for");
            transformMemberExpression(node2, "", scopeManager);
            scopeManager.popScope();
          }
        });
      }
      if (node.update) {
        recursive(node.update, scopeManager, {
          Identifier(node2, state) {
            if (!scopeManager.isLoopVariable(node2.name)) {
              scopeManager.pushScope("for");
              transformIdentifier(node2, state);
              scopeManager.popScope();
            }
          }
        });
      }
      scopeManager.pushScope("for");
      c(node.body, scopeManager);
      scopeManager.popScope();
    }
    function transformExpression(node, scopeManager) {
      recursive(node, scopeManager, {
        MemberExpression(node2) {
          transformMemberExpression(node2, "", scopeManager);
        },
        CallExpression(node2, state) {
          transformCallExpression(node2, state);
        },
        Identifier(node2, state) {
          transformIdentifier(node2, state);
          const isIfStatement = scopeManager.getCurrentScopeType() === "if";
          const isContextBound = scopeManager.isContextBound(node2.name) && !scopeManager.isRootParam(node2.name);
          if (isContextBound && isIfStatement) {
            addArrayAccess(node2);
          }
        }
      });
    }
    function transformIfStatement(node, scopeManager, c) {
      if (node.test) {
        scopeManager.pushScope("if");
        transformExpression(node.test, scopeManager);
        scopeManager.popScope();
      }
      scopeManager.pushScope("if");
      c(node.consequent, scopeManager);
      scopeManager.popScope();
      if (node.alternate) {
        scopeManager.pushScope("els");
        c(node.alternate, scopeManager);
        scopeManager.popScope();
      }
    }
    function transformNestedArrowFunctions(ast) {
      recursive(ast, null, {
        VariableDeclaration(node, state, c) {
          if (node.declarations && node.declarations.length > 0) {
            const declarations = node.declarations;
            declarations.forEach((decl) => {
              if (decl.init && decl.init.type === "ArrowFunctionExpression") {
                const isRootFunction = decl.init.start === 0;
                if (!isRootFunction) {
                  const functionDeclaration = {
                    type: "FunctionDeclaration",
                    id: decl.id,
                    // Use the variable name as function name
                    params: decl.init.params,
                    body: decl.init.body.type === "BlockStatement" ? decl.init.body : {
                      type: "BlockStatement",
                      body: [
                        {
                          type: "ReturnStatement",
                          argument: decl.init.body
                        }
                      ]
                    },
                    async: decl.init.async,
                    generator: false
                  };
                  Object.assign(node, functionDeclaration);
                }
              }
            });
          }
          if (node.body && node.body.body) {
            node.body.body.forEach((stmt) => c(stmt, state));
          }
        }
      });
    }
    function preProcessContextBoundVars(ast, scopeManager) {
      simple(ast, {
        VariableDeclaration(node) {
          node.declarations.forEach((decl) => {
            const isContextProperty = decl.init && decl.init.type === "MemberExpression" && decl.init.object && (decl.init.object.name === "context" || decl.init.object.name === CONTEXT_NAME || decl.init.object.name === "context2");
            const isSubContextProperty = decl.init && decl.init.type === "MemberExpression" && decl.init.object?.object && (decl.init.object.object.name === "context" || decl.init.object.object.name === CONTEXT_NAME || decl.init.object.object.name === "context2");
            if (isContextProperty || isSubContextProperty) {
              if (decl.id.name) {
                scopeManager.addContextBoundVar(decl.id.name);
              }
              if (decl.id.properties) {
                decl.id.properties.forEach((property) => {
                  if (property.key.name) {
                    scopeManager.addContextBoundVar(property.key.name);
                  }
                });
              }
            }
          });
        }
      });
    }
    function transpile(fn) {
      let code = typeof fn === "function" ? fn.toString() : fn;
      const ast = parse(code.trim(), {
        ecmaVersion: "latest",
        sourceType: "module"
      });
      transformNestedArrowFunctions(ast);
      const scopeManager = new ScopeManager();
      let originalParamName;
      preProcessContextBoundVars(ast, scopeManager);
      simple(ast, {
        FunctionDeclaration(node) {
          transformFunctionDeclaration(node, scopeManager);
        },
        ArrowFunctionExpression(node) {
          const isRootFunction = node.start === 0;
          if (isRootFunction && node.params && node.params.length > 0) {
            originalParamName = node.params[0].name;
            node.params[0].name = CONTEXT_NAME;
          }
          transformArrowFunctionParams(node, scopeManager, isRootFunction);
        },
        VariableDeclaration(node) {
          node.declarations.forEach((decl) => {
            if (decl.id.type === "ArrayPattern") {
              const tempVarName = scopeManager.generateTempVar();
              const tempVarDecl = {
                type: "VariableDeclaration",
                kind: node.kind,
                declarations: [
                  {
                    type: "VariableDeclarator",
                    id: {
                      type: "Identifier",
                      name: tempVarName
                    },
                    init: decl.init
                  }
                ]
              };
              decl.id.elements?.forEach((element) => {
                if (element.type === "Identifier") {
                  scopeManager.addArrayPatternElement(element.name);
                }
              });
              const individualDecls = decl.id.elements.map((element, index) => ({
                type: "VariableDeclaration",
                kind: node.kind,
                declarations: [
                  {
                    type: "VariableDeclarator",
                    id: element,
                    init: {
                      type: "MemberExpression",
                      object: {
                        type: "Identifier",
                        name: tempVarName
                      },
                      property: {
                        type: "Literal",
                        value: index
                      },
                      computed: true
                    }
                  }
                ]
              }));
              Object.assign(node, {
                type: "BlockStatement",
                body: [tempVarDecl, ...individualDecls]
              });
            }
          });
        },
        ForStatement(node) {
        }
      });
      recursive(ast, scopeManager, {
        BlockStatement(node, state, c) {
          node.body.forEach((stmt) => c(stmt, state));
        },
        ReturnStatement(node, state) {
          transformReturnStatement(node, state);
        },
        VariableDeclaration(node, state) {
          transformVariableDeclaration(node, state);
        },
        Identifier(node, state) {
          transformIdentifier(node, state);
        },
        CallExpression(node, state) {
          transformCallExpression(node, state);
        },
        MemberExpression(node) {
          transformMemberExpression(node, originalParamName, scopeManager);
        },
        AssignmentExpression(node, state) {
          transformAssignmentExpression(node, state);
        },
        FunctionDeclaration(node, state) {
          return;
        },
        ForStatement(node, state, c) {
          transformForStatement(node, state, c);
        },
        IfStatement(node, state, c) {
          transformIfStatement(node, state, c);
        }
      });
      const transformedCode = generate(ast);
      const _wraperFunction = new Function("", `return ${transformedCode}`);
      return _wraperFunction(this);
    }

    var __defProp$7 = Object.defineProperty;
    var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$7 = (obj, key, value) => __defNormalProp$7(obj, typeof key !== "symbol" ? key + "" : key, value);
    class PineTS {
      constructor(source, tickerId, timeframe, limit, sDate, eDate) {
        this.source = source;
        this.tickerId = tickerId;
        this.timeframe = timeframe;
        this.limit = limit;
        this.sDate = sDate;
        this.eDate = eDate;
        __publicField$7(this, "data", []);
        //#region [Pine Script built-in variables]
        __publicField$7(this, "open", []);
        __publicField$7(this, "high", []);
        __publicField$7(this, "low", []);
        __publicField$7(this, "close", []);
        __publicField$7(this, "volume", []);
        __publicField$7(this, "hl2", []);
        __publicField$7(this, "hlc3", []);
        __publicField$7(this, "ohlc4", []);
        __publicField$7(this, "openTime", []);
        __publicField$7(this, "closeTime", []);
        //#endregion
        //#region run context
        __publicField$7(this, "_periods");
        //#endregion
        //public fn: Function;
        __publicField$7(this, "_readyPromise", null);
        __publicField$7(this, "_ready", false);
        this._readyPromise = new Promise((resolve) => {
          this.loadMarketData(source, tickerId, timeframe, limit, sDate, eDate).then((data) => {
            const marketData = data.reverse();
            this._periods = marketData.length;
            this.data = marketData;
            const _open = marketData.map((d) => d.open);
            const _close = marketData.map((d) => d.close);
            const _high = marketData.map((d) => d.high);
            const _low = marketData.map((d) => d.low);
            const _volume = marketData.map((d) => d.volume);
            const _hlc3 = marketData.map((d) => (d.high + d.low + d.close) / 3);
            const _hl2 = marketData.map((d) => (d.high + d.low) / 2);
            const _ohlc4 = marketData.map((d) => (d.high + d.low + d.open + d.close) / 4);
            const _openTime = marketData.map((d) => d.openTime);
            const _closeTime = marketData.map((d) => d.closeTime);
            this.open = _open;
            this.close = _close;
            this.high = _high;
            this.low = _low;
            this.volume = _volume;
            this.hl2 = _hl2;
            this.hlc3 = _hlc3;
            this.ohlc4 = _ohlc4;
            this.openTime = _openTime;
            this.closeTime = _closeTime;
            this._ready = true;
            resolve(true);
          });
        });
      }
      get periods() {
        return this._periods;
      }
      async loadMarketData(source, tickerId, timeframe, limit, sDate, eDate) {
        if (Array.isArray(source)) {
          return source;
        } else {
          return source.getMarketData(tickerId, timeframe, limit, sDate, eDate);
        }
      }
      async ready() {
        if (this._ready) return true;
        if (!this._readyPromise) throw new Error("PineTS is not ready");
        return this._readyPromise;
      }
      async run(pineTSCode, n, useTACache) {
        await this.ready();
        if (!n) n = this._periods;
        const context = new Context({
          marketData: this.data,
          source: this.source,
          tickerId: this.tickerId,
          timeframe: this.timeframe,
          limit: this.limit,
          sDate: this.sDate,
          eDate: this.eDate
        });
        context.pineTSCode = pineTSCode;
        context.useTACache = useTACache;
        const transformer = transpile.bind(this);
        let transpiledFn = transformer(pineTSCode);
        const contextVarNames = ["const", "var", "let", "params"];
        for (let i = this._periods - n, idx = n - 1; i < this._periods; i++, idx--) {
          context.idx = i;
          context.data.close = this.close.slice(idx);
          context.data.open = this.open.slice(idx);
          context.data.high = this.high.slice(idx);
          context.data.low = this.low.slice(idx);
          context.data.volume = this.volume.slice(idx);
          context.data.hl2 = this.hl2.slice(idx);
          context.data.hlc3 = this.hlc3.slice(idx);
          context.data.ohlc4 = this.ohlc4.slice(idx);
          context.data.openTime = this.openTime.slice(idx);
          context.data.closeTime = this.closeTime.slice(idx);
          const result = await transpiledFn(context);
          if (typeof result === "object") {
            if (typeof context.result !== "object") {
              context.result = {};
            }
            for (let key in result) {
              if (context.result[key] === void 0) {
                context.result[key] = [];
              }
              const val = Array.isArray(result[key]) ? result[key][0] : result[key];
              context.result[key].push(val);
            }
          } else {
            if (!Array.isArray(context.result)) {
              context.result = [];
            }
            context.result.push(result);
          }
          for (let ctxVarName of contextVarNames) {
            for (let key in context[ctxVarName]) {
              if (Array.isArray(context[ctxVarName][key])) {
                const val = context[ctxVarName][key][0];
                context[ctxVarName][key].unshift(val);
              }
            }
          }
        }
        return context;
      }
    }

    var __defProp$6 = Object.defineProperty;
    var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$6 = (obj, key, value) => __defNormalProp$6(obj, key + "" , value);
    class Core {
      constructor(context) {
        this.context = context;
        __publicField$6(this, "color", {
          param: (source, index = 0) => {
            if (Array.isArray(source)) {
              return source[index];
            }
            return source;
          },
          rgb: (r, g, b, a) => a ? `rgba(${r}, ${g}, ${b}, ${a})` : `rgb(${r}, ${g}, ${b})`,
          new: (color, a) => {
            if (color && color.startsWith("#")) {
              const hex = color.slice(1);
              const r = parseInt(hex.slice(0, 2), 16);
              const g = parseInt(hex.slice(2, 4), 16);
              const b = parseInt(hex.slice(4, 6), 16);
              return a ? `rgba(${r}, ${g}, ${b}, ${a})` : `rgb(${r}, ${g}, ${b})`;
            }
            return a ? `rgba(${color}, ${a})` : color;
          },
          white: "white",
          lime: "lime",
          green: "green",
          red: "red",
          maroon: "maroon",
          black: "black",
          gray: "gray",
          blue: "blue"
        });
      }
      extractPlotOptions(options) {
        const _options = {};
        for (let key in options) {
          if (Array.isArray(options[key])) {
            _options[key] = options[key][0];
          } else {
            _options[key] = options[key];
          }
        }
        return _options;
      }
      indicator(title, shorttitle, options) {
      }
      //in the current implementation, plot functions are only used to collect data for the plots array and map it to the market data
      plotchar(series, title, options) {
        if (!this.context.plots[title]) {
          this.context.plots[title] = { data: [], options: this.extractPlotOptions(options), title };
        }
        this.context.plots[title].data.push({
          time: this.context.marketData[this.context.marketData.length - this.context.idx - 1].openTime,
          value: series[0],
          options: { ...this.extractPlotOptions(options), style: "char" }
        });
      }
      plot(series, title, options) {
        if (!this.context.plots[title]) {
          this.context.plots[title] = { data: [], options: this.extractPlotOptions(options), title };
        }
        this.context.plots[title].data.push({
          time: this.context.marketData[this.context.marketData.length - this.context.idx - 1].openTime,
          value: series[0],
          options: this.extractPlotOptions(options)
        });
      }
      na(series) {
        return Array.isArray(series) ? isNaN(series[0]) : isNaN(series);
      }
      nz(series, replacement = 0) {
        const val = Array.isArray(series) ? series[0] : series;
        const rep = Array.isArray(series) ? replacement[0] : replacement;
        return isNaN(val) ? rep : val;
      }
    }

    class Input {
      constructor(context) {
        this.context = context;
      }
      param(source, index = 0) {
        if (Array.isArray(source)) {
          return [source[index]];
        }
        return [source];
      }
      any(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      int(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      float(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      bool(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      string(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      timeframe(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      time(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      price(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      session(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      source(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      symbol(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      text_area(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      enum(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      color(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
    }

    var __defProp$5 = Object.defineProperty;
    var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$5 = (obj, key, value) => __defNormalProp$5(obj, key + "" , value);
    class PineMath {
      constructor(context) {
        this.context = context;
        __publicField$5(this, "_cache", {});
      }
      param(source, index, name) {
        if (!this.context.params[name]) this.context.params[name] = [];
        if (Array.isArray(source)) {
          if (index) {
            this.context.params[name] = source.slice(index);
            this.context.params[name].length = source.length;
            return this.context.params[name];
          }
          this.context.params[name] = source.slice(0);
          return this.context.params[name];
        } else {
          this.context.params[name][0] = source;
          return this.context.params[name];
        }
      }
      abs(source) {
        return Math.abs(source[0]);
      }
      pow(source, power) {
        return Math.pow(source[0], power[0]);
      }
      sqrt(source) {
        return Math.sqrt(source[0]);
      }
      log(source) {
        return Math.log(source[0]);
      }
      ln(source) {
        return Math.log(source[0]);
      }
      exp(source) {
        return Math.exp(source[0]);
      }
      floor(source) {
        return Math.floor(source[0]);
      }
      ceil(source) {
        return Math.ceil(source[0]);
      }
      round(source) {
        return Math.round(source[0]);
      }
      random() {
        return Math.random();
      }
      max(...source) {
        const arg = source.map((e) => Array.isArray(e) ? e[0] : e);
        return Math.max(...arg);
      }
      min(...source) {
        const arg = source.map((e) => Array.isArray(e) ? e[0] : e);
        return Math.min(...arg);
      }
      //sum of last n values
      sum(source, length) {
        const len = Array.isArray(length) ? length[0] : length;
        if (Array.isArray(source)) {
          return source.slice(0, len).reduce((a, b) => a + b, 0);
        }
        return source;
      }
      sin(source) {
        return Math.sin(source[0]);
      }
      cos(source) {
        return Math.cos(source[0]);
      }
      tan(source) {
        return Math.tan(source[0]);
      }
      acos(source) {
        return Math.acos(source[0]);
      }
      asin(source) {
        return Math.asin(source[0]);
      }
      atan(source) {
        return Math.atan(source[0]);
      }
      avg(...sources) {
        const args = sources.map((e) => Array.isArray(e) ? e[0] : e);
        return args.reduce((a, b) => {
          const aVal = Array.isArray(a) ? a[0] : a;
          const bVal = Array.isArray(b) ? b[0] : b;
          return aVal + bVal;
        }, 0) / args.length;
      }
    }

    var __defProp$4 = Object.defineProperty;
    var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$4 = (obj, key, value) => __defNormalProp$4(obj, key + "" , value);
    const TIMEFRAMES = ["1", "3", "5", "15", "30", "45", "60", "120", "180", "240", "D", "W", "M"];
    class PineRequest {
      constructor(context) {
        this.context = context;
        __publicField$4(this, "_cache", {});
      }
      param(source, index, name) {
        if (!this.context.params[name]) this.context.params[name] = [];
        if (Array.isArray(source)) {
          if (index) {
            this.context.params[name] = source.slice(index);
          } else {
            this.context.params[name] = source.slice(0);
          }
          return [source[index], name];
        } else {
          this.context.params[name][0] = source;
          return [source, name];
        }
      }
      async security(symbol, timeframe, expression, gaps = false, lookahead = false, ignore_invalid_symbol = false, currency = null, calc_bars_count = null) {
        const _symbol = symbol[0];
        const _timeframe = timeframe[0];
        const _expression = expression[0];
        const _expression_name = expression[1];
        const ctxTimeframeIdx = TIMEFRAMES.indexOf(this.context.timeframe);
        const reqTimeframeIdx = TIMEFRAMES.indexOf(_timeframe);
        if (ctxTimeframeIdx == -1 || reqTimeframeIdx == -1) {
          throw new Error("Invalid timeframe");
        }
        if (ctxTimeframeIdx > reqTimeframeIdx) {
          throw new Error("Only higher timeframes are supported for now");
        }
        if (ctxTimeframeIdx === reqTimeframeIdx) {
          return _expression;
        }
        const myOpenTime = this.context.data.openTime[0];
        const myCloseTime = this.context.data.closeTime[0];
        if (this.context.cache[_expression_name]) {
          const secContext2 = this.context.cache[_expression_name];
          const secContextIdx2 = this._findSecContextIdx(myOpenTime, myCloseTime, secContext2.data.openTime, secContext2.data.closeTime, lookahead);
          return secContextIdx2 == -1 ? NaN : secContext2.params[_expression_name][secContextIdx2];
        }
        const pineTS = new PineTS(this.context.source, _symbol, _timeframe, this.context.limit || 1e3, this.context.sDate, this.context.eDate);
        const secContext = await pineTS.run(this.context.pineTSCode);
        this.context.cache[_expression_name] = secContext;
        const secContextIdx = this._findSecContextIdx(myOpenTime, myCloseTime, secContext.data.openTime, secContext.data.closeTime, lookahead);
        return secContextIdx == -1 ? NaN : secContext.params[_expression_name][secContextIdx];
      }
      _findSecContextIdx(myOpenTime, myCloseTime, openTime, closeTime, lookahead = false) {
        for (let i = 0; i < openTime.length; i++) {
          if (openTime[i] <= myOpenTime && myCloseTime <= closeTime[i]) {
            return i + (lookahead ? 1 : 2);
          }
        }
        return -1;
      }
    }

    class TechnicalAnalysis {
      constructor(context) {
        this.context = context;
      }
      get tr() {
        const val = this.context.math.max(
          this.context.data.high[0] - this.context.data.low[0],
          this.context.math.abs(this.context.data.high[0] - this.context.data.close[1]),
          this.context.math.abs(this.context.data.low[0] - this.context.data.close[1])
        );
        return val;
      }
      param(source, index, name) {
        if (!this.context.params[name]) this.context.params[name] = [];
        if (Array.isArray(source)) {
          if (index) {
            this.context.params[name] = source.slice(index);
            this.context.params[name].length = source.length;
            return this.context.params[name];
          }
          this.context.params[name] = source.slice(0);
          return this.context.params[name];
        } else {
          this.context.params[name][0] = source;
          return this.context.params[name];
        }
      }
      ema(source, _period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const result = ema(source.slice(0).reverse(), period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      sma(source, _period, _cacheId) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const reversedSource = source.slice(0).reverse();
        if (this.context.useTACache && _cacheId) {
          if (!this.context.cache[_cacheId]) {
            this.context.cache[_cacheId] = {};
          }
          const cacheObj = this.context.cache[_cacheId];
          if (cacheObj) {
            const result2 = sma_cache(reversedSource, period, cacheObj);
            const idx2 = this.context.idx;
            return this.context.precision(result2[idx2]);
          }
        }
        const result = sma(reversedSource, period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      vwma(source, _period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const volume = this.context.data.volume;
        const result = vwma(source.slice(0).reverse(), volume.slice(0).reverse(), period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      wma(source, _period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const result = wma(source.slice(0).reverse(), period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      hma(source, _period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const result = hma(source.slice(0).reverse(), period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      rma(source, _period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const result = rma(source.slice(0).reverse(), period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      change(source, _length = 1) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = change$1(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      rsi(source, _period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const result = rsi(source.slice(0).reverse(), period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      atr(_period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const high = this.context.data.high.slice().reverse();
        const low = this.context.data.low.slice().reverse();
        const close = this.context.data.close.slice().reverse();
        const result = atr(high, low, close, period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      mom(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = mom(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      roc(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = roc(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      dev(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = dev(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      variance(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = variance$1(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      highest(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = highest(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      lowest(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = lowest(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      median(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = median$1(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      stdev(source, _length, _bias = true) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const bias = Array.isArray(_bias) ? _bias[0] : _bias;
        const result = stdev(source.slice(0).reverse(), length, bias);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      linreg(source, _length, _offset) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const offset = Array.isArray(_offset) ? _offset[0] : _offset;
        const result = linreg(source.slice(0).reverse(), length, offset);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      supertrend(_factor, _atrPeriod) {
        const factor = Array.isArray(_factor) ? _factor[0] : _factor;
        const atrPeriod = Array.isArray(_atrPeriod) ? _atrPeriod[0] : _atrPeriod;
        const high = this.context.data.high.slice().reverse();
        const low = this.context.data.low.slice().reverse();
        const close = this.context.data.close.slice().reverse();
        const [supertrend, direction] = calculateSupertrend(high, low, close, factor, atrPeriod);
        const idx = this.context.idx;
        return [[this.context.precision(supertrend[idx]), direction[idx]]];
      }
    }
    function atr(high, low, close, period) {
      const tr = new Array(high.length);
      tr[0] = high[0] - low[0];
      for (let i = 1; i < high.length; i++) {
        const hl = high[i] - low[i];
        const hc = Math.abs(high[i] - close[i - 1]);
        const lc = Math.abs(low[i] - close[i - 1]);
        tr[i] = Math.max(hl, hc, lc);
      }
      const atr2 = new Array(high.length).fill(NaN);
      let sum = 0;
      for (let i = 0; i < period; i++) {
        sum += tr[i];
      }
      atr2[period - 1] = sum / period;
      for (let i = period; i < tr.length; i++) {
        atr2[i] = (atr2[i - 1] * (period - 1) + tr[i]) / period;
      }
      return atr2;
    }
    function ema(source, period) {
      const result = new Array(source.length).fill(NaN);
      const alpha = 2 / (period + 1);
      let sum = 0;
      for (let i = 0; i < period; i++) {
        sum += source[i] || 0;
      }
      result[period - 1] = sum / period;
      for (let i = period; i < source.length; i++) {
        result[i] = source[i] * alpha + result[i - 1] * (1 - alpha);
      }
      return result;
    }
    function rsi(source, period) {
      const result = new Array(source.length).fill(NaN);
      const gains = new Array(source.length).fill(0);
      const losses = new Array(source.length).fill(0);
      for (let i = 1; i < source.length; i++) {
        const diff = source[i] - source[i - 1];
        gains[i] = diff > 0 ? diff : 0;
        losses[i] = diff < 0 ? -diff : 0;
      }
      let avgGain = 0;
      let avgLoss = 0;
      for (let i = 1; i <= period; i++) {
        avgGain += gains[i];
        avgLoss += losses[i];
      }
      avgGain /= period;
      avgLoss /= period;
      result[period] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);
      for (let i = period + 1; i < source.length; i++) {
        avgGain = (avgGain * (period - 1) + gains[i]) / period;
        avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
        result[i] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);
      }
      return result;
    }
    function rma(source, period) {
      const result = new Array(source.length).fill(NaN);
      const alpha = 1 / period;
      let sum = 0;
      for (let i = 0; i < period; i++) {
        sum += source[i] || 0;
      }
      result[period - 1] = sum / period;
      for (let i = period; i < source.length; i++) {
        const currentValue = source[i] || 0;
        result[i] = currentValue * alpha + result[i - 1] * (1 - alpha);
      }
      return result;
    }
    function sma_cache(source, period, cacheObj) {
      const result = cacheObj.previousResult || new Array(source.length).fill(NaN);
      const lastProcessedIndex = cacheObj.lastProcessedIndex || -1;
      let previousSum = cacheObj.previousSum || 0;
      if (lastProcessedIndex === -1 || source.length !== lastProcessedIndex + 1) {
        previousSum = 0;
        for (let i = 0; i < period; i++) {
          previousSum += source[i] || 0;
        }
        result[period - 1] = previousSum / period;
        for (let i = 0; i < period - 1; i++) {
          result[i] = NaN;
        }
        for (let i = period; i < source.length; i++) {
          previousSum = previousSum - (source[i - period] || 0) + (source[i] || 0);
          result[i] = previousSum / period;
        }
      } else if (source.length === lastProcessedIndex + 2) {
        const newIndex = source.length - 1;
        previousSum = previousSum - (source[newIndex - period] || 0) + (source[newIndex] || 0);
        result[newIndex] = previousSum / period;
      } else {
        return sma(source, period);
      }
      cacheObj.previousSum = previousSum;
      cacheObj.lastProcessedIndex = source.length - 1;
      cacheObj.previousResult = result;
      return result;
    }
    function sma(source, period) {
      const result = new Array(source.length).fill(NaN);
      for (let i = period - 1; i < source.length; i++) {
        let sum = 0;
        for (let j = 0; j < period; j++) {
          sum += source[i - j] || 0;
        }
        result[i] = sum / period;
      }
      return result;
    }
    function vwma(source, volume, period) {
      const result = new Array(source.length).fill(NaN);
      for (let i = period - 1; i < source.length; i++) {
        let sumVol = 0;
        let sumVolPrice = 0;
        for (let j = 0; j < period; j++) {
          sumVol += volume[i - j];
          sumVolPrice += source[i - j] * volume[i - j];
        }
        result[i] = sumVolPrice / sumVol;
      }
      return result;
    }
    function hma(source, period) {
      const halfPeriod = Math.floor(period / 2);
      const wma1 = wma(source, halfPeriod);
      const wma2 = wma(source, period);
      const rawHma = wma1.map((value, index) => 2 * value - wma2[index]);
      const sqrtPeriod = Math.floor(Math.sqrt(period));
      const result = wma(rawHma, sqrtPeriod);
      return result;
    }
    function wma(source, period) {
      const result = new Array(source.length);
      for (let i = period - 1; i < source.length; i++) {
        let numerator = 0;
        let denominator = 0;
        for (let j = 0; j < period; j++) {
          numerator += source[i - j] * (period - j);
          denominator += period - j;
        }
        result[i] = numerator / denominator;
      }
      for (let i = 0; i < period - 1; i++) {
        result[i] = NaN;
      }
      return result;
    }
    function change$1(source, length = 1) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length; i < source.length; i++) {
        result[i] = source[i] - source[i - length];
      }
      return result;
    }
    function mom(source, length) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length; i < source.length; i++) {
        result[i] = source[i] - source[i - length];
      }
      return result;
    }
    function roc(source, length) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length; i < source.length; i++) {
        result[i] = (source[i] - source[i - length]) / source[i - length] * 100;
      }
      return result;
    }
    function dev(source, length) {
      const result = new Array(source.length).fill(NaN);
      const smaValues = sma(source, length);
      for (let i = length - 1; i < source.length; i++) {
        let sumDeviation = 0;
        for (let j = 0; j < length; j++) {
          sumDeviation += Math.abs(source[i - j] - smaValues[i]);
        }
        result[i] = sumDeviation / length;
      }
      return result;
    }
    function variance$1(source, length) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length - 1; i < source.length; i++) {
        let sum = 0;
        let sumSquares = 0;
        for (let j = 0; j < length; j++) {
          sum += source[i - j];
          sumSquares += source[i - j] * source[i - j];
        }
        const mean = sum / length;
        result[i] = sumSquares / length - mean * mean;
      }
      return result;
    }
    function highest(source, length) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length - 1; i < source.length; i++) {
        let max = -Infinity;
        for (let j = 0; j < length; j++) {
          const value = source[i - j];
          if (isNaN(value)) {
            max = max === -Infinity ? NaN : max;
          } else {
            max = Math.max(max, value);
          }
        }
        result[i] = max;
      }
      return result;
    }
    function lowest(source, length) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length - 1; i < source.length; i++) {
        let min = Infinity;
        for (let j = 0; j < length; j++) {
          const value = source[i - j];
          if (isNaN(value) || value === void 0) {
            min = min === Infinity ? NaN : min;
          } else {
            min = Math.min(min, value);
          }
        }
        result[i] = min;
      }
      return result;
    }
    function median$1(source, length) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length - 1; i < source.length; i++) {
        const window = source.slice(i - length + 1, i + 1);
        const sorted = window.slice().sort((a, b) => a - b);
        const mid = Math.floor(length / 2);
        result[i] = length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
      }
      return result;
    }
    function stdev(source, length, biased = true) {
      const result = new Array(source.length).fill(NaN);
      const smaValues = sma(source, length);
      for (let i = length - 1; i < source.length; i++) {
        let sum = 0;
        for (let j = 0; j < length; j++) {
          sum += Math.pow(source[i - j] - smaValues[i], 2);
        }
        const divisor = biased ? length : length - 1;
        result[i] = Math.sqrt(sum / divisor);
      }
      return result;
    }
    function linreg(source, length, offset) {
      const size = source.length;
      const output = new Array(size).fill(NaN);
      for (let i = length - 1; i < size; i++) {
        let sumX = 0;
        let sumY = 0;
        let sumXY = 0;
        let sumXX = 0;
        const n = length;
        for (let j = 0; j < length; j++) {
          const x = j;
          const y = source[i - length + 1 + j];
          sumX += x;
          sumY += y;
          sumXY += x * y;
          sumXX += x * x;
        }
        const denominator = n * sumXX - sumX * sumX;
        if (denominator === 0) {
          output[i] = NaN;
          continue;
        }
        const slope = (n * sumXY - sumX * sumY) / denominator;
        const intercept = (sumY - slope * sumX) / n;
        const linRegValue = intercept + slope * (length - 1 - offset);
        output[i] = linRegValue;
      }
      return output;
    }
    function calculateSupertrend(high, low, close, factor, atrPeriod) {
      const length = high.length;
      const supertrend = new Array(length).fill(NaN);
      const direction = new Array(length).fill(0);
      const atrValues = atr(high, low, close, atrPeriod);
      const upperBand = new Array(length).fill(NaN);
      const lowerBand = new Array(length).fill(NaN);
      for (let i = 0; i < length; i++) {
        const hl2 = (high[i] + low[i]) / 2;
        const atrValue = atrValues[i];
        if (!isNaN(atrValue)) {
          upperBand[i] = hl2 + factor * atrValue;
          lowerBand[i] = hl2 - factor * atrValue;
        }
      }
      let prevUpperBand = upperBand[atrPeriod];
      let prevLowerBand = lowerBand[atrPeriod];
      let prevSupertrend = close[atrPeriod] <= prevUpperBand ? prevUpperBand : prevLowerBand;
      let prevDirection = close[atrPeriod] <= prevUpperBand ? -1 : 1;
      supertrend[atrPeriod] = prevSupertrend;
      direction[atrPeriod] = prevDirection;
      for (let i = atrPeriod + 1; i < length; i++) {
        let currentUpperBand = upperBand[i];
        if (currentUpperBand < prevUpperBand || close[i - 1] > prevUpperBand) {
          upperBand[i] = currentUpperBand;
        } else {
          upperBand[i] = prevUpperBand;
        }
        let currentLowerBand = lowerBand[i];
        if (currentLowerBand > prevLowerBand || close[i - 1] < prevLowerBand) {
          lowerBand[i] = currentLowerBand;
        } else {
          lowerBand[i] = prevLowerBand;
        }
        if (prevSupertrend === prevUpperBand) {
          if (close[i] > upperBand[i]) {
            direction[i] = 1;
            supertrend[i] = lowerBand[i];
          } else {
            direction[i] = -1;
            supertrend[i] = upperBand[i];
          }
        } else {
          if (close[i] < lowerBand[i]) {
            direction[i] = -1;
            supertrend[i] = upperBand[i];
          } else {
            direction[i] = 1;
            supertrend[i] = lowerBand[i];
          }
        }
        prevUpperBand = upperBand[i];
        prevLowerBand = lowerBand[i];
        prevSupertrend = supertrend[i];
      }
      return [supertrend, direction];
    }

    var __defProp$3 = Object.defineProperty;
    var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$3 = (obj, key, value) => __defNormalProp$3(obj, key + "" , value);
    class PineArrayObject {
      constructor(array) {
        this.array = array;
      }
    }
    class PineArray {
      constructor(context) {
        this.context = context;
        __publicField$3(this, "_cache", {});
      }
      param(source, index = 0) {
        if (Array.isArray(source)) {
          return source[index];
        }
        return source;
      }
      /**
       * This function simulates PineScript's array.get() function
       * @param id - the array object to get the value from
       * @param index - the index of the value to get
       * @returns the value at the given index
       */
      get(id, index) {
        return id.array[index];
      }
      set(id, index, value) {
        id.array[index] = value;
      }
      push(id, value) {
        id.array.push(value);
      }
      // Basic statistics
      sum(id) {
        return id.array.reduce((a, b) => a + (isNaN(b) ? 0 : b), 0);
      }
      avg(id) {
        return this.sum(id) / id.array.length;
      }
      min(id, nth = 0) {
        const sorted = [...id.array].sort((a, b) => a - b);
        return sorted[nth] ?? this.context.NA;
      }
      max(id, nth = 0) {
        const sorted = [...id.array].sort((a, b) => b - a);
        return sorted[nth] ?? this.context.NA;
      }
      size(id) {
        return id.array.length;
      }
      // Array creation
      new_bool(size, initial_value = false) {
        return new PineArrayObject(Array(size).fill(initial_value));
      }
      new_float(size, initial_value = NaN) {
        return new PineArrayObject(Array(size).fill(initial_value));
      }
      new_int(size, initial_value = 0) {
        return new PineArrayObject(Array(size).fill(Math.round(initial_value)));
      }
      new_string(size, initial_value = "") {
        return new PineArrayObject(Array(size).fill(initial_value));
      }
      new(size, initial_value) {
        return new PineArrayObject(Array(size).fill(initial_value));
      }
      // Array operations
      slice(id, start, end) {
        const adjustedEnd = end !== void 0 ? end + 1 : void 0;
        return new PineArrayObject(id.array.slice(start, adjustedEnd));
      }
      reverse(id) {
        id.array.reverse();
      }
      includes(id, value) {
        return id.array.includes(value);
      }
      indexof(id, value) {
        return id.array.indexOf(value);
      }
      lastindexof(id, value) {
        return id.array.lastIndexOf(value);
      }
      // More complex functions
      stdev(id, biased = true) {
        const mean = this.avg(id);
        const deviations = id.array.map((x) => Math.pow(x - mean, 2));
        const divisor = biased ? id.array.length : id.array.length - 1;
        return Math.sqrt(this.sum(new PineArrayObject(deviations)) / divisor);
      }
      variance(id, biased = true) {
        const mean = this.avg(id);
        const deviations = id.array.map((x) => Math.pow(x - mean, 2));
        const divisor = biased ? id.array.length : id.array.length - 1;
        return this.sum(new PineArrayObject(deviations)) / divisor;
      }
      covariance(arr1, arr2, biased = true) {
        if (arr1.array.length !== arr2.array.length || arr1.array.length < 2) return NaN;
        const divisor = biased ? arr1.array.length : arr1.array.length - 1;
        const mean1 = this.avg(arr1);
        const mean2 = this.avg(arr2);
        let sum = 0;
        for (let i = 0; i < arr1.array.length; i++) {
          sum += (arr1.array[i] - mean1) * (arr2.array[i] - mean2);
        }
        return sum / divisor;
      }
      // Additional utility methods
      first(id) {
        return id.array.length > 0 ? id.array[0] : this.context.NA;
      }
      last(id) {
        return id.array.length > 0 ? id.array[id.array.length - 1] : this.context.NA;
      }
      clear(id) {
        id.array.length = 0;
      }
      join(id, separator = ",") {
        return id.array.join(separator);
      }
      /** Array Manipulation Functions */
      abs(id) {
        return new PineArrayObject(id.array.map((val) => Math.abs(val)));
      }
      concat(id, other) {
        id.array.push(...other.array);
        return id;
      }
      copy(id) {
        return new PineArrayObject([...id.array]);
      }
      every(id, callback) {
        return id.array.every(callback);
      }
      fill(id, value, start = 0, end) {
        const length = id.array.length;
        const adjustedEnd = end !== void 0 ? Math.min(end, length) : length;
        for (let i = start; i < adjustedEnd; i++) {
          id.array[i] = value;
        }
      }
      from(source) {
        return new PineArrayObject([...source]);
      }
      insert(id, index, value) {
        id.array.splice(index, 0, value);
      }
      pop(id) {
        return id.array.pop();
      }
      range(id) {
        return this.max(id) - this.min(id);
      }
      remove(id, index) {
        if (index >= 0 && index < id.array.length) {
          return id.array.splice(index, 1)[0];
        }
        return this.context.NA;
      }
      shift(id) {
        return id.array.shift();
      }
      sort(id, order = "asc") {
        id.array.sort((a, b) => order === "asc" ? a - b : b - a);
      }
      sort_indices(id, comparator) {
        const indices = id.array.map((_, index) => index);
        indices.sort((a, b) => {
          const valA = id.array[a];
          const valB = id.array[b];
          return comparator ? comparator(valA, valB) : valA - valB;
        });
        return new PineArrayObject(indices);
      }
      standardize(id) {
        const mean = this.avg(id);
        const stdev = this.stdev(id);
        if (stdev === 0) {
          return new PineArrayObject(id.array.map(() => 0));
        }
        return new PineArrayObject(id.array.map((x) => (x - mean) / stdev));
      }
      unshift(id, value) {
        id.array.unshift(value);
      }
      some(id, callback) {
        return id.array.some(callback);
      }
    }

    var __defProp$2 = Object.defineProperty;
    var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
    class Context {
      constructor({
        marketData,
        source,
        tickerId,
        timeframe,
        limit,
        sDate,
        eDate
      }) {
        __publicField$2(this, "data", {
          open: [],
          high: [],
          low: [],
          close: [],
          volume: [],
          hl2: [],
          hlc3: [],
          ohlc4: []
        });
        __publicField$2(this, "cache", {});
        __publicField$2(this, "useTACache", false);
        __publicField$2(this, "NA", NaN);
        __publicField$2(this, "math");
        __publicField$2(this, "ta");
        __publicField$2(this, "input");
        __publicField$2(this, "request");
        __publicField$2(this, "array");
        __publicField$2(this, "core");
        __publicField$2(this, "lang");
        __publicField$2(this, "idx", 0);
        __publicField$2(this, "params", {});
        __publicField$2(this, "const", {});
        __publicField$2(this, "var", {});
        __publicField$2(this, "let", {});
        __publicField$2(this, "result");
        __publicField$2(this, "plots", {});
        __publicField$2(this, "marketData");
        __publicField$2(this, "source");
        __publicField$2(this, "tickerId");
        __publicField$2(this, "timeframe", "");
        __publicField$2(this, "limit");
        __publicField$2(this, "sDate");
        __publicField$2(this, "eDate");
        __publicField$2(this, "pineTSCode");
        this.marketData = marketData;
        this.source = source;
        this.tickerId = tickerId;
        this.timeframe = timeframe;
        this.limit = limit;
        this.sDate = sDate;
        this.eDate = eDate;
        this.math = new PineMath(this);
        this.ta = new TechnicalAnalysis(this);
        this.input = new Input(this);
        this.request = new PineRequest(this);
        this.array = new PineArray(this);
        const core = new Core(this);
        this.core = {
          plotchar: core.plotchar.bind(core),
          na: core.na.bind(core),
          color: core.color,
          plot: core.plot.bind(core),
          nz: core.nz.bind(core)
        };
      }
      //#region [Runtime functions] ===========================
      /**
       * this function is used to initialize the target variable with the source array
       * this array will represent a time series and its values will be shifted at runtime in order to mimic Pine script behavior
       * @param trg - the target variable name : used internally to maintain the series in the execution context
       * @param src - the source data, can be an array or a single value
       * @param idx - the index of the source array, used to get a sub-series of the source data
       * @returns the target array
       */
      init(trg, src, idx = 0) {
        if (!trg) {
          if (Array.isArray(src)) {
            trg = [this.precision(src[src.length - this.idx - 1 + idx])];
          } else {
            trg = [this.precision(src)];
          }
        } else {
          if (!Array.isArray(src) || Array.isArray(src[0])) {
            trg[0] = Array.isArray(src?.[0]) ? src[0] : this.precision(src);
          } else {
            trg[0] = this.precision(src[src.length - this.idx - 1 + idx]);
          }
        }
        return trg;
      }
      /**
           * this function is used to set the floating point precision of a number
           * by default it is set to 10 decimals which is the same as pine script
           * @param n - the number to be precision
           * @param decimals - the number of decimals to precision to
      
           * @returns the precision number
           */
      precision(n, decimals = 10) {
        if (typeof n !== "number" || isNaN(n)) return n;
        return Number(n.toFixed(decimals));
      }
      /**
       * This function is used to apply special transformation to internal PineTS parameters and handle them as time-series
       * @param source - the source data, can be an array or a single value
       * @param index - the index of the source array, used to get a sub-series of the source data
       * @param name - the name of the parameter, used as a unique identifier in the current execution context, this allows us to properly handle the param as a series
       * @returns the current value of the param
       */
      param(source, index, name) {
        if (typeof source === "string") return source;
        if (!Array.isArray(source) && typeof source === "object") return source;
        if (!this.params[name]) this.params[name] = [];
        if (Array.isArray(source)) {
          if (index) {
            this.params[name] = source.slice(index);
            this.params[name].length = source.length;
            return this.params[name];
          }
          this.params[name] = source.slice(0);
          return this.params[name];
        } else {
          this.params[name][0] = source;
          return this.params[name];
        }
      }
      //#endregion
    }

    var __defProp$1 = Object.defineProperty;
    var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
    const BINANCE_API_URL = "https://api.binance.com/api/v3";
    const timeframe_to_binance = {
      "1": "1m",
      // 1 minute
      "3": "3m",
      // 3 minutes
      "5": "5m",
      // 5 minutes
      "15": "15m",
      // 15 minutes
      "30": "30m",
      // 30 minutes
      "45": null,
      // 45 minutes (not directly supported by Binance, needs custom handling)
      "60": "1h",
      // 1 hour
      "120": "2h",
      // 2 hours
      "180": null,
      // 3 hours (not directly supported by Binance, needs custom handling)
      "240": "4h",
      // 4 hours
      "4H": "4h",
      // 4 hours
      "1D": "1d",
      // 1 day
      D: "1d",
      // 1 day
      "1W": "1w",
      // 1 week
      W: "1w",
      // 1 week
      "1M": "1M",
      // 1 month
      M: "1M"
      // 1 month
    };
    class CacheManager$1 {
      constructor(cacheDuration = 5 * 60 * 1e3) {
        __publicField$1(this, "cache");
        __publicField$1(this, "cacheDuration");
        this.cache = /* @__PURE__ */ new Map();
        this.cacheDuration = cacheDuration;
      }
      generateKey(params) {
        return Object.entries(params).filter(([_, value]) => value !== void 0).map(([key, value]) => `${key}:${value}`).join("|");
      }
      get(params) {
        const key = this.generateKey(params);
        const cached = this.cache.get(key);
        if (!cached) return null;
        if (Date.now() - cached.timestamp > this.cacheDuration) {
          this.cache.delete(key);
          return null;
        }
        return cached.data;
      }
      set(params, data) {
        const key = this.generateKey(params);
        this.cache.set(key, {
          data,
          timestamp: Date.now()
        });
      }
      clear() {
        this.cache.clear();
      }
      // Optional: method to remove expired entries
      cleanup() {
        const now = Date.now();
        for (const [key, entry] of this.cache.entries()) {
          if (now - entry.timestamp > this.cacheDuration) {
            this.cache.delete(key);
          }
        }
      }
    }
    class BinanceProvider {
      constructor() {
        __publicField$1(this, "cacheManager");
        this.cacheManager = new CacheManager$1(5 * 60 * 1e3);
      }
      async getMarketDataInterval(tickerId, timeframe, sDate, eDate) {
        try {
          const interval = timeframe_to_binance[timeframe.toUpperCase()];
          if (!interval) {
            console.error(`Unsupported timeframe: ${timeframe}`);
            return [];
          }
          const timeframeDurations = {
            "1m": 60 * 1e3,
            "3m": 3 * 60 * 1e3,
            "5m": 5 * 60 * 1e3,
            "15m": 15 * 60 * 1e3,
            "30m": 30 * 60 * 1e3,
            "1h": 60 * 60 * 1e3,
            "2h": 2 * 60 * 60 * 1e3,
            "4h": 4 * 60 * 60 * 1e3,
            "1d": 24 * 60 * 60 * 1e3,
            "1w": 7 * 24 * 60 * 60 * 1e3,
            "1M": 30 * 24 * 60 * 60 * 1e3
          };
          let allData = [];
          let currentStart = sDate;
          const endTime = eDate;
          const intervalDuration = timeframeDurations[interval];
          if (!intervalDuration) {
            console.error(`Duration not defined for interval: ${interval}`);
            return [];
          }
          while (currentStart < endTime) {
            const chunkEnd = Math.min(currentStart + 1e3 * intervalDuration, endTime);
            const data = await this.getMarketData(
              tickerId,
              timeframe,
              1e3,
              // Max allowed by Binance
              currentStart,
              chunkEnd
            );
            if (data.length === 0) break;
            allData = allData.concat(data);
            currentStart = data[data.length - 1].closeTime + 1;
            if (data.length < 1e3) break;
          }
          return allData;
        } catch (error) {
          console.error("Error in getMarketDataInterval:", error);
          return [];
        }
      }
      //TODO : allow querying more than 1000 klines
      //TODO : immplement cache
      async getMarketData(tickerId, timeframe, limit, sDate, eDate) {
        try {
          const cacheParams = { tickerId, timeframe, limit, sDate, eDate };
          const cachedData = this.cacheManager.get(cacheParams);
          if (cachedData) {
            console.log("cache hit", tickerId, timeframe, limit, sDate, eDate);
            return cachedData;
          }
          const interval = timeframe_to_binance[timeframe.toUpperCase()];
          if (!interval) {
            console.error(`Unsupported timeframe: ${timeframe}`);
            return [];
          }
          let url = `${BINANCE_API_URL}/klines?symbol=${tickerId}&interval=${interval}`;
          if (!limit && sDate && eDate) {
            return this.getMarketDataInterval(tickerId, timeframe, sDate, eDate);
          }
          if (limit) {
            url += `&limit=${limit}`;
          }
          if (sDate) {
            url += `&startTime=${sDate}`;
          }
          if (eDate) {
            url += `&endTime=${eDate}`;
          }
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const result = await response.json();
          const data = result.map((item) => {
            return {
              openTime: parseInt(item[0]),
              open: parseFloat(item[1]),
              high: parseFloat(item[2]),
              low: parseFloat(item[3]),
              close: parseFloat(item[4]),
              volume: parseFloat(item[5]),
              closeTime: parseInt(item[6]),
              quoteAssetVolume: parseFloat(item[7]),
              numberOfTrades: parseInt(item[8]),
              takerBuyBaseAssetVolume: parseFloat(item[9]),
              takerBuyQuoteAssetVolume: parseFloat(item[10]),
              ignore: item[11]
            };
          });
          this.cacheManager.set(cacheParams, data);
          return data;
        } catch (error) {
          console.error("Error in binance.klines:", error);
          return [];
        }
      }
    }

    var __defProp = Object.defineProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    class CacheManager {
      constructor(cacheDuration = 5 * 60 * 1e3) {
        __publicField(this, "cache");
        __publicField(this, "cacheDuration");
        this.cache = /* @__PURE__ */ new Map();
        this.cacheDuration = cacheDuration;
      }
      generateKey(params) {
        return Object.entries(params).filter(([_, value]) => value !== void 0).map(([key, value]) => `${key}:${value}`).join("|");
      }
      get(params) {
        const key = this.generateKey(params);
        const cached = this.cache.get(key);
        if (!cached) return null;
        if (Date.now() - cached.timestamp > this.cacheDuration) {
          this.cache.delete(key);
          return null;
        }
        return cached.data;
      }
      set(params, data) {
        const key = this.generateKey(params);
        this.cache.set(key, {
          data,
          timestamp: Date.now()
        });
      }
      clear() {
        this.cache.clear();
      }
      /**
       * Optional: Remove expired entries.
       */
      cleanup() {
        const now = Date.now();
        for (const [key, entry] of this.cache.entries()) {
          if (now - entry.timestamp > this.cacheDuration) {
            this.cache.delete(key);
          }
        }
      }
    }
    const timeframe_to_yfinance = {
      "1": "1m",
      "3": "2m",
      // Yahoo Finance doesn't support a 3-minute interval directly
      "5": "5m",
      "15": "15m",
      "30": "30m",
      "60": "1h",
      "1H": "1h",
      "1D": "1d",
      "D": "1d",
      "1W": "1wk",
      "W": "1wk",
      "1M": "1mo",
      "M": "1mo"
    };
    class YFinanceProvider {
      constructor() {
        __publicField(this, "cacheManager");
        this.cacheManager = new CacheManager(5 * 60 * 1e3);
      }
      /**
       * Retrieves market data for the given ticker and timeframe.
       *
       * If start (sDate) and end (eDate) dates are provided, they are used to limit the data;
       * otherwise, a default range (1 month) is used.
       *
       * @param tickerId - The ticker symbol (e.g., "AAPL").
       * @param timeframe - The timeframe identifier (e.g., "1", "5", "1D").
       * @param limit - Optional limit (ignored if sDate and eDate are provided).
       * @param sDate - Optional start date in milliseconds.
       * @param eDate - Optional end date in milliseconds.
       * @returns A promise that resolves to an array of market data objects.
       */
      async getMarketData(tickerId, timeframe, limit, sDate, eDate) {
        try {
          const cacheParams = { tickerId, timeframe, limit, sDate, eDate };
          const cachedData = this.cacheManager.get(cacheParams);
          if (cachedData) {
            console.log("YFinance cache hit:", tickerId, timeframe, limit, sDate, eDate);
            return cachedData;
          }
          const queryOptions = {};
          const interval = timeframe_to_yfinance[timeframe.toUpperCase()];
          if (!interval) {
            console.error(`Unsupported timeframe for YFinance: ${timeframe}`);
            return [];
          }
          queryOptions.interval = interval;
          if (sDate && eDate) {
            queryOptions.period1 = Math.floor(sDate / 1e3);
            queryOptions.period2 = Math.floor(eDate / 1e3);
          } else {
            queryOptions.range = "1mo";
          }
          const result = await yahooFinance.historical(tickerId, queryOptions);
          const data = result.map((item) => ({
            time: new Date(item.date).getTime(),
            // Convert date to milliseconds
            open: item.open,
            high: item.high,
            low: item.low,
            close: item.close,
            volume: item.volume
          }));
          this.cacheManager.set(cacheParams, data);
          return data;
        } catch (error) {
          console.error("Error in YFinanceProvider.getMarketData:", error);
          return [];
        }
      }
    }

    const Provider = {
      Binance: new BinanceProvider(),
      yFinance: new YFinanceProvider()};

    /*
     * Copyright (C) 2025 EsIstJosh
     *
     * This file is part of [lightweight-charts-python] and is licensed under the GNU AGPL v3.0.
     *
     * Note: This file imports modules that remain under the MIT license (e.g., from the original project).
     * The original MIT license text is included in the MIT_LICENSE file in the repository.
     *
     * For the full text of the GNU AGPL v3.0, see <https://www.gnu.org/licenses/agpl-3.0.html>.
     */
    /**
     * CodeEditor creates a bottom-docked pane-style Monaco Editor.
     * The pane spans the full width and can have its height adjusted via a drag handle.
     *
     * New methods executePineTS and addPineTSToChart are added so that
     * the code from the editor is compiled, run via PineTS, and the resulting plots
     * are added to the chart using a provided Handler instance.
     */
    class CodeEditor {
        container;
        header;
        editorDiv;
        resizer;
        editorInstance = null;
        closeButton;
        isResizing = false;
        startY = 0;
        startHeight = 0;
        MIN_HEIGHT = 100; // Minimum pane height in pixels
        MAX_HEIGHT = window.innerHeight - 50; // Maximum pane height
        // Store the Handler instance passed in the constructor.
        handler;
        /**
         * @param handler - The chart handler that manages the Lightweight Charts instance.
         */
        constructor(handler) {
            this.handler = handler;
            // Create the container pane with bottom docking.
            this.container = document.createElement("div");
            Object.assign(this.container.style, {
                position: "fixed",
                bottom: "0",
                left: "0",
                width: "100%",
                height: "300px", // default height
                backgroundColor: "#1e1e1e",
                borderTop: "2px solid #444",
                zIndex: "10000",
                display: "none",
                flexDirection: "column",
            });
            // Create the resizer handle.
            this.resizer = document.createElement("div");
            Object.assign(this.resizer.style, {
                height: "5px",
                width: "100%",
                backgroundColor: "#666",
                cursor: "ns-resize",
                userSelect: "none",
            });
            // Attach mouse events for resizing.
            this.resizer.addEventListener("mousedown", this.onDragStart.bind(this));
            document.addEventListener("mousemove", this.onDrag.bind(this));
            document.addEventListener("mouseup", this.onDragEnd.bind(this));
            this.container.appendChild(this.resizer);
            // Create the header.
            this.header = document.createElement("div");
            Object.assign(this.header.style, {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                padding: "10px",
                backgroundColor: "#333",
            });
            // Left container holds title and action buttons.
            const leftContainer = document.createElement("div");
            leftContainer.style.display = "flex";
            leftContainer.style.alignItems = "center";
            leftContainer.style.gap = "10px";
            const title = document.createElement("span");
            title.innerText = "Code Editor";
            title.style.color = "white";
            leftContainer.appendChild(title);
            // Actions container holds the new buttons.
            const actionsContainer = document.createElement("div");
            actionsContainer.style.display = "flex";
            actionsContainer.style.gap = "10px";
            // Execute button.
            const executeButton = document.createElement("button");
            executeButton.innerText = "Execute";
            Object.assign(executeButton.style, {
                backgroundColor: "#4caf50",
                color: "white",
                border: "none",
                padding: "5px 10px",
                cursor: "pointer",
            });
            executeButton.onclick = () => {
                // Call the integrated execute method.
                this.executePineTS();
            };
            actionsContainer.appendChild(executeButton);
            // Add to Chart button.
            const addToChartButton = document.createElement("button");
            addToChartButton.innerText = "Add to Chart";
            Object.assign(addToChartButton.style, {
                backgroundColor: "#2196f3",
                color: "white",
                border: "none",
                padding: "5px 10px",
                cursor: "pointer",
            });
            addToChartButton.onclick = () => {
                // Call the integrated add-to-chart method.
                this.addPineTSToChart();
            };
            actionsContainer.appendChild(addToChartButton);
            // Append left container (title + actions) and then the close button.
            leftContainer.appendChild(actionsContainer);
            // Create the close button.
            this.closeButton = document.createElement("button");
            this.closeButton.innerText = "Close";
            Object.assign(this.closeButton.style, {
                backgroundColor: "#ff5555",
                color: "white",
                border: "none",
                padding: "5px 10px",
                cursor: "pointer",
            });
            this.closeButton.onclick = () => this.close();
            // Append left container and close button to header.
            this.header.appendChild(leftContainer);
            this.header.appendChild(this.closeButton);
            this.container.appendChild(this.header);
            // Create the editor container.
            this.editorDiv = document.createElement("div");
            Object.assign(this.editorDiv.style, {
                flex: "1",
                height: "calc(100% - 45px)", // Subtract resizer (5px) and header (40px approx)
            });
            this.container.appendChild(this.editorDiv);
            // Append the container pane to the document body.
            document.body.appendChild(this.container);
            // Initialize Monaco Editor in the editor container.
            this.initializeMonaco();
        }
        /**
         * Initializes the Monaco Editor in the editor pane.
         */
        initializeMonaco() {
            this.editorInstance = monaco__namespace.editor.create(this.editorDiv, {
                value: "Feature not implemented yet",
                language: "typescript",
                theme: "vs-dark",
                automaticLayout: true,
            });
            console.log("Monaco Editor initialized in pane.");
        }
        /**
         * Opens (displays) the pane.
         */
        open() {
            this.container.style.display = "flex";
            // Refresh the layout after showing.
            this.editorInstance?.layout();
        }
        /**
         * Closes (hides) the pane.
         */
        close() {
            this.container.style.display = "none";
        }
        /**
         * Sets the code value in the editor.
         * @param code - The code to set in the editor.
         */
        setValue(code) {
            this.editorInstance?.setValue(code);
        }
        /**
         * Gets the current code from the editor.
         * @returns The code in the editor.
         */
        getValue() {
            return this.editorInstance?.getValue() || "";
        }
        /**
         * Executes the PineTS code from the editor.
         * It compiles the code into a function that accepts 'context', runs it via PineTS,
         * and then adds the resulting plots to the chart using the global Handler instance.
         */
        async executePineTS() {
            try {
                const code = this.getValue();
                const userCallback = new Function('context', code);
                // Create a new PineTS instance (adjust parameters as needed).
                const pineTS = new PineTS(Provider.yFinance, 'BTCUSDT', 'D', 100);
                // Run the indicator code.
                const { result, plots } = await pineTS.run(userCallback);
                console.log("PineTS execution result:", result);
                // Use the Handler passed via constructor.
                for (const plotName in plots) {
                    if (plots.hasOwnProperty(plotName)) {
                        addPlotToHandler(this.handler, plotName, plots[plotName]);
                    }
                }
            }
            catch (error) {
                console.error("Error executing PineTS code:", error);
            }
        }
        /**
         * Adds or updates the chart series using the PineTS code from the editor.
         * The logic is similar to executePineTS; you can modify it to update existing series if desired.
         */
        async addPineTSToChart() {
            try {
                const code = this.getValue();
                const userCallback = new Function('context', code);
                const pineTS = new PineTS(Provider.yFinance, 'BTCUSDT', 'D', 100);
                const { result, plots } = await pineTS.run(userCallback);
                console.log("PineTS run (Add to Chart) result:", result);
                for (const plotName in plots) {
                    if (plots.hasOwnProperty(plotName)) {
                        // For simplicity, we're adding a new series.
                        // You can add logic to check for an existing series and update it.
                        addPlotToHandler(this.handler, plotName, plots[plotName]);
                    }
                }
            }
            catch (error) {
                console.error("Error executing PineTS code (Add to Chart):", error);
            }
        }
        /**
         * Handler for the start of a drag event on the resizer.
         * @param event - The mouse down event.
         */
        onDragStart(event) {
            this.isResizing = true;
            this.startY = event.clientY;
            this.startHeight = parseInt(window.getComputedStyle(this.container).height, 10);
            event.preventDefault();
        }
        /**
         * Handler for the dragging event to resize the pane.
         * @param event - The mouse move event.
         */
        onDrag(event) {
            if (!this.isResizing)
                return;
            // Calculate the new height as the distance from the bottom.
            const newHeight = this.startHeight + (this.startY - event.clientY);
            // Clamp the new height between MIN_HEIGHT and MAX_HEIGHT.
            const clampedHeight = Math.min(Math.max(newHeight, this.MIN_HEIGHT), this.MAX_HEIGHT);
            this.container.style.height = `${clampedHeight}px`;
            // Notify Monaco that the container size has changed.
            this.editorInstance?.layout();
        }
        /**
         * Handler for the end of a drag event.
         * @param event - The mouse up event.
         */
        onDragEnd(event) {
            if (this.isResizing) {
                this.isResizing = false;
            }
        }
    }
    /**
     * Convert a single PineTS plot object into a Lightweight Charts series using Handler.
     * @param handler   Your existing Handler instance (manages the chart).
     * @param plotName  The name of the plot (e.g. "Momentum", "Cross", etc.).
     * @param plotObj   The object returned by PineTS for this plot.
     */
    function addPlotToHandler(handler, plotName, plotObj) {
        const { data, options } = plotObj;
        const style = options?.style || 'line'; // default to 'line' if not specified
        // 1) Prepare a config object for Handler's createXSeries methods
        //    (color, linewidth, lineStyle, etc.)
        const baseOptions = {
            color: options?.color,
            lineWidth: options?.linewidth,
            // You can add more fields if needed, e.g. lineStyle, upColor, downColor, etc.
        };
        // 2) Create the appropriate series based on style
        let createdSeries;
        switch (style) {
            case 'line':
                createdSeries = handler.createLineSeries(plotName, baseOptions);
                break;
            case 'histogram':
                createdSeries = handler.createHistogramSeries(plotName, baseOptions);
                break;
            case 'area':
                createdSeries = handler.createAreaSeries(plotName, baseOptions);
                break;
            case 'bar':
                createdSeries = handler.createBarSeries(plotName, baseOptions);
                break;
            case 'cross':
                // "cross" isn't a native style in Lightweight Charts.
                // Often, we approximate with a line series having a thick or special style:
                baseOptions.lineWidth = baseOptions.lineWidth ?? 6; // e.g. big line
                createdSeries = handler.createLineSeries(plotName, baseOptions);
                break;
            default:
                console.warn(`Unsupported plot style: ${style}. Using line instead.`);
                createdSeries = handler.createLineSeries(plotName, baseOptions);
                break;
        }
        // 3) Convert PineTS data into a format Lightweight Charts expects: { time, value, color? }
        //    PineTS often uses milliseconds. Lightweight Charts expects 'time' in seconds or a Date-like object.
        const seriesData = data.map((pt) => ({
            time: Math.floor(pt.time / 1000), // convert ms -> seconds
            value: pt.value,
            // If you want per-point color, pass 'color' here. The series must support it (e.g. histogram).
            color: pt.color ?? options?.color,
        }));
        // 4) Set data on the newly created series
        createdSeries.series.setData(seriesData);
    }

    class Menu {
        makeButton;
        callbackName;
        div;
        isOpen = false;
        widget;
        constructor(makeButton, items, activeItem, separator, align, callbackName) {
            this.makeButton = makeButton;
            this.callbackName = callbackName;
            this.div = document.createElement('div');
            this.div.classList.add('topbar-menu');
            this.widget = this.makeButton(activeItem + ' ↓', null, separator, true, align);
            this.updateMenuItems(items);
            this.widget.elem.addEventListener('click', () => {
                this.isOpen = !this.isOpen;
                if (!this.isOpen) {
                    this.div.style.display = 'none';
                    return;
                }
                let rect = this.widget.elem.getBoundingClientRect();
                this.div.style.display = 'flex';
                this.div.style.flexDirection = 'column';
                let center = rect.x + (rect.width / 2);
                this.div.style.left = center - (this.div.clientWidth / 2) + 'px';
                this.div.style.top = rect.y + rect.height + 'px';
            });
            document.body.appendChild(this.div);
        }
        updateMenuItems(items) {
            this.div.innerHTML = '';
            items.forEach(text => {
                let button = this.makeButton(text, null, false, false);
                button.elem.addEventListener('click', () => {
                    this._clickHandler(button.elem.innerText);
                });
                button.elem.style.margin = '4px 4px';
                button.elem.style.padding = '2px 2px';
                this.div.appendChild(button.elem);
            });
            this.widget.elem.innerText = items[0] + ' ↓';
        }
        _clickHandler(name) {
            this.widget.elem.innerText = name + ' ↓';
            window.callbackFunction(`${this.callbackName ?? 'undefined'}_~_${name}`);
            this.div.style.display = 'none';
            this.isOpen = false;
        }
    }

    /*
     * Portions of this file are derived from [lightweight-charts-python] and are
     * licensed under the MIT License. The original copyright notice and license
     * can be found in the LICENSE file.
     *
     * Modifications by [EsIstJosh] are licensed under the GNU AGPL v3.0.
     * See <https://www.gnu.org/licenses/agpl-3.0.html> for the full license text.
     */
    class TopBar {
        _handler;
        _div;
        left;
        right;
        codeEditor;
        constructor(handler) {
            this._handler = handler;
            this._div = document.createElement('div');
            this._div.classList.add('topbar');
            const createTopBarContainer = (justification) => {
                const div = document.createElement('div');
                div.classList.add('topbar-container');
                div.style.justifyContent = justification;
                this._div.appendChild(div);
                return div;
            };
            this.left = createTopBarContainer('flex-start');
            this.right = createTopBarContainer('flex-end');
            this.codeEditor = new CodeEditor(this._handler); // ✅ Instantiate the Monaco Editor
            // ✅ Add a button to open the editor
            this.makeButton("()=> ƒ", true, true, "right", false, undefined, () => this.codeEditor.open());
        }
        makeSwitcher(items, defaultItem, callbackName, align = 'left') {
            const switcherElement = document.createElement('div');
            switcherElement.style.margin = '4px 12px';
            let activeItemEl;
            const createAndReturnSwitcherButton = (itemName) => {
                const button = document.createElement('button');
                button.classList.add('topbar-button');
                button.classList.add('switcher-button');
                button.style.margin = '0px 2px';
                button.innerText = itemName;
                if (itemName == defaultItem) {
                    activeItemEl = button;
                    button.classList.add('active-switcher-button');
                }
                const buttonWidth = TopBar.getClientWidth(button);
                button.style.minWidth = buttonWidth + 1 + 'px';
                button.addEventListener('click', () => widget.onItemClicked(button));
                switcherElement.appendChild(button);
                return button;
            };
            const widget = {
                elem: switcherElement,
                callbackName: callbackName,
                intervalElements: items.map(createAndReturnSwitcherButton),
                onItemClicked: (item) => {
                    if (item == activeItemEl)
                        return;
                    activeItemEl.classList.remove('active-switcher-button');
                    item.classList.add('active-switcher-button');
                    activeItemEl = item;
                    window.callbackFunction(`${widget.callbackName}_~_${item.innerText}`);
                }
            };
            this.appendWidget(switcherElement, align, true);
            return widget;
        }
        makeTextBoxWidget(text, align = 'left', callbackName = null) {
            if (callbackName) {
                const textBox = document.createElement('input');
                textBox.classList.add('topbar-textbox-input');
                textBox.value = text;
                textBox.style.width = `${(textBox.value.length + 2)}ch`;
                textBox.addEventListener('focus', () => {
                    window.textBoxFocused = true;
                });
                textBox.addEventListener('input', (e) => {
                    e.preventDefault();
                    textBox.style.width = `${(textBox.value.length + 2)}ch`;
                });
                textBox.addEventListener('keydown', (e) => {
                    if (e.key == 'Enter') {
                        e.preventDefault();
                        textBox.blur();
                    }
                });
                textBox.addEventListener('blur', () => {
                    window.callbackFunction(`${callbackName}_~_${textBox.value}`);
                    window.textBoxFocused = false;
                });
                this.appendWidget(textBox, align, true);
                return textBox;
            }
            else {
                const textBox = document.createElement('div');
                textBox.classList.add('topbar-textbox');
                textBox.innerText = text;
                this.appendWidget(textBox, align, true);
                return textBox;
            }
        }
        makeMenu(items, activeItem, separator, align, callbackName) {
            return new Menu(this.makeButton.bind(this), items, activeItem, separator, align, callbackName);
        }
        makeButton(defaultText, separator, append = true, align = 'left', toggle = false, callbackName, callable) {
            let button = document.createElement('button');
            button.classList.add('topbar-button');
            button.innerText = defaultText;
            // Temporarily append to measure width
            document.body.appendChild(button);
            button.style.minWidth = `${button.clientWidth + 1}px`;
            document.body.removeChild(button);
            let state = false;
            const onItemClicked = () => {
                if (toggle) {
                    state = !state;
                    button.style.backgroundColor = state ? 'var(--active-bg-color)' : '';
                    button.style.color = state ? 'var(--active-color)' : '';
                    if (callbackName) {
                        window.callbackFunction(`${callbackName}_~_${state}`);
                    }
                }
                else {
                    if (callbackName) {
                        window.callbackFunction(`${callbackName}_~_${button.innerText}`);
                    }
                }
                if (callable)
                    callable();
            };
            button.addEventListener('click', onItemClicked);
            if (append)
                this.appendWidget(button, align, separator);
            return { elem: button, callbackName };
        }
        makeSliderWidget(min, max, step, defaultValue, callbackName, align = 'left') {
            // Create container for the slider
            const sliderContainer = document.createElement('div');
            sliderContainer.classList.add('topbar-slider-container');
            sliderContainer.style.display = 'flex';
            sliderContainer.style.alignItems = 'center';
            sliderContainer.style.margin = '4px 12px';
            // Create label for displaying the value
            const valueLabel = document.createElement('span');
            valueLabel.classList.add('topbar-slider-label');
            valueLabel.style.marginRight = '8px';
            valueLabel.innerText = defaultValue.toString();
            // Create the slider input
            const slider = document.createElement('input');
            slider.classList.add('topbar-slider');
            slider.type = 'range';
            slider.min = min.toString();
            slider.max = max.toString();
            slider.step = step.toString();
            slider.value = defaultValue.toString();
            slider.style.cursor = 'pointer';
            // Update label and trigger callback on change
            slider.addEventListener('input', () => {
                valueLabel.innerText = slider.value;
                window.callbackFunction(`${callbackName}_~_${slider.value}`);
            });
            // Append elements to the slider container
            sliderContainer.appendChild(valueLabel);
            sliderContainer.appendChild(slider);
            // Append the slider widget to the top bar
            this.appendWidget(sliderContainer, align, true);
            return sliderContainer;
        }
        makeSeparator(align = 'left') {
            const separator = document.createElement('div');
            separator.classList.add('topbar-seperator');
            const div = align == 'left' ? this.left : this.right;
            div.appendChild(separator);
        }
        appendWidget(widget, align, separator) {
            const div = align == 'left' ? this.left : this.right;
            if (separator) {
                if (align == 'left')
                    div.appendChild(widget);
                this.makeSeparator(align);
                if (align == 'right')
                    div.appendChild(widget);
            }
            else
                div.appendChild(widget);
            this._handler.reSize();
        }
        static getClientWidth(element) {
            document.body.appendChild(element);
            const width = element.clientWidth;
            document.body.removeChild(element);
            return width;
        }
    }

    const defaultOptions$1 = {
        title: '',
        followMode: 'tracking',
        horizontalDeadzoneWidth: 45,
        verticalDeadzoneHeight: 100,
        verticalSpacing: 20,
        topOffset: 20,
    };
    class TooltipElement {
        _chart;
        _element;
        _titleElement;
        _priceElement;
        _dateElement;
        _timeElement;
        _options;
        _lastTooltipWidth = null;
        constructor(chart, options) {
            this._options = {
                ...defaultOptions$1,
                ...options,
            };
            this._chart = chart;
            const element = document.createElement('div');
            applyStyle(element, {
                display: 'flex',
                'flex-direction': 'column',
                'align-items': 'center',
                position: 'absolute',
                transform: 'translate(calc(0px - 50%), 0px)',
                opacity: '0',
                left: '0%',
                top: '0',
                'z-index': '100',
                'background-color': 'white',
                'border-radius': '4px',
                padding: '5px 10px',
                'font-family': "-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif",
                'font-size': '12px',
                'font-weight': '400',
                'box-shadow': '0px 2px 4px rgba(0, 0, 0, 0.2)',
                'line-height': '16px',
                'pointer-events': 'none',
                color: '#131722',
            });
            const titleElement = document.createElement('div');
            applyStyle(titleElement, {
                'font-size': '12px',
                'line-height': '24px',
                'font-weight': '590',
            });
            setElementText(titleElement, this._options.title);
            element.appendChild(titleElement);
            const priceElement = document.createElement('div');
            applyStyle(priceElement, {
                'font-size': '12px',
                'line-height': '18px',
                'font-weight': '590',
            });
            setElementText(priceElement, '');
            element.appendChild(priceElement);
            const dateElement = document.createElement('div');
            applyStyle(dateElement, {
                color: '#787B86',
            });
            setElementText(dateElement, '');
            element.appendChild(dateElement);
            const timeElement = document.createElement('div');
            applyStyle(timeElement, {
                color: '#787B86',
            });
            setElementText(timeElement, '');
            element.appendChild(timeElement);
            this._element = element;
            this._titleElement = titleElement;
            this._priceElement = priceElement;
            this._dateElement = dateElement;
            this._timeElement = timeElement;
            const chartElement = this._chart.chartElement();
            chartElement.appendChild(this._element);
            const chartElementParent = chartElement.parentElement;
            if (!chartElementParent) {
                console.error('Chart Element is not attached to the page.');
                return;
            }
            const position = getComputedStyle(chartElementParent).position;
            if (position !== 'relative' && position !== 'absolute') {
                console.error('Chart Element position is expected be `relative` or `absolute`.');
            }
        }
        destroy() {
            if (this._chart && this._element)
                this._chart.chartElement().removeChild(this._element);
        }
        applyOptions(options) {
            this._options = {
                ...this._options,
                ...options,
            };
        }
        options() {
            return this._options;
        }
        updateTooltipContent(tooltipContentData) {
            if (!this._element) {
                console.warn('Tooltip element not found.');
                return;
            }
            const tooltipMeasurement = this._element.getBoundingClientRect();
            this._lastTooltipWidth = tooltipMeasurement.width;
            if (tooltipContentData.title !== undefined && this._titleElement) {
                console.log(`Setting title: ${tooltipContentData.title}`); // Debug log
                setElementText(this._titleElement, tooltipContentData.title);
            }
            else {
                console.warn('Title element is missing or title data is undefined.');
            }
            setElementText(this._priceElement, tooltipContentData.price);
            setElementText(this._dateElement, tooltipContentData.date);
            setElementText(this._timeElement, tooltipContentData.time);
        }
        updatePosition(positionData) {
            if (!this._chart || !this._element)
                return;
            this._element.style.opacity = positionData.visible ? '1' : '0';
            if (!positionData.visible) {
                return;
            }
            const x = this._calculateXPosition(positionData, this._chart);
            const y = this._calculateYPosition(positionData);
            this._element.style.transform = `translate(${x}, ${y})`;
        }
        _calculateXPosition(positionData, chart) {
            const x = positionData.paneX + chart.priceScale('left').width();
            const deadzoneWidth = this._lastTooltipWidth
                ? Math.ceil(this._lastTooltipWidth / 2)
                : this._options.horizontalDeadzoneWidth;
            const xAdjusted = Math.min(Math.max(deadzoneWidth, x), chart.timeScale().width() - deadzoneWidth);
            return `calc(${xAdjusted}px - 50%)`;
        }
        _calculateYPosition(positionData) {
            if (this._options.followMode == 'top') {
                return `${this._options.topOffset}px`;
            }
            const y = positionData.paneY;
            const flip = y <= this._options.verticalSpacing + this._options.verticalDeadzoneHeight;
            const yPx = y + (flip ? 1 : -1) * this._options.verticalSpacing;
            const yPct = flip ? '' : ' - 100%';
            return `calc(${yPx}px${yPct})`;
        }
    }
    function setElementText(element, text) {
        if (!element || text === element.innerText)
            return;
        element.innerText = text;
        element.style.display = text ? 'block' : 'none';
    }
    function applyStyle(element, styles) {
        for (const [key, value] of Object.entries(styles)) {
            element.style.setProperty(key, value);
        }
    }

    function centreOffset(lineBitmapWidth) {
        return Math.floor(lineBitmapWidth * 0.5);
    }
    /**
     * Calculates the bitmap position for an item with a desired length (height or width), and centred according to
     * an position coordinate defined in media sizing.
     * @param positionMedia - position coordinate for the bar (in media coordinates)
     * @param pixelRatio - pixel ratio. Either horizontal for x positions, or vertical for y positions
     * @param desiredWidthMedia - desired width (in media coordinates)
     * @returns Position of of the start point and length dimension.
     */
    function positionsLine(positionMedia, pixelRatio, desiredWidthMedia = 1, widthIsBitmap) {
        const scaledPosition = Math.round(pixelRatio * positionMedia);
        const lineBitmapWidth = Math.round(desiredWidthMedia * pixelRatio);
        const offset = centreOffset(lineBitmapWidth);
        const position = scaledPosition - offset;
        return { position, length: lineBitmapWidth };
    }

    function convertTime(t) {
        if (lightweightCharts.isUTCTimestamp(t))
            return t * 1000;
        if (lightweightCharts.isBusinessDay(t))
            return new Date(t.year, t.month, t.day).valueOf();
        const [year, month, day] = t.split('-').map(parseInt);
        return new Date(year, month, day).valueOf();
    }
    function formattedDateAndTime(timestamp) {
        if (!timestamp)
            return ['', ''];
        const dateObj = new Date(timestamp);
        // Format date string
        const year = dateObj.getFullYear();
        const month = dateObj.toLocaleString('default', { month: 'short' });
        const date = dateObj.getDate().toString().padStart(2, '0');
        const formattedDate = `${date} ${month} ${year}`;
        // Format time string
        const hours = dateObj.getHours().toString().padStart(2, '0');
        const minutes = dateObj.getMinutes().toString().padStart(2, '0');
        const formattedTime = `${hours}:${minutes}`;
        return [formattedDate, formattedTime];
    }

    class TooltipCrosshairLinePaneRenderer {
        _data;
        constructor(data) {
            this._data = data;
        }
        draw(target) {
            if (!this._data.visible)
                return;
            target.useBitmapCoordinateSpace((scope) => {
                const ctx = scope.context;
                const crosshairPos = positionsLine(this._data.x, scope.horizontalPixelRatio, 1);
                ctx.fillStyle = this._data.color; // Use the color directly from _data
                ctx.fillRect(crosshairPos.position, this._data.topMargin * scope.verticalPixelRatio, crosshairPos.length, scope.bitmapSize.height);
            });
        }
    }
    class MultiTouchCrosshairPaneView {
        _data;
        constructor(data) {
            this._data = data;
        }
        update(data) {
            this._data = data;
        }
        renderer() {
            return new TooltipCrosshairLinePaneRenderer(this._data);
        }
        zOrder() {
            return 'bottom';
        }
    }
    const defaultOptions = {
        lineColor: 'rgba(0, 0, 0, 0.2)',
        priceExtractor: (data) => {
            if (data.value !== undefined) {
                return data.value.toFixed(2);
            }
            if (data.close !== undefined) {
                return data.close.toFixed(2);
            }
            return '';
        }
    };
    class TooltipPrimitive {
        _options;
        _tooltip = undefined;
        _paneViews;
        _data = {
            x: 0,
            visible: false,
            color: 'rgba(0, 0, 0, 0.2)',
            topMargin: 0,
        };
        _attachedParams;
        constructor(options) {
            this._options = {
                ...defaultOptions,
                ...options,
            };
            this._data.color = this._options.lineColor; // Set the initial color
            this._paneViews = [new MultiTouchCrosshairPaneView(this._data)];
        }
        attached(param) {
            this._attachedParams = param;
            const series = this.series();
            if (series) {
                const seriesOptions = series.options();
                const lineColor = seriesOptions.lineColor || seriesOptions.color || 'rgba(0,0,0,0.2)';
                if (this._options.autoColor) { // Apply the extracted lineColor to the primitive
                    this.applyOptions({
                        lineColor,
                    });
                }
            }
            this._setCrosshairMode();
            param.chart.subscribeCrosshairMove(this._moveHandler);
            this._createTooltipElement();
        }
        detached() {
            const chart = this.chart();
            if (chart) {
                chart.unsubscribeCrosshairMove(this._moveHandler);
            }
            this._hideCrosshair();
            this._hideTooltip();
        }
        paneViews() {
            return this._paneViews;
        }
        updateAllViews() {
            this._paneViews.forEach((pw) => pw.update(this._data));
        }
        setData(data) {
            this._data = data;
            this.updateAllViews();
            this._attachedParams?.requestUpdate();
        }
        currentColor() {
            return this._options.lineColor;
        }
        chart() {
            return this._attachedParams?.chart;
        }
        series() {
            return this._attachedParams?.series;
        }
        applyOptions(options) {
            this._options = {
                ...this._options,
                ...options,
            };
            // Update the data color to match the lineColor if provided
            if (options.lineColor) {
                this.setData({
                    ...this._data,
                    color: options.lineColor,
                });
            }
            // Update the tooltip if it exists
            if (this._tooltip) {
                this._tooltip.applyOptions({
                    ...this._options.tooltip,
                });
            }
            this._attachedParams?.requestUpdate();
        }
        _setCrosshairMode() {
            const chart = this.chart();
            if (!chart) {
                throw new Error('Unable to change crosshair mode because the chart instance is undefined');
            }
            chart.applyOptions({
                crosshair: {
                    mode: lightweightCharts.CrosshairMode.Magnet,
                    vertLine: {
                        visible: false,
                        labelVisible: false,
                    },
                    horzLine: {
                        visible: false,
                        labelVisible: false,
                    },
                },
            });
        }
        _moveHandler = (param) => this._onMouseMove(param);
        switch(series) {
            if (this.series() === series) {
                console.log('Tooltip is already attached to this series.');
                return;
            }
            this._hideCrosshair();
            series.attachPrimitive(this, 'Tooltip', true, false);
            const seriesOptions = series.options();
            const lineColor = seriesOptions.lineColor || seriesOptions.color || 'rgba(0,0,0,0.2)';
            if (this._options.autoColor) { // Apply the extracted lineColor to the primitive
                this.applyOptions({
                    lineColor,
                });
            }
            console.log('Switched tooltip to the new series.');
        }
        _hideCrosshair() {
            this._hideTooltip();
            this.setData({
                x: 0,
                visible: false,
                color: this._options.lineColor,
                topMargin: 0,
            });
        }
        _hideTooltip() {
            if (!this._tooltip)
                return;
            this._tooltip.updateTooltipContent({
                title: '',
                price: '',
                date: '',
                time: '',
            });
            this._tooltip.updatePosition({
                paneX: 0,
                paneY: 0,
                visible: false,
            });
        }
        _onMouseMove(param) {
            const chart = this.chart();
            const series = this.series();
            const logical = param.logical;
            if (!logical || !chart || !series) {
                this._hideCrosshair();
                return;
            }
            const data = param.seriesData.get(series);
            if (!data) {
                this._hideCrosshair();
                return;
            }
            const price = this._options.priceExtractor(data);
            const coordinate = chart.timeScale().logicalToCoordinate(logical);
            const [date, time] = formattedDateAndTime(param.time ? convertTime(param.time) : undefined);
            if (this._tooltip) {
                const title = series.options()?.title || 'Unknown Series';
                const tooltipOptions = this._tooltip.options();
                const topMargin = tooltipOptions.followMode === 'top' ? tooltipOptions.topOffset + 10 : 0;
                this.setData({
                    x: coordinate ?? 0,
                    visible: coordinate !== null,
                    color: this._options.lineColor,
                    topMargin,
                });
                this._tooltip.updateTooltipContent({
                    title, // Display the series title here
                    price,
                    date,
                    time,
                });
                this._tooltip.updatePosition({
                    paneX: param.point?.x ?? 0,
                    paneY: param.point?.y ?? 0,
                    visible: true,
                });
            }
        }
        _createTooltipElement() {
            const chart = this.chart();
            if (!chart)
                throw new Error('Unable to create Tooltip element. Chart not attached');
            this._tooltip = new TooltipElement(chart, {
                ...this._options.tooltip,
            });
        }
    }

    let ColorPicker$1 = class ColorPicker {
        colorOption;
        static colors = [
            '#EBB0B0', '#E9CEA1', '#E5DF80', '#ADEB97', '#A3C3EA', '#D8BDED',
            '#E15F5D', '#E1B45F', '#E2D947', '#4BE940', '#639AE1', '#D7A0E8',
            '#E42C2A', '#E49D30', '#E7D827', '#3CFF0A', '#3275E4', '#B06CE3',
            '#F3000D', '#EE9A14', '#F1DA13', '#2DFC0F', '#1562EE', '#BB00EF',
            '#B50911', '#E3860E', '#D2BD11', '#48DE0E', '#1455B4', '#6E009F',
            '#7C1713', '#B76B12', '#8D7A13', '#479C12', '#165579', '#51007E',
        ];
        _div;
        saveDrawings;
        opacity = 0;
        _opacitySlider;
        _opacityLabel;
        rgba;
        constructor(saveDrawings, colorOption) {
            this.colorOption = colorOption;
            this.saveDrawings = saveDrawings;
            this._div = document.createElement('div');
            this._div.classList.add('color-picker');
            let colorPicker = document.createElement('div');
            colorPicker.style.margin = '10px';
            colorPicker.style.display = 'flex';
            colorPicker.style.flexWrap = 'wrap';
            ColorPicker.colors.forEach((color) => colorPicker.appendChild(this.makeColorBox(color)));
            let separator = document.createElement('div');
            separator.style.backgroundColor = window.pane.borderColor;
            separator.style.height = '1px';
            separator.style.width = '130px';
            let opacity = document.createElement('div');
            opacity.style.margin = '10px';
            let opacityText = document.createElement('div');
            opacityText.style.color = 'lightgray';
            opacityText.style.fontSize = '12px';
            opacityText.innerText = 'Opacity';
            this._opacityLabel = document.createElement('div');
            this._opacityLabel.style.color = 'lightgray';
            this._opacityLabel.style.fontSize = '12px';
            this._opacitySlider = document.createElement('input');
            this._opacitySlider.type = 'range';
            this._opacitySlider.value = (this.opacity * 100).toString();
            this._opacityLabel.innerText = this._opacitySlider.value + '%';
            this._opacitySlider.oninput = () => {
                this._opacityLabel.innerText = this._opacitySlider.value + '%';
                this.opacity = parseInt(this._opacitySlider.value) / 100;
                this.updateColor();
            };
            opacity.appendChild(opacityText);
            opacity.appendChild(this._opacitySlider);
            opacity.appendChild(this._opacityLabel);
            this._div.appendChild(colorPicker);
            this._div.appendChild(separator);
            this._div.appendChild(opacity);
            window.containerDiv.appendChild(this._div);
        }
        _updateOpacitySlider() {
            this._opacitySlider.value = (this.opacity * 100).toString();
            this._opacityLabel.innerText = this._opacitySlider.value + '%';
        }
        makeColorBox(color) {
            const box = document.createElement('div');
            box.style.width = '18px';
            box.style.height = '18px';
            box.style.borderRadius = '3px';
            box.style.margin = '3px';
            box.style.boxSizing = 'border-box';
            box.style.backgroundColor = color;
            box.addEventListener('mouseover', () => box.style.border = '2px solid lightgray');
            box.addEventListener('mouseout', () => box.style.border = 'none');
            const rgba = ColorPicker.extractRGBA(color);
            box.addEventListener('click', () => {
                this.rgba = rgba;
                this.updateColor();
            });
            return box;
        }
        static extractRGBA(anyColor) {
            const dummyElem = document.createElement('div');
            dummyElem.style.color = anyColor;
            document.body.appendChild(dummyElem);
            const computedColor = getComputedStyle(dummyElem).color;
            document.body.removeChild(dummyElem);
            const rgb = computedColor.match(/\d+/g)?.map(Number);
            if (!rgb)
                return [];
            let isRgba = computedColor.includes('rgba');
            let opacity = isRgba ? parseFloat(computedColor.split(',')[3]) : 1;
            return [rgb[0], rgb[1], rgb[2], opacity];
        }
        updateColor() {
            if (!Drawing.lastHoveredObject || !this.rgba)
                return;
            const oColor = `rgba(${this.rgba[0]}, ${this.rgba[1]}, ${this.rgba[2]}, ${this.opacity})`;
            Drawing.lastHoveredObject.applyOptions({ [this.colorOption]: oColor });
            this.saveDrawings();
        }
        openMenu(rect) {
            if (!Drawing.lastHoveredObject)
                return;
            this.rgba = ColorPicker.extractRGBA(Drawing.lastHoveredObject._options[this.colorOption]);
            this.opacity = this.rgba[3];
            this._updateOpacitySlider();
            this._div.style.top = (rect.top - 30) + 'px';
            this._div.style.left = rect.right + 'px';
            this._div.style.display = 'flex';
            setTimeout(() => document.addEventListener('mousedown', (event) => {
                if (!this._div.contains(event.target)) {
                    this.closeMenu();
                }
            }), 10);
        }
        closeMenu() {
            document.body.removeEventListener('click', this.closeMenu);
            this._div.style.display = 'none';
        }
    };

    class ColorPicker {
        container;
        _opacitySlider;
        _opacity_label;
        exitButton;
        color = "#ff0000";
        rgba; // [R, G, B, A]
        opacity;
        applySelection;
        constructor(initialValue, applySelection) {
            this.applySelection = applySelection;
            this.rgba = ColorPicker.extractRGBA(initialValue);
            this.opacity = this.rgba[3];
            this.container = document.createElement("div");
            this.container.classList.add("color-picker");
            this.container.style.display = "flex";
            this.container.style.flexDirection = "column";
            this.container.style.width = "150px";
            this.container.style.height = "300px";
            this.container.style.position = "relative"; // Ensure proper positioning for the exit button.
            // Build UI elements
            const colorGrid = this.createColorGrid();
            const opacityUI = this.createOpacityUI();
            this.exitButton = this.createExitButton(); // Create the exit button.
            // Append elements to the container
            this.container.appendChild(colorGrid);
            this.container.appendChild(this.createSeparator());
            this.container.appendChild(this.createSeparator());
            this.container.appendChild(opacityUI);
            this.container.appendChild(this.exitButton); // Append the exit button last
        }
        createExitButton() {
            const button = document.createElement('div');
            button.innerText = '✕'; // Close icon
            button.title = 'Close';
            button.style.position = 'absolute';
            button.style.bottom = '5px'; // Move to the bottom
            button.style.right = '5px'; // Default bottom-right corner
            button.style.width = '20px';
            button.style.height = '20px';
            button.style.cursor = 'pointer';
            button.style.display = 'flex';
            button.style.justifyContent = 'center';
            button.style.alignItems = 'center';
            button.style.fontSize = '16px';
            button.style.backgroundColor = '#ccc';
            button.style.borderRadius = '50%';
            button.style.color = '#000';
            button.style.boxShadow = '0 1px 3px rgba(0,0,0,0.3)';
            // Add hover effect
            button.addEventListener('mouseover', () => {
                button.style.backgroundColor = '#e74c3c'; // Red hover color
                button.style.color = '#fff'; // White text on hover
            });
            button.addEventListener('mouseout', () => {
                button.style.backgroundColor = '#ccc';
                button.style.color = '#000';
            });
            // Close the menu when clicked
            button.addEventListener('click', () => {
                this.closeMenu();
            });
            return button;
        }
        createColorGrid() {
            const colorGrid = document.createElement('div');
            colorGrid.style.display = 'grid';
            colorGrid.style.gridTemplateColumns = 'repeat(7, 1fr)'; // 5 columns
            colorGrid.style.gap = '5px';
            colorGrid.style.overflowY = 'auto';
            colorGrid.style.flex = '1';
            const colors = ColorPicker.generateFullSpectrumColors(9); // Generate vibrant colors
            colors.forEach((color) => {
                const box = this.createColorBox(color);
                colorGrid.appendChild(box);
            });
            return colorGrid;
        }
        createColorBox(color) {
            const box = document.createElement("div");
            box.style.aspectRatio = "1"; // Maintain square shape
            box.style.borderRadius = "6px";
            box.style.backgroundColor = color;
            box.style.cursor = "pointer";
            box.addEventListener("click", () => {
                this.rgba = ColorPicker.extractRGBA(color);
                this.updateTargetColor();
            });
            return box;
        }
        static generateFullSpectrumColors(stepsPerTransition) {
            const colors = [];
            // Red to Green (255, 0, 0 → 255, 255, 0)
            for (let g = 0; g <= 255; g += Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(255, ${g}, 0, 1)`);
            }
            // Green to Yellow-Green to Green-Blue (255, 255, 0 → 0, 255, 0)
            for (let r = 255; r >= 0; r -= Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(${r}, 255, 0, 1)`);
            }
            // Green to Cyan (0, 255, 0 → 0, 255, 255)
            for (let b = 0; b <= 255; b += Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(0, 255, ${b}, 1)`);
            }
            // Cyan to Blue (0, 255, 255 → 0, 0, 255)
            for (let g = 255; g >= 0; g -= Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(0, ${g}, 255, 1)`);
            }
            // Blue to Magenta (0, 0, 255 → 255, 0, 255)
            for (let r = 0; r <= 255; r += Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(${r}, 0, 255, 1)`);
            }
            // Magenta to Red (255, 0, 255 → 255, 0, 0)
            for (let b = 255; b >= 0; b -= Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(255, 0, ${b}, 1)`);
            }
            // White to Black (255, 255, 255 → 0, 0, 0)
            for (let i = 255; i >= 0; i -= Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(${i}, ${i}, ${i}, 1)`);
            }
            return colors;
        }
        createOpacityUI() {
            const opacityContainer = document.createElement("div");
            opacityContainer.style.margin = "10px";
            opacityContainer.style.display = "flex";
            opacityContainer.style.flexDirection = "column";
            opacityContainer.style.alignItems = "center";
            const opacityText = document.createElement("div");
            opacityText.style.color = "lightgray";
            opacityText.style.fontSize = "12px";
            opacityText.innerText = "Opacity";
            this._opacitySlider = document.createElement("input");
            this._opacitySlider.type = "range";
            this._opacitySlider.min = "0";
            this._opacitySlider.max = "100";
            this._opacitySlider.value = (this.opacity * 100).toString();
            this._opacitySlider.style.width = "80%";
            this._opacity_label = document.createElement("div");
            this._opacity_label.style.color = "lightgray";
            this._opacity_label.style.fontSize = "12px";
            this._opacity_label.innerText = `${this._opacitySlider.value}%`;
            this._opacitySlider.oninput = () => {
                this._opacity_label.innerText = `${this._opacitySlider.value}%`;
                this.opacity = parseInt(this._opacitySlider.value) / 100;
                this.updateTargetColor();
            };
            opacityContainer.appendChild(opacityText);
            opacityContainer.appendChild(this._opacitySlider);
            opacityContainer.appendChild(this._opacity_label);
            return opacityContainer;
        }
        createSeparator() {
            const separator = document.createElement("div");
            separator.style.height = "1px";
            separator.style.width = "100%";
            separator.style.backgroundColor = "#ccc";
            separator.style.margin = "5px 0";
            return separator;
        }
        openMenu(event, parentMenuWidth, // Width of the parent menu
        applySelection) {
            this.applySelection = applySelection;
            // Attach menu to the DOM temporarily to calculate dimensions
            this.container.style.display = 'block';
            document.body.appendChild(this.container);
            console.log('Menu attached:', this.container);
            // Calculate submenu dimensions
            const submenuWidth = this.container.offsetWidth || 150; // Default submenu width
            const submenuHeight = this.container.offsetHeight || 250; // Default submenu height
            console.log('Submenu dimensions:', { submenuWidth, submenuHeight });
            // Get mouse position
            const cursorX = event.clientX;
            const cursorY = event.clientY;
            console.log('Mouse position:', { cursorX, cursorY });
            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            // Calculate position relative to the parent menu
            let left = cursorX + parentMenuWidth; // Offset by parent menu width
            let top = cursorY;
            // Adjust position to avoid overflowing viewport
            const adjustedLeft = left + submenuWidth > viewportWidth ? cursorX - submenuWidth : left;
            const adjustedTop = top + submenuHeight > viewportHeight ? viewportHeight - submenuHeight - 10 : top;
            console.log({ left, top, adjustedLeft, adjustedTop });
            // Apply calculated position
            this.container.style.left = `${adjustedLeft}px`;
            this.container.style.top = `${adjustedTop}px`;
            this.container.style.display = 'flex';
            this.container.style.position = 'absolute';
            // Ensure the exit button stays within bounds
            this.exitButton.style.bottom = '5px';
            this.exitButton.style.right = '5px';
            // Close menu when clicking outside
            document.addEventListener('mousedown', this._handleOutsideClick.bind(this), { once: true });
        }
        closeMenu() {
            this.container.style.display = 'none';
            document.removeEventListener('mousedown', this._handleOutsideClick);
        }
        _handleOutsideClick(event) {
            if (!this.container.contains(event.target)) {
                this.closeMenu();
            }
        }
        static extractRGBA(color) {
            const dummyElem = document.createElement('div');
            dummyElem.style.color = color;
            document.body.appendChild(dummyElem);
            const computedColor = getComputedStyle(dummyElem).color;
            document.body.removeChild(dummyElem);
            const rgb = computedColor.match(/\d+/g)?.map(Number) || [0, 0, 0];
            const opacity = computedColor.includes("rgba")
                ? parseFloat(computedColor.split(",")[3])
                : 1;
            return [rgb[0], rgb[1], rgb[2], opacity];
        }
        getElement() {
            return this.container;
        }
        // Dynamically updates the label and selection function
        update(initialValue, applySelection) {
            this.rgba = ColorPicker.extractRGBA(initialValue);
            this.opacity = this.rgba[3];
            this.applySelection = applySelection;
            this.updateTargetColor();
        }
        updateTargetColor() {
            this.color = `rgba(${this.rgba[0]}, ${this.rgba[1]}, ${this.rgba[2]}, ${this.opacity})`;
            this.applySelection(this.color); // Apply color selection immediately
        }
    }

    class StylePicker {
        static _styles = [
            { name: 'Solid', var: lightweightCharts.LineStyle.Solid },
            { name: 'Dotted', var: lightweightCharts.LineStyle.Dotted },
            { name: 'Dashed', var: lightweightCharts.LineStyle.Dashed },
            { name: 'Large Dashed', var: lightweightCharts.LineStyle.LargeDashed },
            { name: 'Sparse Dotted', var: lightweightCharts.LineStyle.SparseDotted },
        ];
        _div;
        _saveDrawings;
        constructor(saveDrawings) {
            this._saveDrawings = saveDrawings;
            this._div = document.createElement('div');
            this._div.classList.add('context-menu');
            StylePicker._styles.forEach((style) => {
                this._div.appendChild(this._makeTextBox(style.name, style.var));
            });
            window.containerDiv.appendChild(this._div);
        }
        _makeTextBox(text, style) {
            const item = document.createElement('span');
            item.classList.add('context-menu-item');
            item.innerText = text;
            item.addEventListener('click', () => {
                Drawing.lastHoveredObject?.applyOptions({ lineStyle: style });
                this._saveDrawings();
            });
            return item;
        }
        openMenu(rect) {
            this._div.style.top = (rect.top - 30) + 'px';
            this._div.style.left = rect.right + 'px';
            this._div.style.display = 'block';
            setTimeout(() => document.addEventListener('mousedown', (event) => {
                if (!this._div.contains(event.target)) {
                    this.closeMenu();
                }
            }), 10);
        }
        closeMenu() {
            document.removeEventListener('click', this.closeMenu);
            this._div.style.display = 'none';
        }
    }

    // volumeProfile.ts
    const defaultVolumeProfileOptions = {
        visible: true,
        sections: 0,
        upColor: undefined, //"rgba(255, 255, 255, 0.25)",
        downColor: undefined, //"rgba(50, 50, 50, 0.25)",
        borderUpColor: undefined, //"rgba(255, 255, 255, 0.33)",
        borderDownColor: undefined, //"rgba(50, 50, 50, 0.33)",
        rightSide: true,
        width: 0,
        lineColor: "#ffffff",
        lineStyle: lightweightCharts.LineStyle.Solid,
        drawGrid: true,
        gridWidth: 1,
        gridColor: "rgba(255, 255, 255, 0.125)",
        gridLineStyle: lightweightCharts.LineStyle.SparseDotted,
        // Possibly xScaleLock, yScaleLock, etc.
    };
    /**
     * The VolumeProfile class implementing ISeriesPrimitive
     * with full dragging/hover logic for p1/p2, akin to TrendTrace.
     */
    class VolumeProfile extends PluginBase {
        p1;
        p2;
        _listeners = [];
        visibleRange = null;
        // Provided by constructor
        // The merged data (OHLC + volume)
        _originalData;
        // The data slice for p1..p2
        _currentSlice = null;
        // Aggregated bins => stored here
        _vpData;
        // The single or multiple pane views we use
        _paneViews;
        // Options from the user + defaults
        _options;
        // Throttle re-renders
        _pendingUpdate = false;
        // For drag/hover logic
        _state = InteractionState.NONE;
        _latestHoverPoint = null;
        _startDragPoint = null;
        static _mouseIsDown = false;
        _hovered = false; // if you want a hovered style
        chart_;
        series_;
        constructor(handler, options = defaultVolumeProfileOptions, p1, p2) {
            super(); // call base plugin constructor if needed
            this.chart_ = handler.chart;
            this.series_ = handler.series;
            const priceData = this.series_.data();
            const volumeData = handler.volumeSeries.data();
            const timeScale = this.chart_.timeScale();
            this.visibleRange = timeScale.getVisibleLogicalRange();
            if (p1 && p2) {
                // Use provided p1 and p2
                this.p1 = p1;
                this.p2 = p2;
            }
            else {
                // Use visible range or default values
                this.p1 = {
                    time: null,
                    logical: this.visibleRange?.from ?? 0,
                    price: 0,
                };
                this.p2 = {
                    time: null,
                    logical: this.visibleRange?.to ?? (this.series.data().length - 1),
                    price: 0,
                };
            }
            // Merge user-specified options with defaults
            this._options = {
                ...defaultVolumeProfileOptions,
                ...options,
            };
            if (volumeData.length > 0 && volumeData.every((v) => "value" in v)) {
                // Merge priceData & volumeData
                this._originalData = priceData.map((dp, idx) => ({
                    ...dp,
                    x1: idx,
                    x2: idx,
                    volume: volumeData[idx]?.value || 0,
                }));
            }
            else {
                console.warn('[ProfileProcessor] volumeData is empty or missing "value" property.');
                // Handle the case where volumeData is invalid
                this._originalData = priceData.map((dp, idx) => ({
                    ...dp,
                    x1: idx,
                    x2: idx,
                    volume: 0, // Default volume
                }));
            }
            // Slice & compute initial bins
            this.sliceData();
            this._vpData = this.calculateVolumeProfile();
            // Create the single pane view
            this._paneViews = [new VolumeProfilePaneView(this)];
            this._subscribeEvents();
            // Trigger initial update
            this.update();
        }
        // The DOM event callbacks
        _handleDomMouseDown = () => {
            // If you want to track raw DOM mousedown
            // (optionally do nothing, or set internal state).
        };
        _handleDomMouseUp = () => {
            // If user physically let go anywhere, we finalize the drag
            // ...
            this._onMouseUp();
        };
        // 8) The subscribe/unsubscribe utilities
        _subscribe(name, listener) {
            document.addEventListener(name, listener);
            this._listeners.push({ name, listener });
        }
        _unsubscribe(name, listener) {
            document.removeEventListener(name, listener);
            const idx = this._listeners.findIndex((x) => x.name === name && x.listener === listener);
            if (idx !== -1)
                this._listeners.splice(idx, 1);
        }
        /**
         * Subscribe to relevant events, e.g., crosshair move, chart click.
         */
        _subscribeEvents() {
            if (this.p1 && this.p2 && this.p1.time && this.p2.time) {
                this.chart_.subscribeCrosshairMove(this._handleMouseMove);
                this.chart_.subscribeClick(this._handleMouseDownOrUp);
                // Store subscriptions for later unsubscription
                this._listeners.push({ name: "crosshairMove", listener: this._handleMouseMove }, { name: "click", listener: this._handleMouseDownOrUp });
            }
            else {
                // Subscribe to visible logical range changes with a handler
                this.chart_
                    .timeScale()
                    .subscribeVisibleLogicalRangeChange(this._handleVisibleLogicalRangeChange);
                // Store the subscription for later unsubscription
                this._listeners.push({
                    name: "visibleLogicalRangeChange",
                    listener: this._handleVisibleLogicalRangeChange,
                });
            }
        }
        /**
         * Handle changes to the visible logical range.
         * Reprocesses the volume profile data and updates the view.
         */
        _handleVisibleLogicalRangeChange = () => {
            const timeScale = this.chart_.timeScale();
            this.visibleRange = timeScale.getVisibleLogicalRange();
            if (!this.visibleRange || !this.series_) {
                console.warn("[VolumeProfile] Visible range or source series is undefined.");
                return;
            }
            // Update p1 and p2 based on the new visible range
            this.p1 = {
                time: null,
                logical: this.visibleRange.from ?? 0,
                price: 0,
            };
            this.p2 = {
                time: null,
                logical: this.visibleRange.to ?? (this.series_.data().length - 1),
                price: 0,
            };
            this.sliceData();
            // Reprocess the volume profile data based on the new visible range
            const vpData = this.calculateVolumeProfile();
            if (vpData) {
                this._vpData = vpData;
                this.updateAllViews();
                this.requestUpdate(); // Trigger re-rendering
            }
            else {
                console.warn("[VolumeProfile] Failed to process Volume Profile data on visible range change.");
            }
        };
        _handleMouseMove = (param) => {
            const mousePoint = this._eventToPoint(param);
            this._latestHoverPoint = mousePoint;
            if (VolumeProfile._mouseIsDown) {
                this._handleDragInteraction(param);
            }
            else {
                // If near p1/p2 => HOVERING, else NONE
                if (this._mouseIsOverPointCanvas(param, 1) ||
                    this._mouseIsOverPointCanvas(param, 2)) {
                    if (this._state === InteractionState.NONE) {
                        this._moveToState(InteractionState.HOVERING);
                    }
                }
                else {
                    if (this._state !== InteractionState.NONE) {
                        this._moveToState(InteractionState.NONE);
                    }
                }
            }
        };
        /**
         * Click => toggle mouseDown
         */
        _handleMouseDownOrUp = () => {
            VolumeProfile._mouseIsDown = !VolumeProfile._mouseIsDown;
            if (VolumeProfile._mouseIsDown) {
                this._onMouseDown();
            }
            else {
                this._onMouseUp();
            }
            this.sliceData();
            this._vpData = this.calculateVolumeProfile();
            // Force re-render
            this.update();
        };
        _onMouseDown() {
            this._startDragPoint = this._latestHoverPoint;
            if (!this._startDragPoint || !this.p1 || !this.p2)
                return;
            // Are we near p1 or p2 in 'raw' logic?
            const nearP1 = this._mouseIsOverPointRaw(this._startDragPoint, this.p1);
            const nearP2 = this._mouseIsOverPointRaw(this._startDragPoint, this.p2);
            if (nearP1) {
                this._moveToState(InteractionState.DRAGGINGP1);
            }
            else if (nearP2) {
                this._moveToState(InteractionState.DRAGGINGP2);
            }
            else {
                this._moveToState(InteractionState.DRAGGING);
            }
        }
        _onMouseUp() {
            VolumeProfile._mouseIsDown = false;
            this._startDragPoint = null;
            this._moveToState(InteractionState.HOVERING);
            // Re-slice the data based on the updated p1 and p2 points.
            this.sliceData();
            // Recompute the volume profile bins with the updated options.
            this._vpData = this.calculateVolumeProfile();
            // Trigger an update to re-render the pane views.
            this.update();
        }
        _handleDragInteraction(param) {
            if (this._state !== InteractionState.DRAGGING &&
                this._state !== InteractionState.DRAGGINGP1 &&
                this._state !== InteractionState.DRAGGINGP2) {
                return;
            }
            const newPoint = this._eventToPoint(param);
            if (!newPoint || !this._startDragPoint)
                return;
            const diff = {
                logical: newPoint.logical - this._startDragPoint.logical,
                price: newPoint.price - this._startDragPoint.price,
            };
            this._onDrag(diff);
            // Now re-slice the data & recalc bins
            this.sliceData();
            this._vpData = this.calculateVolumeProfile();
            // Force re-render
            this.update();
            // Update anchor
            this._startDragPoint = newPoint;
        }
        _onDrag(diff) {
            if (!this.p1 || !this.p2)
                return;
            // If the user is dragging entire shape, do both
            if (this._state === InteractionState.DRAGGING) {
                this._addDiffToPoint(this.p1, diff.logical, diff.price);
                this._addDiffToPoint(this.p2, diff.logical, diff.price);
            }
            else if (this._state === InteractionState.DRAGGINGP1) {
                this._addDiffToPoint(this.p1, diff.logical, diff.price);
            }
            else if (this._state === InteractionState.DRAGGINGP2) {
                this._addDiffToPoint(this.p2, diff.logical, diff.price);
            }
            // Re-slice the data based on the updated p1 and p2 points.
            this.sliceData();
            // Recompute the volume profile bins with the updated options.
            this._vpData = this.calculateVolumeProfile();
            // Trigger an update to re-render the pane views.
            this.update();
        }
        _addDiffToPoint(point, ldiff, pdiff) {
            point.logical = (point.logical + ldiff);
            point.price = point.price + pdiff;
            // If you want to recalc time, do so here
        }
        /**
         * Minimal "raw" logic check
         */
        _mouseIsOverPointRaw(mousePt, pt) {
            if (!mousePt)
                return false;
            const tol = 1; // 1 bar index + 1 price unit tolerance, or whichever
            if (Math.abs(mousePt.logical - pt.logical) < tol) {
                if (Math.abs(mousePt.price - pt.price) < tol)
                    return true;
            }
            return false;
        }
        /**
         * "Canvas" check if user is near p1/p2
         */
        _mouseIsOverPointCanvas(param, which) {
            if (!param.point || !this.p1 || !this.p2)
                return false;
            const tolerancePx = 10;
            const cpt = which === 1
                ? convertPoint(this.p1, this.chart_, this.series_)
                : convertPoint(this.p2, this.chart_, this.series_);
            const dx = param.point.x - cpt.x;
            const dy = param.point.y - cpt.y;
            return dx * dx + dy * dy < tolerancePx * tolerancePx;
        }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._hovered = false;
                    // Unsubscribe from DOM events
                    this._unsubscribe("mousedown", this._handleDomMouseDown);
                    this._unsubscribe("mouseup", this._handleDomMouseUp);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._hovered = true;
                    // Sub to mousedown, unsub from mouseup
                    this._subscribe("mousedown", this._handleDomMouseDown);
                    this._unsubscribe("mouseup", this._handleDomMouseUp);
                    break;
                case InteractionState.DRAGGING:
                case InteractionState.DRAGGINGP1:
                case InteractionState.DRAGGINGP2:
                    document.body.style.cursor = "grabbing";
                    this._hovered = false;
                    // unsub from mousedown, sub to mouseup
                    this._unsubscribe("mousedown", this._handleDomMouseDown);
                    this._subscribe("mouseup", this._handleDomMouseUp);
                    break;
            }
            this._state = state;
            // Re-slice the data based on the updated p1 and p2 points.
            this.sliceData();
            // Recompute the volume profile bins with the updated options.
            this._vpData = this.calculateVolumeProfile();
            // Trigger an update to re-render the pane views.
            this.update();
        }
        /**
         * Convert the mouse event => LogicalPoint
         */
        _eventToPoint(param) {
            if (!param.point || param.logical == null)
                return null;
            const barPrice = this.series_.coordinateToPrice(param.point.y);
            if (barPrice == null)
                return null;
            return {
                time: param.time ?? null,
                logical: param.logical,
                price: barPrice.valueOf(),
            };
        }
        /** Slices the original data in [p1..p2] range */
        sliceData() {
            if (!this.p1 || !this.p2)
                return;
            const start = Math.min(this.p1.logical, this.p2.logical);
            const end = Math.max(this.p1.logical, this.p2.logical);
            this._currentSlice = this._originalData.slice(Math.max(0, start), Math.min(end + 1, this._originalData.length - 1));
        }
        calculateDynamicSections(visibleBars, priceMin, priceMax) {
            const K1 = 20; // Adjust for sensitivity to number of bars
            const K2 = 5; // Adjust for sensitivity to price range
            if (visibleBars <= 0 || priceMax <= priceMin) {
                return 10; // Default fallback value if inputs are invalid
            }
            // Dynamic calculation of section count
            const sectionsFromBars = visibleBars / K1;
            const sectionsFromPrice = (priceMax - priceMin) / K2;
            // Take the maximum of the two calculations
            const dynamicSections = 2 *
                Math.max(1, Math.floor(Math.max(sectionsFromBars, sectionsFromPrice)));
            return Math.max(5, dynamicSections);
        }
        calculateVolumeProfile() {
            const visibleBars = Math.min(this.visibleRange.to, this._originalData.length - 1) -
                Math.max(this.visibleRange.from, 0);
            let priceMin = Number.POSITIVE_INFINITY;
            let priceMax = Number.NEGATIVE_INFINITY;
            const profile = [];
            let refTime;
            if (this._currentSlice && this._currentSlice.length > 0) {
                for (const pt of this._currentSlice) {
                    const repPrice = pt.close ?? pt.open;
                    if (repPrice !== undefined) {
                        priceMin = Math.min(priceMin, repPrice);
                        priceMax = Math.max(priceMax, repPrice);
                    }
                }
                // Handle cases where priceMin or priceMax were not updated
                if (priceMin === Number.POSITIVE_INFINITY ||
                    priceMax === Number.NEGATIVE_INFINITY) {
                    priceMin = 0;
                    priceMax = 1;
                }
                // Determine the number of sections dynamically if not explicitly set
                let binCount = this._options.sections !== undefined && this._options.sections > 0
                    ? this._options.sections
                    : this.calculateDynamicSections(visibleBars, priceMin, priceMax);
                // Calculate price range and bin size
                const priceRange = priceMax === priceMin ? 1 : priceMax - priceMin;
                const binSize = priceRange / binCount;
                for (let i = 0; i < binCount; i++) {
                    const binMin = priceMin + i * binSize;
                    const binMax = priceMin + (i + 1) * binSize;
                    let upData = 0;
                    let downData = 0;
                    for (const pt of this._currentSlice) {
                        const repPrice = pt.close ?? pt.open;
                        if (repPrice !== undefined &&
                            repPrice >= binMin &&
                            repPrice < binMax) {
                            const isUp = (pt.close ?? 0) >= (pt.open ?? 0);
                            const volume = pt.volume || 0;
                            if (isUp)
                                upData += volume;
                            else
                                downData += volume;
                        }
                    }
                    // Decide color/border
                    const isUp = upData >= downData;
                    const color = isUp
                        ? this._options.upColor ?? setOpacity(this.series_.options().upColor, .1) ?? "rgba(0,128,0,0.1)"
                        : this._options.downColor ?? setOpacity(this.series_.options().downColor, .1) ?? "rgba(128,0,0,0.1)";
                    const borderColor = isUp
                        ? this._options.borderUpColor ?? setOpacity(this.series_.options().upColor, .5) ?? "rgba(0,128,0,0.66)"
                        : this._options.borderDownColor ?? setOpacity(this.series_.options().downColor, .5) ?? "rgba(128,0,0,0.66)";
                    profile.push({
                        price: binMin,
                        upData,
                        downData,
                        color: this._options.visible ? color : "rgba(0,0,0,0)",
                        borderColor: this._options.visible ? borderColor : "rgba(0,0,0,0)",
                        minPrice: binMin,
                        maxPrice: binMax,
                    });
                }
                refTime = this._options.rightSide
                    ? this._currentSlice[this._currentSlice.length - 1].time
                    : this._currentSlice[0].time;
            }
            else {
                // fallback
                refTime = Date.now().toString();
            }
            this.update();
            return {
                time: refTime,
                profile,
                width: this._options.width ?? 20,
                visibleRange: this.visibleRange,
            };
        }
        /**
         * Schedules an update with requestAnimationFrame
         */
        update() {
            if (!this._pendingUpdate) {
                this._pendingUpdate = true;
                requestAnimationFrame(() => {
                    super.requestUpdate();
                    this.updateAllViews();
                    // or if you just have "this.updateAllViews();"
                    console.log("VolumeProfile updated p1=", this.p1, "p2=", this.p2);
                    this._pendingUpdate = false;
                });
            }
        }
        updateAllViews() {
            // If you want a direct forced re-render
            this._paneViews.forEach((pv) => pv.update());
        }
        /**
         * ISeriesPrimitive: returns your pane views
         */
        paneViews() {
            return this._paneViews;
        }
        /**
         * If you want autoscaling, define it
         */
        autoscaleInfo() {
            if (!this._vpData.profile.length)
                return null;
            return {
                priceRange: {
                    minValue: this._vpData.profile[0].minPrice,
                    maxValue: this._vpData.profile[this._vpData.profile.length - 1].maxPrice,
                },
            };
        }
        /**
         * Applies updated VolumeProfile options, re-slices data, recalculates the profile, and updates the view.
         *
         * @param updatedOptions - A partial object containing one or more VolumeProfileOptions to update.
         */
        applyOptions(updatedOptions) {
            // Merge the new options into the existing options object.
            this._options = {
                ...this._options,
                ...updatedOptions,
            };
            // Re-slice the data based on the updated p1 and p2 points.
            this.sliceData();
            // Recompute the volume profile bins with the updated options.
            this._vpData = this.calculateVolumeProfile();
            // Trigger an update to re-render the pane views.
            this.update();
        }
    }
    /**
     * The VolumeProfilePaneView => transforms bins => screen coords, returns a renderer
     */
    class VolumeProfilePaneView {
        _source;
        _x = null;
        _width = 0;
        _items = [];
        _maxVolume;
        visibleRange = null;
        _p1 = { x: null, y: null };
        _p2 = { x: null, y: null };
        constructor(source) {
            this._source = source;
            // compute maxVolume from the profile
            this._maxVolume = this._source._vpData.profile.reduce((acc, bin) => {
                return Math.max(acc, bin.upData + bin.downData);
            }, 0);
        }
        update() {
            if (!this._source.p1 || !this._source.p2)
                return;
            const data = this._source._vpData;
            const chart = this._source.chart_;
            const series = this._source.series_;
            const timeScale = chart.timeScale();
            // Convert data.time => x
            this._x = timeScale.timeToCoordinate(data.time) ?? null;
            const barSpacing = timeScale.options().barSpacing ?? 1;
            const start = Math.max(0, Math.min(this._source.p1.logical, this._source.p2.logical));
            const end = Math.min(Math.max(this._source.p1.logical, this._source.p2.logical), this._source._originalData.length - 1);
            this._width =
                (data.width && data.width !== 0 ? data.width : (end - start) / 3) *
                    barSpacing;
            // Convert p1/p2 => canvas coords
            this._p1 = convertPoint(this._source.p1, chart, series);
            this._p2 = convertPoint(this._source.p2, chart, series);
            // Rebuild items from bins
            this._items = [];
            if (!data.profile.length)
                return;
            // Possibly re-check maxVolume if slice changed
            this._maxVolume = data.profile.reduce((acc, bin) => {
                return Math.max(acc, bin.upData + bin.downData);
            }, 0);
            for (const bin of data.profile) {
                const y1 = series.priceToCoordinate(bin.maxPrice);
                const y2 = series.priceToCoordinate(bin.minPrice);
                if (y1 == null || y2 == null) {
                    this._items.push({
                        y1: null,
                        y2: null,
                        combinedWidth: 0,
                        upWidth: 0,
                        downWidth: 0,
                        color: bin.color,
                        borderColor: bin.borderColor,
                    });
                    continue;
                }
                const rawVolume = bin.upData + bin.downData;
                const combinedWidth = this._maxVolume > 0 ? this._width * (rawVolume / this._maxVolume) : 0;
                let upWidth = 0, downWidth = 0;
                if (rawVolume > 0) {
                    upWidth = (bin.upData / rawVolume) * combinedWidth;
                    downWidth = (bin.downData / rawVolume) * combinedWidth;
                }
                this._items.push({
                    y1,
                    y2,
                    combinedWidth,
                    upWidth,
                    downWidth,
                    color: bin.color,
                    borderColor: bin.borderColor,
                });
            }
        }
        renderer() {
            return new VolumeProfileRenderer({
                x: this._x,
                width: this._width,
                items: this._items,
                visibleRange: {
                    from: this._source.chart
                        .timeScale()
                        .logicalToCoordinate(Math.max(0, this._source.visibleRange.from)),
                    to: this._source.chart
                        .timeScale()
                        .logicalToCoordinate(Math.min(this._source.series.data().length - 1, this._source.visibleRange.to))
                },
                maxVolume: this._maxVolume,
                maxBars: this._source.series.data().length
            }, this._p1, this._p2, this._source._options, false);
        }
        zOrder() {
            return 'bottom';
        }
    }
    /**
     * The VolumeProfileRenderer => draws bins, extends TwoPointDrawingPaneRenderer
     */
    class VolumeProfileRenderer extends TwoPointDrawingPaneRenderer {
        _data;
        options;
        p1;
        p2;
        constructor(data, p1, p2, options, hovered) {
            super(p1, p2, options, hovered);
            this._data = data;
            this.options = options;
            this.p1 = p1;
            this.p2 = p2;
        }
        draw() { }
        drawBackground(target) {
            console.log(`[VolumeProfileRenderer] draw() called with rightSide: ${this.options.rightSide}`);
            target.useBitmapCoordinateSpace((scope) => {
                let ctx = scope.context;
                // Draw grid lines
                this._drawGrid(ctx, scope);
                setLineStyle(ctx, this.options.lineStyle);
                // Draw the volume profile bars
                this._data.items.forEach((row) => {
                    if (row.y1 === null || row.y2 === null)
                        return;
                    if (this._data.x === null)
                        return; // Ensure x-coordinate is valid
                    // Calculate rectangle position and dimensions
                    const rectY = Math.min(row.y1, row.y2) * scope.verticalPixelRatio;
                    const rectHeight = Math.abs(row.y2 - row.y1) * scope.verticalPixelRatio;
                    const combinedWidth = row.upWidth + row.downWidth;
                    const rectWidth = combinedWidth * scope.horizontalPixelRatio;
                    // Determine rectX based on rightSide
                    let rectX;
                    if (this.options.rightSide) {
                        // Render on the right side
                        rectX = (this._data.x - combinedWidth) * scope.horizontalPixelRatio;
                    }
                    else {
                        // Render on the left side
                        rectX = this._data.x * scope.horizontalPixelRatio;
                    }
                    // Dynamic radius calculation
                    const minRadius = 2; // Minimum radius in pixels
                    const maxRadius = 25; // Maximum radius in pixels
                    const percentage = 0.25; // 25% of the bar's height
                    const radius = Math.min(Math.max(rectHeight * percentage, minRadius), maxRadius);
                    if (rectHeight > 0) {
                        // Draw the border rectangle
                        ctx.beginPath();
                        this._drawRoundedRect(ctx, rectX, rectY, rectWidth, rectHeight, radius);
                        ctx.strokeStyle = row.borderColor;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        // Calculate fill dimensions
                        const fillWidth = Math.max(row.upWidth, row.downWidth) * scope.horizontalPixelRatio;
                        let fillX;
                        if (!this.options.rightSide) {
                            // Fill starts from the left of the bar
                            fillX = rectX;
                        }
                        else {
                            // Fill starts from the left minus fillWidth (i.e., from the right side)
                            fillX = rectX + (combinedWidth - fillWidth);
                        }
                        // Draw the filled rectangle representing greater volume
                        ctx.beginPath();
                        this._drawRoundedRect(ctx, fillX, rectY, fillWidth, rectHeight, radius);
                        ctx.fillStyle = row.color;
                        ctx.fill();
                    }
                });
            });
        }
        /**
         * Draw a grid within the volume profile region, aligning grid rows with sections.
         */
        _drawGrid(ctx, scope) {
            const { items, x } = this._data;
            if (!items || items.length === 0 || x === null)
                return;
            // Check if grid drawing is enabled
            if (!this.options.drawGrid)
                return;
            // Determine the grid width
            let gridWidth;
            if (this.options.gridWidth !== undefined && this.options.gridWidth !== 1) {
                // Use the specified gridWidth from options
                gridWidth = this.options.gridWidth * scope.horizontalPixelRatio;
            }
            else {
                gridWidth = (this._data.visibleRange.to - this._data.visibleRange.from) * scope.horizontalPixelRatio;
            }
            // Set grid line color
            ctx.strokeStyle = this.options.visible
                ? this.options.gridColor || "rgba(255, 255, 255, 0.2)"
                : "rgba(0,0,0,0)"; // Use gridColor from options or default
            // Use setLineStyle to configure grid line style
            setLineStyle(ctx, this.options.gridLineStyle || lightweightCharts.LineStyle.Solid);
            // Loop through each item to draw the grid lines individually with correct offset
            items.forEach((item) => {
                if (item.y1 === null || item.y2 === null)
                    return;
                // Calculate per-item X shift amount based on its upWidth and downWidth
                const shiftAmount = (item.upWidth + item.downWidth) * scope.horizontalPixelRatio;
                let gridStartX;
                let gridEndX;
                if (this.options.rightSide) {
                    gridStartX = (x - gridWidth);
                    gridEndX = x - shiftAmount;
                }
                else {
                    gridStartX = x + shiftAmount;
                    gridEndX = x + gridWidth;
                }
                // Scale Y-axis positions
                const y1 = item.y1 * scope.verticalPixelRatio;
                const y2 = item.y2 * scope.verticalPixelRatio;
                // Draw horizontal grid lines per item
                ctx.beginPath();
                ctx.moveTo(gridStartX, y1);
                ctx.lineTo(gridEndX, y1);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(gridStartX, y2);
                ctx.lineTo(gridEndX, y2);
                ctx.stroke();
            });
        }
        /**
         * Draws a rounded rectangle on the canvas context.
         * Rounds left corners if rightSide is true, otherwise rounds right corners.
         * @param ctx - Canvas rendering context.
         * @param x - The x-coordinate of the rectangle's starting point.
         * @param y - The y-coordinate of the rectangle's starting point.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param r - The radius for the rounded corners.
         * @param rightSide - Determines which corners to round.
         */
        _drawRoundedRect(ctx, x, y, w, h, r) {
            const rFinal = Math.abs(Math.min(r, w / 2, h / 2)); // Ensure radius doesn't exceed dimensions
            ctx.beginPath();
            if (w > 0 && r > 0) {
                if (this.options.rightSide) {
                    // Round top-left and bottom-left corners
                    ctx.moveTo(x + rFinal, y);
                    ctx.lineTo(x + w, y);
                    ctx.lineTo(x + w, y + h);
                    ctx.lineTo(x + rFinal, y + h);
                    ctx.arcTo(x, y + h, x, y + h - rFinal, rFinal);
                    ctx.lineTo(x, y + rFinal);
                    ctx.arcTo(x, y, x + rFinal, y, rFinal);
                }
                else {
                    // Round top-right and bottom-right corners
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + w - rFinal, y);
                    ctx.arcTo(x + w, y, x + w, y + rFinal, rFinal);
                    ctx.lineTo(x + w, y + h - rFinal);
                    ctx.arcTo(x + w, y + h, x + w - rFinal, y + h, rFinal);
                    ctx.lineTo(x, y + h);
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
            }
            else {
                return;
            }
        }
    }

    // Helper export function to calculate ATR
    /**
     * Compute Simple Moving Average (SMA) iteratively
     * @param data - Array of values
     * @param length - SMA period
     * @returns SMA value at the latest index
     */
    function getSma(data, length) {
        if (data.length < length)
            return NaN;
        let sum = 0;
        // Initialize first SMA window
        for (let i = 0; i < length; i++) {
            sum += data[i];
        }
        let sma = sum / length;
        // Compute SMA iteratively
        for (let i = length; i < data.length; i++) {
            sum = sum - data[i - length] + data[i];
            sma = sum / length;
        }
        return sma;
    }
    /**
     * Computes the Rolling Moving Average (RMA) for a data array.
     * @param data Array of values (gains, losses, or prices).
     * @param period RMA period (e.g., 14 for RSI).
     * @returns Array of RMA values, same length as `data`.
     */
    function getRma(data, period) {
        if (period <= 0) {
            // Defensive check
            return NaN;
        }
        const alpha = 1 / period;
        const rmaArr = new Array(data.length).fill(NaN);
        // We must start the initial average with the first data point (or first "period" average).
        // A common approach for RSI: use the first "period" items' average.
        // But for simplicity, let's start from the first item:
        if (data.length > 0) {
            let avg = data[0]; // Start with the first data point
            rmaArr[0] = avg;
            for (let i = 1; i < data.length; i++) {
                avg = alpha * data[i] + (1 - alpha) * avg;
                rmaArr[i] = avg;
            }
        }
        return rmaArr[rmaArr.length - 1];
    }
    function getLinreg(data, period, offset = 0) {
        if (data.length < period)
            return NaN;
        const subset = data.slice(data.length - period);
        const n = period;
        const sumX = (n * (n - 1)) / 2;
        const sumY = subset.reduce((sum, val) => sum + val, 0);
        const sumXY = subset.reduce((sum, val, idx) => sum + idx * val, 0);
        const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        return intercept + slope * (n - 1);
    }
    /**
     * Computes the Relative Strength Index (RSI).
     * @param data - Array of closing prices.
     * @param length - RSI period.
     * @returns RSI value at the latest index.
     */
    function getRsi(data, length) {
        if (data.length < length)
            return NaN;
        let changeArray = data.map((val, idx) => (idx === 0 ? 0 : val - data[idx - 1]));
        let upMoves = changeArray.map(val => Math.max(val, 0));
        let downMoves = changeArray.map(val => Math.max(-val, 0));
        let avgGain = getRma(upMoves, length); // Use Rolling Moving Average for smoothing
        let avgLoss = getRma(downMoves, length);
        if (avgLoss === 0)
            return 100; // Avoid division by zero
        if (avgGain === 0)
            return 0;
        let rs = avgGain / avgLoss;
        return 100 - 100 / (1 + rs);
    }
    /**
    * Applies color attributes to each data point in a histogram series.
    * For the first point, the upColor is used.
    * For each subsequent point, if the current value is greater than or equal
    * to the previous value, upColor is used; otherwise, downColor is used.
    *
    * @param data - Array of data points with at least { time, value }.
    * @param upColor - Color to use when the value is rising (default: 'green').
    * @param downColor - Color to use when the value is falling (default: 'red').
    */
    function setHistogramColors(data, upColor, downColor) {
        for (let i = 0; i < data.length; i++) {
            if (i === 0) {
                data[i].color = upColor;
            }
            else {
                const currentValue = data[i].value;
                const previousValue = data[i - 1].value;
                if (!isNaN(currentValue) && !isNaN(previousValue)) {
                    data[i].color = currentValue >= previousValue ? upColor : downColor;
                }
                else {
                    data[i].color = upColor;
                }
            }
        }
    }
    /************************************************
     * Helper: getNumericArray
     * Ensures the override for a param is an array of numbers.
     * If the user passes a single number, we wrap it.
     ************************************************/
    function getNumericArray(overrideParams, paramName, defaultArr) {
        const val = overrideParams && paramName in overrideParams
            ? overrideParams[paramName]
            : defaultArr;
        return Array.isArray(val) ? val.map(x => Number(x)) : [Number(val)];
    }
    /************************************************
     * Helper: pickParam
     * For figure index i (0-based), pick arr[i] if exists; otherwise, repeat last.
     ************************************************/
    function pickParam(arr, i) {
        return i < arr.length ? arr[i] : arr[arr.length - 1];
    }
    /**
     * A helper function to retrieve (paramMap + overrideParams) for each param key.
     */
    function getParams(definition, overrideParams) {
        const combined = {};
        for (const [paramName, spec] of Object.entries(definition.paramMap)) {
            const val = overrideParams?.[paramName] ?? spec.defaultValue;
            combined[paramName] = val;
        }
        return combined;
    }

    /************************************************
     * 1) Arnaud Legoux Moving Average (ALMA)
     *    Parameters: length, offset, sigma
     *    Title is set as ALMA{length} (e.g. "ALMA9")
     ************************************************/
    const arnaudLegouxMovingAverage = {
        name: "Arnaud Legoux Moving Average",
        shortName: "ALMA",
        shouldOhlc: false,
        paramMap: {
            length: { defaultValue: [9], type: "numberArray" },
            offset: { defaultValue: [0.85], type: "numberArray" },
            sigma: { defaultValue: [6], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const defLength = this.paramMap.length.defaultValue;
            const defOffset = this.paramMap.offset.defaultValue;
            const defSigma = this.paramMap.sigma.defaultValue;
            const lenArr = getNumericArray(overrideParams, "length", defLength);
            const offArr = getNumericArray(overrideParams, "offset", defOffset);
            const sigArr = getNumericArray(overrideParams, "sigma", defSigma);
            const figureCount = Math.max(lenArr.length, offArr.length, sigArr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const length = pickParam(lenArr, i);
                const offset = pickParam(offArr, i);
                const sigma = pickParam(sigArr, i);
                const almaArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < length - 1) {
                        almaArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    let norm = 0, sum = 0;
                    const m = offset * (length - 1);
                    const s = length / sigma;
                    for (let j = 0; j < length; j++) {
                        const weight = Math.exp(-Math.pow(j - m, 2) / (2 * Math.pow(s, 2)));
                        norm += weight;
                        const index2 = idx - (length - 1) + j;
                        sum += dataList[index2].close * weight;
                    }
                    almaArr.push({ time: bar.time, value: sum / norm });
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                // Title follows the old EMA logic: ALMA + the length value (e.g. "ALMA9")
                const key = "alma" + suffix;
                const title = "ALMA" + length + (figureCount > 1 ? ` #${i + 1}` : "");
                results.push({
                    key,
                    title,
                    type: "line",
                    data: almaArr,
                });
            }
            return results;
        },
    };
    /************************************************
     * 2) Bollinger Bands (BOLL)
     *    Parameters: length, multiplier
     *    For each figure, 3 lines are produced (UP, MID, DN).
     *    Titles are set as BOLL_UP{length} etc.
     ************************************************/
    const getBollMd = (subset, mid) => {
        let sum = 0;
        subset.forEach(bar => {
            const diff = bar.close - mid;
            sum += diff * diff;
        });
        return Math.sqrt(sum / subset.length);
    };
    const bollingerBands = {
        name: "Bollinger Bands",
        shortName: "BOLL",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [20], type: "numberArray" },
            multiplier: { defaultValue: [2], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const pArr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const mArr = getNumericArray(overrideParams, "multiplier", this.paramMap.multiplier.defaultValue);
            const figureCount = Math.max(pArr.length, mArr.length);
            const allFigs = [];
            for (let i = 0; i < figureCount; i++) {
                const length = pickParam(pArr, i);
                const multiplier = pickParam(mArr, i);
                let closeSum = 0;
                const upArr = [];
                const midArr = [];
                const dnArr = [];
                dataList.forEach((bar, idx) => {
                    closeSum += bar.close;
                    if (idx >= length - 1) {
                        const mid = closeSum / length;
                        const windowData = dataList.slice(idx - (length - 1), idx + 1);
                        const md = getBollMd(windowData, mid);
                        upArr.push({ time: bar.time, value: mid + multiplier * md });
                        midArr.push({ time: bar.time, value: mid });
                        dnArr.push({ time: bar.time, value: mid - multiplier * md });
                        closeSum -= dataList[idx - (length - 1)].close;
                    }
                    else {
                        upArr.push({ time: bar.time, value: NaN });
                        midArr.push({ time: bar.time, value: NaN });
                        dnArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                allFigs.push({
                    key: `boll_up${suffix}`,
                    title: `BOLL_UP${length}${suffix}`,
                    type: "line",
                    data: upArr,
                });
                allFigs.push({
                    key: `boll_mid${suffix}`,
                    title: `BOLL_MID${length}${suffix}`,
                    type: "line",
                    data: midArr,
                });
                allFigs.push({
                    key: `boll_dn${suffix}`,
                    title: `BOLL_DN${length}${suffix}`,
                    type: "line",
                    data: dnArr,
                });
            }
            return allFigs;
        },
    };
    /************************************************
     * 3) Exponential Moving Average (EMA)
     *    Parameter: length (array)
     *    Title: "EMA" concatenated with the length value (e.g. "EMA12")
     ************************************************/
    const exponentialMovingAverage = {
        name: "Exponential Moving Average",
        shortName: "EMA",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [6, 12, 20], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                let emaVal = 0, sum = 0;
                const dataOut = [];
                dataList.forEach((bar, idx) => {
                    sum += bar.close;
                    if (idx === val - 1) {
                        emaVal = sum / val;
                    }
                    else if (idx > val - 1) {
                        const multiplier = 2 / (val + 1);
                        emaVal = (bar.close - emaVal) * multiplier + emaVal;
                    }
                    if (idx >= val - 1) {
                        dataOut.push({ time: bar.time, value: emaVal });
                        sum -= dataList[idx - (val - 1)].close;
                    }
                    else {
                        dataOut.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "ema" + suffix;
                // Title is the short name followed immediately by the length value
                const title = "EMA" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: dataOut });
            });
            return figs;
        },
    };
    /************************************************
     * 4) Highest High (HH)
     *    Parameter: length (array)
     *    Title: "HH" concatenated with the length value (e.g. "HH14")
     ************************************************/
    const highestHigh = {
        name: "Highest High",
        shortName: "HH",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const out = [];
            arr.forEach((val, i) => {
                const hhArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < val - 1) {
                        hhArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    let highest = -Infinity;
                    for (let j = idx - (val - 1); j <= idx; j++) {
                        highest = Math.max(highest, dataList[j].high);
                    }
                    hhArr.push({ time: bar.time, value: highest });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "hh" + suffix;
                const title = "HH" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                out.push({ key, title, type: "line", data: hhArr });
            });
            return out;
        },
    };
    /************************************************
     * 5) Linear Regression (LINREG)
     *    Parameter: length (array)
     *    Title: "LINREG" concatenated with the length value (e.g. "LINREG14")
     ************************************************/
    const linRegIndicator = {
        name: "Linear Regression",
        shortName: "LINREG",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const closeArr = dataList.map(b => b.close);
            const figs = [];
            arr.forEach((val, i) => {
                const linRegArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < val - 1) {
                        linRegArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const slice = closeArr.slice(idx - (val - 1), idx + 1);
                    const linVal = getLinreg(slice, val, 0);
                    linRegArr.push({ time: bar.time, value: linVal });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "linreg" + suffix;
                const title = "LINREG" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: linRegArr });
            });
            return figs;
        },
    };
    /************************************************
     * 6) Lowest Low (LL)
     *    Parameter: length (array)
     *    Title: "LL" concatenated with the length value (e.g. "LL14")
     ************************************************/
    const lowestLow = {
        name: "Lowest Low",
        shortName: "LL",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                const llArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < val - 1) {
                        llArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    let lowest = Infinity;
                    for (let j = idx - (val - 1); j <= idx; j++) {
                        lowest = Math.min(lowest, dataList[j].low);
                    }
                    llArr.push({ time: bar.time, value: lowest });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "ll" + suffix;
                const title = "LL" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: llArr });
            });
            return figs;
        },
    };
    /************************************************
     * 7) Median
     *    Parameter: length (array)
     *    Title: "Median" concatenated with the length value (e.g. "Median14")
     ************************************************/
    const median = {
        name: "Median",
        shortName: "Median",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                const medArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < val - 1) {
                        medArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const subset = dataList.slice(idx - (val - 1), idx + 1).map(b => b.close);
                    subset.sort((a, b) => a - b);
                    const mid = Math.floor(subset.length / 2);
                    const medianVal = subset.length % 2 === 0
                        ? (subset[mid - 1] + subset[mid]) / 2
                        : subset[mid];
                    medArr.push({ time: bar.time, value: medianVal });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "median" + suffix;
                const title = "Median" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: medArr });
            });
            return figs;
        },
    };
    /************************************************
     * 8) Moving Average (MA)
     *    Parameter: length (array) (4 values originally)
     *    Title: "MA" concatenated with the length value (e.g. "MA5")
     ************************************************/
    const movingAverage = {
        name: "Moving Average",
        shortName: "MA",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [5, 10, 30, 60], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                const maArr = [];
                let sum = 0;
                dataList.forEach((bar, idx) => {
                    sum += bar.close;
                    if (idx >= val - 1) {
                        const avg = sum / val;
                        maArr.push({ time: bar.time, value: avg });
                        sum -= dataList[idx - (val - 1)].close;
                    }
                    else {
                        maArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "ma" + suffix;
                const title = "MA" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: maArr });
            });
            return figs;
        },
    };
    /************************************************
     * 9) Rolling Moving Average (RMA)
     *    Parameter: length (array)
     *    Title: "RMA" concatenated with the length value (e.g. "RMA14")
     ************************************************/
    const rollingMovingAverage = {
        name: "Rolling Moving Average",
        shortName: "RMA",
        shouldOhlc: false,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                const alpha = 1 / val;
                let sum = 0;
                const rmaArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx === 0) {
                        sum = bar.close;
                    }
                    else {
                        sum = alpha * bar.close + (1 - alpha) * sum;
                    }
                    rmaArr.push({ time: bar.time, value: sum });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "rma" + suffix;
                const title = "RMA" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: rmaArr });
            });
            return figs;
        },
    };
    /************************************************
     * 10) Simple Moving Average (SMA)
     *    Parameters: n, k (both as arrays)
     *    Title: "SMA" concatenated with n value (e.g. "SMA12,2")
     ************************************************/
    const simpleMovingAverage = {
        name: "Simple Moving Average",
        shortName: "SMA",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [12], type: "numberArray" },
            k: { defaultValue: [2], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", this.paramMap.n.defaultValue);
            const kArr = getNumericArray(overrideParams, "k", this.paramMap.k.defaultValue);
            const figureCount = Math.max(nArr.length, kArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const nVal = pickParam(nArr, i);
                const kVal = pickParam(kArr, i);
                let closeSum = 0;
                let smaVal = 0;
                const smaArr = [];
                dataList.forEach((bar, idx) => {
                    closeSum += bar.close;
                    if (idx >= nVal - 1) {
                        if (idx === nVal - 1) {
                            smaVal = closeSum / nVal;
                        }
                        else {
                            smaVal = (bar.close * kVal + smaVal * (nVal - kVal)) / nVal;
                        }
                        closeSum -= dataList[idx - (nVal - 1)].close;
                        smaArr.push({ time: bar.time, value: smaVal });
                    }
                    else {
                        smaArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                const key = "sma" + suffix;
                const title = "SMA" + nVal + "," + kVal + (figureCount > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: smaArr });
            }
            return figs;
        },
    };
    /************************************************
     * 11) Stop and Reverse (SAR)
     *    Parameters: accStart, accStep, accMax (arrays)
     *    Title: "SAR" concatenated with accStart value (e.g. "SAR0.02,0.02,0.20")
     ************************************************/
    const stopAndReverse = {
        name: "Stop and Reverse",
        shortName: "SAR",
        shouldOhlc: true,
        paramMap: {
            accStart: { defaultValue: [0.02], type: "numberArray" },
            accStep: { defaultValue: [0.02], type: "numberArray" },
            accMax: { defaultValue: [0.20], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const startArr = getNumericArray(overrideParams, "accStart", this.paramMap.accStart.defaultValue);
            const stepArr = getNumericArray(overrideParams, "accStep", this.paramMap.accStep.defaultValue);
            const maxArr = getNumericArray(overrideParams, "accMax", this.paramMap.accMax.defaultValue);
            const figureCount = Math.max(startArr.length, stepArr.length, maxArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const accStart = pickParam(startArr, i);
                const accStep = pickParam(stepArr, i);
                const accMax = pickParam(maxArr, i);
                let af = accStart;
                let ep = 0;
                let sarVal = 0;
                let isUp = false;
                const sarArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx === 0) {
                        sarArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    if (idx === 1) {
                        isUp = bar.close > dataList[0].close;
                        ep = isUp ? bar.high : bar.low;
                        sarVal = isUp ? dataList[0].low : dataList[0].high;
                        sarArr.push({ time: dataList[0].time, value: sarVal });
                    }
                    sarVal = sarVal + af * (ep - sarVal);
                    if (isUp) {
                        if (bar.low < sarVal) {
                            isUp = false;
                            sarVal = ep;
                            af = accStart;
                            ep = bar.low;
                        }
                        else {
                            if (bar.high > ep) {
                                ep = bar.high;
                                af = Math.min(af + accStep, accMax);
                            }
                        }
                    }
                    else {
                        if (bar.high > sarVal) {
                            isUp = true;
                            sarVal = ep;
                            af = accStart;
                            ep = bar.high;
                        }
                        else {
                            if (bar.low < ep) {
                                ep = bar.low;
                                af = Math.min(af + accStep, accMax);
                            }
                        }
                    }
                    sarArr.push({ time: bar.time, value: sarVal });
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                const key = "sar" + suffix;
                const title = "SAR" + accStart + "," + accStep + "," + accMax + (figureCount > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: sarArr });
            }
            return figs;
        },
    };
    /************************************************
     * 12) Super Trend
     *    Parameters: factor, atrPeriod (arrays)
     *    Title: "SuperTrend" concatenated with factor (e.g. "SuperTrend3")
     *    (Note: Two lines are produced per figure: one for the trend and one for the direction.)
     ************************************************/
    const superTrend = {
        name: "Super Trend",
        shortName: "SuperTrend",
        shouldOhlc: true,
        paramMap: {
            factor: { defaultValue: [3], type: "numberArray" },
            atrPeriod: { defaultValue: [10], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const factorArr = getNumericArray(overrideParams, "factor", this.paramMap.factor.defaultValue);
            const atrArr = getNumericArray(overrideParams, "atrPeriod", this.paramMap.atrPeriod.defaultValue);
            const figureCount = Math.max(factorArr.length, atrArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const factor = pickParam(factorArr, i);
                const length = pickParam(atrArr, i); // atrPeriod renamed to length here for unification
                const stArr = [];
                const dirArr = [];
                let prevSuperTrend = NaN;
                let prevUpperBand = NaN;
                let prevLowerBand = NaN;
                let direction = NaN;
                dataList.forEach((bar, idx) => {
                    if (idx < length - 1) {
                        stArr.push({ time: bar.time, value: NaN });
                        dirArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    // Compute ATR over the last 'length' bars
                    let sumTR = 0;
                    for (let k = idx - (length - 1); k <= idx; k++) {
                        const prevClose = dataList[k - 1]?.close ?? dataList[k].close;
                        const cTr = Math.max(dataList[k].high - dataList[k].low, Math.abs(dataList[k].high - prevClose), Math.abs(dataList[k].low - prevClose));
                        sumTR += cTr;
                    }
                    const atr = sumTR / length;
                    const src = (bar.high + bar.low) / 2;
                    let upperBand = src + factor * atr;
                    let lowerBand = src - factor * atr;
                    if (!isNaN(prevLowerBand)) {
                        lowerBand = lowerBand > prevLowerBand || dataList[idx - 1].close < prevLowerBand
                            ? lowerBand
                            : prevLowerBand;
                    }
                    if (!isNaN(prevUpperBand)) {
                        upperBand = upperBand < prevUpperBand || dataList[idx - 1].close > prevUpperBand
                            ? upperBand
                            : prevUpperBand;
                    }
                    if (isNaN(prevSuperTrend)) {
                        direction = 1;
                    }
                    else if (prevSuperTrend === prevUpperBand) {
                        direction = bar.close > upperBand ? -1 : 1;
                    }
                    else {
                        direction = bar.close < lowerBand ? 1 : -1;
                    }
                    const stVal = direction === -1 ? lowerBand : upperBand;
                    stArr.push({ time: bar.time, value: stVal });
                    dirArr.push({ time: bar.time, value: direction });
                    prevSuperTrend = stVal;
                    prevUpperBand = upperBand;
                    prevLowerBand = lowerBand;
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "superTrend" + suffix,
                    title: "SuperTrend" + factor + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: stArr,
                });
                figs.push({
                    key: "direction" + suffix,
                    title: "Direction" + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: dirArr,
                });
            }
            return figs;
        },
    };
    /************************************************
     * 13) Symmetric Weighted Moving Average (SWMA)
     *    Parameter: window (array)
     *    Title: "SWMA" concatenated with the window (e.g. "SWMA4")
     ************************************************/
    const symmetricWeightedMovingAverage = {
        name: "Symmetrically Weighted Moving Average",
        shortName: "SWMA",
        shouldOhlc: false,
        paramMap: {
            window: { defaultValue: [4], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const windowArr = getNumericArray(overrideParams, "window", this.paramMap.window.defaultValue);
            const figs = [];
            windowArr.forEach((win, i) => {
                const swmaArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < win - 1) {
                        swmaArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    let numerator = 0, denominator = 0;
                    for (let j = 0; j < win; j++) {
                        const weight = j + 1;
                        numerator += dataList[idx - (win - 1) + j].close * weight;
                        denominator += weight;
                    }
                    swmaArr.push({ time: bar.time, value: numerator / denominator });
                });
                const suffix = windowArr.length > 1 ? `_${i + 1}` : "";
                const key = "swma" + suffix;
                const title = "SWMA" + win + (windowArr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: swmaArr });
            });
            return figs;
        },
    };
    /************************************************
     * 14) Triple Exponentially Smoothed Average (TRIX)
     *    Parameters: n, m (arrays)
     *    Title: "TRIX" concatenated with n value (e.g. "TRIX12")
     *    Produces 2 lines: one for TRIX and one for its moving average ("MATRIX")
     ************************************************/
    const tripleExponentiallySmoothedAverage = {
        name: "TRIX",
        shortName: "TRIX",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [12], type: "numberArray" },
            m: { defaultValue: [9], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", this.paramMap.n.defaultValue);
            const mArr = getNumericArray(overrideParams, "m", this.paramMap.m.defaultValue);
            const figureCount = Math.max(nArr.length, mArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const N = pickParam(nArr, i);
                const M = pickParam(mArr, i);
                let ema1 = 0, ema2 = 0, ema3 = 0;
                let sumClose = 0;
                const trixArr = [];
                const maTrixArr = [];
                let trixSum = 0;
                const buffer = [];
                dataList.forEach((bar, idx) => {
                    sumClose += bar.close;
                    if (idx === N - 1) {
                        ema1 = sumClose / N;
                    }
                    else if (idx > N - 1) {
                        ema1 = (bar.close * 2 + (N - 1) * ema1) / (N + 1);
                    }
                    if (idx >= N - 1) {
                        if (idx === 2 * N - 2) {
                            ema2 = ema1;
                        }
                        else if (idx > 2 * N - 2) {
                            ema2 = (ema1 * 2 + (N - 1) * ema2) / (N + 1);
                        }
                    }
                    let trVal = NaN;
                    if (idx >= 2 * N - 2) {
                        if (idx === 3 * N - 3) {
                            ema3 = ema2;
                        }
                        else if (idx > 3 * N - 3) {
                            const old = ema3;
                            ema3 = (ema2 * 2 + (N - 1) * old) / (N + 1);
                            trVal = ((ema3 - old) / old) * 100;
                        }
                    }
                    trixArr.push({ time: bar.time, value: trVal });
                    buffer.push(trVal);
                    trixSum += isNaN(trVal) ? 0 : trVal;
                    if (buffer.length > M) {
                        const oldest = buffer[buffer.length - 1 - M];
                        trixSum -= isNaN(oldest) ? 0 : oldest;
                    }
                    const maVal = buffer.length >= M && !isNaN(trVal) ? trixSum / M : NaN;
                    maTrixArr.push({ time: bar.time, value: maVal });
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "trix" + suffix,
                    title: "TRIX" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: trixArr,
                });
                figs.push({
                    key: "maTrix" + suffix,
                    title: figureCount > 1 ? `MATRIX #${i + 1}` : "MATRIX",
                    type: "line",
                    data: maTrixArr,
                });
            }
            return figs;
        },
    };
    /************************************************
     * 15) Volume Weighted Average Price (VWAP)
     *    Parameter: anchorInterval (array)
     *    Title: "VWAP" concatenated with anchorInterval (e.g. "VWAP1")
     ************************************************/
    const volumeWeightedAveragePrice = {
        name: "Volume Weighted Average Price",
        shortName: "VWAP",
        shouldOhlc: true,
        paramMap: {
            anchorInterval: { defaultValue: [1], type: "numberArray" },
        },
        calc(dataList, overrideParams, volumeData) {
            if (!volumeData) {
                return [
                    { key: "vwap", title: "VWAP", type: "line", data: [] }
                ];
            }
            const arr = getNumericArray(overrideParams, "anchorInterval", this.paramMap.anchorInterval.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                let cumulativeVolume = 0, cumulativeVWAP = 0;
                const vwapArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx % val === 0) {
                        cumulativeVolume = 0;
                        cumulativeVWAP = 0;
                    }
                    const volume = volumeData[idx]?.value ?? 0;
                    const typicalPrice = (bar.high + bar.low + bar.close) / 3;
                    cumulativeVWAP += typicalPrice * volume;
                    cumulativeVolume += volume;
                    const vwapVal = cumulativeVolume !== 0 ? cumulativeVWAP / cumulativeVolume : NaN;
                    vwapArr.push({ time: bar.time, value: vwapVal });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "vwap" + suffix,
                    title: "VWAP" + val + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: vwapArr,
                });
            });
            return figs;
        },
    };
    /************************************************
     * 16) Volume Weighted Moving Average (VWMA)
     *    Parameter: length (array)
     *    Title: "VWMA" concatenated with the length value (e.g. "VWMA20")
     ************************************************/
    const volumeWeightedMovingAverage = {
        name: "Volume Weighted Moving Average",
        shortName: "VWMA",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [20], type: "numberArray" },
        },
        calc(dataList, overrideParams, volumeData) {
            if (!volumeData) {
                return [
                    { key: "vwma", title: "VWMA", type: "line", data: [] }
                ];
            }
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                let sumVolumePrice = 0, sumVolume = 0;
                const vwmaArr = [];
                dataList.forEach((bar, idx) => {
                    const volume = volumeData[idx]?.value ?? 0;
                    sumVolumePrice += bar.close * volume;
                    sumVolume += volume;
                    if (idx >= val - 1) {
                        const avg = sumVolume !== 0 ? sumVolumePrice / sumVolume : NaN;
                        vwmaArr.push({ time: bar.time, value: avg });
                        const oldVolume = volumeData[idx - (val - 1)].value ?? 0;
                        sumVolumePrice -= dataList[idx - (val - 1)].close * oldVolume;
                        sumVolume -= oldVolume;
                    }
                    else {
                        vwmaArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "vwma" + suffix,
                    title: "VWMA" + val + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: vwmaArr,
                });
            });
            return figs;
        },
    };
    /************************************************
     * 17) Weighted Moving Average (WMA)
     *    Parameter: length (array)
     *    Title: "WMA" concatenated with the length value (e.g. "WMA9")
     ************************************************/
    const weightedMovingAverage = {
        name: "Weighted Moving Average",
        shortName: "WMA",
        shouldOhlc: false,
        paramMap: {
            length: { defaultValue: [9], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                const wmaArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < val - 1) {
                        wmaArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    let norm = 0, sum = 0;
                    for (let j = 0; j < val; j++) {
                        const weight = val - j;
                        norm += weight;
                        sum += dataList[idx - j].close * weight;
                    }
                    wmaArr.push({ time: bar.time, value: sum / norm });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "wma" + suffix,
                    title: "WMA" + val + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: wmaArr,
                });
            });
            return figs;
        },
    };
    const highestHighLowestLow = {
        name: "High & Low",
        shortName: "HHLL",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            // Get the length values (as an array of numbers)
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                const hhArr = [];
                const llArr = [];
                // Iterate through each data bar to compute both HH and LL
                dataList.forEach((bar, idx) => {
                    if (idx < val - 1) {
                        hhArr.push({ time: bar.time, value: NaN });
                        llArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    let highest = -Infinity;
                    let lowest = Infinity;
                    for (let j = idx - (val - 1); j <= idx; j++) {
                        highest = Math.max(highest, dataList[j].high);
                        lowest = Math.min(lowest, dataList[j].low);
                    }
                    hhArr.push({ time: bar.time, value: highest });
                    llArr.push({ time: bar.time, value: lowest });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "hh" + suffix,
                    title: "HH" + val + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: hhArr,
                });
                figs.push({
                    key: "ll" + suffix,
                    title: "LL" + val + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: llArr,
                });
            });
            return figs;
        },
    };
    const OVERLAYS = [
        // Overlay Indicators
        arnaudLegouxMovingAverage,
        bollingerBands,
        exponentialMovingAverage,
        highestHigh,
        highestHighLowestLow,
        linRegIndicator,
        lowestLow,
        median,
        movingAverage,
        rollingMovingAverage,
        simpleMovingAverage,
        stopAndReverse,
        superTrend,
        symmetricWeightedMovingAverage,
        tripleExponentiallySmoothedAverage,
        volumeWeightedAveragePrice,
        volumeWeightedMovingAverage,
        weightedMovingAverage,
        // Oscillator Indicators (unchanged)
    ];

    /*
      Partial Integration of KLineCharts' Indicators with Lightweight Charts
      ===============================================================

    */
    /************************************************
     * Oscillator Indicators (other than MACD)
     ************************************************/
    /* 1) awesomeOscillator */
    const awesomeOscillator = {
        name: "Awesome Oscillator",
        shortName: "AO",
        shouldOhlc: true,
        paramMap: {
            shortPeriod: { defaultValue: [5], type: "numberArray", min: 1, max: 100 },
            longPeriod: { defaultValue: [34], type: "numberArray", min: 1, max: 200 },
        },
        calc(dataList, overrideParams) {
            const shortArr = getNumericArray(overrideParams, "shortPeriod", [5]);
            const longArr = getNumericArray(overrideParams, "longPeriod", [34]);
            const figureCount = Math.max(shortArr.length, longArr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const shortP = pickParam(shortArr, i);
                const longP = pickParam(longArr, i);
                const maxP = Math.max(shortP, longP);
                let shortSum = 0, longSum = 0;
                const aoArr = [];
                dataList.forEach((bar, idx) => {
                    const mid = (bar.high + bar.low) / 2;
                    shortSum += mid;
                    longSum += mid;
                    let sMa = NaN, lMa = NaN;
                    if (idx >= shortP - 1) {
                        sMa = shortSum / shortP;
                        const removeVal = (dataList[idx - (shortP - 1)].high + dataList[idx - (shortP - 1)].low) / 2;
                        shortSum -= removeVal;
                    }
                    if (idx >= longP - 1) {
                        lMa = longSum / longP;
                        const removeVal = (dataList[idx - (longP - 1)].high + dataList[idx - (longP - 1)].low) / 2;
                        longSum -= removeVal;
                    }
                    let aoVal = NaN;
                    if (idx >= maxP - 1) {
                        aoVal = sMa - lMa;
                    }
                    aoArr.push({ time: bar.time, value: aoVal });
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                const key = "ao" + suffix;
                const title = "AO" + pickParam(shortArr, i) + (figureCount > 1 ? ` #${i + 1}` : "");
                // Optional color parameters remain unchanged.
                const upColor = overrideParams?.upColor ?? "green";
                const downColor = overrideParams?.downColor ?? "red";
                setHistogramColors(aoArr, upColor, downColor);
                results.push({
                    key,
                    title,
                    type: "histogram",
                    data: aoArr,
                    pane: 1
                });
            }
            return results;
        },
    };
    /* 2) Average True Range (ATR) */
    const averageTrueRange = {
        name: "Average True Range",
        shortName: "ATR",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray", min: 1, max: 100 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [14]);
            const results = [];
            arr.forEach((length, i) => {
                const atrArr = [];
                let sumTR = 0;
                const trValues = [];
                dataList.forEach((bar, idx) => {
                    if (idx === 0) {
                        atrArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const prevClose = dataList[idx - 1].close;
                    const tr = Math.max(bar.high - bar.low, Math.abs(bar.high - prevClose), Math.abs(bar.low - prevClose));
                    trValues.push(tr);
                    sumTR += tr;
                    if (trValues.length > length) {
                        sumTR -= trValues.shift();
                    }
                    const atrVal = trValues.length >= length ? sumTR / length : NaN;
                    atrArr.push({ time: bar.time, value: atrVal });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "atr" + suffix,
                    title: "ATR" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: atrArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 3) Bias */
    const bias = {
        name: "Bias",
        shortName: "BIAS",
        shouldOhlc: true,
        paramMap: {
            period1: { defaultValue: [6], type: "numberArray", min: 1, max: 999 },
            period2: { defaultValue: [12], type: "numberArray", min: 1, max: 999 },
            period3: { defaultValue: [24], type: "numberArray", min: 1, max: 999 },
        },
        calc(dataList, overrideParams) {
            const p1Arr = getNumericArray(overrideParams, "period1", [6]);
            const p2Arr = getNumericArray(overrideParams, "period2", [12]);
            const p3Arr = getNumericArray(overrideParams, "period3", [24]);
            const figureCount = Math.max(p1Arr.length, p2Arr.length, p3Arr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const p1 = pickParam(p1Arr, i);
                const p2 = pickParam(p2Arr, i);
                const p3 = pickParam(p3Arr, i);
                const arrP = [p1, p2, p3];
                const sums = arrP.map(() => 0);
                // Produce three lines in one set
                const figs = arrP.map((val, idx) => ({
                    key: `bias${idx + 1}` + (figureCount > 1 ? `_${i + 1}` : ""),
                    title: `BIAS${val}` + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: [],
                    pane: 1
                }));
                dataList.forEach((bar, idx) => {
                    const c = bar.close;
                    arrP.forEach((period, j) => {
                        sums[j] += c;
                        if (idx >= period - 1) {
                            const mean = sums[j] / period;
                            const biasVal = ((c - mean) / mean) * 100;
                            figs[j].data.push({ time: bar.time, value: biasVal });
                            sums[j] -= dataList[idx - (period - 1)].close;
                        }
                        else {
                            figs[j].data.push({ time: bar.time, value: NaN });
                        }
                    });
                });
                results.push(...figs);
            }
            return results;
        },
    };
    /* 4) BRAR (Buy-Ratio Analysis) */
    const brar = {
        name: "Buy-Ratio Analysis",
        shortName: "BRAR",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [26], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [26]);
            const results = [];
            arr.forEach((length, i) => {
                let hcy = 0, cyl = 0, ho = 0, ol = 0;
                const brData = [];
                const arData = [];
                dataList.forEach((bar, idx) => {
                    const prev = idx - 1 >= 0 ? dataList[idx - 1] : bar;
                    ho += bar.high - bar.open;
                    ol += bar.open - bar.low;
                    hcy += bar.high - prev.close;
                    cyl += prev.close - bar.low;
                    if (idx >= length - 1) {
                        const brVal = cyl !== 0 ? (hcy / cyl) * 100 : 0;
                        const arVal = ol !== 0 ? (ho / ol) * 100 : 0;
                        brData.push({ time: bar.time, value: brVal });
                        arData.push({ time: bar.time, value: arVal });
                        const oldBar = dataList[idx - (length - 1)];
                        const oldPrev = idx - length >= 0 ? dataList[idx - length] : oldBar;
                        hcy -= (oldBar.high - oldPrev.close);
                        cyl -= (oldPrev.close - oldBar.low);
                        ho -= (oldBar.high - oldBar.open);
                        ol -= (oldBar.open - oldBar.low);
                    }
                    else {
                        brData.push({ time: bar.time, value: NaN });
                        arData.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "br" + suffix,
                    title: "BR" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: brData,
                    pane: 1
                });
                results.push({
                    key: "ar" + suffix,
                    title: "AR" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: arData,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 5) Bull and Bear Index (BBI) */
    const bullAndBearIndex = {
        name: "Bull and Bear Index",
        shortName: "BBI",
        shouldOhlc: true,
        paramMap: {
            p1: { defaultValue: [3], type: "numberArray", min: 1 },
            p2: { defaultValue: [6], type: "numberArray", min: 1 },
            p3: { defaultValue: [12], type: "numberArray", min: 1 },
            p4: { defaultValue: [24], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const p1Arr = getNumericArray(overrideParams, "p1", [3]);
            const p2Arr = getNumericArray(overrideParams, "p2", [6]);
            const p3Arr = getNumericArray(overrideParams, "p3", [12]);
            const p4Arr = getNumericArray(overrideParams, "p4", [24]);
            const figureCount = Math.max(p1Arr.length, p2Arr.length, p3Arr.length, p4Arr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const p1 = pickParam(p1Arr, i);
                const p2 = pickParam(p2Arr, i);
                const p3 = pickParam(p3Arr, i);
                const p4 = pickParam(p4Arr, i);
                const params = [p1, p2, p3, p4];
                const sums = [0, 0, 0, 0];
                const mas = [0, 0, 0, 0];
                const bbiArr = [];
                dataList.forEach((bar, idx) => {
                    const c = bar.close;
                    params.forEach((pVal, j) => {
                        sums[j] += c;
                        if (idx >= pVal - 1) {
                            mas[j] = sums[j] / pVal;
                            sums[j] -= dataList[idx - (pVal - 1)].close;
                        }
                    });
                    if (idx >= Math.max(...params) - 1) {
                        const val = (mas[0] + mas[1] + mas[2] + mas[3]) / 4;
                        bbiArr.push({ time: bar.time, value: val });
                    }
                    else {
                        bbiArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "bbi" + suffix,
                    title: "BBI" + [p1, p2, p3, p4].join(",") + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: bbiArr,
                    pane: 1
                });
            }
            return results;
        },
    };
    /* 6) Commodity Channel Index (CCI) */
    const commodityChannelIndex = {
        name: "Commodity Channel Index",
        shortName: "CCI",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [20], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [20]);
            const results = [];
            arr.forEach((length, i) => {
                let tpSum = 0;
                const tpList = [];
                const cciArr = [];
                dataList.forEach((bar, idx) => {
                    const tp = (bar.high + bar.low + bar.close) / 3;
                    tpSum += tp;
                    tpList.push(tp);
                    if (idx >= length - 1) {
                        const maTp = tpSum / length;
                        let sumAbs = 0;
                        for (let j = idx - (length - 1); j <= idx; j++) {
                            sumAbs += Math.abs(tpList[j] - maTp);
                        }
                        const md = sumAbs / length;
                        const cciVal = md !== 0 ? ((tp - maTp) / (md * 0.015)) : 0;
                        cciArr.push({ time: bar.time, value: cciVal });
                        const agoTp = (dataList[idx - (length - 1)].high +
                            dataList[idx - (length - 1)].low +
                            dataList[idx - (length - 1)].close) / 3;
                        tpSum -= agoTp;
                    }
                    else {
                        cciArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "cci" + suffix,
                    title: "CCI" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: cciArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 7) Current Ratio (CR) */
    const currentRatio = {
        name: "Current Ratio",
        shortName: "CR",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [26], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [26]);
            const results = [];
            arr.forEach((length, i) => {
                let sumNum = 0, sumDen = 0;
                const queueNum = [];
                const queueDen = [];
                const crArr = [];
                dataList.forEach((bar, idx) => {
                    const prev = idx - 1 >= 0 ? dataList[idx - 1] : bar;
                    const mid = (prev.high + prev.low) / 2;
                    const highSubMid = Math.max(0, bar.high - mid);
                    const midSubLow = Math.max(0, mid - bar.low);
                    sumNum += highSubMid;
                    sumDen += midSubLow;
                    queueNum.push(highSubMid);
                    queueDen.push(midSubLow);
                    let crVal = NaN;
                    if (idx >= length - 1) {
                        crVal = sumDen !== 0 ? (sumNum / sumDen) * 100 : 0;
                        sumNum -= queueNum[idx - (length - 1)];
                        sumDen -= queueDen[idx - (length - 1)];
                    }
                    crArr.push({ time: bar.time, value: crVal });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "cr" + suffix,
                    title: "CR" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: crArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 8) Difference of Moving Average (DMA)
       Parameters: n1, n2, m */
    const differentOfMovingAverage = {
        name: "Difference of Moving Average",
        shortName: "DMA",
        shouldOhlc: true,
        paramMap: {
            n1: { defaultValue: [10], type: "numberArray", min: 1 },
            n2: { defaultValue: [50], type: "numberArray", min: 1 },
            m: { defaultValue: [10], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const n1Arr = getNumericArray(overrideParams, "n1", [10]);
            const n2Arr = getNumericArray(overrideParams, "n2", [50]);
            const mArr = getNumericArray(overrideParams, "m", [10]);
            const figureCount = Math.max(n1Arr.length, n2Arr.length, mArr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const n1 = pickParam(n1Arr, i);
                const n2 = pickParam(n2Arr, i);
                const mVal = pickParam(mArr, i);
                const maxP = Math.max(n1, n2);
                let sum1 = 0, sum2 = 0, dmaSum = 0;
                const dmaArr = [];
                const amaArr = [];
                const resultsDma = [];
                dataList.forEach((bar, idx) => {
                    sum1 += bar.close;
                    sum2 += bar.close;
                    let ma1 = NaN, ma2 = NaN;
                    if (idx >= n1 - 1) {
                        ma1 = sum1 / n1;
                        sum1 -= dataList[idx - (n1 - 1)].close;
                    }
                    if (idx >= n2 - 1) {
                        ma2 = sum2 / n2;
                        sum2 -= dataList[idx - (n2 - 1)].close;
                    }
                    if (idx >= maxP - 1) {
                        const dif = ma1 - ma2;
                        resultsDma.push(dif);
                        dmaArr.push({ time: bar.time, value: dif });
                        dmaSum += dif;
                        if (resultsDma.length > mVal) {
                            dmaSum -= resultsDma[resultsDma.length - 1 - mVal];
                            const amaVal = dmaSum / mVal;
                            amaArr.push({ time: bar.time, value: amaVal });
                        }
                        else {
                            amaArr.push({ time: bar.time, value: NaN });
                        }
                    }
                    else {
                        dmaArr.push({ time: bar.time, value: NaN });
                        amaArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "dma" + suffix,
                    title: "DMA" + n1 + "-" + n2 + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: dmaArr,
                    pane: 1
                });
                results.push({
                    key: "ama" + suffix,
                    title: "AMA" + n1 + "-" + n2 + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: amaArr,
                    pane: 1
                });
            }
            return results;
        },
    };
    /* 9) Directional Movement Index (DMI)
       Parameters: n, mm */
    const directionalMovementIndex = {
        name: "Directional Movement Index",
        shortName: "DMI",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [14], type: "numberArray", min: 1 },
            mm: { defaultValue: [6], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", [14]);
            const mmArr = getNumericArray(overrideParams, "mm", [6]);
            const figureCount = Math.max(nArr.length, mmArr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const N = pickParam(nArr, i);
                const MM = pickParam(mmArr, i);
                let tr = 0, dmp = 0, dmm = 0;
                let adx = 0;
                let outAdxStarted = false;
                const pdiArr = [];
                const mdiArr = [];
                const adxArr = [];
                const adxrArr = [];
                dataList.forEach((bar, idx) => {
                    const prev = idx - 1 >= 0 ? dataList[idx - 1] : bar;
                    const highDiff = bar.high - prev.high;
                    const lowDiff = prev.low - bar.low;
                    const cTr = Math.max(bar.high - bar.low, Math.abs(bar.high - prev.close), Math.abs(prev.close - bar.low));
                    let cDmp = 0, cDmm = 0;
                    if (highDiff > 0 && highDiff > lowDiff)
                        cDmp = highDiff;
                    if (lowDiff > 0 && lowDiff > highDiff)
                        cDmm = lowDiff;
                    if (idx === 0) {
                        tr = cTr;
                        dmp = cDmp;
                        dmm = cDmm;
                    }
                    else {
                        tr = (tr * (N - 1) + cTr) / N;
                        dmp = (dmp * (N - 1) + cDmp) / N;
                        dmm = (dmm * (N - 1) + cDmm) / N;
                    }
                    let pdi = NaN, mdi = NaN;
                    if (tr !== 0) {
                        pdi = (dmp / tr) * 100;
                        mdi = (dmm / tr) * 100;
                    }
                    pdiArr.push({ time: bar.time, value: pdi });
                    mdiArr.push({ time: bar.time, value: mdi });
                    let dx = NaN;
                    if (!isNaN(pdi) && !isNaN(mdi) && (pdi + mdi) !== 0) {
                        dx = (Math.abs(mdi - pdi) / (mdi + pdi)) * 100;
                    }
                    if (idx < N - 1) {
                        adxArr.push({ time: bar.time, value: NaN });
                        adxrArr.push({ time: bar.time, value: NaN });
                    }
                    else {
                        if (!outAdxStarted) {
                            adx = dx;
                            outAdxStarted = true;
                        }
                        else {
                            adx = (adx * (N - 1) + dx) / N;
                        }
                        adxArr.push({ time: bar.time, value: adx });
                        if (idx < N - 1 + MM) {
                            adxrArr.push({ time: bar.time, value: NaN });
                        }
                        else {
                            const olderAdx = adxArr[adxArr.length - 1 - MM];
                            if (olderAdx) {
                                const val = (adx + olderAdx.value) / 2;
                                adxrArr.push({ time: bar.time, value: val });
                            }
                            else {
                                adxrArr.push({ time: bar.time, value: NaN });
                            }
                        }
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "pdi" + suffix,
                    title: "PDI" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: pdiArr,
                    pane: 1
                });
                results.push({
                    key: "mdi" + suffix,
                    title: "MDI" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: mdiArr,
                    pane: 1
                });
                results.push({
                    key: "adx" + suffix,
                    title: "ADX" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: adxArr,
                    pane: 1
                });
                results.push({
                    key: "adxr" + suffix,
                    title: "ADXR" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: adxrArr,
                    pane: 1
                });
            }
            return results;
        },
    };
    /* 10) Momentum (MTM)
       Parameters: n, m
    */
    const momentum = {
        name: "Momentum",
        shortName: "MTM",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [12], type: "numberArray", min: 1 },
            m: { defaultValue: [6], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", [12]);
            const mArr = getNumericArray(overrideParams, "m", [6]);
            const figureCount = Math.max(nArr.length, mArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const N = pickParam(nArr, i);
                const M = pickParam(mArr, i);
                const mtmArr = [];
                const maMtmArr = [];
                let sumMtm = 0;
                const mtmBuffer = [];
                dataList.forEach((bar, idx) => {
                    if (idx >= N) {
                        const oldBar = dataList[idx - N];
                        const val = bar.close - oldBar.close;
                        mtmArr.push({ time: bar.time, value: val });
                        mtmBuffer.push(val);
                        sumMtm += val;
                        if (mtmBuffer.length > M) {
                            sumMtm -= mtmBuffer[mtmBuffer.length - 1 - M];
                        }
                        const maVal = mtmBuffer.length >= M ? sumMtm / M : NaN;
                        maMtmArr.push({ time: bar.time, value: maVal });
                    }
                    else {
                        mtmArr.push({ time: bar.time, value: NaN });
                        maMtmArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "mtm" + suffix,
                    title: "MTM" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: mtmArr,
                    pane: 1
                });
                figs.push({
                    key: "maMtm" + suffix,
                    title: "MAMTM" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: maMtmArr,
                    pane: 1
                });
            }
            return figs;
        },
    };
    /* 11) Psychological Line (PSY)
       Parameters: n, m
    */
    const psychologicalLine = {
        name: "Psychological Line",
        shortName: "PSY",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [12], type: "numberArray", min: 1 },
            m: { defaultValue: [6], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", [12]);
            const mArr = getNumericArray(overrideParams, "m", [6]);
            const figureCount = Math.max(nArr.length, mArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const N = pickParam(nArr, i);
                const M = pickParam(mArr, i);
                let upCount = 0;
                const upQueue = [];
                let psySum = 0;
                const psyArr = [];
                const maPsyArr = [];
                const psyBuffer = [];
                dataList.forEach((bar, idx) => {
                    const prev = idx - 1 >= 0 ? dataList[idx - 1] : bar;
                    const upFlag = bar.close > prev.close ? 1 : 0;
                    upQueue.push(upFlag);
                    upCount += upFlag;
                    if (idx >= N - 1) {
                        const ratio = (upCount / N) * 100;
                        psyArr.push({ time: bar.time, value: ratio });
                        psyBuffer.push(ratio);
                        psySum += ratio;
                        if (psyBuffer.length > M) {
                            psySum -= psyBuffer[psyBuffer.length - 1 - M];
                        }
                        const maVal = psyBuffer.length >= M ? psySum / M : NaN;
                        maPsyArr.push({ time: bar.time, value: maVal });
                        upCount -= upQueue[idx - (N - 1)];
                    }
                    else {
                        psyArr.push({ time: bar.time, value: NaN });
                        maPsyArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "psy" + suffix,
                    title: "PSY" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: psyArr,
                    pane: 1
                });
                figs.push({
                    key: "maPsy" + suffix,
                    title: "MAPSY" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: maPsyArr,
                    pane: 1
                });
            }
            return figs;
        },
    };
    /* 12) Rate of Change (ROC)
       Parameters: n, m
    */
    const rateOfChange = {
        name: "Rate of Change",
        shortName: "ROC",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [12], type: "numberArray", min: 1 },
            m: { defaultValue: [6], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", [12]);
            const mArr = getNumericArray(overrideParams, "m", [6]);
            const figureCount = Math.max(nArr.length, mArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const N = pickParam(nArr, i);
                const M = pickParam(mArr, i);
                const rocArr = [];
                const maRocArr = [];
                let rocSum = 0;
                const buffer = [];
                dataList.forEach((bar, idx) => {
                    if (idx >= N) {
                        const ago = dataList[idx - N];
                        const prevClose = ago.close;
                        let rocVal = 0;
                        if (prevClose !== 0) {
                            rocVal = ((bar.close - prevClose) / prevClose) * 100;
                        }
                        rocArr.push({ time: bar.time, value: rocVal });
                        buffer.push(rocVal);
                        rocSum += rocVal;
                        if (buffer.length > M) {
                            rocSum -= buffer[buffer.length - 1 - M];
                        }
                        const maVal = buffer.length >= M ? rocSum / M : NaN;
                        maRocArr.push({ time: bar.time, value: maVal });
                    }
                    else {
                        rocArr.push({ time: bar.time, value: NaN });
                        maRocArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "roc" + suffix,
                    title: "ROC" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: rocArr,
                    pane: 1
                });
                figs.push({
                    key: "maRoc" + suffix,
                    title: "MAROC" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: maRocArr,
                    pane: 1
                });
            }
            return figs;
        },
    };
    /* 13) Relative Strength Index (RSI)
       Parameters: p1, p2, p3
    */
    const relativeStrengthIndex = {
        name: "RSI + SMA",
        shortName: "RSI_SMA",
        shouldOhlc: true,
        paramMap: {
            p1: { defaultValue: [14], type: "numberArray", min: 1 }, // RSI period
            p2: { defaultValue: [21], type: "numberArray", min: 1 }, // SMA-of-RSI period
        },
        calc(dataList, overrideParams) {
            const p1Arr = getNumericArray(overrideParams, "p1", [14]); // RSI length
            const p2Arr = getNumericArray(overrideParams, "p2", [10]); // SMA length
            const figureCount = Math.max(p1Arr.length, p2Arr.length);
            const closeArr = dataList.map(b => b.close);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const p1 = pickParam(p1Arr, i);
                const p2 = pickParam(p2Arr, i);
                let rsiValues = [];
                const rsiData = [];
                const smaData = [];
                // Compute RSI iteratively and feed it into getSma step-by-step
                dataList.forEach((bar, idx) => {
                    const rsiVal = getRsi(closeArr.slice(0, idx + 1), p1); // Get latest RSI value
                    rsiValues.push(rsiVal);
                    const smaVal = getSma(rsiValues, p2); // Get latest SMA of RSI
                    rsiData.push({ time: bar.time, value: rsiVal });
                    smaData.push({ time: bar.time, value: smaVal });
                });
                // Build the indicator lines
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                const lineRsi = {
                    key: `rsi${suffix}`,
                    title: `RSI(${p1})${suffix}`,
                    type: "line",
                    data: rsiData,
                    pane: 1
                };
                const lineSma = {
                    key: `smaOfRsi${suffix}`,
                    title: `SMA(${p2}) of RSI(${p1})${suffix}`,
                    type: "line",
                    data: smaData,
                    pane: 1
                };
                figs.push(lineRsi, lineSma);
            }
            return figs;
        },
    };
    /* 14) Stochastic (KDJ)
       Parameters: n, kPeriod, dPeriod
    */
    const stoch = {
        name: "Stochastic",
        shortName: "KDJ",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [9], type: "numberArray", min: 1 },
            kPeriod: { defaultValue: [3], type: "numberArray", min: 1 },
            dPeriod: { defaultValue: [3], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", [9]);
            const kArr = getNumericArray(overrideParams, "kPeriod", [3]);
            const dArr = getNumericArray(overrideParams, "dPeriod", [3]);
            const figureCount = Math.max(nArr.length, kArr.length, dArr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const nVal = pickParam(nArr, i);
                const kPeriod = pickParam(kArr, i);
                const dPeriod = pickParam(dArr, i);
                let prevK = 50, prevD = 50;
                const kArrOut = [];
                const dArrOut = [];
                const jArrOut = [];
                dataList.forEach((bar, idx) => {
                    if (idx < nVal - 1) {
                        kArrOut.push({ time: bar.time, value: NaN });
                        dArrOut.push({ time: bar.time, value: NaN });
                        jArrOut.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const slice = dataList.slice(idx - (nVal - 1), idx + 1);
                    const highN = Math.max(...slice.map(b => b.high));
                    const lowN = Math.min(...slice.map(b => b.low));
                    const rsv = highN === lowN ? 100 : ((bar.close - lowN) / (highN - lowN)) * 100;
                    const kVal = ((kPeriod - 1) * prevK + rsv) / kPeriod;
                    const dVal = ((dPeriod - 1) * prevD + kVal) / dPeriod;
                    const jVal = 3 * kVal - 2 * dVal;
                    kArrOut.push({ time: bar.time, value: kVal });
                    dArrOut.push({ time: bar.time, value: dVal });
                    jArrOut.push({ time: bar.time, value: jVal });
                    prevK = kVal;
                    prevD = dVal;
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "k" + suffix,
                    title: "K" + nVal + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: kArrOut,
                    pane: 1
                });
                results.push({
                    key: "d" + suffix,
                    title: "D" + nVal + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: dArrOut,
                    pane: 1
                });
                results.push({
                    key: "j" + suffix,
                    title: "J" + nVal + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: jArrOut,
                    pane: 1
                });
            }
            return results;
        },
    };
    /* 15) Variance
       Parameter: length
    */
    const variance = {
        name: "Variance",
        shortName: "Variance",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray", min: 1, max: 100 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [14]);
            const results = [];
            arr.forEach((length, i) => {
                const varArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < length - 1) {
                        varArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const subset = dataList.slice(idx - (length - 1), idx + 1).map(b => b.close);
                    const mean = subset.reduce((sum, val) => sum + val, 0) / subset.length;
                    const variance = subset.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / subset.length;
                    varArr.push({ time: bar.time, value: variance });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "variance" + suffix,
                    title: "Variance" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: varArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 16) Williams %R (WR)
       Parameters: p1, p2, p3
    */
    const williamsR = {
        name: "Williams %R",
        shortName: "WR",
        shouldOhlc: true,
        paramMap: {
            p1: { defaultValue: [6], type: "numberArray", min: 1 },
            p2: { defaultValue: [10], type: "numberArray", min: 1 },
            p3: { defaultValue: [14], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const p1Arr = getNumericArray(overrideParams, "p1", [6]);
            const p2Arr = getNumericArray(overrideParams, "p2", [10]);
            const p3Arr = getNumericArray(overrideParams, "p3", [14]);
            const figureCount = Math.max(p1Arr.length, p2Arr.length, p3Arr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const p1 = pickParam(p1Arr, i);
                const p2 = pickParam(p2Arr, i);
                const p3 = pickParam(p3Arr, i);
                const arrP = [p1, p2, p3];
                const lines = arrP.map((val, j) => ({
                    key: `wr${j + 1}` + (figureCount > 1 ? `_${i + 1}` : ""),
                    title: `WR${val}` + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: [],
                    pane: 1
                }));
                dataList.forEach((bar, idx) => {
                    arrP.forEach((period, j) => {
                        if (idx >= period - 1) {
                            let highest = -Infinity, lowest = Infinity;
                            for (let k = idx - (period - 1); k <= idx; k++) {
                                highest = Math.max(highest, dataList[k].high);
                                lowest = Math.min(lowest, dataList[k].low);
                            }
                            const wrVal = highest !== lowest ? ((bar.close - highest) / (highest - lowest)) * 100 : 0;
                            lines[j].data.push({ time: bar.time, value: wrVal });
                        }
                        else {
                            lines[j].data.push({ time: bar.time, value: NaN });
                        }
                    });
                });
                results.push(...lines);
            }
            return results;
        },
    };
    /* 17) Change
       Parameter: length
    */
    const change = {
        name: "Change",
        shortName: "Change",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [1], type: "numberArray", min: 1, max: 100 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [1]);
            const results = [];
            arr.forEach((length, i) => {
                const chArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < length) {
                        chArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const prevClose = dataList[idx - length].close;
                    chArr.push({ time: bar.time, value: bar.close - prevClose });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "change" + suffix,
                    title: "Change" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: chArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 18) Range
       Parameter: length
    */
    const range = {
        name: "Range",
        shortName: "Range",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray", min: 1, max: 100 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [14]);
            const results = [];
            arr.forEach((length, i) => {
                const rArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < length - 1) {
                        rArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const subset = dataList.slice(idx - (length - 1), idx + 1);
                    const highest = Math.max(...subset.map(b => b.high));
                    const lowest = Math.min(...subset.map(b => b.low));
                    rArr.push({ time: bar.time, value: highest - lowest });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "range" + suffix,
                    title: "Range" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: rArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 19) Standard Deviation
       Parameter: length
    */
    const standardDeviation = {
        name: "Standard Deviation",
        shortName: "StdDev",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray", min: 1, max: 100 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [14]);
            const results = [];
            arr.forEach((length, i) => {
                const sdArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < length - 1) {
                        sdArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const subset = dataList.slice(idx - (length - 1), idx + 1).map(b => b.close);
                    const mean = subset.reduce((sum, val) => sum + val, 0) / subset.length;
                    const variance = subset.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / subset.length;
                    const stdDev = Math.sqrt(variance);
                    sdArr.push({ time: bar.time, value: stdDev });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "stdDev" + suffix,
                    title: "StdDev" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: sdArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    // =====================================================================
    // 15) Moving Average Convergence Divergence (MACD) - MACD Series Modified
    // =====================================================================
    const movingAverageConvergenceDivergence = {
        name: 'Moving Average Convergence Divergence',
        shortName: 'MACD',
        shouldOhlc: true,
        paramMap: {
            shortPeriod: { defaultValue: 12, type: 'number', min: 1 },
            longPeriod: { defaultValue: 26, type: 'number', min: 1 },
            signalPeriod: { defaultValue: 9, type: 'number', min: 1 },
        },
        calc(dataList, overrideParams) {
            const pm = getParams(this, overrideParams);
            const shortP = pm.shortPeriod;
            const longP = pm.longPeriod;
            const signalP = pm.signalPeriod;
            let emaShort = 0, emaLong = 0;
            let dif = 0, dea = 0;
            let difSum = 0;
            const difArr = [];
            const deaArr = [];
            const macdArr = [];
            let sumClose = 0;
            dataList.forEach((bar, i) => {
                sumClose += bar.close;
                // Initialize short EMA
                if (i === shortP - 1) {
                    emaShort = sumClose / shortP;
                }
                else if (i > shortP - 1) {
                    emaShort =
                        (bar.close * 2 + (shortP - 1) * emaShort) / (shortP + 1);
                }
                // Initialize long EMA
                if (i === longP - 1) {
                    emaLong = sumClose / longP;
                }
                else if (i > longP - 1) {
                    emaLong =
                        (bar.close * 2 + (longP - 1) * emaLong) / (longP + 1);
                }
                if (i >= Math.max(shortP, longP) - 1) {
                    dif = emaShort - emaLong;
                    difArr.push({ time: bar.time, value: dif });
                    difSum += dif;
                    if (difArr.length === signalP) {
                        dea = difSum / signalP;
                    }
                    else if (difArr.length > signalP) {
                        dea = (dif * 2 + (signalP - 1) * dea) / (signalP + 1);
                    }
                    if (difArr.length >= signalP) {
                        deaArr.push({ time: bar.time, value: dea });
                        macdArr.push({
                            time: bar.time,
                            value: (dif - dea) * 2,
                        });
                    }
                    else {
                        deaArr.push({ time: bar.time, value: NaN });
                        macdArr.push({ time: bar.time, value: NaN });
                    }
                }
                else {
                    difArr.push({ time: bar.time, value: NaN });
                    deaArr.push({ time: bar.time, value: NaN });
                    macdArr.push({ time: bar.time, value: NaN });
                }
            });
            // Extract optional color parameters with defaults.
            const upColor = overrideParams?.upColor ?? 'green';
            const downColor = overrideParams?.downColor ?? 'red';
            setHistogramColors(macdArr, upColor, downColor);
            return [
                { key: 'dif', title: 'DIF', type: 'line', data: difArr, pane: 1 },
                { key: 'dea', title: 'DEA', type: 'line', data: deaArr, pane: 1 },
                { key: 'macd', title: 'MACD', type: 'histogram', data: macdArr, pane: 1 },
            ];
        },
    };
    // You can continue adding other indicators below as needed.
    // =====================================================================
    //  INDICATORS (collect them in one array)
    // =====================================================================
    const OSCILLATORS = [
        // Oscillator Indicators
        awesomeOscillator,
        averageTrueRange,
        bias,
        brar,
        bullAndBearIndex,
        commodityChannelIndex,
        currentRatio,
        differentOfMovingAverage,
        directionalMovementIndex,
        momentum,
        movingAverageConvergenceDivergence,
        psychologicalLine,
        rateOfChange,
        relativeStrengthIndex,
        stoch,
        variance,
        williamsR,
        change,
        range,
        standardDeviation,
    ];

    // =========================
    //  Basic Data Interfaces
    // =========================
    const INDICATORS = [...OVERLAYS, ...OSCILLATORS];

    class DataMenu {
        contextMenu;
        handler;
        container;
        // Set the default active tab to "options" (primary).
        currentTab = "options";
        constructor(options) {
            this.contextMenu = options.contextMenu;
            this.handler = options.handler;
            // Use the context menu's container as the modal container.
            this.container = this.contextMenu.div;
        }
        /**
         * Opens the export/import dialog modal.
         * The modal has two tabs: one for full serialization and one for options.
         * Each tab has its own set of export/import buttons.
         * A common Save button is provided.
         *
         * @param target - The object to export/import (must implement IJsonSerializable).
         * @param event - An optional MouseEvent used for positioning.
         */
        openMenu(target, event, overrideType) {
            // Determine the type to export using the override if provided.
            const typeStr = overrideType || target._type || target.constructor.name;
            // Compute JSON strings for full serialization.
            const fullData = {
                type: typeStr,
                object: target.toJSON(), // Using "object" instead of "data"
                title: target.title,
            };
            const fullJson = JSON.stringify(fullData, null, 2);
            // Retrieve options. If the target is a Handler, use target.chart.options().
            let opts = {};
            if (target instanceof Handler) {
                opts = target.chart.options();
            }
            else if (target.options !== undefined) {
                opts = typeof target.options === "function" ? target.options() : target.options;
            }
            else if (target._options !== undefined) {
                opts = target._options;
            }
            // Use the key 'options' for the options export.
            const optionsData = {
                ...opts
            };
            const optionsJson = JSON.stringify(optionsData, null, 2);
            const modalOverlay = document.createElement("div");
            modalOverlay.style.position = "fixed";
            modalOverlay.style.top = "0";
            modalOverlay.style.left = "0";
            modalOverlay.style.width = "100%";
            modalOverlay.style.height = "100%";
            modalOverlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
            modalOverlay.style.display = "flex";
            modalOverlay.style.justifyContent = "center";
            modalOverlay.style.alignItems = "center";
            modalOverlay.style.zIndex = "1000";
            // Close the modal when the Esc key is pressed.
            const handleKeyDown = (e) => {
                if (e.key === "Escape") {
                    this.close(modalOverlay, handleKeyDown);
                }
            };
            document.addEventListener("keydown", handleKeyDown);
            // Create the modal content container.
            const modalContent = document.createElement("div");
            // Set dark mode for both tabs.
            modalContent.style.backgroundColor = "#333";
            modalContent.style.color = "#fff";
            modalContent.style.padding = "20px";
            modalContent.style.borderRadius = "8px";
            modalContent.style.width = "80%";
            modalContent.style.maxWidth = "800px";
            modalContent.style.maxHeight = "90%";
            modalContent.style.overflowY = "auto";
            modalContent.style.boxShadow = "0 2px 10px rgba(0,0,0,0.5)";
            modalContent.setAttribute("tabindex", "-1");
            modalContent.focus();
            // Create tab headers. Options tab will be on the left.
            const tabsContainer = document.createElement("div");
            tabsContainer.style.display = "flex";
            tabsContainer.style.borderBottom = "1px solid #555";
            tabsContainer.style.marginBottom = "10px";
            const optionsTab = document.createElement("button");
            optionsTab.textContent = "Options";
            optionsTab.style.flex = "1";
            optionsTab.style.padding = "10px";
            optionsTab.style.cursor = "pointer";
            optionsTab.style.border = "none";
            // Active tab background.
            optionsTab.style.backgroundColor = this.currentTab === "options" ? "#555" : "#333";
            optionsTab.onclick = () => {
                this.currentTab = "options";
                optionsTab.style.backgroundColor = "#555";
                fullTab.style.backgroundColor = "#333";
                textarea.value = optionsJson;
                optionsButtonsContainer.style.display = "flex";
                fullButtonsContainer.style.display = "none";
            };
            const fullTab = document.createElement("button");
            fullTab.textContent = "Full";
            fullTab.style.flex = "1";
            fullTab.style.padding = "10px";
            fullTab.style.cursor = "pointer";
            fullTab.style.border = "none";
            fullTab.style.backgroundColor = this.currentTab === "full" ? "#555" : "#333";
            fullTab.onclick = () => {
                this.currentTab = "full";
                fullTab.style.backgroundColor = "#555";
                optionsTab.style.backgroundColor = "#333";
                textarea.value = fullJson;
                fullButtonsContainer.style.display = "flex";
                optionsButtonsContainer.style.display = "none";
            };
            // Append tabs in the order: Options (left), then Full (right).
            tabsContainer.appendChild(optionsTab);
            tabsContainer.appendChild(fullTab);
            modalContent.appendChild(tabsContainer);
            // Title element.
            const titleElem = document.createElement("h2");
            titleElem.textContent = `Export/Import ${target.title} Data`;
            modalContent.appendChild(titleElem);
            // Create the textarea for JSON editing.
            const textarea = document.createElement("textarea");
            // Since currentTab defaults to "options", display options JSON.
            textarea.value = this.currentTab === "full" ? fullJson : optionsJson;
            textarea.style.width = "100%";
            textarea.style.height = "400px";
            textarea.style.marginTop = "10px";
            textarea.style.marginBottom = "10px";
            textarea.style.resize = "vertical";
            // Dark mode styling.
            textarea.style.backgroundColor = "#444";
            textarea.style.color = "#fff";
            textarea.setAttribute("aria-label", "JSON Data Editor");
            modalContent.appendChild(textarea);
            // Create two separate button containers for each tab.
            const fullButtonsContainer = document.createElement("div");
            fullButtonsContainer.style.display = this.currentTab === "full" ? "flex" : "none";
            fullButtonsContainer.style.flexWrap = "wrap";
            fullButtonsContainer.style.justifyContent = "flex-end";
            fullButtonsContainer.style.gap = "10px";
            const exportFullButton = document.createElement("button");
            exportFullButton.textContent = "Export";
            exportFullButton.style.padding = "8px 12px";
            exportFullButton.style.cursor = "pointer";
            exportFullButton.style.backgroundColor = "#f44336";
            exportFullButton.style.color = "#fff";
            exportFullButton.style.border = "none";
            exportFullButton.style.borderRadius = "4px";
            exportFullButton.onclick = () => {
                this.downloadJson(fullJson, `${target.title}_full.json`);
            };
            fullButtonsContainer.appendChild(exportFullButton);
            const importFullButton = document.createElement("button");
            importFullButton.textContent = "Import";
            importFullButton.style.padding = "8px 12px";
            importFullButton.style.cursor = "pointer";
            importFullButton.style.backgroundColor = "#4CAF50";
            importFullButton.style.color = "#fff";
            importFullButton.style.border = "none";
            importFullButton.style.borderRadius = "4px";
            importFullButton.onclick = () => {
                try {
                    const modifiedData = JSON.parse(textarea.value);
                    if (typeof modifiedData !== "object" || !modifiedData.object) {
                        throw new Error("Invalid structure: missing 'object'.");
                    }
                    target.fromJSON(modifiedData.object);
                    if (typeof target.updateView === "function") {
                        target.updateView();
                    }
                    this.showNotification("Whole data imported successfully.", "success");
                }
                catch (error) {
                    this.showNotification("Failed to import whole data: " + error.message, "error");
                }
            };
            fullButtonsContainer.appendChild(importFullButton);
            const optionsButtonsContainer = document.createElement("div");
            optionsButtonsContainer.style.display = this.currentTab === "options" ? "flex" : "none";
            optionsButtonsContainer.style.flexWrap = "wrap";
            optionsButtonsContainer.style.justifyContent = "flex-end";
            optionsButtonsContainer.style.gap = "10px";
            const exportOptionsButton = document.createElement("button");
            exportOptionsButton.textContent = "Export Options";
            exportOptionsButton.style.padding = "8px 12px";
            exportOptionsButton.style.cursor = "pointer";
            exportOptionsButton.style.backgroundColor = "#f44336";
            exportOptionsButton.style.color = "#fff";
            exportOptionsButton.style.border = "none";
            exportOptionsButton.style.borderRadius = "4px";
            exportOptionsButton.onclick = () => {
                this.downloadJson(optionsJson, `${target.title}_options.json`);
            };
            optionsButtonsContainer.appendChild(exportOptionsButton);
            const importOptionsButton = document.createElement("button");
            importOptionsButton.textContent = "Import Options";
            importOptionsButton.style.padding = "8px 12px";
            importOptionsButton.style.cursor = "pointer";
            importOptionsButton.style.backgroundColor = "#4CAF50";
            importOptionsButton.style.color = "#fff";
            importOptionsButton.style.border = "none";
            importOptionsButton.style.borderRadius = "4px";
            importOptionsButton.onclick = () => {
                // Create a hidden file input element and trigger its click.
                const fileInput = document.createElement("input");
                fileInput.type = "file";
                fileInput.accept = "application/json";
                fileInput.style.display = "none";
                fileInput.addEventListener("change", () => {
                    if (fileInput.files && fileInput.files.length > 0) {
                        const file = fileInput.files[0];
                        const reader = new FileReader();
                        reader.onload = () => {
                            try {
                                // Get the file contents (as text)
                                const fileContents = reader.result;
                                if (typeof fileContents !== "string") {
                                    throw new Error("File content is not a string.");
                                }
                                // Replace the textarea content with the imported JSON
                                textarea.value = fileContents;
                                // Parse the JSON content
                                const modifiedData = JSON.parse(fileContents);
                                // Check that the expected key exists.
                                if (typeof modifiedData !== "object" || !modifiedData.options) {
                                    throw new Error("Invalid structure: missing 'options'.");
                                }
                                target.fromJSON(modifiedData.options);
                                if (typeof target.updateView === "function") {
                                    target.updateView();
                                }
                                this.showNotification("Options imported successfully.", "success");
                            }
                            catch (error) {
                                this.showNotification("Failed to import options: " + error.message, "error");
                            }
                        };
                        reader.readAsText(file);
                    }
                });
                fileInput.click();
            };
            optionsButtonsContainer.appendChild(importOptionsButton);
            const saveButton = document.createElement("button");
            saveButton.textContent = "Save";
            saveButton.style.padding = "8px 12px";
            saveButton.style.cursor = "pointer";
            saveButton.style.backgroundColor = "#008CBA";
            saveButton.style.color = "#fff";
            saveButton.style.border = "none";
            saveButton.style.borderRadius = "4px";
            saveButton.onclick = () => {
                try {
                    const modifiedData = JSON.parse(textarea.value);
                    if (typeof modifiedData !== "object" || !modifiedData.options) {
                        throw new Error("Invalid structure: missing 'options'.");
                    }
                    // 1) Apply to the chart
                    target.fromJSON(modifiedData);
                    if (typeof target.updateView === "function") {
                        target.updateView();
                    }
                    // 2) Then do the file download
                    const dataString = JSON.stringify(modifiedData, null, 2);
                    // ... (same Blob + <a download> logic)
                    this.showNotification("Options applied and exported successfully.", "success");
                }
                catch (error) {
                    this.showNotification("Failed to save options: " + error.message, "error");
                }
            };
            // In your DataMenu's openMenu method (or where you add the Save as Default button)
            const saveDefaultButton = document.createElement("button");
            saveDefaultButton.textContent = "Save as Default";
            saveDefaultButton.style.padding = "8px 12px";
            saveDefaultButton.style.cursor = "pointer";
            saveDefaultButton.style.backgroundColor = "#008CBA";
            saveDefaultButton.style.color = "#fff";
            saveDefaultButton.style.border = "none";
            saveDefaultButton.style.borderRadius = "4px";
            saveDefaultButton.onclick = () => {
                let opts = {};
                // Extract options from the target.
                if (target instanceof Handler) {
                    opts = target.chart.options();
                }
                else if (typeof target.options === "function") {
                    opts = target.options();
                }
                else if (target.options !== undefined) {
                    opts = target.options;
                }
                else if (target._options !== undefined) {
                    opts = target._options;
                }
                // Build a JSON string strictly containing the options.
                const optionsJson = JSON.stringify(opts, null, 2);
                // Determine the key:
                // If target._type is "custom/Custom" (case-insensitive), then prompt the user.
                // Otherwise, use target._type converted to lowercase. If _type is undefined, fallback to target.title.
                let key;
                if (target._type && target._type.toLowerCase() === "custom/custom") {
                    key = prompt("Enter save key (e.g., area, line, candlestick):", target.title.toLowerCase()) || "";
                    if (!key)
                        return; // abort if no key is provided.
                }
                else {
                    key = target._type ? target._type.toLowerCase() : target.title.toLowerCase();
                }
                // Build the callback message using a fixed prefix "save_defaults" and the key and options JSON separated by ";;;"
                const message = `save_defaults_~_${key};;;${optionsJson}`;
                window.callbackFunction(message);
            };
            this.container.appendChild(saveDefaultButton);
            // Create a container for the bottom buttons that holds both sets.
            const bottomButtonsContainer = document.createElement("div");
            bottomButtonsContainer.style.display = "flex";
            bottomButtonsContainer.style.flexDirection = "column";
            bottomButtonsContainer.style.gap = "10px";
            bottomButtonsContainer.appendChild(fullButtonsContainer);
            bottomButtonsContainer.appendChild(optionsButtonsContainer);
            bottomButtonsContainer.appendChild(saveButton);
            bottomButtonsContainer.appendChild(saveDefaultButton);
            modalContent.appendChild(bottomButtonsContainer);
            modalOverlay.appendChild(modalContent);
            this.container.appendChild(modalOverlay);
        }
        downloadJson(jsonData, filename) {
            try {
                const blob = new Blob([jsonData], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }
            catch (error) {
                this.showNotification("Failed to download data: " + error, "error");
            }
        }
        addSaveDefaultButton(target) {
            const saveDefaultButton = document.createElement("button");
            saveDefaultButton.textContent = "Save as Default";
            saveDefaultButton.style.padding = "8px 12px";
            saveDefaultButton.style.cursor = "pointer";
            saveDefaultButton.style.backgroundColor = "#008CBA";
            saveDefaultButton.style.color = "#fff";
            saveDefaultButton.style.border = "none";
            saveDefaultButton.style.borderRadius = "4px";
            saveDefaultButton.onclick = () => {
                let opts = {};
                // Extract options from the target.
                if (target instanceof Handler) {
                    // For a Handler, use its chart options.
                    opts = target.chart.options();
                }
                else if (typeof target.options === "function") {
                    opts = target.options();
                }
                else if (target.options !== undefined) {
                    opts = target.options;
                }
                else if (target._options !== undefined) {
                    opts = target._options;
                }
                // Build a JSON string strictly containing the options.
                const optionsJson = JSON.stringify(opts, null, 2);
                // Use the target's title (lowercase) as the key.
                // Prompt the user for the key, defaulting to target.title.toLowerCase().
                const key = prompt("Enter save key (area, line, trend-trace, candlestick etc):", target.title.toLowerCase());
                if (!key) {
                    // User cancelled or provided an empty key; abort saving.
                    return;
                }
                // Build the callback message.
                const message = `save_defaults_${key}_~_${optionsJson}`;
                // Call the global callback function.
                window.callbackFunction(message);
            };
            this.container.appendChild(saveDefaultButton);
        }
        close(overlay, keyDownHandler) {
            if (overlay.parentElement) {
                overlay.parentElement.removeChild(overlay);
            }
            document.removeEventListener("keydown", keyDownHandler);
        }
        showNotification(message, type) {
            const notification = document.createElement("div");
            notification.textContent = message;
            notification.style.position = "fixed";
            notification.style.bottom = "20px";
            notification.style.right = "20px";
            notification.style.padding = "10px 20px";
            notification.style.borderRadius = "4px";
            notification.style.color = "#fff";
            notification.style.backgroundColor = type === "success" ? "#4CAF50" : "#f44336";
            notification.style.boxShadow = "0 2px 6px rgba(0,0,0,0.2)";
            notification.style.zIndex = "1001";
            notification.style.opacity = "0";
            notification.style.transition = "opacity 0.5s ease-in-out";
            this.container.appendChild(notification);
            setTimeout(() => {
                notification.style.opacity = "1";
            }, 100);
            setTimeout(() => {
                notification.style.opacity = "0";
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.parentElement.removeChild(notification);
                    }
                }, 500);
            }, 3000);
        }
        openDefaultOptions(defaultKey) {
            // 1) Fetch the current defaults for this key from your manager.
            //    e.g., if your Handler has a property like `defaultsManager`.
            const defaultsManager = this.handler.defaultsManager;
            if (!defaultsManager) {
                this.showNotification("No defaults manager found.", "error");
                return;
            }
            const currentDefaults = defaultsManager.get(defaultKey);
            if (!currentDefaults) {
                this.showNotification(`No default config found for key: "${defaultKey}"`, "error");
                return;
            }
            // Convert current defaults to JSON (prettified)
            JSON.stringify(currentDefaults, null, 2);
            // 2) Create the modal overlay
            const modalOverlay = document.createElement("div");
            Object.assign(modalOverlay.style, {
                position: "fixed",
                top: "0",
                left: "0",
                width: "100%",
                height: "100%",
                backgroundColor: "rgba(0,0,0,0.5)",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                zIndex: "1000",
            });
            // ESC key closes the modal
            const handleKeyDown = (e) => {
                if (e.key === "Escape") {
                    this.close(modalOverlay, handleKeyDown);
                }
            };
            document.addEventListener("keydown", handleKeyDown);
            // 3) Modal content container
            const modalContent = document.createElement("div");
            Object.assign(modalContent.style, {
                backgroundColor: "#333",
                color: "#fff",
                padding: "20px",
                borderRadius: "8px",
                width: "80%",
                maxWidth: "800px",
                maxHeight: "90%",
                overflowY: "auto",
                boxShadow: "0 2px 10px rgba(0,0,0,0.5)",
            });
            modalContent.setAttribute("tabindex", "-1");
            modalContent.focus();
            // Title
            const titleElem = document.createElement("h2");
            titleElem.textContent = `Edit Default Options - "${defaultKey}"`;
            modalContent.appendChild(titleElem);
            // 4) Textarea with the current defaults JSON
            const textarea = document.createElement("textarea");
            textarea.value = JSON.stringify(currentDefaults, null, 2);
            Object.assign(textarea.style, {
                width: "100%",
                height: "400px",
                resize: "vertical",
                backgroundColor: "#444",
                color: "#fff",
                border: "none",
                margin: "10px 0",
                padding: "10px",
            });
            modalContent.appendChild(textarea);
            // Buttons row
            const buttonRow = document.createElement("div");
            Object.assign(buttonRow.style, {
                display: "flex",
                flexWrap: "wrap",
                gap: "10px",
                justifyContent: "flex-end",
            });
            // Export button
            const exportButton = document.createElement("button");
            exportButton.textContent = "Export";
            Object.assign(exportButton.style, {
                padding: "8px 12px",
                cursor: "pointer",
                backgroundColor: "#f44336",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
            });
            exportButton.onclick = () => {
                this.downloadJson(textarea.value, `${defaultKey}_defaults.json`);
            };
            buttonRow.appendChild(exportButton);
            // Import button
            const importButton = document.createElement("button");
            importButton.textContent = "Import";
            Object.assign(importButton.style, {
                padding: "8px 12px",
                cursor: "pointer",
                backgroundColor: "#4CAF50",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
            });
            importButton.onclick = () => {
                const fileInput = document.createElement("input");
                fileInput.type = "file";
                fileInput.accept = "application/json";
                fileInput.style.display = "none";
                fileInput.addEventListener("change", () => {
                    if (fileInput.files && fileInput.files.length > 0) {
                        const file = fileInput.files[0];
                        const reader = new FileReader();
                        reader.onload = () => {
                            try {
                                if (typeof reader.result !== "string") {
                                    throw new Error("File content is not a string.");
                                }
                                // Put contents into the textarea
                                textarea.value = reader.result;
                            }
                            catch (err) {
                                this.showNotification("Failed to read defaults file: " + err.message, "error");
                            }
                        };
                        reader.readAsText(file);
                    }
                });
                fileInput.click();
            };
            buttonRow.appendChild(importButton);
            // ─── SAVE BUTTON (Updated) ───────────────────────────────────────────
            // Instead of calling defaultsManager.set(...),
            // we replicate the "save as default" approach: build a 'save_defaults_...' message.
            const saveButton = document.createElement("button");
            saveButton.textContent = "Save";
            Object.assign(saveButton.style, {
                padding: "8px 12px",
                cursor: "pointer",
                backgroundColor: "#008CBA",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
            });
            saveButton.onclick = () => {
                try {
                    // Parse the user-edited JSON
                    const newData = JSON.parse(textarea.value);
                    // Convert to a string for the message
                    const dataString = JSON.stringify(newData, null, 2);
                    // We'll attempt to build a key from defaultKey. If the user wants a different one,
                    // they can specify it here, or we can just rely on defaultKey.
                    let key = defaultKey;
                    // If you want to handle custom logic for "custom/custom" or a user prompt, do so here.
                    // Build the message same as your normal "Save as Default" approach
                    // e.g. "save_defaults_area_~_{...json...}" or if you'd prefer "save_defaults_~_{key};;;{json}"
                    const message = `save_defaults_${key}_~_${dataString}`;
                    // Call the callback
                    window.callbackFunction(message);
                    this.showNotification(`Defaults for "${key}" saved successfully.`, "success");
                }
                catch (error) {
                    this.showNotification("Failed to save defaults: " + error.message, "error");
                }
            };
            buttonRow.appendChild(saveButton);
            // Cancel button
            const cancelButton = document.createElement("button");
            cancelButton.textContent = "Cancel";
            Object.assign(cancelButton.style, {
                padding: "8px 12px",
                cursor: "pointer",
                backgroundColor: "#444",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
            });
            cancelButton.onclick = () => {
                this.close(modalOverlay, handleKeyDown);
            };
            buttonRow.appendChild(cancelButton);
            modalContent.appendChild(buttonRow);
            modalOverlay.appendChild(modalContent);
            this.container.appendChild(modalOverlay);
        }
    }

    /**
     * A multi-panel Settings modal that replicates the layout of TradingView’s “Chart Settings”:
     * - Left-hand navigation with categories
     * - Right-hand content panel for relevant settings
     * - Bottom row with “Template”, “Cancel”, and “Ok” buttons
     */
    class SettingsModal {
        container;
        backdrop;
        isOpen = false;
        // Left-nav categories and the right-hand content area.
        categories = [];
        contentArea;
        activeCategoryId = "";
        // A reference to the chart handler (or chart instance)
        handler;
        // Optionally, a custom color picker component reference.
        colorPicker = null;
        /**
         * Pass in your chart handler so that the modal controls can read and update chart options.
         */
        constructor(handler) {
            this.handler = handler;
            this.colorPicker = new ColorPicker('#000000', (color) => null);
            // Create the backdrop
            this.backdrop = document.createElement("div");
            this.backdrop.style.position = "fixed";
            this.backdrop.style.top = "0";
            this.backdrop.style.left = "0";
            this.backdrop.style.width = "100%";
            this.backdrop.style.height = "100%";
            this.backdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
            this.backdrop.style.opacity = "0";
            this.backdrop.style.transition = "opacity 0.3s ease";
            this.backdrop.style.zIndex = "9998"; // behind the modal
            this.backdrop.style.display = "none";
            this.backdrop.addEventListener("click", (e) => {
                // If clicked outside the modal, we can close or ignore
                if (e.target === this.backdrop) {
                    this.close(false);
                }
            });
            document.body.appendChild(this.backdrop);
            // Create the main container (the modal itself)
            this.container = document.createElement("div");
            this.container.style.position = "fixed";
            this.container.style.top = "50%";
            this.container.style.left = "50%";
            this.container.style.transform = "translate(-50%, -50%)";
            this.container.style.width = "700px";
            this.container.style.maxWidth = "90%";
            this.container.style.height = "500px";
            this.container.style.maxHeight = "90%";
            this.container.style.backgroundColor = "#2B2B2B";
            this.container.style.color = "#FFF";
            this.container.style.borderRadius = "6px";
            this.container.style.boxShadow = "0 2px 10px rgba(0,0,0,0.8)";
            this.container.style.zIndex = "9999";
            this.container.style.opacity = "0";
            this.container.style.display = "none";
            this.container.style.transition = "opacity 0.3s ease, transform 0.3s ease";
            document.body.appendChild(this.container);
            // Title bar with "Settings" and a close (×) button
            const titleBar = document.createElement("div");
            titleBar.style.display = "flex";
            titleBar.style.alignItems = "center";
            titleBar.style.justifyContent = "space-between";
            titleBar.style.padding = "12px 16px";
            titleBar.style.borderBottom = "1px solid #3C3C3C";
            const titleText = document.createElement("div");
            titleText.innerText = "Settings";
            titleText.style.fontSize = "16px";
            titleText.style.fontWeight = "bold";
            titleBar.appendChild(titleText);
            // “X” close button
            const closeBtn = document.createElement("div");
            closeBtn.innerText = "×";
            closeBtn.style.fontSize = "20px";
            closeBtn.style.cursor = "pointer";
            closeBtn.onclick = () => this.close(false);
            titleBar.appendChild(closeBtn);
            this.container.appendChild(titleBar);
            // Main content area: left nav and right content panel.
            const mainContent = document.createElement("div");
            mainContent.style.display = "flex";
            mainContent.style.flex = "1 1 auto";
            mainContent.style.height = "calc(100% - 50px)"; // subtract title and bottom bar
            this.container.appendChild(mainContent);
            // Left navigation panel
            const leftNav = document.createElement("div");
            leftNav.style.width = "150px";
            leftNav.style.borderRight = "1px solid #3C3C3C";
            leftNav.style.display = "flex";
            leftNav.style.flexDirection = "column";
            mainContent.appendChild(leftNav);
            // Right content panel
            this.contentArea = document.createElement("div");
            this.contentArea.style.flex = "1";
            this.contentArea.style.padding = "16px";
            this.contentArea.style.overflowY = "auto";
            mainContent.appendChild(this.contentArea);
            // Bottom bar with Template, Cancel, and Ok buttons.
            const bottomBar = document.createElement("div");
            bottomBar.style.borderTop = "1px solid #3C3C3C";
            bottomBar.style.display = "flex";
            bottomBar.style.alignItems = "center";
            bottomBar.style.justifyContent = "space-between";
            bottomBar.style.padding = "8px 12px";
            const templateBtn = document.createElement("button");
            templateBtn.innerText = "Template ▾";
            templateBtn.style.backgroundColor = "#444";
            templateBtn.style.color = "#FFF";
            templateBtn.style.border = "none";
            templateBtn.style.borderRadius = "4px";
            templateBtn.style.padding = "6px 12px";
            bottomBar.appendChild(templateBtn);
            const rightBtnContainer = document.createElement("div");
            rightBtnContainer.style.display = "flex";
            rightBtnContainer.style.gap = "8px";
            const cancelBtn = document.createElement("button");
            cancelBtn.innerText = "Cancel";
            cancelBtn.style.backgroundColor = "#444";
            cancelBtn.style.color = "#FFF";
            cancelBtn.style.border = "none";
            cancelBtn.style.borderRadius = "4px";
            cancelBtn.style.padding = "6px 12px";
            cancelBtn.style.cursor = "pointer";
            cancelBtn.onclick = () => this.close(false);
            rightBtnContainer.appendChild(cancelBtn);
            const okBtn = document.createElement("button");
            okBtn.innerText = "Ok";
            okBtn.style.backgroundColor = "#008CBA";
            okBtn.style.color = "#FFF";
            okBtn.style.border = "none";
            okBtn.style.borderRadius = "4px";
            okBtn.style.padding = "6px 12px";
            okBtn.style.cursor = "pointer";
            okBtn.onclick = () => this.close(true);
            rightBtnContainer.appendChild(okBtn);
            bottomBar.appendChild(rightBtnContainer);
            this.container.appendChild(bottomBar);
            /***************************************
             * Define new left-nav categories (tabs)
             ***************************************/
            this.categories = [
                {
                    id: "series-colors", // The main tab for color editing across *all* series
                    label: "Series Colors",
                    buildContent: () => this.buildSeriesColorsTab(),
                },
                // Your other tabs ...
                {
                    id: "layout-options",
                    label: "Layout Options",
                    buildContent: () => this.buildLayoutOptionsTab(),
                },
                {
                    id: "grid-options",
                    label: "Grid Options",
                    buildContent: () => this.buildGridOptionsTab(),
                },
                {
                    id: "crosshair-options",
                    label: "Crosshair Options",
                    buildContent: () => this.buildCrosshairOptionsTab(),
                },
                {
                    id: "time-scale-options",
                    label: "Time Scale",
                    buildContent: () => this.buildTimeScaleOptionsTab(),
                },
                {
                    id: "price-scale-options",
                    label: "Price Scale",
                    buildContent: () => this.buildPriceScaleOptionsTab(),
                },
                {
                    id: "defaults-list",
                    label: "Defaults",
                    buildContent: () => this.buildDefaultsListTab(),
                },
                {
                    id: "source-code",
                    label: "source-code",
                    buildContent: () => this.buildSourceCodeTab(),
                },
            ];
            // Build the left-nav buttons
            this.categories.forEach((cat) => {
                const catBtn = document.createElement("div");
                catBtn.innerText = cat.label;
                Object.assign(catBtn.style, {
                    padding: "8px 16px",
                    cursor: "pointer",
                    borderBottom: "1px solid #3C3C3C",
                });
                catBtn.addEventListener("click", () => this.switchCategory(cat.id));
                leftNav.appendChild(catBtn);
            });
            // Start with the first category active
            if (this.categories.length > 0) {
                this.switchCategory(this.categories[0].id);
            }
        }
        // ─────────────────────────────────────────────────────────────
        // 1) Show / Hide Modal
        // ─────────────────────────────────────────────────────────────
        open() {
            if (this.isOpen)
                return;
            this.isOpen = true;
            // Show the backdrop
            this.backdrop.style.display = "block";
            setTimeout(() => {
                this.backdrop.style.opacity = "1";
            }, 10);
            // Show the container
            this.container.style.display = "block";
            setTimeout(() => {
                this.container.style.opacity = "1";
                this.container.style.transform = "translate(-50%, -50%) scale(1)";
            }, 10);
        }
        close(confirmed) {
            // If “Ok” was clicked, do final logic (like saving user changes).
            if (confirmed) {
                console.log("Settings Modal: OK clicked. Save changes here.");
                // Implement real save logic if needed.
            }
            else {
                console.log("Settings Modal: Cancel clicked.");
                // Implement rollback logic if needed.
            }
            this.isOpen = false;
            this.backdrop.style.opacity = "0";
            this.container.style.opacity = "0";
            this.container.style.transform = "translate(-50%, -50%) scale(0.95)";
            setTimeout(() => {
                if (!this.isOpen) {
                    this.backdrop.style.display = "none";
                    this.container.style.display = "none";
                }
            }, 300);
        }
        // ─────────────────────────────────────────────────────────────
        // 2) Navigation / Category Switching
        // ─────────────────────────────────────────────────────────────
        switchCategory(catId) {
            this.activeCategoryId = catId;
            // Clear the content area
            this.contentArea.innerHTML = "";
            // Find the category object
            const categoryObj = this.categories.find((c) => c.id === catId);
            if (categoryObj) {
                categoryObj.buildContent();
            }
        }
        /**************************************
         * New Tab Builders (for each option)
         **************************************/
        /**
         * Layout Options Tab
         * Recreates settings for text and background colors.
         */
        buildLayoutOptionsTab() {
            const title = document.createElement("div");
            title.innerText = "Layout Options";
            title.style.fontSize = "14px";
            title.style.fontWeight = "bold";
            title.style.marginBottom = "8px";
            this.contentArea.appendChild(title);
            // Text Color Option
            const currentTextColor = this.getCurrentOptionValue("layout.textColor") || "#000000";
            this.addColorPicker("Text Color", currentTextColor, (color) => {
                this.handler.chart.applyOptions({ layout: { textColor: color } });
            });
            // Background Options based on current type:
            const currentBackground = this.handler.chart.options().layout?.background;
            if (currentBackground && currentBackground.type === "solid") {
                // Solid background color
                const bgColor = currentBackground.color || "#FFFFFF";
                this.addColorPicker("Background Color", bgColor, (color) => {
                    this.handler.chart.applyOptions({
                        layout: { background: { type: lightweightCharts.ColorType.Solid, color } },
                    });
                });
            }
            else if (currentBackground && currentBackground.type === lightweightCharts.ColorType.VerticalGradient) {
                // Gradient background colors
                let topColor = currentBackground.topColor || "rgba(255,0,0,0.33)";
                let bottomColor = currentBackground.bottomColor || "rgba(0,255,0,0.33)";
                this.addColorPicker("Top Color", topColor, (color) => {
                    bottomColor = currentBackground.bottomColor || "rgba(0,255,0,0.33)";
                    this.handler.chart.applyOptions({
                        layout: {
                            background: { type: lightweightCharts.ColorType.VerticalGradient, topColor: color, bottomColor },
                        },
                    });
                });
                this.addColorPicker("Bottom Color", bottomColor, (color) => {
                    topColor = currentBackground.topColor || "rgba(255,0,0,0.33)";
                    this.handler.chart.applyOptions({
                        layout: {
                            background: { type: lightweightCharts.ColorType.VerticalGradient, topColor, bottomColor: color },
                        },
                    });
                });
            }
            else {
                console.warn("Unknown background type.");
            }
            // Button to switch background type
            const switchBtn = document.createElement("button");
            switchBtn.innerText = "Switch Background Type";
            switchBtn.style.marginTop = "12px";
            switchBtn.onclick = () => this.toggleBackgroundType();
            this.contentArea.appendChild(switchBtn);
        }
        /**
         * Grid Options Tab
         * Provides controls for grid line colors, styles, and visibility.
         */
        buildGridOptionsTab() {
            const title = document.createElement("div");
            title.innerText = "Grid Options";
            title.style.fontSize = "14px";
            title.style.fontWeight = "bold";
            title.style.marginBottom = "8px";
            this.contentArea.appendChild(title);
            // Vertical grid line color
            const vertLineColor = this.getCurrentOptionValue("grid.vertLines.color") || "#D6DCDE";
            this.addColorPicker("Vertical Line Color", vertLineColor, (color) => {
                this.handler.chart.applyOptions({ grid: { vertLines: { color } } });
            });
            // Horizontal grid line color
            const horzLineColor = this.getCurrentOptionValue("grid.horzLines.color") || "#D6DCDE";
            this.addColorPicker("Horizontal Line Color", horzLineColor, (color) => {
                this.handler.chart.applyOptions({ grid: { horzLines: { color } } });
            });
            // 1) Build a lookup that maps the user-friendly string to the numeric enum
            const styleMapping = {
                "Solid": lightweightCharts.LineStyle.Solid,
                "Dotted": lightweightCharts.LineStyle.Dotted,
                "Dashed": lightweightCharts.LineStyle.Dashed,
                "LargeDashed": lightweightCharts.LineStyle.LargeDashed,
                "SparseDotted": lightweightCharts.LineStyle.SparseDotted,
            };
            // 2) When you handle the dropdown selection:
            this.addDropdown("Vertical Line Style", ["Solid", "Dashed", "Dotted", "LargeDashed"], (selected) => {
                // Map the string to the numeric style
                const lineStyle = styleMapping[selected];
                // Apply the chart options
                this.handler.chart.applyOptions({
                    grid: { vertLines: { style: lineStyle } },
                });
            });
            this.addDropdown("Horizontal Line Style", ["Solid", "Dashed", "Dotted", "LargeDashed"], (selected) => {
                // Map the string to the numeric style
                const lineStyle = styleMapping[selected];
                // Apply the chart options
                this.handler.chart.applyOptions({
                    grid: { horzLines: { style: lineStyle } },
                });
            });
            // Checkboxes for line visibility
            const vertVisible = this.getCurrentOptionValue("grid.vertLines.visible") !== false;
            this.addCheckbox("Show Vertical Lines", vertVisible, (visible) => {
                this.handler.chart.applyOptions({ grid: { vertLines: { visible } } });
            });
            const horzVisible = this.getCurrentOptionValue("grid.horzLines.visible") !== false;
            this.addCheckbox("Show Horizontal Lines", horzVisible, (visible) => {
                this.handler.chart.applyOptions({ grid: { horzLines: { visible } } });
            });
        }
        /**
         * Crosshair Options Tab
         * Provides full customization controls for the crosshair:
         * - Mode (Normal, Magnet, Hidden)
         * - Vertical line: width, style, color, label background color
         * - Horizontal line: style, color, label background color
         */
        buildCrosshairOptionsTab() {
            // Create and append the title element
            const title = document.createElement("div");
            title.innerText = "Crosshair Options";
            title.style.fontSize = "14px";
            title.style.fontWeight = "bold";
            title.style.marginBottom = "8px";
            this.contentArea.appendChild(title);
            // -------------------------------
            // Crosshair Mode Dropdown
            // -------------------------------
            const crosshairModes = ["Normal", "Magnet", "Hidden"];
            this.addDropdown("Crosshair Mode", crosshairModes, (selected) => {
                this.handler.chart.applyOptions({
                    crosshair: { mode: selected },
                });
            });
            // -------------------------------
            // Vertical Crosshair Line Options
            // -------------------------------
            // Vertical line width dropdown (values 1–10)
            const widthOptions = Array.from({ length: 10 }, (_, i) => (i + 1).toString());
            this.addDropdown("Vertical Line Width", widthOptions, (selected) => {
                const newWidth = parseInt(selected, 10);
                this.handler.chart.applyOptions({
                    crosshair: { vertLine: { width: newWidth } },
                });
            });
            // Vertical line style dropdown.
            const lineStyleOptions = ["Solid", "Dotted", "Dashed", "LargeDashed", "SparseDotted"];
            this.addDropdown("Vertical Line Style", lineStyleOptions, (selected) => {
                this.handler.chart.applyOptions({
                    crosshair: { vertLine: { style: selected } },
                });
            });
            // Vertical line color picker.
            const vertLineColor = this.getCurrentOptionValue("crosshair.vertLine.color") || "#C3BCDB44";
            this.addColorPicker("Vertical Line Color", vertLineColor, (newColor) => {
                this.handler.chart.applyOptions({
                    crosshair: { vertLine: { color: newColor } },
                });
            });
            // Vertical line label background color picker.
            const vertLabelBg = this.getCurrentOptionValue("crosshair.vertLine.labelBackgroundColor") || "#9B7DFF";
            this.addColorPicker("Vertical Label Background", vertLabelBg, (newColor) => {
                this.handler.chart.applyOptions({
                    crosshair: { vertLine: { labelBackgroundColor: newColor } },
                });
            });
            // -------------------------------
            // Horizontal Crosshair Line Options
            // -------------------------------
            // Horizontal line width dropdown (values 1–10)
            this.addDropdown("Horizontal Line Width", widthOptions, (selected) => {
                const newWidth = parseInt(selected, 10);
                this.handler.chart.applyOptions({
                    crosshair: { horzLine: { width: newWidth } },
                });
            });
            // Horizontal line style dropdown.
            this.addDropdown("Horizontal Line Style", lineStyleOptions, (selected) => {
                this.handler.chart.applyOptions({
                    crosshair: { horzLine: { style: selected } },
                });
            });
            // Horizontal line color picker.
            const horzLineColor = this.getCurrentOptionValue("crosshair.horzLine.color") || "#9B7DFF";
            this.addColorPicker("Horizontal Line Color", horzLineColor, (newColor) => {
                this.handler.chart.applyOptions({
                    crosshair: { horzLine: { color: newColor } },
                });
            });
            // Horizontal line label background color picker.
            const horzLabelBg = this.getCurrentOptionValue("crosshair.horzLine.labelBackgroundColor") || "#9B7DFF";
            this.addColorPicker("Horizontal Label Background", horzLabelBg, (newColor) => {
                this.handler.chart.applyOptions({
                    crosshair: { horzLine: { labelBackgroundColor: newColor } },
                });
            });
        }
        /**
         * Time Scale Options Tab
         * Provides numeric and boolean controls for time scale settings.
         */
        buildTimeScaleOptionsTab() {
            const title = document.createElement("div");
            title.innerText = "Time Scale Options";
            title.style.fontSize = "14px";
            title.style.fontWeight = "bold";
            title.style.marginBottom = "8px";
            this.contentArea.appendChild(title);
            // Right Offset
            const rightOffset = this.getCurrentOptionValue("timeScale.rightOffset") || 0;
            this.addNumberField("Right Offset", rightOffset, (val) => {
                this.handler.chart.applyOptions({ timeScale: { rightOffset: val } });
            });
            // Bar Spacing
            const barSpacing = this.getCurrentOptionValue("timeScale.barSpacing") || 10;
            this.addNumberField("Bar Spacing", barSpacing, (val) => {
                this.handler.chart.applyOptions({ timeScale: { barSpacing: val } });
            });
            // Min Bar Spacing
            const minBarSpacing = this.getCurrentOptionValue("timeScale.minBarSpacing") || 0.1;
            this.addNumberField("Min Bar Spacing", minBarSpacing, (val) => {
                this.handler.chart.applyOptions({ timeScale: { minBarSpacing: val } });
            });
            // Additional checkboxes (e.g., Fix Left/Right Edge, Lock Visible Range, etc.)
            const fixLeftEdge = this.getCurrentOptionValue("timeScale.fixLeftEdge") || false;
            this.addCheckbox("Fix Left Edge", fixLeftEdge, (val) => {
                this.handler.chart.applyOptions({ timeScale: { fixLeftEdge: val } });
            });
            const fixRightEdge = this.getCurrentOptionValue("timeScale.fixRightEdge") || false;
            this.addCheckbox("Fix Right Edge", fixRightEdge, (val) => {
                this.handler.chart.applyOptions({ timeScale: { fixRightEdge: val } });
            });
            const lockVisibleRange = this.getCurrentOptionValue("timeScale.lockVisibleTimeRangeOnResize") || false;
            this.addCheckbox("Lock Visible Range on Resize", lockVisibleRange, (val) => {
                this.handler.chart.applyOptions({ timeScale: { lockVisibleTimeRangeOnResize: val } });
            });
            const visible = this.getCurrentOptionValue("timeScale.visible");
            this.addCheckbox("Time Scale Visible", visible !== false, (val) => {
                this.handler.chart.applyOptions({ timeScale: { visible: val } });
            });
            const borderVisible = this.getCurrentOptionValue("timeScale.borderVisible");
            this.addCheckbox("Border Visible", borderVisible !== false, (val) => {
                this.handler.chart.applyOptions({ timeScale: { borderVisible: val } });
            });
            const borderColor = this.getCurrentOptionValue("timeScale.borderColor") || "#000000";
            this.addColorPicker("Border Color", borderColor, (color) => {
                this.handler.chart.applyOptions({ timeScale: { borderColor: color } });
            });
        }
        /**
           * Price Scale Options Tab
           * Provides a dropdown for mode and checkboxes for additional options.
           */
        buildPriceScaleOptionsTab() {
            const title = document.createElement("div");
            title.innerText = "Price Scale Options";
            title.style.fontSize = "14px";
            title.style.fontWeight = "bold";
            title.style.marginBottom = "8px";
            this.contentArea.appendChild(title);
            // For this example, we use the "right" price scale.
            const priceScale = this.handler.chart.priceScale("right");
            priceScale.options().mode || lightweightCharts.PriceScaleMode.Normal;
            const modeOptions = [
                { label: "Normal", value: lightweightCharts.PriceScaleMode.Normal },
                { label: "Logarithmic", value: lightweightCharts.PriceScaleMode.Logarithmic },
                { label: "Percentage", value: lightweightCharts.PriceScaleMode.Percentage },
                { label: "Indexed To 100", value: lightweightCharts.PriceScaleMode.IndexedTo100 },
            ];
            const modeLabels = modeOptions.map((opt) => opt.label);
            this.addDropdown("Price Scale Mode", modeLabels, (selected) => {
                const selectedOption = modeOptions.find((opt) => opt.label === selected);
                if (selectedOption) {
                    priceScale.applyOptions({ mode: selectedOption.value });
                }
            });
            // Additional toggles for the price scale
            const autoScale = priceScale.options().autoScale !== undefined
                ? priceScale.options().autoScale
                : true;
            this.addCheckbox("Auto Scale", autoScale, (val) => {
                priceScale.applyOptions({ autoScale: val });
            });
            const invertScale = priceScale.options().invertScale || false;
            this.addCheckbox("Invert Scale", invertScale, (val) => {
                priceScale.applyOptions({ invertScale: val });
            });
            const alignLabels = priceScale.options().alignLabels !== undefined
                ? priceScale.options().alignLabels
                : true;
            this.addCheckbox("Align Labels", alignLabels, (val) => {
                priceScale.applyOptions({ alignLabels: val });
            });
            const borderVisible = priceScale.options().borderVisible !== undefined
                ? priceScale.options().borderVisible
                : true;
            this.addCheckbox("Border Visible", borderVisible, (val) => {
                priceScale.applyOptions({ borderVisible: val });
            });
            const ticksVisible = priceScale.options().ticksVisible || false;
            this.addCheckbox("Ticks Visible", ticksVisible, (val) => {
                priceScale.applyOptions({ ticksVisible: val });
            });
        }
        /**
         * Demonstrates how a sub-tab might be built for “Clone Series”.
         */
        buildCloneSeriesTab(series) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `Clone Series - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, { fontSize: "16px", fontWeight: "bold", marginBottom: "12px" });
            this.contentArea.appendChild(title);
            // TODO: Real logic for cloning the series
            // E.g., ask user for a name, create a new series with same config, etc.
            const msg = document.createElement("div");
            msg.innerText = "(Clone Series logic not yet implemented.)";
            msg.style.color = "#ccc";
            msg.style.marginBottom = "12px";
            this.contentArea.appendChild(msg);
            // Back button
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        buildVisibilityOptionsTab(series) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `Visibility Options - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, { fontSize: "16px", fontWeight: "bold", marginBottom: "12px" });
            this.contentArea.appendChild(title);
            // TODO: e.g., checkboxes for “visible”, “markers visible”, etc.
            const msg = document.createElement("div");
            msg.innerText = "(Visibility Options logic not yet implemented.)";
            msg.style.color = "#ccc";
            msg.style.marginBottom = "12px";
            this.contentArea.appendChild(msg);
            // Back button
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        // Same pattern for Style Options
        buildStyleOptionsTab(series) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `Style Options - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, { fontSize: "16px", fontWeight: "bold", marginBottom: "12px" });
            this.contentArea.appendChild(title);
            // TODO: real style config controls
            const msg = document.createElement("div");
            msg.innerText = "(Style Options logic not yet implemented.)";
            msg.style.color = "#ccc";
            msg.style.marginBottom = "12px";
            this.contentArea.appendChild(msg);
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        buildWidthOptionsTab(series) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `Width Options - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, { fontSize: "16px", fontWeight: "bold", marginBottom: "12px" });
            this.contentArea.appendChild(title);
            // TODO: e.g., numeric field for line width, bar width, etc.
            const msg = document.createElement("div");
            msg.innerText = "(Width Options logic not yet implemented.)";
            msg.style.color = "#ccc";
            msg.style.marginBottom = "12px";
            this.contentArea.appendChild(msg);
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        // We can reuse your existing “Series Colors” logic or open that here
        buildColorOptionsTab(series) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `Color Options - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, { fontSize: "16px", fontWeight: "bold", marginBottom: "12px" });
            this.contentArea.appendChild(title);
            // Because you already have a dedicated approach for color pickers,
            // you could replicate or integrate that logic here
            const msg = document.createElement("div");
            msg.innerText = "(Color Options logic not yet implemented.)";
            msg.style.color = "#ccc";
            msg.style.marginBottom = "12px";
            this.contentArea.appendChild(msg);
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        buildPrimitivesTab(series) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `Primitives - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, { fontSize: "16px", fontWeight: "bold", marginBottom: "12px" });
            this.contentArea.appendChild(title);
            // e.g., shapes or overlays
            const msg = document.createElement("div");
            msg.innerText = "(Primitives logic not yet implemented.)";
            msg.style.color = "#ccc";
            msg.style.marginBottom = "12px";
            this.contentArea.appendChild(msg);
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        buildIndicatorsTab(series) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `Indicators - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, { fontSize: "16px", fontWeight: "bold", marginBottom: "12px" });
            this.contentArea.appendChild(title);
            const msg = document.createElement("div");
            msg.innerText = "(Indicators logic not yet implemented.)";
            msg.style.color = "#ccc";
            msg.style.marginBottom = "12px";
            this.contentArea.appendChild(msg);
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        /**
        * Builds a Source Code tab that displays the complete source code
        * and provides a button to download it.
        * Also includes links to the main project's source and your modified PineTS (AGPL) repository.
        */
        buildSourceCodeTab() {
            // Clear the content area
            this.contentArea.innerHTML = "";
            // Title for the Source Code tab
            const title = document.createElement("div");
            title.innerText = "Source Code";
            title.style.fontSize = "16px";
            title.style.fontWeight = "bold";
            title.style.marginBottom = "12px";
            this.contentArea.appendChild(title);
            // Informational text
            const info = document.createElement("div");
            info.innerText = "Below is the complete source code for this project. You can also view the repositories:";
            info.style.marginBottom = "12px";
            this.contentArea.appendChild(info);
            // Links container
            const linksContainer = document.createElement("div");
            linksContainer.style.marginBottom = "12px";
            linksContainer.style.fontSize = "14px";
            // Main project link
            const mainProjectLink = document.createElement("a");
            mainProjectLink.href = "https://github.com/EsIstJosh/lightweight-charts-python/tree/main";
            mainProjectLink.target = "_blank";
            mainProjectLink.style.color = "#008CBA";
            mainProjectLink.style.textDecoration = "underline";
            mainProjectLink.innerText = "Main Project Source";
            // Separator text
            const separator = document.createTextNode(" | ");
            // Modified PineTS link (AGPL)
            const pineTSLink = document.createElement("a");
            pineTSLink.href = "https://github.com/EsIstJosh/PineTS";
            pineTSLink.target = "_blank";
            pineTSLink.style.color = "#008CBA";
            pineTSLink.style.textDecoration = "underline";
            pineTSLink.innerText = "Modified PineTS Source (AGPL)";
            // Append links to the container
            linksContainer.appendChild(mainProjectLink);
            linksContainer.appendChild(separator);
            linksContainer.appendChild(pineTSLink);
            this.contentArea.appendChild(linksContainer);
            // Create a textarea for displaying source code (replace placeholder with actual source code if available)
            const textarea = document.createElement("textarea");
            textarea.style.width = "100%";
            textarea.style.height = "400px";
            textarea.style.backgroundColor = "#444";
            textarea.style.color = "#fff";
            textarea.style.border = "1px solid #555";
            textarea.style.borderRadius = "4px";
            textarea.style.resize = "vertical";
            textarea.value = "/* Insert your complete source code here... */";
            this.contentArea.appendChild(textarea);
            // Download button to save the source code as a file
            const downloadBtn = document.createElement("button");
            downloadBtn.innerText = "Download Source Code";
            Object.assign(downloadBtn.style, {
                padding: "8px 12px",
                backgroundColor: "#008CBA",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
                marginTop: "12px",
            });
            downloadBtn.onclick = () => {
                const blob = new Blob([textarea.value], { type: "text/plain;charset=utf-8" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "source-code.txt";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };
            this.contentArea.appendChild(downloadBtn);
            // Back button to return to the default category (for example, the first category)
            this.addButton("⤝ Back", () => this.switchCategory(this.categories[0].id), {
                backgroundColor: "#444",
            });
        }
        buildSeriesMenuTab(series) {
            // Clear content area
            this.contentArea.innerHTML = "";
            // Title
            const title = document.createElement("div");
            title.innerText = `Series Settings - ${series.options().title ?? "Untitled"}`;
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(title);
            // Title input
            this.addTextInput("Title", series.options().title || "", (newTitle) => {
                series.applyOptions({ title: newTitle });
                // Optionally update seriesMap
                const oldTitle = series.options().title;
                if (oldTitle && this.handler.seriesMap.has(oldTitle)) {
                    this.handler.seriesMap.delete(oldTitle);
                }
                this.handler.seriesMap.set(newTitle, series);
            });
            // Sub-tabs
            this.addButton("Clone Series ▸", () => this.buildCloneSeriesTab(series));
            this.addButton("Visibility Options ▸", () => this.buildVisibilityOptionsTab(series));
            this.addButton("Style Options ▸", () => this.buildStyleOptionsTab(series));
            this.addButton("Width Options ▸", () => this.buildWidthOptionsTab(series));
            this.addButton("Color Options ▸", () => this.buildSeriesColorsTabSingle(series));
            this.addButton("Price Scale Options ▸", () => this.buildPriceScaleOptionsTab());
            this.addButton("Primitives ▸", () => this.buildPrimitivesTab(series));
            this.addButton("Indicators ▸", () => this.buildIndicatorsTab(series));
            this.addButton("Export/Import Series Data ▸", () => this.buildDataExportImportTab(series));
        }
        // ─────────────────────────────────────────────────────────────
        // 3) TAB BUILDERS
        // ─────────────────────────────────────────────────────────────
        /**
         * "Series Colors" main tab: displays color pickers for *all* series side-by-side.
         * This is in addition to the per-series color sub-tab accessible in “Series Menu.”
         */
        buildSeriesColorsTab() {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = "Series Colors (All Series)";
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(title);
            // Retrieve all series from your handler.seriesMap
            const seriesEntries = Array.from(this.handler.seriesMap.entries());
            if (seriesEntries.length === 0) {
                const noSeriesMsg = document.createElement("div");
                noSeriesMsg.innerText = "No series found.";
                noSeriesMsg.style.color = "#ccc";
                this.contentArea.appendChild(noSeriesMsg);
                return;
            }
            // For each series, create a mini color section
            seriesEntries.forEach(([seriesName, series]) => {
                this.buildSeriesColorSection(seriesName, series);
            });
        }
        buildSeriesColorSection(seriesName, series) {
            const container = document.createElement("div");
            Object.assign(container.style, {
                border: "1px solid #444",
                marginBottom: "8px",
                padding: "8px",
                borderRadius: "4px",
            });
            const header = document.createElement("div");
            header.innerText = `Series: ${seriesName}`;
            Object.assign(header.style, {
                fontSize: "14px",
                fontWeight: "bold",
                marginBottom: "6px",
            });
            container.appendChild(header);
            const seriesType = series.seriesType?.();
            // For OHLC or Candlestick-like data
            if (seriesType === "Candlestick" || seriesType === "Bar" || seriesType === "Custom") {
                if ("upColor" in series.options()) {
                    // Body
                    this.addSideBySideColors("Body", series.options().upColor, series.options().downColor, (upColor, downColor) => {
                        series.applyOptions({ upColor, downColor });
                    }, container);
                }
                if ('borderUpColor' in series.options()) {
                    // Borders
                    this.addSideBySideColors("Borders", series.options().borderUpColor, series.options().borderDownColor, (upColor, downColor) => {
                        series.applyOptions({
                            borderUpColor: upColor,
                            borderDownColor: downColor,
                        });
                    }, container);
                    this.addSideBySideColors("Wick", series.options().wickUpColor, series.options().wickDownColor, (upColor, downColor) => {
                        series.applyOptions({
                            wickUpColor: upColor,
                            wickDownColor: downColor,
                        });
                    }, container);
                }
            }
            else if (seriesType === "Line") {
                // Single color
                const currentLineColor = series.options().color || "#ffffff";
                this.addColorPicker("Line Color", currentLineColor, (newCol) => series.applyOptions({ color: newCol }), container);
            }
            else if (seriesType === "Area") {
                const opts = series.options();
                // lineColor, topColor, bottomColor
                this.addColorPicker("Line Color", opts.lineColor || "#EEEEEE", (c) => {
                    series.applyOptions({ lineColor: c });
                }, container);
                this.addColorPicker("Top Fill", opts.topColor || "#008cff44", (c) => {
                    series.applyOptions({ topColor: c });
                }, container);
                this.addColorPicker("Bottom Fill", opts.bottomColor || "#008cff00", (c) => {
                    series.applyOptions({ bottomColor: c });
                }, container);
            }
            else {
                const msg = document.createElement("div");
                msg.innerText = `No color settings for series type: ${seriesType}`;
                msg.style.color = "#bbb";
                container.appendChild(msg);
            }
            // Finally, attach container to content area
            this.contentArea.appendChild(container);
        }
        /**
         * A single-series “Color Options” sub-tab
         */
        buildSeriesColorsTabSingle(series) {
            // Clear the content area
            this.contentArea.innerHTML = "";
            // A container for everything on this tab
            const container = document.createElement("div");
            Object.assign(container.style, {
                border: "1px solid #444",
                marginBottom: "8px",
                padding: "8px",
                borderRadius: "4px",
            });
            this.contentArea.appendChild(container);
            // Title
            const title = document.createElement("div");
            title.innerText = `Color Options - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            container.appendChild(title);
            const seriesType = series.type?.();
            if (seriesType === "Candlestick" || seriesType === "Bar" || seriesType === "Custom") {
                if ("upColor" in series.options()) {
                    // Body
                    this.addSideBySideColors("Body", series.options().upColor, series.options().downColor, (upColor, downColor) => {
                        series.applyOptions({ upColor, downColor });
                    }, container);
                }
                if ('borderUpColor' in series.options()) {
                    this.addSideBySideColors("Borders", series.options().borderUpColor, series.options().borderDownColor, (upColor, downColor) => {
                        series.applyOptions({
                            borderUpColor: upColor,
                            borderDownColor: downColor,
                        });
                    }, container);
                    this.addSideBySideColors("Wick", series.options().wickUpColor, series.options().wickDownColor, (upColor, downColor) => {
                        series.applyOptions({
                            wickUpColor: upColor,
                            wickDownColor: downColor,
                        });
                    }, container);
                }
            }
            else if (seriesType === "Line") {
                const currentLineColor = series.options().color || "#FFFFFF";
                this.addColorPicker("Line Color", currentLineColor, (newColor) => {
                    series.applyOptions({ color: newColor });
                }, container);
                // etc...
            }
            else if (seriesType === "Area") {
                const opts = series.options();
                // ...
                this.addColorPicker("Line Color", opts.lineColor || "#EEEEEE", (c) => {
                    series.applyOptions({ lineColor: c });
                }, container);
                // ...
            }
            else {
                const unknownMsg = document.createElement("div");
                unknownMsg.innerText = `No color settings for series type: ${seriesType}`;
                unknownMsg.style.color = "#bbb";
                container.appendChild(unknownMsg);
            }
            // Back button at the bottom
            const backBtn = document.createElement("button");
            backBtn.innerText = "⤝ Back";
            Object.assign(backBtn.style, {
                backgroundColor: "#444",
                marginTop: "16px",
                padding: "8px 12px",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
            });
            backBtn.onclick = () => this.buildSeriesMenuTab(series);
            container.appendChild(backBtn);
        }
        buildDataExportImportTab(series) {
            this.subTabSkeleton("Export/Import", series, "(Export/Import logic not yet implemented.)");
        }
        /**
         * Helper to quickly build a “placeholder” sub-tab.
         */
        subTabSkeleton(tabName, series, message) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `${tabName} - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(title);
            const msg = document.createElement("div");
            msg.innerText = message;
            Object.assign(msg.style, {
                color: "#ccc",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(msg);
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        buildDefaultsListTab() {
            // Clear content area
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = "Default Configurations";
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(title);
            // Suppose your Handler has a property: handler.defaultsManager
            const defaultsManager = this.handler?.defaultsManager;
            if (!defaultsManager) {
                const msg = document.createElement("div");
                msg.innerText = "No defaults manager found.";
                msg.style.color = "#ccc";
                this.contentArea.appendChild(msg);
                return;
            }
            // Retrieve all defaults from the manager
            const allDefaultsMap = defaultsManager.getAll(); // a Map<string, any>
            const allKeys = Array.from(allDefaultsMap.keys());
            if (allKeys.length === 0) {
                const msg = document.createElement("div");
                msg.innerText = "No default configurations found.";
                msg.style.color = "#ccc";
                this.contentArea.appendChild(msg);
                return;
            }
            // Add a new button for Export/Import of the chart config
            this.addButton("Current Chart Config ▸", (evt) => {
                // You can place your logic here; for example:
                // 1. If dataMenu is not instantiated, create it
                if (!this.handler.ContextMenu.dataMenu) {
                    // dataMenu is hypothetical—replace with your own menu or logic
                    this.handler.ContextMenu.dataMenu = new DataMenu({
                        contextMenu: this.handler.ContextMenu,
                        handler: this.handler,
                    });
                }
                // 2. Then open the menu or export logic
                // “Handler” is a label or ID you can pass along, depending on your needs
                this.handler.ContextMenu.dataMenu.openMenu(this.handler, evt, "Handler");
            }, {
                backgroundColor: "#444",
                borderRadius: "8px",
                marginBottom: "8px",
                display: "block",
            });
            // For each key, add a button to open the default options editor
            allKeys.forEach((key) => {
                this.addButton(`Edit "${key}" Defaults`, () => {
                    // We assume there's a dataMenu in your handler with openDefaultOptions(key)
                    if (this.handler.ContextMenu?.dataMenu &&
                        typeof this.handler.ContextMenu.dataMenu.openDefaultOptions === "function") {
                        this.handler.ContextMenu.dataMenu.openDefaultOptions(key);
                    }
                    else {
                        console.warn("No dataMenu or openDefaultOptions method found on handler.");
                    }
                }, {
                    backgroundColor: "#444",
                    borderRadius: "8px",
                    marginBottom: "8px",
                    display: "block",
                });
            });
        }
        // ─────────────────────────────────────────────────────────────
        // 6) HELPER METHODS
        // ─────────────────────────────────────────────────────────────
        /**
         * Adds a color “swatch” button that, when clicked, opens our *reusable* colorPicker menu.
         */
        addColorPicker(label, defaultColor, onChange, parent = this.contentArea) {
            // Container row
            const container = document.createElement("div");
            Object.assign(container.style, {
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                marginBottom: "8px",
                fontFamily: "sans-serif",
                fontSize: "14px",
            });
            // Label
            const lbl = document.createElement("span");
            lbl.innerText = label;
            container.appendChild(lbl);
            // Swatch (div) that shows the currently selected color
            const swatch = document.createElement("div");
            Object.assign(swatch.style, {
                width: "26px",
                height: "26px",
                borderRadius: "4px",
                cursor: "pointer",
                border: "1px solid #999",
                backgroundColor: defaultColor,
            });
            container.appendChild(swatch);
            // When user clicks the swatch, open the REUSABLE colorPicker
            swatch.addEventListener("click", (ev) => {
                // 1) Update the colorPicker's current color and callback
                this.colorPicker.update(swatch.style.backgroundColor, (newColor) => {
                    // We'll also set the swatch's background to the newly chosen color
                    swatch.style.backgroundColor = newColor;
                    onChange(newColor);
                });
                // 2) Open the colorPicker near the clicked swatch
                this.colorPicker.openMenu(ev, swatch.offsetWidth, (newColor) => {
                    // This "applySelection" callback is also triggered whenever the user picks a color
                    swatch.style.backgroundColor = newColor;
                    onChange(newColor);
                });
            });
            parent.appendChild(container);
        }
        /**
         * Adds a dropdown (select) control.
         */
        addDropdown(label, options, onChange) {
            const container = document.createElement("div");
            container.style.display = "flex";
            container.style.alignItems = "center";
            container.style.marginBottom = "8px";
            container.style.justifyContent = "space-between";
            container.style.marginBottom = "8px";
            const lbl = document.createElement("span");
            lbl.innerText = label;
            container.appendChild(lbl);
            const select = document.createElement("select");
            select.style.backgroundColor = "#444";
            select.style.color = "#fff";
            select.style.border = "1px solid #555";
            select.style.borderRadius = "4px";
            select.style.outline = "none";
            options.forEach((opt) => {
                const option = document.createElement("option");
                option.value = opt;
                option.innerText = opt;
                select.appendChild(option);
            });
            select.onchange = () => onChange(select.value);
            container.appendChild(select);
            this.contentArea.appendChild(container);
        }
        addButton(label, onClick, customStyle) {
            const button = document.createElement("button");
            button.innerText = label;
            Object.assign(button.style, {
                padding: "8px 12px",
                margin: "4px 0",
                backgroundColor: "#008CBA",
                color: "#fff",
                border: "none",
                borderRadius: "8px",
                cursor: "pointer",
                fontFamily: "sans-serif",
                fontSize: "14px",
            });
            if (customStyle) {
                Object.assign(button.style, customStyle);
            }
            button.onclick = onClick;
            this.contentArea.appendChild(button);
        }
        /**
         * Adds a numeric input field.
         */
        addNumberField(label, initial, onChange) {
            const container = document.createElement("div");
            container.style.display = "flex";
            container.style.alignItems = "center";
            container.style.justifyContent = "space-between";
            container.style.marginBottom = "8px";
            const lbl = document.createElement("span");
            lbl.innerText = label;
            container.appendChild(lbl);
            const input = document.createElement("input");
            input.type = "number";
            input.value = initial.toString();
            input.style.width = "60px";
            input.style.backgroundColor = "#444";
            input.style.color = "#fff";
            input.style.border = "1px solid #555";
            input.style.borderRadius = "4px";
            input.oninput = () => {
                const val = parseFloat(input.value);
                onChange(isNaN(val) ? 0 : val);
            };
            container.appendChild(input);
            this.contentArea.appendChild(container);
        }
        /**
         * Adds a checkbox control.
         */
        addCheckbox(label, initial, onChange) {
            const container = document.createElement("label");
            container.style.display = "flex";
            container.style.alignItems = "center";
            container.style.marginBottom = "8px";
            const input = document.createElement("input");
            input.type = "checkbox";
            input.checked = initial;
            input.style.marginRight = "8px";
            input.onchange = () => onChange(input.checked);
            container.appendChild(input);
            const span = document.createElement("span");
            span.innerText = label;
            container.appendChild(span);
            this.contentArea.appendChild(container);
        }
        /**
         * Retrieves the current option value from the chart given a dot‑separated path.
         */
        getCurrentOptionValue(optionPath) {
            const keys = optionPath.split(".");
            let options = this.handler.chart.options();
            for (const key of keys) {
                if (options && key in options) {
                    options = options[key];
                }
                else {
                    console.warn(`Option path "${optionPath}" is invalid.`);
                    return null;
                }
            }
            return options;
        }
        /**
        * Toggles the chart’s background type between solid and vertical-gradient.
        */
        toggleBackgroundType() {
            // Get the current background settings
            const currentBg = this.handler.chart.options().layout?.background;
            // If there's no background at all, define a fallback
            if (!currentBg) {
                // Example: default to solid white
                this.handler.chart.applyOptions({
                    layout: {
                        background: {
                            type: lightweightCharts.ColorType.Solid,
                            color: "#FFFFFF",
                        },
                    },
                });
                this.buildLayoutOptionsTab();
                return;
            }
            // Check what the current background type is
            if (currentBg.type === lightweightCharts.ColorType.Solid) {
                // We are going from SOLID => VERTICAL GRADIENT
                // Use the current solid color as the topColor, or fallback
                const existingSolidColor = currentBg.color || "#FFFFFF";
                // Optionally, if you previously stored a bottom color somewhere,
                // you can retrieve that. Otherwise, pick a fallback:
                const defaultBottom = "rgba(0,255,0,0.33)";
                const updatedBackground = {
                    type: lightweightCharts.ColorType.VerticalGradient,
                    topColor: existingSolidColor,
                    bottomColor: defaultBottom,
                };
                this.handler.chart.applyOptions({
                    layout: { background: updatedBackground },
                });
            }
            else if (currentBg.type === lightweightCharts.ColorType.VerticalGradient) {
                // We are going from VERTICAL GRADIENT => SOLID
                // Choose which gradient color to adopt as your new "solid" color.
                // Often the top color is used, but you could pick bottom if you prefer.
                const currentTop = currentBg.topColor || "#FFFFFF";
                const updatedBackground = {
                    type: lightweightCharts.ColorType.Solid,
                    color: currentTop,
                };
                this.handler.chart.applyOptions({
                    layout: { background: updatedBackground },
                });
            }
            else {
                // If it's some other background type or missing fields,
                // fallback to a default
                console.warn("Unknown background type. Falling back to solid #FFFFFF.");
                this.handler.chart.applyOptions({
                    layout: {
                        background: {
                            type: lightweightCharts.ColorType.Solid,
                            color: "#FFFFFF",
                        },
                    },
                });
            }
            // Finally, refresh the Layout Options tab so the new colors become current.
            this.buildLayoutOptionsTab();
        }
        /***********************************************************
          * 4. Helper Methods for UI Controls
          ***********************************************************/
        /** Simple function to create a text input row. */
        addTextInput(label, defaultValue, onChange) {
            const container = document.createElement("div");
            Object.assign(container.style, {
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                marginBottom: "8px",
                fontFamily: "sans-serif",
                fontSize: "14px",
            });
            const lbl = document.createElement("span");
            lbl.innerText = label;
            container.appendChild(lbl);
            const input = document.createElement("input");
            input.type = "text";
            input.value = defaultValue;
            Object.assign(input.style, {
                width: "150px",
                padding: "4px",
                backgroundColor: "#444",
                color: "#fff",
                border: "1px solid #555",
                borderRadius: "4px",
            });
            input.oninput = () => onChange(input.value);
            container.appendChild(input);
            this.contentArea.appendChild(container);
        }
        /**
         * Adds two color swatches for “Up” and “Down” colors, plus a checkbox
         * that toggles both to alpha=0. Uses the single ColorPicker instance.
         */
        addSideBySideColors(label, defaultUpColor, defaultDownColor, onChange, parent = this.contentArea) {
            // 1) Create row container for checkbox, label, and swatches
            const row = document.createElement("div");
            Object.assign(row.style, {
                display: "flex",
                alignItems: "center",
                marginBottom: "8px",
                gap: "12px",
            });
            // 2) Checkbox to enable/disable alpha=0
            const enabledCheck = document.createElement("input");
            enabledCheck.type = "checkbox";
            enabledCheck.checked = true; // Start “enabled”
            row.appendChild(enabledCheck);
            // 3) Label
            const lbl = document.createElement("span");
            lbl.innerText = label;
            Object.assign(lbl.style, { minWidth: "60px" });
            row.appendChild(lbl);
            // 4) Container for the up/down swatches
            const pickersContainer = document.createElement("div");
            Object.assign(pickersContainer.style, {
                display: "flex",
                gap: "8px",
            });
            row.appendChild(pickersContainer);
            // Track the “current” colors
            let currentUpColor = defaultUpColor;
            let currentDownColor = defaultDownColor;
            // Track the “saved” real colors (we restore these if user re-checks)
            let savedUpColor = defaultUpColor;
            let savedDownColor = defaultDownColor;
            // 5) Create the two swatches (Up and Down)
            const upSwatch = document.createElement("div");
            Object.assign(upSwatch.style, {
                width: "32px",
                height: "32px",
                borderRadius: "4px",
                cursor: "pointer",
                border: "1px solid #999",
                backgroundColor: currentUpColor,
            });
            const downSwatch = document.createElement("div");
            Object.assign(downSwatch.style, {
                width: "32px",
                height: "32px",
                borderRadius: "4px",
                cursor: "pointer",
                border: "1px solid #999",
                backgroundColor: currentDownColor,
            });
            pickersContainer.appendChild(upSwatch);
            pickersContainer.appendChild(downSwatch);
            // Helper: notify the outside world about color changes
            const fireChange = () => {
                onChange(currentUpColor, currentDownColor);
            };
            // 6) Checkbox logic: alpha=0 when unchecked, restore when checked
            enabledCheck.addEventListener("change", () => {
                if (enabledCheck.checked) {
                    // Re-enabling -> restore saved colors
                    currentUpColor = savedUpColor;
                    currentDownColor = savedDownColor;
                }
                else {
                    // Disabling -> remember real colors, set alpha=0
                    savedUpColor = currentUpColor;
                    savedDownColor = currentDownColor;
                    // If you want to use your setOpacity(...) function:
                    currentUpColor = setOpacity(currentUpColor, 0);
                    currentDownColor = setOpacity(currentDownColor, 0);
                    // Or if you'd prefer to use the colorPicker's logic, you'd replicate it here.
                }
                upSwatch.style.backgroundColor = currentUpColor;
                downSwatch.style.backgroundColor = currentDownColor;
                fireChange();
            });
            // 7) Using the single ColorPicker each time user clicks a swatch
            //    We'll show an example for the "Up" swatch
            upSwatch.addEventListener("click", (evt) => {
                // If user clicks while disabled, let's re-enable first
                if (!enabledCheck.checked) {
                    enabledCheck.checked = true;
                    enabledCheck.dispatchEvent(new Event("change"));
                    // triggers the logic above to restore alpha
                }
                // Now open the color picker with the current color
                this.colorPicker.update(currentUpColor, (newColor) => {
                    // Called as the user picks a color
                    currentUpColor = newColor;
                    upSwatch.style.backgroundColor = newColor;
                    fireChange();
                });
                // Position the color picker near the swatch
                this.colorPicker.openMenu(evt, upSwatch.offsetWidth, (finalColor) => {
                    // "applySelection" final callback
                    currentUpColor = finalColor;
                    upSwatch.style.backgroundColor = finalColor;
                    fireChange();
                });
            });
            // 8) Similarly for the "Down" swatch
            downSwatch.addEventListener("click", (evt) => {
                if (!enabledCheck.checked) {
                    enabledCheck.checked = true;
                    enabledCheck.dispatchEvent(new Event("change"));
                }
                this.colorPicker.update(currentDownColor, (newColor) => {
                    currentDownColor = newColor;
                    downSwatch.style.backgroundColor = newColor;
                    fireChange();
                });
                this.colorPicker.openMenu(evt, downSwatch.offsetWidth, (finalColor) => {
                    currentDownColor = finalColor;
                    downSwatch.style.backgroundColor = finalColor;
                    fireChange();
                });
            });
            // 9) Finally, append the row to the parent
            parent.appendChild(row);
        }
    }
    /*
      Example usage somewhere in your code:
      
      logSeriesColorsFromMap.call(this);

      This will print to the console something like:

        > Color keys for Series: "MyCandles"
          Found color: upColor = "#1565C0"
          Found color: downColor = "#8B4513"
          Found color: borderUpColor = "#00FF00"
          Found color: borderDownColor = "#FF0000"
          ...
    */

    // ----------------------------------
    // External Library Imports
    // ----------------------------------
    // ----------------------------------
    // If you have actual code referencing commented-out or removed imports,
    // reintroduce them accordingly.
    // ----------------------------------
    let activeMenu = null;
    class ContextMenu {
        handler;
        handlerMap;
        getMouseEventParams;
        div;
        hoverItem;
        items = [];
        colorPicker = new ColorPicker("#ff0000", () => null);
        saveDrawings = null;
        drawingTool = null;
        recentSeries = null;
        recentDrawing = null;
        SettingsModal = null;
        volumeProfile = null;
        dataMenu;
        constructor(handler, handlerMap, getMouseEventParams) {
            this.handler = handler;
            this.handlerMap = handlerMap;
            this.getMouseEventParams = getMouseEventParams;
            this.div = document.createElement("div");
            this.div.classList.add("context-menu");
            document.body.appendChild(this.div);
            this.div.style.overflowY = "scroll";
            this.hoverItem = null;
            document.body.addEventListener("contextmenu", this._onRightClick.bind(this));
            document.body.addEventListener("click", this._onClick.bind(this));
            //this.handler.chart.subscribeCrosshairMove((param: MouseEventParams) => {
            //  this.handleCrosshairMove(param);
            //});
            this.dataMenu = new DataMenu({ contextMenu: this, handler: this.handler });
            this.SettingsModal = new SettingsModal(this.handler);
            this.setupMenu();
        }
        constraints = {
            baseline: { skip: true },
            title: { skip: true },
            PriceLineSource: { skip: true },
            tickInterval: { min: 0, max: 100 },
            lastPriceAnimation: { skip: true },
            lineType: { min: 0, max: 2 },
            lineStyle: { min: 0, max: 4 },
            seriesType: { skip: true },
            chandelierSize: { min: 1 }, // skip: true },
            dynamicCandles: { skip: true },
            volumeMALength: { skip: true },
            volumeMultiplier: { skip: true },
            volumeOpacityPeriod: { skip: true }
        };
        setupDrawingTools(saveDrawings, drawingTool) {
            this.saveDrawings = saveDrawings;
            this.drawingTool = drawingTool;
        }
        shouldSkipOption(optionName) {
            const constraints = this.constraints[optionName] || {};
            return !!constraints.skip;
        }
        separator() {
            const separator = document.createElement("div");
            separator.style.width = "90%";
            separator.style.height = "1px";
            separator.style.margin = "3px 0px";
            separator.style.backgroundColor = window.pane.borderColor;
            this.div.appendChild(separator);
            this.items.push(separator);
        }
        menuItem(text, action, hover = null) {
            const item = document.createElement("span");
            item.classList.add("context-menu-item");
            this.div.appendChild(item);
            const elem = document.createElement("span");
            elem.innerText = text;
            elem.style.pointerEvents = "none";
            item.appendChild(elem);
            if (hover) {
                let arrow = document.createElement("span");
                arrow.innerText = `►`;
                arrow.style.fontSize = "8px";
                arrow.style.pointerEvents = "none";
                item.appendChild(arrow);
            }
            item.addEventListener("mouseover", () => {
                if (this.hoverItem && this.hoverItem.closeAction)
                    this.hoverItem.closeAction();
                this.hoverItem = { elem: elem, action: action, closeAction: hover };
            });
            if (!hover)
                item.addEventListener("click", (event) => {
                    action(event);
                    this.div.style.display = "none";
                });
            else {
                let timeout;
                item.addEventListener("mouseover", () => (timeout = setTimeout(() => action(item.getBoundingClientRect()), 100)));
                item.addEventListener("mouseout", () => clearTimeout(timeout));
            }
            this.items.push(item);
        }
        _onClick(ev) {
            const target = ev.target;
            const menus = [this.colorPicker];
            menus.forEach((menu) => {
                if (!menu.getElement().contains(target)) {
                    menu.closeMenu();
                }
            });
        }
        // series-context-menu.ts
        _onRightClick(event) {
            event.preventDefault(); // Prevent the browser's context menu
            const mouseEventParams = this.getMouseEventParams();
            const seriesFromProximity = this.getProximitySeries(this.getMouseEventParams());
            const drawingFromProximity = this.getProximityDrawing(); // Implement this method based on your drawing logic
            const trendFromProximity = this.getProximityTrendTrace();
            console.log("Mouse Event Params:", mouseEventParams);
            console.log("Proximity Series:", seriesFromProximity);
            console.log("Proximity Drawing:", drawingFromProximity);
            this.clearMenu(); // Clear existing menu items
            this.clearAllMenus(); // Clear other menus if necessary
            if (seriesFromProximity) {
                // Right-click on a series
                console.log("Right-click detected on a series (proximity).");
                this.populateSeriesMenu(seriesFromProximity, event);
                this.recentSeries = seriesFromProximity;
            }
            else if (drawingFromProximity) {
                // Right-click on a drawing
                console.log("Right-click detected on a drawing.");
                this.populateDrawingMenu(event, drawingFromProximity);
                this.recentDrawing = drawingFromProximity;
            }
            else if (trendFromProximity) {
                // Right-click on a drawing
                console.log("Right-click detected on a drawing.");
                this.populateTrendTraceMenu(event, trendFromProximity);
            }
            else if (mouseEventParams?.hoveredSeries) {
                // Fallback to hovered series
                console.log("Right-click detected on a series (hovered).");
                this.populateSeriesMenu(mouseEventParams.hoveredSeries, event);
                this.recentSeries = seriesFromProximity;
            }
            else {
                // Right-click on chart background
                console.log("Right-click detected on the chart background.");
                this.populateChartMenu(event);
            }
            // Position the menu at cursor location
            this.showMenu(event);
            event.preventDefault();
            event.stopPropagation(); // Prevent event bubbling
        }
        // series-context-menu.ts
        getProximityDrawing() {
            // Implement your logic to determine if a drawing is under the cursor
            // For example:
            if (Drawing.hoveredObject) {
                return Drawing.hoveredObject;
            }
            return null;
        }
        getProximityTrendTrace() {
            if (TrendTrace.hoveredObject) {
                return TrendTrace.hoveredObject;
            }
            return null;
        }
        getProximitySeries(param) {
            if (!param || !param.seriesData) {
                console.warn("No mouse event parameters or series data available.");
                return null;
            }
            if (!param.point) {
                console.warn("No point data in MouseEventParams.");
                return null;
            }
            const cursorY = param.point.y;
            let sourceSeries = null;
            const referenceSeries = this.handler.chart.panes()[param.paneIndex ?? 0].getSeries()[0];
            if (this.handler.series && this.handler.series.getPane().paneIndex() === param.paneIndex) {
                sourceSeries = this.handler.series;
                console.log(`Using handler.series for coordinate conversion.`);
            }
            else if (referenceSeries) {
                sourceSeries = referenceSeries;
                console.log(`Using referenceSeries for coordinate conversion.`);
            }
            else {
                console.warn("No handler.series or referenceSeries available.");
                return null;
            }
            // If the pane index from the event doesn't match the source series' pane,
            // update sourceSeries based on the pane index from the event.
            if (param.paneIndex !== sourceSeries.getPane().paneIndex()) {
                sourceSeries = this.handler.chart.panes()[param.paneIndex ?? 1].getSeries()[0];
            }
            const cursorPrice = sourceSeries.coordinateToPrice(cursorY);
            console.log(`Converted chart Y (${cursorY}) to Price: ${cursorPrice}`);
            if (cursorPrice === null) {
                console.warn("Cursor price is null. Unable to determine proximity.");
                return null;
            }
            const seriesByDistance = [];
            param.seriesData.forEach((data, series) => {
                let refPrice;
                if (isSingleValueData(data)) {
                    refPrice = data.value;
                }
                else if (isOHLCData(data)) {
                    refPrice = data.close;
                }
                if (refPrice !== undefined && !isNaN(refPrice)) {
                    const distance = Math.abs(refPrice - cursorPrice);
                    const paneSize = this.handler.chart.panes()[param.paneIndex].getHeight();
                    const top = sourceSeries.coordinateToPrice(0);
                    const bottom = sourceSeries.coordinateToPrice(paneSize);
                    if (top === null || bottom === null)
                        return null;
                    const percentageDifference = (distance / (top - bottom)) * 100;
                    if (percentageDifference <= 3 && param.paneIndex === series.getPane().paneIndex()) {
                        seriesByDistance.push({ distance, series: series });
                    }
                }
            });
            // Sort series by proximity (distance)
            seriesByDistance.sort((a, b) => a.distance - b.distance);
            if (seriesByDistance.length > 1 && this.recentSeries === seriesByDistance[0].series) {
                console.log("Multiple series found.");
                return seriesByDistance[1].series;
            }
            else if (seriesByDistance.length > 0) {
                console.log("Closest series found.");
                return seriesByDistance[0].series;
            }
            console.log("No series found within the proximity threshold.");
            return null;
        }
        showMenu(event) {
            const x = event.clientX;
            const y = event.clientY;
            this.div.style.position = "absolute";
            this.div.style.zIndex = "10000";
            this.div.style.left = `${x}px`;
            this.div.style.top = `${y}px`;
            this.div.style.width = "250px";
            this.div.style.maxHeight = `400px`;
            this.div.style.overflowY = "auto";
            this.div.style.display = "block";
            this.div.style.overflowX = "hidden";
            console.log("Displaying Menu at:", x, y);
            activeMenu = this.div;
            console.log("Displaying Menu", x, y);
            document.addEventListener("mousedown", this.hideMenuOnOutsideClick.bind(this), { once: true });
        }
        hideMenuOnOutsideClick(event) {
            if (!this.div.contains(event.target)) {
                this.hideMenu();
            }
        }
        hideMenu() {
            this.div.style.display = "none";
            if (activeMenu === this.div) {
                activeMenu = null;
            }
        }
        clearAllMenus() {
            this.handlerMap.forEach((handler) => {
                if (handler.ContextMenu) {
                    handler.ContextMenu.clearMenu();
                }
            });
        }
        setupMenu() {
            if (!this.div.querySelector(".chart-options-container")) {
                const chartOptionsContainer = document.createElement("div");
                chartOptionsContainer.classList.add("chart-options-container");
                this.div.appendChild(chartOptionsContainer);
            }
            if (!this.div.querySelector(".context-menu-item.close-menu")) {
                this.addMenuItem("Close Menu", () => this.hideMenu());
            }
        }
        addNumberInput(label, defaultValue, onChange, min, max, step) {
            return this.addMenuInput(this.div, {
                type: "number",
                label,
                value: defaultValue,
                onChange,
                min,
                max,
                step,
            });
        }
        addCheckbox(label, value, onChange) {
            return this.addMenuInput(this.div, {
                type: "boolean",
                label,
                value: value,
                onChange,
            });
        }
        addSelectInput(label, currentValue, options, onSelectChange) {
            return this.addMenuInput(this.div, {
                type: "select",
                label,
                value: currentValue,
                onChange: onSelectChange,
                options,
            });
        }
        addMenuInput(parent, config, idPrefix = "") {
            const container = document.createElement("div");
            container.classList.add("context-menu-item");
            container.style.display = "flex";
            container.style.alignItems = "right";
            container.style.justifyContent = "space-around";
            if (config.label) {
                const labelElem = document.createElement("label");
                labelElem.innerText = config.label;
                labelElem.htmlFor = `${idPrefix}${config.label.toLowerCase()}`;
                labelElem.style.flex = "0.8";
                labelElem.style.whiteSpace = "nowrap";
                container.appendChild(labelElem);
            }
            let inputElem;
            switch (config.type) {
                case "hybrid": {
                    if (!config.hybridConfig) {
                        throw new Error("Hybrid type requires hybridConfig.");
                    }
                    // Container for the two side-by-side buttons (plus an optional dropdown).
                    const container = document.createElement("div");
                    container.classList.add("context-menu-item");
                    container.style.position = "relative";
                    container.style.display = "flex";
                    container.style.flexDirection = "row";
                    container.style.justifyContent = "flex-end";
                    container.style.alignItems = "right";
                    // -------------------------------
                    // Shared Styling for Both Buttons
                    // -------------------------------
                    const baseButtonStyle = {
                        backgroundColor: "#2b2b2b",
                        color: "#fff",
                        border: "1px solid #444",
                        padding: "2px 2px", // Minimal padding so text is visible
                        textAlign: "center",
                        cursor: "pointer",
                        boxSizing: "border-box",
                        display: "flex",
                        alignItems: "right",
                        justifyContent: "right",
                        // No fixed height; the button grows to fit text or symbols
                        // If you need a strict height, uncomment below and set as desired:
                        // height: "24px",
                        // lineHeight: "24px",
                    };
                    // Helper function to apply shared styling.
                    function applyStyles(elem, styles) {
                        for (const [key, value] of Object.entries(styles)) {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            elem.style[key] = value;
                        }
                    }
                    // -------------------------------
                    // Main Button (Left) - No Label
                    // -------------------------------
                    const mainButton = document.createElement("div");
                    applyStyles(mainButton, baseButtonStyle);
                    mainButton.style.borderRadius = "4px 0 0 4px"; // Rounded left corners
                    mainButton.innerText = config.sublabel ?? '▵';
                    // No label or text in the main button
                    mainButton.addEventListener("click", (event) => {
                        event.stopPropagation();
                        config.hybridConfig.defaultAction();
                    });
                    // -------------------------------
                    // Dropdown Button (Right) - Displays ∷
                    // -------------------------------
                    const dropdownButton = document.createElement("div");
                    applyStyles(dropdownButton, baseButtonStyle);
                    // Remove left border to join seamlessly with mainButton
                    dropdownButton.style.borderLeft = "none";
                    dropdownButton.style.borderRadius = "0 4px 4px 0"; // Rounded right corners
                    dropdownButton.innerText = "☷";
                    // -------------------------------
                    // Dropdown Container (Shown if multiple options)
                    // -------------------------------
                    const dropdown = document.createElement("div");
                    dropdown.style.position = "absolute";
                    dropdown.style.top = "100%"; // or set to "0" and adjust left/right if needed
                    dropdown.style.right = "0";
                    dropdown.style.backgroundColor = "#2b2b2b";
                    dropdown.style.color = "#fff";
                    dropdown.style.border = "1px solid #444";
                    dropdown.style.borderRadius = "4px";
                    dropdown.style.minWidth = "100px";
                    dropdown.style.boxShadow = "0px 2px 5px rgba(0, 0, 0, 0.5)";
                    dropdown.style.zIndex = "10000";
                    dropdown.style.display = "none";
                    // Decide single vs. multiple option behavior
                    if (config.hybridConfig.options.length === 1) {
                        // If there is exactly one option, clicking the dropdownButton calls that single action
                        const singleOption = config.hybridConfig.options[0];
                        dropdownButton.addEventListener("click", (event) => {
                            event.stopPropagation();
                            singleOption.action();
                        });
                    }
                    else {
                        // Multiple options => build and toggle the dropdown
                        config.hybridConfig.options.forEach((option) => {
                            const optionElem = document.createElement("div");
                            optionElem.innerText = option.name;
                            optionElem.style.cursor = "pointer";
                            optionElem.style.padding = "5px 10px";
                            optionElem.addEventListener("click", (event) => {
                                event.stopPropagation();
                                dropdown.style.display = "none";
                                option.action();
                            });
                            optionElem.addEventListener("mouseenter", () => {
                                optionElem.style.backgroundColor = "#444";
                            });
                            optionElem.addEventListener("mouseleave", () => {
                                optionElem.style.backgroundColor = "#2b2b2b";
                            });
                            dropdown.appendChild(optionElem);
                        });
                        // Toggle dropdown by clicking the dropdownButton
                        dropdownButton.addEventListener("click", (event) => {
                            event.stopPropagation();
                            dropdown.style.display =
                                dropdown.style.display === "none" ? "block" : "none";
                        });
                        // Add the dropdown to the container so it appears below/right
                        container.appendChild(dropdown);
                    }
                    // Add both buttons side by side to the container
                    container.appendChild(mainButton);
                    container.appendChild(dropdownButton);
                    // Assign the final element reference
                    inputElem = container;
                    break;
                }
                case "number": {
                    const input = document.createElement("input");
                    input.type = "number";
                    input.value = config.value !== undefined ? config.value.toString() : "";
                    input.style.backgroundColor = "#2b2b2b"; // Darker gray background
                    input.style.color = "#fff"; // White text
                    input.style.border = "1px solid #444"; // Subtle border
                    input.style.borderRadius = "4px";
                    input.style.textAlign = "center";
                    input.style.marginLeft = "auto"; // Adds margin to the right of the input
                    input.style.marginRight = "8px"; // Adds margin to the right of the input
                    input.style.width = "40px"; // Ensures a consistent width
                    // Set min/max if provided
                    if (config.min !== undefined)
                        input.min = config.min.toString();
                    if (config.max !== undefined)
                        input.max = config.max.toString();
                    // NEW: Set step if provided, default to 1 if not
                    if (config.step !== undefined && !isNaN(config.step)) {
                        input.step = config.step.toString();
                    }
                    else {
                        input.step = "1"; // Or any other default
                    }
                    input.addEventListener("input", (event) => {
                        const target = event.target;
                        let newValue = parseFloat(target.value);
                        if (!isNaN(newValue)) {
                            config.onChange(newValue);
                        }
                    });
                    inputElem = input;
                    break;
                }
                case "boolean": {
                    const input = document.createElement("input");
                    input.type = "checkbox";
                    input.checked = config.value ?? false;
                    input.style.marginLeft = "auto";
                    input.style.marginRight = "8px";
                    input.addEventListener("change", (event) => {
                        const target = event.target;
                        config.onChange(target.checked);
                    });
                    inputElem = input;
                    break;
                }
                case "select": {
                    const select = document.createElement("select");
                    select.id = `${idPrefix}${config.label ? config.label.toLowerCase() : "select"}`;
                    select.style.backgroundColor = "#2b2b2b"; // Darker gray background
                    select.style.color = "#fff"; // White text
                    select.style.border = "1px solid #444"; // Subtle border
                    select.style.borderRadius = "4px";
                    select.style.marginLeft = "auto";
                    select.style.marginRight = "8px"; // Adds margin to the right of the dropdown
                    select.style.width = "80px"; // Ensures consistent width for dropdown
                    config.options?.forEach((optionValue) => {
                        const option = document.createElement("option");
                        option.value = optionValue;
                        option.text = optionValue;
                        option.style.whiteSpace = "normal"; // Allow wrapping within dropdown
                        option.style.textAlign = "right";
                        if (optionValue === config.value)
                            option.selected = true;
                        select.appendChild(option);
                    });
                    select.addEventListener("change", (event) => {
                        const target = event.target;
                        config.onChange(target.value);
                    });
                    inputElem = select;
                    break;
                }
                case "string": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.value = config.value ?? "";
                    input.style.backgroundColor = "#2b2b2b"; // Darker gray background
                    input.style.color = "#fff"; // White text
                    input.style.border = "1px solid #444"; // Subtle border
                    input.style.borderRadius = "4px";
                    input.style.marginLeft = "auto";
                    input.style.textAlign = "center";
                    input.style.marginRight = "8px"; // Adds margin to the right of the text input
                    input.style.width = "60px"; // Ensures consistent width
                    input.addEventListener("input", (event) => {
                        const target = event.target;
                        config.onChange(target.value);
                    });
                    inputElem = input;
                    break;
                }
                case "color": {
                    const input = document.createElement("input");
                    input.type = "color";
                    input.value = config.value ?? "#000000";
                    input.style.marginLeft = "auto";
                    input.style.cursor = "pointer";
                    input.style.marginRight = "8px"; // Adds margin to the right of the input
                    input.style.width = "100px"; // Ensures a consistent width
                    input.addEventListener("input", (event) => {
                        const target = event.target;
                        config.onChange(target.value);
                    });
                    inputElem = input;
                    break;
                }
                default:
                    throw new Error("Unsupported input type");
            }
            //inputElem.style.padding= "2px 10px 2px 10px";
            container.style.padding = "2px 10px 2px 10px";
            container.appendChild(inputElem);
            parent.appendChild(container);
            return container;
        }
        addMenuItem(text, action, shouldHide = true, hasSubmenu = false, submenuLevel = 1) {
            const item = document.createElement("span");
            item.classList.add("context-menu-item");
            item.innerText = text;
            if (hasSubmenu) {
                const defaultArrow = document.createElement("span");
                defaultArrow.classList.add("submenu-arrow");
                defaultArrow.innerText = "ː".repeat(submenuLevel);
                item.appendChild(defaultArrow);
            }
            item.addEventListener("click", (event) => {
                event.stopPropagation();
                action();
                if (shouldHide) {
                    this.hideMenu();
                }
            });
            const arrows = ["➩", "➯", "➱", "➬", "➫"];
            item.addEventListener("mouseenter", () => {
                item.style.backgroundColor = "royalblue";
                item.style.color = "white";
                if (!item.querySelector(".hover-arrow")) {
                    const hoverArrow = document.createElement("span");
                    hoverArrow.classList.add("hover-arrow");
                    const randomIndex = Math.floor(Math.random() * arrows.length);
                    const selectedArrow = arrows[randomIndex];
                    hoverArrow.innerText = selectedArrow;
                    hoverArrow.style.marginLeft = "auto";
                    hoverArrow.style.fontSize = "8px";
                    hoverArrow.style.color = "white";
                    item.appendChild(hoverArrow);
                }
            });
            item.addEventListener("mouseleave", () => {
                item.style.backgroundColor = "";
                item.style.color = "";
                const hoverArrow = item.querySelector(".hover-arrow");
                if (hoverArrow) {
                    item.removeChild(hoverArrow);
                }
            });
            this.div.appendChild(item);
            this.items.push(item);
            return item;
        }
        clearMenu() {
            const dynamicItems = this.div.querySelectorAll(".context-menu-item:not(.close-menu), .context-submenu");
            dynamicItems.forEach((item) => item.remove());
            this.items = [];
            this.div.innerHTML = "";
        }
        /**
         * Unified color picker menu item.
         * @param label Display label for the menu item
         * @param currentColor The current color value
         * @param optionPath The dot-separated path to the option
         * @param optionTarget The chart or series to apply the color to
         */
        addColorPickerMenuItem(label, currentColor, optionPath, optionTarget) {
            const menuItem = document.createElement("span");
            menuItem.classList.add("context-menu-item");
            menuItem.innerText = label;
            this.div.appendChild(menuItem);
            const applyColor = (newColor) => {
                const options = buildOptions(optionPath, newColor);
                optionTarget.applyOptions(options);
                console.log(`Updated ${optionPath} to ${newColor}`);
                // If optionTarget is a series and the option is color-based, update LegendSeries colors
                const isSeries = (target) => {
                    return (typeof target === "object" &&
                        target !== null &&
                        // Some property check to confirm it's ISeriesApiExtended
                        typeof target.applyOptions === "function" &&
                        typeof target.dataByIndex === "function");
                };
                if (isSeries(optionTarget) &&
                    ["color", "lineColor", "upColor", "downColor"].includes(optionPath)) {
                    // Attempt to find the legend item in the legend _lines array
                    const legendItem = this.handler.legend._lines.find((item) => item.series === optionTarget);
                    if (legendItem) {
                        // Map the relevant color to the correct index
                        // color, lineColor, upColor => index 0
                        // downColor => index 1
                        if (optionPath === "downColor") {
                            legendItem.colors[1] = newColor;
                            console.log(`Legend down color updated to: ${newColor}`);
                        }
                        else {
                            legendItem.colors[0] = newColor;
                            console.log(`Legend up/main color updated to: ${newColor}`);
                        }
                    }
                }
            };
            menuItem.addEventListener("click", (event) => {
                event.stopPropagation();
                if (!this.colorPicker) {
                    this.colorPicker = new ColorPicker(currentColor ?? "#000000", applyColor);
                }
                this.colorPicker.openMenu(event, 225, applyColor);
            });
            return menuItem;
        }
        // Class-level arrays to store current options for width and style.
        currentWidthOptions = [];
        currentStyleOptions = [];
        /**
         * Populates the clone series submenu.
         *
         * @param series - The original series to clone.
         * @param event - The mouse event triggering the context menu.
         */
        populateSeriesMenu(series, event) {
            // Type guard to check if series is extended
            const _series = ensureExtendedSeries(series, this.handler.legend);
            // Now `series` is guaranteed to be extended
            const seriesOptions = series.options();
            if (!seriesOptions) {
                console.warn("No options found for the selected series.");
                return;
            }
            this.div.innerHTML = "";
            const colorOptions = [];
            const visibilityOptions = [];
            const otherOptions = [];
            // Temporary arrays before assigning to class-level variables
            const tempWidthOptions = [];
            const tempStyleOptions = [];
            for (const optionName of Object.keys(seriesOptions)) {
                const optionValue = seriesOptions[optionName];
                if (this.shouldSkipOption(optionName))
                    continue;
                if (optionName.toLowerCase().includes("base"))
                    continue;
                const lowerOptionName = camelToTitle(optionName).toLowerCase();
                const isWidthOption = lowerOptionName.includes("width") ||
                    lowerOptionName === "radius" ||
                    lowerOptionName.includes("radius");
                if (lowerOptionName.includes("color")) {
                    // Color options
                    if (typeof optionValue === "string") {
                        colorOptions.push({ label: optionName, value: optionValue });
                    }
                    else {
                        console.warn(`Expected string value for color option "${optionName}".`);
                    }
                }
                else if (isWidthOption) {
                    if (typeof optionValue === "number") {
                        let minVal = 1;
                        let maxVal = 10;
                        let step = 1;
                        // If this property is specifically "radius", make it 0..1
                        if (lowerOptionName.includes("radius")) {
                            minVal = 0;
                            maxVal = 1;
                            step = 0.1;
                        }
                        // Add it to your "width" options array with the specialized range
                        tempWidthOptions.push({
                            name: optionName,
                            label: optionName,
                            value: optionValue,
                            min: minVal,
                            max: maxVal,
                            step: step,
                        });
                    }
                }
                else if (lowerOptionName.includes("visible") ||
                    lowerOptionName.includes("visibility")) {
                    // Visibility options
                    if (typeof optionValue === "boolean") {
                        visibilityOptions.push({ label: optionName, value: optionValue });
                    }
                    else {
                        console.warn(`Expected boolean value for visibility option "${optionName}".`);
                    }
                }
                else if (optionName === "lineType") {
                    // lineType is a style option
                    // LineType: Simple=0, WithSteps=1
                    const possibleLineTypes = this.getPredefinedOptions(camelToTitle(optionName));
                    tempStyleOptions.push({
                        name: optionName,
                        label: optionName,
                        value: optionValue,
                        options: possibleLineTypes,
                    });
                }
                else if (optionName === "crosshairMarkerRadius") {
                    // crosshairMarkerRadius should appear under Width Options
                    if (typeof optionValue === "number") {
                        tempWidthOptions.push({
                            name: optionName,
                            label: optionName,
                            value: optionValue,
                            min: 1,
                            max: 50,
                        });
                    }
                    else {
                        console.warn(`Expected number value for crosshairMarkerRadius option "${optionName}".`);
                    }
                }
                else if (lowerOptionName.includes("style")) {
                    // Style options (e.g. lineStyle)
                    if (typeof optionValue === "string" ||
                        Object.values(lightweightCharts.LineStyle).includes(optionValue) ||
                        typeof optionValue === "number") {
                        const possibleStyles = [
                            "Solid",
                            "Dotted",
                            "Dashed",
                            "Large Dashed",
                            "Sparse Dotted",
                        ];
                        tempStyleOptions.push({
                            name: optionName,
                            label: optionName,
                            value: optionValue,
                            options: possibleStyles,
                        });
                    }
                } // Example: handle shape if "shape" is in the name
                else if (lowerOptionName.includes("shape")) {
                    // If we confirm it's a recognized CandleShape
                    if (isCandleShape(optionValue)) {
                        const predefinedShapes = [
                            "Rectangle",
                            "Rounded",
                            "Ellipse",
                            "Arrow",
                            "3d",
                            "Polygon",
                            "Bar",
                            "Slanted"
                        ];
                        if (predefinedShapes) {
                            tempStyleOptions.push({
                                name: optionName,
                                label: optionName,
                                value: optionValue, // This is guaranteed CandleShape now
                                options: predefinedShapes,
                            });
                        }
                    }
                }
                else {
                    // Other options go directly to otherOptions
                    otherOptions.push({ label: optionName, value: optionValue });
                }
            }
            // Assign the temp arrays to class-level arrays for use in submenus
            this.currentWidthOptions = tempWidthOptions;
            this.currentStyleOptions = tempStyleOptions;
            this.addTextInput("Title", series.options().title || "", // Default to empty string if no title exists
            (newValue) => {
                const options = { title: newValue };
                // Remove old entry and re-add with new title
                if (this.handler.seriesMap.has(series.options().title)) {
                    this.handler.seriesMap.delete(series.options().title);
                }
                this.handler.seriesMap.set(newValue, series);
                console.log(`Updated seriesMap label to: ${newValue}`);
                // Update the legend title
                const legendItem = this.handler.legend._lines.find((item) => item.series === series);
                if (legendItem && legendItem.series === series) {
                    legendItem.name = newValue;
                    console.log(`Updated legend title to: ${newValue}`);
                }
                series.applyOptions(options);
                console.log(`Updated title to: ${newValue}`);
            });
            // Retrieve current pane index of the series and the array of existing panes.
            const currentPaneIndex = series.getPane().paneIndex();
            const panes = this.handler.chart.panes();
            // Determine the current value (label) for the hybrid input.
            const currentValue = `Pane ${currentPaneIndex}`;
            // Define the default action:
            // If the series is in the main pane (pane 0), move it to the next existing pane (if available)
            // or create a new pane if there isn’t one.
            // Otherwise (if the series is on any other pane), move it back to the main pane (pane 0).
            const defaultAction = () => {
                if (currentPaneIndex === 0) {
                    series.moveToPane(panes.length);
                    console.log(`Default: Moved series from pane ${currentPaneIndex} to a new pane at index ${panes.length}.`);
                }
                else {
                    series.moveToPane(0);
                    console.log(`Default: Moved series from pane ${currentPaneIndex} back to main pane (0).`);
                }
            };
            // Build the list of options:
            // For each existing pane, add an option labeled "Pane 0", "Pane 1", etc.
            // Then add an extra option for a "New Pane".
            const options = [];
            for (let i = 0; i < panes.length; i++) {
                if (i === currentPaneIndex) {
                    continue;
                }
                options.push({
                    name: `Pane ${i}`,
                    action: () => {
                        series.moveToPane(i);
                        console.log(`Moved series to existing pane ${i}.`);
                    },
                });
            }
            options.push({
                name: "New Pane",
                action: () => {
                    series.moveToPane(panes.length);
                    console.log(`Moved series to a new pane at index ${panes.length}.`);
                },
            });
            // Create the hybrid input using your addMenuInput helper.
            // This will render a dropdown that shows all options and executes the corresponding action on change.
            this.addMenuInput(this.div, {
                type: "hybrid",
                label: "Move to pane",
                sublabel: currentPaneIndex === 0 ? 'New Pane' : 'Top',
                value: currentValue,
                onChange: (newValue) => {
                    // When the user selects an option, look it up in the options array and execute its action.
                    const selectedOption = options.find((opt) => opt.name === newValue);
                    if (selectedOption) {
                        selectedOption.action();
                    }
                },
                hybridConfig: {
                    defaultAction: defaultAction,
                    options: options.map((opt) => ({
                        name: opt.name,
                        action: opt.action,
                    })),
                },
            });
            // Inside populateSeriesMenu (already in your code above)
            this.addMenuItem("Clone Series ▸", () => {
                this.populateCloneSeriesMenu(series, event);
            }, false, true);
            // Add main menu items only if these arrays have content
            if (visibilityOptions.length > 0) {
                this.addMenuItem("Visibility Options ▸", () => {
                    this.populateVisibilityMenu(event, series);
                }, false, true);
            }
            if (this.currentStyleOptions.length > 0) {
                this.addMenuItem("Style Options ▸", () => {
                    this.populateStyleMenu(event, series);
                }, false, true);
            }
            if (this.currentWidthOptions.length > 0) {
                this.addMenuItem("Width Options ▸", () => {
                    this.populateWidthMenu(event, series);
                }, false, true);
            }
            if (colorOptions.length > 0) {
                this.addMenuItem("Color Options ▸", () => {
                    this.populateColorOptionsMenu(colorOptions, series, event);
                }, false, true);
            }
            // **** New block: add numeric inputs for volume-based or chandelier aggregation ****
            //let aggregatorOptions = series.options();
            //if ( "volumeCandles" in aggregatorOptions && "volumeMALength" in aggregatorOptions &&
            //  "volumeMultiplier" in aggregatorOptions &&
            //  "chandelierSize" in aggregatorOptions &&
            //  aggregatorOptions?.volumeCandles !== undefined) {
            //const aggregatorOptions = series.options() as  OhlcSeriesOptions ;
            // if ('volumeCandles' in aggregatorOptions && "volumeMALength" in aggregatorOptions &&
            //   "volumeMultiplier" in aggregatorOptions) {
            //  // Add a checkbox for toggling volumeCandles.
            //  // When toggled, the series options are updated and the menu is repopulated.
            //  this.addCheckbox("Volume Candles", (aggregatorOptions as OhlcSeriesOptions).volumeCandles ?? false, (newValue: boolean) => {
            //    const options = { volumeCandles: newValue };
            //    series.applyOptions(options as Partial<OhlcSeriesOptions>);
            //    console.log(`Updated volumeCandles to ${newValue}`);
            //    // Repopulate the series menu with the updated options.
            //    this.populateSeriesMenu(series, event);
            //  });
            //  if ((series.options() as ohlcSeriesOptions).volumeCandles) {
            //  // Volume candles are enabled: add number inputs for the volume moving average length and multiplier.
            //  this.addNumberInput(
            //    "Volume MA Length",
            //    (aggregatorOptions as OhlcSeriesOptions).volumeMALength ?? 20,
            //    (newValue: number) => {
            //      const options = { volumeMALength: newValue };
            //      series.applyOptions(options as Partial<OhlcSeriesOptions>);
            //      console.log(`Updated Volume MA Length to ${newValue}`);
            //      // Optionally repopulate the menu dynamically if needed.
            //    },
            //    1,
            //    100,
            //    1
            //  );
            //  this.addNumberInput(
            //    "Volume Multiplier",
            //    (aggregatorOptions as OhlcSeriesOptions).volumeMultiplier ?? 1.0,
            //    (newValue: number) => {
            //      const options = { volumeMultiplier: newValue };
            //      series.applyOptions(options as Partial<OhlcSeriesOptions>);
            //      console.log(`Updated Volume Multiplier to ${newValue}`);
            //      // Optionally repopulate the menu dynamically if needed.
            //    },
            //    0.1,
            //    10,
            //    0.1
            //  );
            //}else {
            //  // Volume candles are disabled: add a number input for chandelier size.
            // if (
            //   series instanceof ohlcSeries &&
            //   (series.options() as OhlcSeriesOptions).chandelierSize
            // ) {
            //   // series is an OhlcSeries and has a defined chandelierSize option.
            //   // Your code here...
            //
            //   this.addNumberInput(
            //     "Chandelier Size",
            //     (series.options() as OhlcSeriesOptions).chandelierSize ?? 1,
            //     (newValue: number) => {
            //       const options = { chandelierSize: newValue };
            //       series.applyOptions(options as Partial<OhlcSeriesOptions>);
            //       console.log(`Updated Chandelier Size to ${newValue}`);
            //       // Optionally repopulate the menu dynamically if needed.
            //     },
            //     1,
            //     100,
            //     1
            //   );
            // }
            //
            //
            // *************************************************************************
            // Add other options dynamically
            // Add a new input for volume opacity period if volume opacity is enabled.
            if (seriesOptions.enableVolumeOpacity) {
                this.addNumberInput("Volume Opacity Period", seriesOptions.volumeOpacityPeriod ?? 21, // Default period if not set
                (newValue) => {
                    const options = { volumeOpacityPeriod: newValue };
                    series.applyOptions(options);
                    console.log(`Updated Volume Opacity Period to ${newValue}`);
                    // Optionally, repopulate the menu if you want to reflect the change immediately.
                }, 1, // Minimum period
                10000, // Maximum period (adjust as needed)
                1 // Step value
                );
            }
            if (seriesOptions.enableVolumeOpacity) {
                // Define the allowed modes for volume opacity.
                const allowedModes = ["/ max", "> previous", "> average"];
                // Ensure the current mode is valid; default to "/ max" if not.
                const currentMode = allowedModes.includes(seriesOptions.volumeOpacityMode)
                    ? seriesOptions.volumeOpacityMode
                    : "/ max";
                // Create a select input for volume opacity mode.
                this.addSelectInput("Volume Opacity Mode", currentMode ?? '> previous', allowedModes, (newValue) => {
                    const options = { volumeOpacityMode: newValue };
                    series.applyOptions(options);
                    console.log(`Updated Volume Opacity Mode to: ${newValue}`);
                });
            }
            otherOptions.forEach((option) => {
                const optionLabel = camelToTitle(option.label); // Human-readable label
                // Skip if explicitly marked as skippable
                if (this.constraints[option.label]?.skip) {
                    return;
                }
                if (typeof option.value === "boolean") {
                    this.addCheckbox(camelToTitle(option.label), Boolean(option.value), (newValue) => {
                        const options = buildOptions(option.label, newValue);
                        series.applyOptions(options);
                        console.log(`Updated ${option.label} to ${newValue}`);
                        // Optionally, repopulate the menu dynamically if needed.
                    });
                }
                else if (typeof option.value === "string") {
                    // Add a submenu or text input for string options
                    const predefinedOptions = this.getPredefinedOptions(option.label);
                    if (predefinedOptions && predefinedOptions.length > 0) {
                        this.addMenuItem(`${optionLabel} ▸`, () => {
                            this.div.innerHTML = ""; // Clear existing menu items
                            this.addSelectInput(optionLabel, option.value, predefinedOptions, (newValue) => {
                                const options = buildOptions(option.label, newValue);
                                series.applyOptions(options);
                                console.log(`Updated ${option.label} to ${newValue}`);
                                // Repopulate the menu dynamically
                            });
                        }, false, true // Mark as a submenu
                        );
                    }
                    else {
                        this.addMenuItem(`${optionLabel} ▸`, () => {
                            this.div.innerHTML = ""; // Clear existing menu items
                            this.addTextInput(optionLabel, option.value, (newValue) => {
                                const options = buildOptions(option.label, newValue);
                                series.applyOptions(options);
                                console.log(`Updated ${option.label} to ${newValue}`);
                                // Repopulate the menu dynamically
                            });
                        }, false, true // Mark as a submenu
                        );
                    }
                }
                else if (typeof option.value === "number") {
                    // Get min and max constraints, if any.
                    const min = this.constraints[option.label]?.min;
                    const max = this.constraints[option.label]?.max;
                    // Directly add the number input for the numeric option.
                    this.addNumberInput(optionLabel, option.value, (newValue) => {
                        const options = buildOptions(option.label, newValue);
                        series.applyOptions(options);
                        console.log(`Updated ${option.label} to ${newValue}`);
                        // Optionally, repopulate the menu dynamically if needed.
                    }, min, max);
                }
                else {
                    return; // Skip unsupported data types.
                }
            }),
                // Add "Price Scale Options" Menu
                this.addMenuItem("Price Scale Options ▸", () => {
                    this.populatePriceScaleMenu(event, (series.options().priceScaleId ?? "right"), series);
                }, false, true);
            // Add the "Primitives" submenu
            this.addMenuItem("Primitives ▸", () => {
                this.populatePrimitivesMenu(_series, event);
            }, false, true);
            // 2) If all items are OHLC, add a submenu item for your “Indicators”
            this.addMenuItem("Indicators ▸", () => {
                this.populateIndicatorMenu(series, event);
            }, false, // do not hide the entire menu automatically
            true // indicates a submenu arrow “▸”
            );
            // Check if this series is part of an indicator
            if (isISeriesIndicator(series)) {
                const indicatorSeries = series;
                this.addMenuItem(`Configure ${indicatorSeries.indicator.name}`, () => {
                    this.configureIndicatorParams(indicatorSeries, event, indicatorSeries.figureCount);
                }, false);
            }
            // NEW: Add a menu item to open the DataMenu for exporting/importing series data.
            this.addMenuItem("Export/Import Series Data ▸", () => {
                if (!this.dataMenu) {
                    this.dataMenu = new DataMenu({ contextMenu: this, handler: this.handler });
                }
                // Open the DataMenu with the series as the target. 
                // Here we pass "Series" as the override type.
                this.dataMenu.openMenu(series, event, "Series");
            }, false);
            // Add remaining existing menu items
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false, false);
            this.showMenu(event);
        }
        populateDrawingMenu(event, drawing) {
            this.div.innerHTML = ""; // Clear existing menu items
            if (!this.drawingTool) {
                this.drawingTool = new DrawingTool(this.handler.chart, this.handler._seriesList[0]);
            }
            // Add drawing-specific menu items
            for (const optionName of Object.keys(drawing._options)) {
                let subMenu;
                if (optionName.toLowerCase().includes("color")) {
                    subMenu = new ColorPicker$1(this.saveDrawings, optionName);
                }
                else if (optionName === "lineStyle") {
                    subMenu = new StylePicker(this.saveDrawings);
                }
                else {
                    continue;
                }
                const onClick = (rect) => subMenu.openMenu(rect);
                this.menuItem(camelToTitle(optionName), onClick, () => {
                    document.removeEventListener("click", subMenu.closeMenu);
                    subMenu._div.style.display = "none";
                });
            }
            // 1) If this drawing is a PitchFork, add a select input for variant.
            if (drawing._type === "PitchFork") {
                // For clarity, cast or check if your PitchFork uses drawing._options.variant
                const currentVariant = drawing._options.variant || "standard";
                const allowedVariants = [
                    "standard",
                    "schiff",
                    "modifiedSchiff",
                    "inside",
                ];
                this.addSelectInput("Pitchfork Variant", currentVariant, allowedVariants, (newValue) => {
                    drawing._options.variant = newValue;
                    if (this.saveDrawings) {
                        this.saveDrawings();
                    }
                });
                // Add a number input for "value".
                this.addNumberInput("Length", drawing._options.length, (newValue) => {
                    drawing._options.length = newValue;
                    if (this.saveDrawings) {
                        this.saveDrawings();
                    }
                }, 0, // minimum value (adjust as needed)
                1000, // maximum value (adjust as needed)
                0.1 // step (adjust as needed)
                );
                // Add a menu item to populate the detailed PitchFork menu.
                this.addMenuItem("Fork Line Options ▸", () => {
                    this.populateForkLineMainMenu(event, drawing);
                }, false, true);
                // NEW: Add a menu item to open the DataMenu for exporting/importing series data.
                this.addMenuItem("Export/Import  PitchFork Data ▸", () => {
                    if (!this.dataMenu) {
                        this.dataMenu = new DataMenu({ contextMenu: this, handler: this.handler });
                    }
                    // Open the DataMenu with the series as the target. 
                    // Here we pass "Series" as the override type.
                    this.dataMenu.openMenu(drawing, event, "PitchFork");
                }, false);
            }
            if (drawing.points?.length >= 2 && drawing.points[0] && drawing.points[1]) {
                let multiPointDrawing;
                if (drawing.points?.length > 2) {
                    multiPointDrawing = drawing;
                }
                else {
                    multiPointDrawing = drawing;
                }
                if (multiPointDrawing.linkedObjects?.length) {
                    multiPointDrawing.linkedObjects.forEach((object) => {
                        if (object instanceof TrendTrace) {
                            this.addMenuItem(`${object.title} Options`, () => {
                                this.populateTrendTraceMenu(event, object);
                            }, false, true);
                        }
                        else if (object instanceof VolumeProfile) {
                            this.addMenuItem(`Volume Profile Options`, () => {
                                this.populateVolumeProfileMenu(event, object);
                            }, false, true);
                        }
                    });
                }
                // Always add the creation menu items for Trend Trace and Volume Profile
                this.addMenuItem("Trend Trace ▸", () => {
                    this._createTrendTrace(event, multiPointDrawing);
                }, false, true);
                this.addMenuItem("Volume Profile ▸", () => {
                    this._createVolumeProfile(multiPointDrawing);
                }, false, true);
            }
            const onClickDelete = () => this.drawingTool.delete(drawing);
            this.separator();
            this.menuItem("Delete Drawing", onClickDelete);
            // Optionally, add a back button or main menu option.
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false, false);
            this.showMenu(event);
        }
        populateChartMenu(event) {
            this.div.innerHTML = "";
            console.log(`Displaying Menu Options: Chart`);
            this.addResetViewOption();
            const params = this.getMouseEventParams();
            // Retrieve current pane index of the series and the array of existing panes.
            const panes = this.handler.chart.panes();
            const paneIndex = params?.paneIndex;
            const pane = this.handler.chart.panes()[paneIndex ?? 0];
            // Determine the current value (label) for the hybrid input.
            // Define the default action:
            // If the series is in the main pane (pane 0), move it to the next existing pane (if available)
            // or create a new pane if there isn’t one.
            // Otherwise (if the series is on any other pane), move it back to the main pane (pane 0).
            const defaultAction = () => {
                (paneIndex ?? 0 > 0 ? pane.moveTo(0) : pane.moveTo(panes.length - 1));
            };
            // Build the list of options:
            // For each existing pane, add an option labeled "Pane 0", "Pane 1", etc.
            // Then add an extra option for a "New Pane".
            const options = [];
            options.push({
                name: `Top`,
                action: () => {
                    pane.moveTo(0);
                    console.log(`Moved pane to top`);
                },
            });
            if (panes.length > 2 && (paneIndex ?? 0) > 1) {
                options.push({
                    name: "Up",
                    action: () => {
                        pane.moveTo((paneIndex ?? 2) - 1);
                        console.log(`Moved pane up`);
                    },
                });
            }
            if (panes.length > 2 && (paneIndex ?? 0) < panes.length - 2) {
                options.push({
                    name: "Down",
                    action: () => {
                        pane.moveTo((paneIndex ?? 0) + 1);
                        console.log(`Moved pane down`);
                    },
                });
            }
            options.push({
                name: `Bottom`,
                action: () => {
                    pane.moveTo(panes.length - 1);
                    console.log(`Moved pane to bottom`);
                },
            });
            if (panes.length > 1) {
                // Create the hybrid input using your addMenuInput helper.
                // This will render a dropdown that shows all options and executes the corresponding action on change.
                this.addMenuInput(this.div, {
                    type: "hybrid",
                    label: "Move pane",
                    sublabel: (paneIndex ?? 0 > 0 ? "Top" : "Bottom"),
                    hybridConfig: {
                        defaultAction: defaultAction,
                        options: options.map((opt) => ({
                            name: opt.name,
                            action: opt.action,
                        })),
                    },
                });
            }
            this.addMenuInput(this.div, {
                type: "hybrid",
                label: "Display Volume Profile",
                sublabel: "≖",
                hybridConfig: {
                    defaultAction: () => {
                        if (!this.volumeProfile) {
                            // Attach VolumeProfile
                            this.volumeProfile = new VolumeProfile(this.handler, defaultVolumeProfileOptions);
                            this.handler.series.attachPrimitive(this.volumeProfile, "Visible Range Volume Profile", false, true);
                            console.log("[ChartMenu] Attached Volume Profile.");
                        }
                        else {
                            // Detach VolumeProfile
                            this.handler.series.detachPrimitive(this.volumeProfile);
                            this.volumeProfile = null;
                            console.log("[ChartMenu] Detached Volume Profile.");
                        }
                    },
                    options: [
                        {
                            name: "Options",
                            action: () => {
                                if (this.volumeProfile) {
                                    this.populateVolumeProfileMenu(event, this.volumeProfile);
                                }
                            },
                        },
                    ],
                },
            });
            this.addMenuItem(" ~ Series List", () => {
                this.populateSeriesListMenu(event, false, (destinationSeries) => {
                    this.populateSeriesMenu(destinationSeries, event);
                });
            }, false, true);
            //// Layout menu
            //this.addMenuItem(
            //  "⌯ Layout Options        ",
            //  () => this.populateLayoutMenu(event),
            //  false,
            //  true
            //);
            //this.addMenuItem(
            //  "⌗ Grid Options          ",
            //  () => this.populateGridMenu(event),
            //  false,
            //  true
            //);
            //this.addMenuItem(
            //  "⊹ Crosshair Options     ",
            //  () => this.populateCrosshairOptionsMenu(event),
            //  false,
            //  true
            //);
            //this.addMenuItem(
            //  "ⴵ Time Scale Options    ",
            //  () => this.populateTimeScaleMenu(event),
            //  false,
            //  true
            //);
            //this.addMenuItem(
            //  "$ Price Scale Options   ",
            //  () => this.populatePriceScaleMenu(event, "right"),
            //  false,
            //  true
            //);
            // ***** NEW: Add a menu item for exporting/importing the handler's state *****
            //this.addMenuItem(
            //  "Export/Import Chart Config ▸",
            //  () => {
            //    if (!this.dataMenu) {
            //      this.dataMenu = new DataMenu({ contextMenu: this, handler: this.handler });
            //    }
            //
            //    this.dataMenu.openMenu(this.handler, event, "Handler");
            //  },
            //  false
            //);
            this.addMenuItem("Settings...", () => {
                this.SettingsModal.open();
            }, false);
            this.showMenu(event);
        }
        populateLayoutMenu(event) {
            // Clear the menu
            this.div.innerHTML = "";
            // Text Color Option
            const textColorOption = {
                name: "Text Color",
                valuePath: "layout.textColor",
            };
            const initialTextColor = this.getCurrentOptionValue(textColorOption.valuePath) ||
                "#000000";
            this.addColorPickerMenuItem(camelToTitle(textColorOption.name), initialTextColor, textColorOption.valuePath, this.handler.chart);
            // Background Color Options Based on Current Background Type
            const currentBackground = this.handler.chart.options().layout?.background;
            if (isSolidColor(currentBackground)) {
                // Solid Background Color
                this.addColorPickerMenuItem("Background Color", currentBackground.color || "#FFFFFF", "layout.background.color", this.handler.chart);
            }
            else if (isVerticalGradientColor(currentBackground)) {
                // Gradient Background Colors
                this.addColorPickerMenuItem("Top Color", currentBackground.topColor || "rgba(255,0,0,0.33)", "layout.background.topColor", this.handler.chart);
                this.addColorPickerMenuItem("Bottom Color", currentBackground.bottomColor || "rgba(0,255,0,0.33)", "layout.background.bottomColor", this.handler.chart);
            }
            else {
                console.warn("Unknown background type; no color options displayed.");
            }
            // Switch Background Type Option
            this.addMenuItem("Switch Background Type", () => {
                this.toggleBackgroundType(event);
            }, false, true);
            // Back to Main Menu Option
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false, false);
            // Display the updated menu
            this.showMenu(event);
        }
        toggleBackgroundType(event) {
            const currentBackground = this.handler.chart.options().layout?.background;
            let updatedBackground;
            // Toggle between Solid and Vertical Gradient
            if (isSolidColor(currentBackground)) {
                updatedBackground = {
                    type: lightweightCharts.ColorType.VerticalGradient,
                    topColor: "rgba(255,0,0,0.2)",
                    bottomColor: "rgba(0,255,0,0.2)",
                };
            }
            else {
                updatedBackground = {
                    type: lightweightCharts.ColorType.Solid,
                    color: "#000000",
                };
            }
            // Apply the updated background type
            this.handler.chart.applyOptions({
                layout: { background: updatedBackground },
            });
            // Repopulate the Layout Menu with the new background type's options
            this.populateLayoutMenu(event);
        }
        populateWidthMenu(event, series) {
            this.div.innerHTML = ""; // Clear current menu
            // Use the stored currentWidthOptions array
            this.currentWidthOptions.forEach((option) => {
                if (typeof option.value === "number") {
                    this.addNumberInput(camelToTitle(option.label), option.value, (newValue) => {
                        const options = buildOptions(option.name, newValue);
                        series.applyOptions(options);
                        console.log(`Updated ${option.label} to ${newValue}`);
                    }, option.min, option.max);
                }
            });
            this.addMenuItem("⤝ Back to Series Options", () => {
                this.populateSeriesMenu(series, event);
            }, false, false);
            this.showMenu(event);
        }
        populatePrimitivesMenu(series, event) {
            this.div.innerHTML = "";
            console.log(`Showing Primitive Menu `);
            const primitives = series.primitives;
            this.addMenuItem("Fill Area Between", () => {
                this.startFillAreaBetween(event, series); // Define the method below
            }, false, false);
            // Access the primitives
            // Debugging output
            console.log("Primitives:", primitives);
            // Add "Customize Fill Area" option if `FillArea` is present
            const hasFillArea = primitives?.FillArea ?? primitives?.pt;
            if (primitives["FillArea"]) {
                this.addMenuItem("Customize Fill Area", () => {
                    this.customizeFillAreaOptions(event, hasFillArea);
                }, false, true);
            }
            this.addMenuItem("Create TrendTrace", () => {
                this._createTrendTrace(event, this.recentDrawing);
            }, false, false);
            // Debugging output
            console.log("Primitives:", primitives);
            // Add "Customize TrendTrace" option if `TrendTrace` is already present
            if (primitives["TrendTrace"]) {
                this.addMenuItem("Customize TrendTrace", () => {
                    this.populateTrendTraceMenu(event, primitives["TrendTrace"]);
                }, false, true);
            }
            //this.addMenuItem(
            //  "Stop Loss / Take Profit ▸",
            //  () => {
            //      // If not attached yet, attach it
            //      if (!primitives["StopLossTakeProfit"]) {
            //          const sltp = new StopLossTakeProfit(
            //              this.handler.chart,
            //              series,
            //              {
            //                  color: '#444',
            //                  hoverColor: '#888',
            //                  backgroundColorStop: 'rgba(255,0,0,0.3)',
            //                  backgroundColorTarget: 'rgba(0,255,0,0.3)',
            //                  extendRightBars: 15,
            //              }
            //          );
            //          primitives["StopLossTakeProfit"] = sltp;
            //          console.log("StopLossTakeProfit attached");
            //      } else {
            //          console.log("StopLossTakeProfit already exists, customizing...");
            //          // If you want to open a submenu to customize,
            //          // e.g., setStopLoss, setTakeProfit, etc.
            //      }
            //  },
            //  false,
            //  true
            //);//
            // Add a Back option
            this.addMenuItem("⤝ Back", () => {
                this.populateSeriesMenu(series, event);
            }, false, false);
            this.showMenu(event);
        }
        populateStyleMenu(event, series) {
            this.div.innerHTML = ""; // Clear the current menu
            this.currentStyleOptions.forEach((option) => {
                const predefinedOptions = this.getPredefinedOptions(option.name);
                if (predefinedOptions) {
                    this.addSelectInput(camelToTitle(option.name), option.value.toString(), predefinedOptions, (newValue) => {
                        let finalValue = newValue;
                        // If the option name indicates it's a line style, map string => numeric
                        if (option.name.toLowerCase().includes("style")) {
                            const lineStyleMap = {
                                Solid: 0,
                                Dotted: 1,
                                Dashed: 2,
                                "Large Dashed": 3,
                                "Sparse Dotted": 4,
                            };
                            finalValue = lineStyleMap[newValue] ?? 0; // fallback to Solid (0)
                        }
                        // If the option name indicates it's a line type, map string => numeric
                        else if (option.name.toLowerCase().includes("linetype")) {
                            const lineTypeMap = {
                                Simple: 0,
                                WithSteps: 1,
                                Curved: 2,
                            };
                            finalValue = lineTypeMap[newValue] ?? 0; // fallback to Simple (0)
                        }
                        // Build the updated options object
                        const updatedOptions = buildOptions(option.name, finalValue);
                        series.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to "${newValue}" =>`, finalValue);
                        // --- Update the Legend Symbol if it's a lineStyle change on a Line series ---
                        if (option.name.toLowerCase().includes("style") &&
                            series.seriesType() === "Line") {
                            // Convert the numeric finalValue into a symbol
                            const lineStyleNumeric = finalValue;
                            const symbol = (() => {
                                switch (lineStyleNumeric) {
                                    case 0:
                                        return "―"; // Solid
                                    case 1:
                                        return "··"; // Dotted
                                    case 2:
                                        return "--"; // Dashed
                                    case 3:
                                        return "- -"; // Large Dashed
                                    case 4:
                                        return "· ·"; // Sparse Dotted
                                    default:
                                        return "~"; // Fallback
                                }
                            })();
                            // Find the corresponding legend item in the legend._lines array
                            const legendItem = this.handler.legend._lines.find((item) => item.series === series);
                            if (legendItem) {
                                legendItem.legendSymbol = [symbol];
                                console.log(`Updated legend symbol for lineStyle(${lineStyleNumeric}) to: ${symbol}`);
                            }
                        }
                    });
                }
                else {
                    console.warn(`No predefined options found for "${option.name}".`);
                }
            });
            // Add a Back option
            this.addMenuItem("⤝ Back", () => {
                this.populateSeriesMenu(series, event);
            }, false, false);
            this.showMenu(event);
        }
        populateCloneSeriesMenu(series, event) {
            this.div.innerHTML = "";
            // Fetch the current data from the series
            const data = series.data();
            // Basic clone targets for any data
            const cloneOptions = ["Line", "Histogram", "Area"];
            if (data && data.length > 0) {
                // Check if any bar is recognized as OHLC
                const hasOHLC = data.some((bar) => isOHLCData(bar));
                // If so, we push "Bar" and "Candlestick" to the menu
                if (hasOHLC) {
                    cloneOptions.push("Bar", "Candlestick", "Ohlc");
                }
            }
            // Generate the menu items for each clone option
            cloneOptions.forEach((type) => {
                this.addMenuItem(`Clone as ${type}`, () => {
                    const clonedSeries = cloneSeriesAsType(series, this.handler, type, this.handler.defaultsManager.defaults.get(type.toLowerCase()) || {});
                    if (clonedSeries) {
                        console.log(`Cloned series as ${type}:`, clonedSeries);
                    }
                    else {
                        console.warn(`Failed to clone as ${type}.`);
                    }
                }, false);
            });
            // Back to Series Options
            this.addMenuItem("⤝ Series Options", () => {
                this.populateSeriesMenu(series, event);
            }, false, false);
            this.showMenu(event);
        }
        addTextInput(label, defaultValue, onChange) {
            const container = document.createElement("div");
            container.classList.add("context-menu-item");
            container.style.display = "flex";
            container.style.alignItems = "center";
            container.style.justifyContent = "space-between";
            const labelElem = document.createElement("label");
            labelElem.innerText = label;
            labelElem.htmlFor = `${label.toLowerCase()}-input`;
            labelElem.style.marginRight = "8px";
            labelElem.style.flex = "1"; // Ensure the label takes up available space
            container.appendChild(labelElem);
            const input = document.createElement("input");
            input.type = "text";
            input.value = defaultValue;
            input.id = `${label.toLowerCase()}-input`;
            input.style.flex = "0 0 100px"; // Fixed width for input
            input.style.marginLeft = "auto"; // Right-align
            input.style.backgroundColor = "#2b2b2b"; // Darker gray background
            input.style.color = "#fff"; // White text color for contrast
            input.style.border = "1px solid #444"; // Subtle border
            input.style.borderRadius = "4px";
            input.style.cursor = "pointer";
            input.addEventListener("input", (event) => {
                const target = event.target;
                onChange(target.value);
            });
            container.appendChild(input);
            this.div.appendChild(container);
            return container;
        }
        populateColorOptionsMenu(colorOptions, series, event) {
            this.div.innerHTML = "";
            colorOptions.forEach((option) => {
                this.addColorPickerMenuItem(camelToTitle(option.label), option.value, option.label, series);
            });
            this.addMenuItem("⤝ Back to Series Options", () => {
                this.populateSeriesMenu(series, event);
            }, false, false);
            this.showMenu(event);
        }
        populateVisibilityMenu(event, series) {
            this.div.innerHTML = "";
            const seriesOptions = series.options();
            const visibilityOptionNames = ["visible", "crosshairMarkerVisible", "priceLineVisible"];
            visibilityOptionNames.forEach((optionName) => {
                const optionValue = seriesOptions[optionName];
                if (typeof optionValue === "boolean") {
                    this.addCheckbox(camelToTitle(optionName), optionValue, (newValue) => {
                        const options = buildOptions(optionName, newValue);
                        series.applyOptions(options);
                        console.log(`Toggled ${optionName} to ${newValue}`);
                    });
                }
            });
            this.addMenuItem("⤝ Back to Series Options", () => {
                this.populateSeriesMenu(series, event);
            }, false, false);
            this.showMenu(event);
        }
        populateBackgroundTypeMenu(event) {
            this.div.innerHTML = "";
            const backgroundOptions = [
                {
                    text: "Solid",
                    action: () => this.setBackgroundType(event, lightweightCharts.ColorType.Solid),
                },
                {
                    text: "Vertical Gradient",
                    action: () => this.setBackgroundType(event, lightweightCharts.ColorType.VerticalGradient),
                },
            ];
            backgroundOptions.forEach((option) => {
                // Use shouldHide = false if you want to move to another menu without closing
                this.addMenuItem(option.text, option.action, false, // don't hide immediately if you want subsequent menus
                false, 1);
            });
            // Back to Chart Menu
            this.addMenuItem("⤝ Chart Menu", () => {
                this.populateChartMenu(event);
            }, false);
            this.showMenu(event);
        }
        populateGradientBackgroundMenuInline(event, gradientBackground) {
            this.div.innerHTML = "";
            this.addColorPickerMenuItem(camelToTitle("Top Color"), gradientBackground.topColor, "layout.background.topColor", this.handler.chart);
            this.addColorPickerMenuItem(camelToTitle("Bottom Color"), gradientBackground.bottomColor, "layout.background.bottomColor", this.handler.chart);
            // Back to Background Type Menu
            this.addMenuItem("⤝ Background Type & Colors", () => {
                this.populateBackgroundTypeMenu(event);
            }, false);
            this.showMenu(event);
        }
        populateGridMenu(event) {
            this.div.innerHTML = ""; // Clear the menu
            // Configuration for grid options
            const gridOptions = [
                {
                    name: "Vertical Line Color",
                    type: "color",
                    valuePath: "grid.vertLines.color",
                    defaultValue: "#D6DCDE",
                },
                {
                    name: "Horizontal Line Color",
                    type: "color",
                    valuePath: "grid.horzLines.color",
                    defaultValue: "#D6DCDE",
                },
                {
                    name: "Vertical Line Style",
                    type: "select",
                    valuePath: "grid.vertLines.style",
                    options: ["Solid", "Dashed", "Dotted", "LargeDashed"],
                    defaultValue: "Solid",
                },
                {
                    name: "Horizontal Line Style",
                    type: "select",
                    valuePath: "grid.horzLines.style",
                    options: ["Solid", "Dashed", "Dotted", "LargeDashed"],
                    defaultValue: "Solid",
                },
                {
                    name: "Show Vertical Lines",
                    type: "boolean",
                    valuePath: "grid.vertLines.visible",
                    defaultValue: true,
                },
                {
                    name: "Show Horizontal Lines",
                    type: "boolean",
                    valuePath: "grid.horzLines.visible",
                    defaultValue: true,
                },
            ];
            // Iterate over the grid options and dynamically add inputs
            gridOptions.forEach((option) => {
                const currentValue = this.getCurrentOptionValue(option.valuePath) ?? option.defaultValue;
                if (option.type === "color") {
                    this.addColorPickerMenuItem(camelToTitle(option.name), currentValue, option.valuePath, this.handler.chart);
                }
                else if (option.type === "select") {
                    this.addSelectInput(camelToTitle(option.name), currentValue, option.options, (newValue) => {
                        const selectedIndex = option.options.indexOf(newValue);
                        const updatedOptions = buildOptions(option.valuePath, selectedIndex);
                        this.handler.chart.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to: ${newValue}`);
                    });
                }
                else if (option.type === "boolean") {
                    this.addCheckbox(camelToTitle(option.name), currentValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        this.handler.chart.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to: ${newValue}`);
                    });
                }
            });
            // Back to Main Menu
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false);
            this.showMenu(event); // Display the updated menu
        }
        populateBackgroundMenu(event) {
            this.div.innerHTML = "";
            this.addMenuItem("Type & Colors", () => {
                this.populateBackgroundTypeMenu(event);
            }, false, true);
            this.addMenuItem("Options", () => {
                this.populateBackgroundOptionsMenu(event);
            }, false, true);
            this.addMenuItem("⤝ Layout Options", () => {
                this.populateLayoutMenu(event);
            }, false);
            this.showMenu(event);
        }
        populateBackgroundOptionsMenu(event) {
            this.div.innerHTML = "";
            const backgroundOptions = [
                { name: "Background Color", valuePath: "layout.background.color" },
                { name: "Background Top Color", valuePath: "layout.background.topColor" },
                {
                    name: "Background Bottom Color",
                    valuePath: "layout.background.bottomColor",
                },
            ];
            backgroundOptions.forEach((option) => {
                const initialColor = this.getCurrentOptionValue(option.valuePath) || "#FFFFFF";
                this.addColorPickerMenuItem(camelToTitle(option.name), initialColor, option.valuePath, this.handler.chart);
            });
            // Back to Background Menu
            this.addMenuItem("⤝ Background", () => {
                this.populateBackgroundMenu(event);
            }, false);
            this.showMenu(event);
        }
        populateSolidBackgroundMenuInline(event, solidBackground) {
            this.div.innerHTML = "";
            this.addColorPickerMenuItem(camelToTitle("Background Color"), solidBackground.color, "layout.background.color", this.handler.chart);
            // Back to Type & Colors
            this.addMenuItem("⤝ Type & Colors", () => {
                this.populateBackgroundTypeMenu(event);
            }, false);
            this.showMenu(event);
        }
        populateCrosshairOptionsMenu(event) {
            this.div.innerHTML = "";
            const crosshairOptions = [
                { name: "Line Color", valuePath: "crosshair.lineColor" },
                { name: "Vertical Line Color", valuePath: "crosshair.vertLine.color" },
                { name: "Horizontal Line Color", valuePath: "crosshair.horzLine.color" },
            ];
            crosshairOptions.forEach((option) => {
                const initialColor = this.getCurrentOptionValue(option.valuePath) || "#000000";
                this.addColorPickerMenuItem(camelToTitle(option.name), initialColor, option.valuePath, this.handler.chart);
            });
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false);
            this.showMenu(event);
        }
        populateTimeScaleMenu(event) {
            this.div.innerHTML = ""; // Clear current menu
            // TimeScaleOptions configuration
            const timeScaleOptions = [
                {
                    name: "Right Offset",
                    type: "number",
                    valuePath: "timeScale.rightOffset",
                    min: 0,
                    max: 100,
                },
                {
                    name: "Bar Spacing",
                    type: "number",
                    valuePath: "timeScale.barSpacing",
                    min: 1,
                    max: 100,
                },
                {
                    name: "Min Bar Spacing",
                    type: "number",
                    valuePath: "timeScale.minBarSpacing",
                    min: 0.1,
                    max: 10,
                    step: 0.1,
                },
                {
                    name: "Fix Left Edge",
                    type: "boolean",
                    valuePath: "timeScale.fixLeftEdge",
                },
                {
                    name: "Fix Right Edge",
                    type: "boolean",
                    valuePath: "timeScale.fixRightEdge",
                },
                {
                    name: "Lock Visible Range on Resize",
                    type: "boolean",
                    valuePath: "timeScale.lockVisibleTimeRangeOnResize",
                },
                {
                    name: "Visible",
                    type: "boolean",
                    valuePath: "timeScale.visible",
                },
                {
                    name: "Border Visible",
                    type: "boolean",
                    valuePath: "timeScale.borderVisible",
                },
                {
                    name: "Border Color",
                    type: "color",
                    valuePath: "timeScale.borderColor",
                },
            ];
            // Iterate over options and dynamically add inputs based on type
            timeScaleOptions.forEach((option) => {
                if (option.type === "number") {
                    const currentValue = this.getCurrentOptionValue(option.valuePath);
                    this.addNumberInput(camelToTitle(option.name), currentValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        this.handler.chart.applyOptions(updatedOptions);
                        console.log(`Updated TimeScale ${option.name} to: ${newValue}`);
                    }, option.min, option.max);
                }
                else if (option.type === "boolean") {
                    const currentValue = this.getCurrentOptionValue(option.valuePath);
                    this.addCheckbox(camelToTitle(option.name), currentValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        this.handler.chart.applyOptions(updatedOptions);
                        console.log(`Updated TimeScale ${option.name} to: ${newValue}`);
                    });
                }
                else if (option.type === "color") {
                    const currentColor = this.getCurrentOptionValue(option.valuePath) ||
                        "#000000";
                    this.addColorPickerMenuItem(camelToTitle(option.name), currentColor, option.valuePath, this.handler.chart);
                }
            });
            // Back to Main Menu
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false);
            this.showMenu(event); // Display the updated menu
        }
        populatePriceScaleMenu(event, priceScaleId = "right", series) {
            this.div.innerHTML = ""; // Clear current menu
            if (series) {
                this.addMenuInput(this.div, {
                    type: "hybrid",
                    label: "Price Scale",
                    value: series.options().priceScaleId || "",
                    onChange: (newValue) => {
                        series.applyOptions({ priceScaleId: newValue });
                        console.log(`Updated price scale to: ${newValue}`);
                    },
                    hybridConfig: {
                        defaultAction: () => {
                            const newPriceScaleId = series.options().priceScaleId === "left" ? "right" : "left";
                            series.applyOptions({ priceScaleId: newPriceScaleId });
                            console.log(`Series price scale switched to: ${newPriceScaleId}`);
                        },
                        options: [
                            {
                                name: "Left",
                                action: () => series.applyOptions({ priceScaleId: "left" }),
                            },
                            {
                                name: "Right",
                                action: () => series.applyOptions({ priceScaleId: "right" }),
                            },
                            {
                                name: "Volume",
                                action: () => series.applyOptions({ priceScaleId: "volume_scale" }),
                            },
                            {
                                name: "Custom",
                                action: () => {
                                    const inputContainer = document.createElement("div");
                                    const inputField = document.createElement("input");
                                    inputField.type = "text";
                                    inputField.placeholder = "Enter custom scale ID";
                                    inputField.value = series.options().priceScaleId || "";
                                    inputField.addEventListener("change", () => {
                                        series.applyOptions({ priceScaleId: inputField.value });
                                        console.log(`Custom scale ID set to: ${inputField.value}`);
                                    });
                                    inputContainer.appendChild(inputField);
                                    this.div.appendChild(inputContainer);
                                },
                            },
                        ],
                    },
                });
            }
            else {
                // Dropdown for Price Scale Mode
                const currentMode = this.handler.chart.priceScale(priceScaleId).options().mode ??
                    lightweightCharts.PriceScaleMode.Normal;
                const modeOptions = [
                    { label: "Normal", value: lightweightCharts.PriceScaleMode.Normal },
                    { label: "Logarithmic", value: lightweightCharts.PriceScaleMode.Logarithmic },
                    { label: "Percentage", value: lightweightCharts.PriceScaleMode.Percentage },
                    { label: "Indexed To 100", value: lightweightCharts.PriceScaleMode.IndexedTo100 },
                ];
                const modeLabels = modeOptions.map((opt) => opt.label);
                this.addSelectInput("Price Scale Mode", modeOptions.find((opt) => opt.value === currentMode)?.label || "Normal", // Current value label
                modeLabels, // Dropdown options (labels)
                (newLabel) => {
                    const selectedOption = modeOptions.find((opt) => opt.label === newLabel);
                    if (selectedOption) {
                        this.applyPriceScaleOptions(priceScaleId, {
                            mode: selectedOption.value,
                        });
                        console.log(`Price scale (${priceScaleId}) mode set to: ${newLabel}`);
                        this.populatePriceScaleMenu(event, priceScaleId, series); // Refresh the menu
                    }
                });
                // Additional Price Scale Options
                const options = this.handler.chart.priceScale(priceScaleId).options();
                const additionalOptions = [
                    {
                        name: "Auto Scale",
                        value: options.autoScale ?? true,
                        action: (newValue) => {
                            this.applyPriceScaleOptions(priceScaleId, { autoScale: newValue });
                            console.log(`Price scale (${priceScaleId}) autoScale set to: ${newValue}`);
                        },
                    },
                    {
                        name: "Invert Scale",
                        value: options.invertScale ?? false,
                        action: (newValue) => {
                            this.applyPriceScaleOptions(priceScaleId, {
                                invertScale: newValue,
                            });
                            console.log(`Price scale (${priceScaleId}) invertScale set to: ${newValue}`);
                        },
                    },
                    {
                        name: "Align Labels",
                        value: options.alignLabels ?? true,
                        action: (newValue) => {
                            this.applyPriceScaleOptions(priceScaleId, {
                                alignLabels: newValue,
                            });
                            console.log(`Price scale (${priceScaleId}) alignLabels set to: ${newValue}`);
                        },
                    },
                    {
                        name: "Border Visible",
                        value: options.borderVisible ?? true,
                        action: (newValue) => {
                            this.applyPriceScaleOptions(priceScaleId, {
                                borderVisible: newValue,
                            });
                            console.log(`Price scale (${priceScaleId}) borderVisible set to: ${newValue}`);
                        },
                    },
                    {
                        name: "Ticks Visible",
                        value: options.ticksVisible ?? false,
                        action: (newValue) => {
                            this.applyPriceScaleOptions(priceScaleId, {
                                ticksVisible: newValue,
                            });
                            console.log(`Price scale (${priceScaleId}) ticksVisible set to: ${newValue}`);
                        },
                    },
                ];
                additionalOptions.forEach((opt) => {
                    this.addMenuItem(`${opt.name}: ${opt.value ? "On" : "Off"}`, () => {
                        const newValue = !opt.value; // Toggle the current value
                        opt.action(newValue);
                        this.populatePriceScaleMenu(event, priceScaleId, series); // Refresh the menu
                    }, false, false);
                });
            }
            // Back to Main Menu
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false);
            this.showMenu(event); // Display the updated menu
        }
        applyPriceScaleOptions(priceScaleId, options) {
            // Access the price scale from the chart using its ID
            const priceScale = this.handler.chart.priceScale(priceScaleId);
            if (!priceScale) {
                console.warn(`Price scale with ID "${priceScaleId}" not found.`);
                return;
            }
            // Apply the provided options to the price scale
            priceScale.applyOptions(options);
            console.log(`Applied options to price scale "${priceScaleId}":`, options);
        }
        getCurrentOptionValue(optionPath) {
            const keys = optionPath.split(".");
            let options = this.handler.chart.options();
            for (const key of keys) {
                if (options && key in options) {
                    options = options[key];
                }
                else {
                    console.warn(`Option path "${optionPath}" is invalid.`);
                    return null;
                }
            }
            return options;
        }
        setBackgroundType(event, type) {
            const currentBackground = this.handler.chart.options().layout?.background;
            let updatedBackground;
            if (type === lightweightCharts.ColorType.Solid) {
                updatedBackground = isSolidColor(currentBackground)
                    ? { type: lightweightCharts.ColorType.Solid, color: currentBackground.color }
                    : { type: lightweightCharts.ColorType.Solid, color: "#000000" };
            }
            else if (type === lightweightCharts.ColorType.VerticalGradient) {
                updatedBackground = isVerticalGradientColor(currentBackground)
                    ? {
                        type: lightweightCharts.ColorType.VerticalGradient,
                        topColor: currentBackground.topColor,
                        bottomColor: currentBackground.bottomColor,
                    }
                    : {
                        type: lightweightCharts.ColorType.VerticalGradient,
                        topColor: "rgba(255,0,0,.2)",
                        bottomColor: "rgba(0,255,0,.2)",
                    };
            }
            else {
                console.error(`Unsupported ColorType: ${type}`);
                return;
            }
            this.handler.chart.applyOptions({
                layout: {
                    background: updatedBackground,
                },
            });
            if (type === lightweightCharts.ColorType.Solid) {
                this.populateSolidBackgroundMenuInline(event, updatedBackground);
            }
            else if (type === lightweightCharts.ColorType.VerticalGradient) {
                this.populateGradientBackgroundMenuInline(event, updatedBackground);
            }
        }
        startFillAreaBetween(event, originSeries) {
            console.log("Fill Area Between started. Origin series set:", originSeries.options().title);
            // Ensure the series is decorated
            // Populate the Series List Menu
            this.populateSeriesListMenu(event, false, (destinationSeries) => {
                if (destinationSeries && destinationSeries !== originSeries) {
                    console.log("Destination series selected:", destinationSeries.options().title);
                    // Ensure the destination series is also decorated
                    // Instantiate and attach the FillArea
                    originSeries.primitives["FillArea"] = new FillArea(originSeries, destinationSeries, {
                        ...defaultFillAreaOptions,
                    });
                    originSeries.attachPrimitive(originSeries.primitives["FillArea"], `Fill Area ⥵ ${destinationSeries.options().title}`, false, true);
                    // Attach the FillArea as a primitive
                    //if (!originSeries.primitives['FillArea']) {
                    //  originSeries.attachPrimitive(originSeries.primitives["FillArea"])
                    //}
                    console.log("Fill Area successfully added between selected series.");
                    alert(`Fill Area added between ${originSeries.options().title} and ${destinationSeries.options().title}`);
                }
                else {
                    alert("Invalid selection. Please choose a different series as the destination.");
                }
            });
        }
        getPredefinedOptions(label) {
            const predefined = {
                "Series Type": ["Line", "Histogram", "Area", "Bar", "Candlestick"],
                "Line Style": [
                    "Solid",
                    "Dotted",
                    "Dashed",
                    "Large Dashed",
                    "Sparse Dotted",
                ],
                "Line Type": ["Simple", "WithSteps", "Curved"],
                seriesType: ["Line", "Histogram", "Area", "Bar", "Candlestick"],
                lineStyle: ["Solid", "Dotted", "Dashed", "Large Dashed", "Sparse Dotted"],
                "Price Line Style": [
                    "Solid",
                    "Dotted",
                    "Dashed",
                    "Large Dashed",
                    "Sparse Dotted",
                ],
                lineType: ["Simple", "WithSteps", "Curved"],
                Shape: ["Rectangle", "Rounded", "Ellipse", "Arrow", "3d", "Polygon", "Bar", "Slanted"],
                "Candle Shape": [
                    "Rectangle",
                    "Rounded",
                    "Ellipse",
                    "Arrow",
                    "3d",
                    "Polygon",
                    "Bar",
                    "Slanted"
                ],
            };
            return predefined[camelToTitle(label)] || null;
        }
        /**
         * Populates the Series List Menu for selecting the destination series.
         * @param onSelect Callback when a series is selected.
         */
        populateSeriesListMenu(event, hideMenu, onSelect) {
            this.div.innerHTML = ""; // Clear the current menu
            // 1) Gather all series from your `handler.seriesMap`.
            const mappedSeries = Array.from(this.handler.seriesMap.entries()).map(([seriesName, series]) => ({
                label: seriesName,
                value: series,
            }));
            let seriesOptions = [...mappedSeries];
            if (this.handler.volumeSeries) {
                const volumeSeries = {
                    label: "Volume",
                    value: this.handler.volumeSeries,
                };
                seriesOptions = [volumeSeries, ...seriesOptions];
            }
            console.log(seriesOptions);
            // 3) Display series in the menu
            seriesOptions.forEach((option) => {
                this.addMenuItem(option.label, () => {
                    onSelect(option.value);
                    if (hideMenu) {
                        this.hideMenu();
                    }
                    else {
                        this.div.innerHTML = ""; // Clear the current menu
                        this.populateSeriesMenu(option.value, event); // Open the series menu
                        this.showMenu(event);
                    }
                }, false, true);
            });
            // Add a "Cancel" option to go back or exit
            this.addMenuItem("Cancel", () => {
                console.log("Operation canceled.");
                this.hideMenu();
            });
            // Back to Main Menu
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false);
            // Show the menu at the current mouse position
            this.showMenu(event);
        }
        customizeFillAreaOptions(event, FillArea) {
            this.div.innerHTML = ""; // Clear current menu
            if (isFillArea(FillArea)) {
                // Add color pickers for each color-related option
                this.addColorPickerMenuItem("Origin > Destination", FillArea.options.originColor, "originColor", FillArea);
                this.addColorPickerMenuItem("Origin < Destination", FillArea.options.destinationColor, "destinationColor", FillArea);
            }
            // Back to main menu
            this.addMenuItem("⤝ Back to Main Menu", () => this.populateChartMenu(event), false);
            this.showMenu(event);
        }
        addResetViewOption() {
            const resetMenuItem = this.addMenuInput(this.div, {
                type: "hybrid",
                label: "∟ Reset",
                sublabel: "View",
                hybridConfig: {
                    defaultAction: () => {
                        this.handler.chart.timeScale().resetTimeScale();
                        this.handler.chart.timeScale().fitContent();
                    },
                    options: [
                        {
                            name: "⥗ Time Scale",
                            action: () => this.handler.chart.timeScale().resetTimeScale(),
                        },
                        {
                            name: "⥘ Price Scale",
                            action: () => this.handler.chart.timeScale().fitContent,
                        },
                    ],
                },
            });
            this.div.appendChild(resetMenuItem);
        }
        /**
         * Creates a TrendTrace for the given series.
         *
         * @param series - The series to which the TrendTrace will be attached.
         */
        _createTrendTrace(event, drawing) {
            // Populate the Series List Menu
            this.populateSeriesListMenu(event, false, (series) => {
                let offset;
                if (drawing._type === "PitchFork" && series && drawing.p1 && drawing.p2) {
                    console.log("Series selected:", series.options().title);
                    const options = drawing._options;
                    offset =
                        (options.length ?? 1) *
                            Math.abs(drawing.p2.logical - drawing.p1.logical);
                }
                if (series && drawing.p1 && drawing.p2) {
                    console.log("Series selected:", series.options().title);
                    series.primitives["TrendTrace"] = new TrendTrace(this.handler, series, drawing.p1, drawing.p2, defaultSequenceOptions, offset);
                    series.attachPrimitive(series.primitives["TrendTrace"], `${drawing.p1?.logical} ⥵ ${drawing.p2?.logical}`, false, true);
                    console.log("Trend Trace successfully created for selected series.");
                    drawing.linkedObjects.push(series.primitives["TrendTrace"]);
                }
            });
        }
        _createVolumeProfile(drawing) {
            const series = this.handler.series ?? this.handler._seriesList[0];
            if (series && drawing.p1 && drawing.p2) {
                console.log("Series selected:", series.options().title);
                // Create the VolumeProfile instance in fixed range mode.
                const volumeProfile = new VolumeProfile(this.handler, defaultVolumeProfileOptions, drawing.p1, drawing.p2);
                // Attach the volume profile primitive to the selected series.
                series.attachPrimitive(volumeProfile, "Volume Profile", false, true);
                console.log("Volume Profile successfully created for selected series.");
                drawing.linkedObjects.push(volumeProfile);
            }
        }
        /**
         * Main entry point for the trend trace menu.
         *
         * @param event - The mouse event that triggered the menu.
         * @param trendTrace - The trend trace instance.
         */
        populateTrendTraceMenu(event, trendTrace) {
            this.div.innerHTML = ""; // Clear the menu
            this.addMenuItem("Color Options ▸", () => this.populateTrendColorMenu(event, trendTrace), false, true);
            this.addMenuItem("General Options ▸", () => this.populateTrendOptionsMenu(event, trendTrace), false, true);
            // Use the new DataExportMenu to open the export/import dialog.
            this.addMenuItem("Export/Import Data ▸", () => {
                if (!this.dataMenu) {
                    this.dataMenu = new DataMenu({ contextMenu: this, handler: this.handler });
                }
                this.dataMenu.openMenu(trendTrace, event, "Trend Trace");
            }, false);
            this.addMenuItem("⤝ Main Menu", () => this.populateChartMenu(event), false);
            this.showMenu(event);
        }
        populateTrendColorMenu(event, trendTrace) {
            this.div.innerHTML = ""; // Clear the menu
            const currentOptions = trendTrace.getOptions();
            const sequence = trendTrace._sequence;
            const ohlcData = sequence.data;
            const isOHLC = ohlcData.every((point) => point.open !== undefined &&
                point.high !== undefined &&
                point.low !== undefined &&
                point.close !== undefined);
            // Build a list of color options based on the data type.
            const colorOptions = [];
            if (isOHLC) {
                colorOptions.push({
                    name: "Up Color",
                    type: "color",
                    valuePath: "upColor",
                    defaultValue: currentOptions.upColor ?? "rgba(0,255,0,.25)",
                }, {
                    name: "Down Color",
                    type: "color",
                    valuePath: "downColor",
                    defaultValue: currentOptions.downColor ?? "rgba(255,0,0,.25)",
                }, {
                    name: "Border Up Color",
                    type: "color",
                    valuePath: "borderUpColor",
                    defaultValue: currentOptions.borderUpColor ?? "#1c9d1c",
                }, {
                    name: "Border Down Color",
                    type: "color",
                    valuePath: "borderDownColor",
                    defaultValue: currentOptions.borderDownColor ?? "#d5160c",
                }, {
                    name: "Wick Up Color",
                    type: "color",
                    valuePath: "wickUpColor",
                    defaultValue: currentOptions.wickUpColor ?? "#1c9d1c",
                }, {
                    name: "Wick Down Color",
                    type: "color",
                    valuePath: "wickDownColor",
                    defaultValue: currentOptions.wickDownColor ?? "#d5160c",
                });
            }
            else
                colorOptions.push({
                    name: "Line Color",
                    type: "color",
                    valuePath: "lineColor",
                    defaultValue: currentOptions.lineColor ?? "#ffffff",
                });
            // Iterate over each color option and add it using addColorPickerMenuItem.
            colorOptions.forEach((option) => {
                this.addColorPickerMenuItem(camelToTitle(option.name), option.defaultValue, option.valuePath, trendTrace);
            });
            // Back to Trend Trace Menu
            this.addMenuItem("⤝ Trend Trace Menu", () => this.populateTrendTraceMenu(event, trendTrace), false);
            this.showMenu(event);
        }
        /**
         * Populates the submenu for general options.
         *
         * Logical indices (P1/P2) are always shown.
         * However, appearance options that are relevant only for OHLC data—
         * such as Bar Spacing, Radius, Shape, Show Wicks, Show Borders, and Chandelier Size—
         * are added only if isOHLCData returns true.
         *
         * Each update uses buildOptions.
         *
         * @param event - The mouse event that triggered the menu.
         * @param trendTrace - The TrendTrace instance.
         */
        populateTrendOptionsMenu(event, trendTrace) {
            this.div.innerHTML = ""; // Clear the menu
            const currentOptions = trendTrace.getOptions();
            const sequence = trendTrace._sequence;
            const ohlcData = sequence.data;
            const isOHLC = ohlcData.every((point) => point.open !== undefined &&
                point.high !== undefined &&
                point.low !== undefined &&
                point.close !== undefined);
            // Define the generalOptions array with a consistent option type.
            const generalOptions = [];
            // If the series is OHLC, add appearance options specific to OHLC.
            if (isOHLC) {
                generalOptions.push({
                    name: "Bar Spacing",
                    type: "number",
                    valuePath: "barSpacing",
                    defaultValue: currentOptions.barSpacing ?? 0.8,
                    min: 0.1,
                    max: 10,
                    step: 0.1,
                }, {
                    name: "Radius",
                    type: "number",
                    valuePath: "radius",
                    defaultValue: currentOptions.radius ?? 0.6,
                    min: 0,
                    max: 1,
                    step: 0.1,
                }, {
                    name: "Shape",
                    type: "select",
                    valuePath: "shape",
                    defaultValue: currentOptions.shape ?? "Rounded",
                    options: [
                        { label: "Rectangle", value: CandleShape.Rectangle },
                        { label: "Rounded", value: CandleShape.Rounded },
                        { label: "Ellipse", value: CandleShape.Ellipse },
                        { label: "Arrow", value: CandleShape.Arrow },
                        { label: "Polygon", value: CandleShape.Polygon },
                        { label: "Bar", value: CandleShape.Bar },
                        { label: "Slanted", value: CandleShape.Slanted },
                    ],
                }, {
                    name: "Show Wicks",
                    type: "boolean",
                    valuePath: "wickVisible",
                    defaultValue: currentOptions.wickVisible ?? true,
                }, {
                    name: "Show Borders",
                    type: "boolean",
                    valuePath: "borderVisible",
                    defaultValue: currentOptions.borderVisible ?? true,
                }, {
                    name: "Chandelier Size",
                    type: "number",
                    valuePath: "chandelierSize",
                    defaultValue: currentOptions.chandelierSize ?? 1,
                    min: 1,
                    max: 100,
                    step: 1,
                }, {
                    name: "Auto Aggregate",
                    type: "boolean",
                    valuePath: "autoscale",
                    defaultValue: currentOptions.autoScale ?? true,
                });
            }
            // Always include the following default appearance options.
            // Line Style option with numeric mapping.
            generalOptions.push({
                name: "Line Style",
                type: "select",
                valuePath: "lineStyle",
                defaultValue: currentOptions.lineStyle ?? 0,
                options: [
                    { label: "Solid", value: 0 },
                    { label: "Dotted", value: 1 },
                    { label: "Dashed", value: 2 },
                    { label: "Large Dashed", value: 3 },
                    { label: "Sparse Dotted", value: 4 },
                ],
            });
            // Line Width option for adjusting the appearance of the line.
            generalOptions.push({
                name: "Line Width",
                type: "number",
                valuePath: "lineWidth",
                defaultValue: currentOptions.lineWidth ?? 1,
                min: 0.5,
                max: 10,
                step: 0.5,
            });
            // Visible toggle option. This option is always added.
            generalOptions.push({
                name: "Visible",
                type: "boolean",
                valuePath: "visible",
                defaultValue: currentOptions.visible ?? true,
            });
            // Iterate over each general option and add an input based on its type.
            generalOptions.forEach((option) => {
                if (option.type === "number") {
                    this.addNumberInput(camelToTitle(option.name), option.defaultValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        trendTrace.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to: ${newValue}`);
                    }, option.min, option.max, option.step);
                }
                else if (option.type === "boolean") {
                    this.addCheckbox(camelToTitle(option.name), option.defaultValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        trendTrace.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to: ${newValue}`);
                    });
                }
                else if (option.type === "select") {
                    // If options are objects, extract their labels.
                    const optionLabels = Array.isArray(option.options) && typeof option.options[0] === "object"
                        ? option.options.map((opt) => opt.label)
                        : option.options;
                    this.addSelectInput(camelToTitle(option.name), option.defaultValue, optionLabels, (newLabel) => {
                        // For option objects, find the corresponding numeric value.
                        const selectedOption = option.options.find((opt) => opt.label === newLabel);
                        if (selectedOption) {
                            const updatedOptions = buildOptions(option.valuePath, selectedOption.value);
                            trendTrace.applyOptions(updatedOptions);
                            console.log(`Updated ${option.name} to: ${selectedOption.value}`);
                        }
                    });
                }
                // (Color options are handled in the color submenu.)
            });
            // Add the Export option.
            // Back to Trend Trace Menu.
            this.addMenuItem("⤝ Trend Trace Menu", () => this.populateTrendTraceMenu(event, trendTrace), false);
            this.showMenu(event);
        }
        populateVolumeProfileMenu(event, volumeProfile) {
            this.div.innerHTML = ""; // Clear the menu
            const currentOptions = volumeProfile._options;
            // Define a unified array for all option types.
            const generalOptions = [];
            // Push non-color options.
            generalOptions.push({
                name: "Visible",
                type: "boolean",
                valuePath: "visible",
                defaultValue: currentOptions.visible ?? true,
            }, {
                name: "Sections",
                type: "number",
                valuePath: "sections",
                defaultValue: currentOptions.sections ?? 20,
                min: 1,
                step: 1,
            }, {
                name: "Right Side",
                type: "boolean",
                valuePath: "rightSide",
                defaultValue: currentOptions.rightSide ?? true,
            }, {
                name: "Width",
                type: "number",
                valuePath: "width",
                defaultValue: currentOptions.width ?? 30,
                min: 1,
                step: 1,
            }, {
                name: "Line Style",
                type: "select",
                valuePath: "lineStyle",
                defaultValue: currentOptions.lineStyle ?? 0,
                options: [
                    { label: "Solid", value: 0 },
                    { label: "Dotted", value: 1 },
                    { label: "Dashed", value: 2 },
                    { label: "Large Dashed", value: 3 },
                    { label: "Sparse Dotted", value: 4 },
                ],
            }, {
                name: "Draw Grid",
                type: "boolean",
                valuePath: "drawGrid",
                defaultValue: currentOptions.drawGrid ?? true,
            }, {
                name: "Grid Width",
                type: "number",
                valuePath: "gridWidth",
                defaultValue: currentOptions.gridWidth ?? undefined, // Undefined to use entire visible range
                min: 1,
                step: 1,
            }, {
                name: "Grid Line Style",
                type: "select",
                valuePath: "gridLineStyle",
                defaultValue: currentOptions.gridLineStyle ?? 4, // Assuming 1 corresponds to 'Dashed'
                options: [
                    { label: "Solid", value: 0 },
                    { label: "Dotted", value: 1 },
                    { label: "Dashed", value: 2 },
                    { label: "Large Dashed", value: 3 },
                    { label: "Sparse Dotted", value: 4 },
                ],
            });
            // Push color options.
            generalOptions.push({
                name: "Up Color",
                type: "color",
                valuePath: "upColor",
                defaultValue: currentOptions.upColor ?? defaultVolumeProfileOptions.upColor,
            }, {
                name: "Down Color",
                type: "color",
                valuePath: "downColor",
                defaultValue: currentOptions.downColor ?? defaultVolumeProfileOptions.downColor,
            }, {
                name: "Border Up Color",
                type: "color",
                valuePath: "borderUpColor",
                defaultValue: currentOptions.borderUpColor ??
                    defaultVolumeProfileOptions.borderUpColor,
            }, {
                name: "Border Down Color",
                type: "color",
                valuePath: "borderDownColor",
                defaultValue: currentOptions.borderDownColor ??
                    defaultVolumeProfileOptions.borderDownColor,
            }, {
                name: "Grid Color",
                type: "color",
                valuePath: "gridColor",
                defaultValue: currentOptions.gridColor ?? defaultVolumeProfileOptions.gridColor,
            });
            // Iterate over each general option and add an input based on its type.
            generalOptions.forEach((option) => {
                if (option.type === "number") {
                    this.addNumberInput(camelToTitle(option.name), option.defaultValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        volumeProfile.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to: ${newValue}`);
                    }, option.min, option.max, option.step);
                }
                else if (option.type === "boolean") {
                    this.addCheckbox(camelToTitle(option.name), option.defaultValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        volumeProfile.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to: ${newValue}`);
                    });
                }
                else if (option.type === "select") {
                    // If options are objects, extract their labels; otherwise, assume an array of strings.
                    const optionLabels = Array.isArray(option.options) && typeof option.options[0] === "object"
                        ? option.options.map((opt) => opt.label)
                        : option.options;
                    this.addSelectInput(camelToTitle(option.name), option.defaultValue, optionLabels, (newLabel) => {
                        const selectedOption = option.options.find((opt) => opt.label === newLabel);
                        if (selectedOption) {
                            const updatedOptions = buildOptions(option.valuePath, selectedOption.value);
                            volumeProfile.applyOptions(updatedOptions);
                            console.log(`Updated ${option.name} to: ${selectedOption.value}`);
                        }
                    });
                }
                else if (option.type === "color") {
                    // Use the existing color picker method.
                    this.addColorPickerMenuItem(camelToTitle(option.name), option.defaultValue, option.valuePath, volumeProfile);
                }
            });
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false);
            this.showMenu(event);
        }
        /**
         * Here, we define the method that shows a minimal overlay listing all indicators,
         * letting the user click “Add” or “Remove.” We'll reuse references to `this.handler.chart`
         * and `this.handler.seriesMap`, etc. We also define `this.applyIndicator` and `this.removeIndicator`
         * as class methods that store a reference to each indicator's series in `indicatorSeriesMap`.
         */
        // A map from indicator name => { figureKey => ISeriesApi }
        indicatorSeriesMap = new Map();
        populateIndicatorMenu(series, event) {
            // Clear the menu first
            this.div.innerHTML = "";
            // Show each indicator
            INDICATORS.forEach((indicator) => {
                this.addMenuItem(`${indicator.name} (${indicator.shortName})`, () => {
                    // If indicator has paramMap, let user configure
                    if (indicator.paramMap) {
                        this.configureIndicatorParams({ series, indicator }, event, 1, true);
                    }
                    else {
                        // Otherwise, directly apply
                        this.applyIndicator(series, indicator, /* no overrides */ {}, 1);
                    }
                }, false);
            });
            // Add a back/cancel item
            this.addMenuItem("⤝ Back", () => {
                this.hideMenu();
                // or populate something else
            }, false);
            // Display
            this.showMenu(event);
        }
        configureIndicatorParams(indicatorInput, event, globalCountParam, init = false // Optional parameter for global figure count.
        ) {
            // Clear existing menu items
            this.div.innerHTML = "";
            let currentCount;
            // Extract the series and indicator from the input.
            const series = "sourceSeries" in indicatorInput
                ? indicatorInput
                : indicatorInput.series;
            const indicator = ("indicator" in indicatorInput
                ? indicatorInput.indicator
                : indicatorInput.indicator);
            // Use stored parameters if available; otherwise, use indicator defaults.
            const storedParams = "paramMap" in indicatorInput ? indicatorInput.paramMap : {};
            const overrides = {};
            /**************************************************
             * 1. Global Figure Count Input
             * If any parameter is an array type, add a top-level input for
             * "Number of Figures". Use the passed globalCountParam if provided,
             * otherwise default to indicatorInput.figureCount if it exists,
             * or else to the default count (derived from the param defaults).
             **************************************************/
            let hasArrayParams = false;
            let defaultCount = 0;
            Object.entries(indicator.paramMap).forEach(([_, paramSpec]) => {
                if (paramSpec.type === "numberArray" ||
                    paramSpec.type === "selectArray" ||
                    paramSpec.type === "booleanArray" ||
                    paramSpec.type === "stringArray") {
                    hasArrayParams = true;
                    const defArr = Array.isArray(paramSpec.defaultValue)
                        ? paramSpec.defaultValue
                        : [paramSpec.defaultValue];
                    defaultCount = Math.max(defaultCount, defArr.length);
                }
            });
            if (hasArrayParams && init) {
                // Determine the current global count:
                if (globalCountParam !== undefined) {
                    currentCount = globalCountParam;
                    indicatorInput.figureCount = globalCountParam;
                }
                else if ("figureCount" in indicatorInput &&
                    indicatorInput.figureCount !== undefined) {
                    currentCount = indicatorInput.figureCount;
                }
                else {
                    currentCount = defaultCount || 1;
                }
                // Add a top-level input for "Number of Figures"
                this.addNumberInput("Number of Figures", currentCount, (newCount) => {
                    // Update the indicator's property with the new count.
                    indicatorInput.figureCount = newCount;
                    // Redraw the parameter menu using the new global count.
                    this.configureIndicatorParams(indicatorInput, event, newCount, true);
                }, 1, 10, 1);
            }
            /**************************************************
             * 2. Process Each Parameter
             **************************************************/
            Object.entries(indicator.paramMap).forEach(([paramName, paramSpec]) => {
                const labelText = paramName; // Optionally, format the label.
                const defaultVal = storedParams[paramName] !== undefined
                    ? storedParams[paramName]
                    : paramSpec.defaultValue;
                if (paramSpec.type === "numberArray" ||
                    paramSpec.type === "selectArray" ||
                    paramSpec.type === "booleanArray" ||
                    paramSpec.type === "stringArray") {
                    // Get the global count from the indicator's property.
                    const count = globalCountParam ?? indicatorInput.figureCount;
                    // Determine base type by stripping "Array"
                    const baseType = paramSpec.type.replace("Array", "");
                    overrides[paramName] = [];
                    for (let i = 0; i < count; i++) {
                        let itemDefault;
                        if (Array.isArray(defaultVal)) {
                            itemDefault =
                                i < defaultVal.length
                                    ? defaultVal[i]
                                    : defaultVal[defaultVal.length - 1];
                        }
                        else {
                            itemDefault = defaultVal;
                        }
                        if (baseType === "number") {
                            this.addNumberInput(`${labelText} ${i + 1}`, itemDefault, (newVal) => {
                                if (!overrides[paramName]) {
                                    overrides[paramName] = [];
                                }
                                overrides[paramName][i] = newVal;
                            }, paramSpec.min, paramSpec.max, paramSpec.step);
                        }
                        else if (baseType === "boolean") {
                            this.addCheckbox(`${labelText} ${i + 1}`, Boolean(itemDefault), (checked) => {
                                if (!overrides[paramName]) {
                                    overrides[paramName] = [];
                                }
                                overrides[paramName][i] = checked;
                            });
                        }
                        else if (baseType === "select") {
                            this.addSelectInput(`${labelText} ${i + 1}`, String(itemDefault), paramSpec.options || [], (selected) => {
                                if (!overrides[paramName]) {
                                    overrides[paramName] = [];
                                }
                                overrides[paramName][i] = selected;
                            });
                        }
                        else if (baseType === "string") {
                            this.addMenuInput(this.div, {
                                type: "string",
                                label: `${labelText} ${i + 1}`,
                                value: itemDefault,
                                onChange: (val) => {
                                    if (!overrides[paramName]) {
                                        overrides[paramName] = [];
                                    }
                                    overrides[paramName][i] = val;
                                },
                            });
                        }
                        if (!overrides[paramName]) {
                            overrides[paramName] = [];
                        }
                        overrides[paramName][i] = itemDefault;
                    }
                }
                else {
                    // Non-array parameters: same as before.
                    if (paramSpec.type === "number") {
                        this.addNumberInput(labelText, defaultVal, (newVal) => {
                            overrides[paramName] = newVal;
                        }, paramSpec.min, paramSpec.max, paramSpec.step);
                        overrides[paramName] = defaultVal;
                    }
                    else if (paramSpec.type === "boolean") {
                        this.addCheckbox(labelText, Boolean(defaultVal), (checked) => {
                            overrides[paramName] = checked;
                        });
                        overrides[paramName] = defaultVal;
                    }
                    else if (paramSpec.type === "select") {
                        this.addSelectInput(labelText, String(defaultVal), paramSpec.options || [], (selected) => {
                            overrides[paramName] = selected;
                        });
                        overrides[paramName] = defaultVal;
                    }
                    else {
                        this.addMenuInput(this.div, {
                            type: "string",
                            label: labelText,
                            value: defaultVal,
                            onChange: (val) => {
                                overrides[paramName] = val;
                            },
                        });
                        overrides[paramName] = defaultVal;
                    }
                }
            });
            /**************************************************
             * 3. Apply and Cancel Buttons
             **************************************************/
            this.addMenuItem("Apply", () => {
                this.hideMenu();
                // Update the defaultValue for each parameter in the indicator's paramMap
                Object.entries(overrides).forEach(([paramName, newValue]) => {
                    if (indicator.paramMap[paramName]) {
                        indicator.paramMap[paramName].defaultValue = newValue;
                    }
                });
                if ("recalculate" in indicatorInput) {
                    indicatorInput.recalculate(overrides);
                    indicatorInput.figures.forEach((figSeries) => {
                        const legendItem = this.handler.legend._lines.find((item) => item.series === figSeries);
                        if (legendItem) {
                            this.handler.seriesMap.set(figSeries.options().title, series);
                            legendItem.name = figSeries.options().title;
                        }
                    });
                }
                else {
                    this.applyIndicator(series, indicator, overrides, currentCount);
                }
            }, false);
            this.addMenuItem("Cancel", () => {
                this.hideMenu();
            }, false);
            this.showMenu(event);
        }
        /**
         * Applies an indicator to the given series.
         *
         * This method now accepts any ISeriesApi (not just Candlestick or Bar) and converts the data
         * to OHLC data if needed before calling the indicator's calc function.
         *
         * After calculating indicator figures, it either updates existing series or creates new ones,
         * and moves them to the appropriate pane if the figure defines a pane offset.
         *
         * @param series - The series on which to apply the indicator.
         * @param ind - The indicator definition.
         * @param overrides - User-specified parameter overrides.
         * @param count - The figure count.
         */
        applyIndicator(series, ind, overrides, count) {
            // 1) Grab your main data.
            const data = [...series.data()];
            if (!data || data.length === 0) {
                console.warn("No data found on this series.");
                return;
            }
            // 2) Convert the data to OHLC if it isn't already.
            let ohlcData;
            if (data.every(isOHLCData)) {
                ohlcData = data;
            }
            else {
                // Assume data is SingleValueData and convert each point.
                ohlcData = data.map(singleToOhlcData);
            }
            const volumeData = this.handler.volumeSeries.data();
            // 2a) Calculate the figures from the indicator
            const figures = ind.calc([...ohlcData], overrides, volumeData ?? undefined);
            //// 2b) If we already have them, update the existing figures
            //if (isISeriesIndicator(series)) {
            //  const figMap = series.figures;
            //  if (figMap) {
            //    figures.forEach((f) => {
            //      const existing = figMap.get(f.key);
            //      if (existing) {
            //        existing.setData(f.data);
            //      }
            //    });
            //  }
            //  return;
            //}
            // 2c) Otherwise, create new indicator series
            const newMap = new Map();
            const colorShades = generateShades(figures.length); // Generate unique shades
            figures.forEach((f, index) => {
                const selectedColor = colorShades[index];
                let seriesInstance = null;
                if (f.type === "histogram") {
                    const hist = this.handler.createHistogramSeries(f.title, {
                        color: selectedColor,
                        base: 0,
                        title: f.title,
                        ...(figures.length > 1 ? { group: ind.name } : {}), // ✅ Only set `group` if multiple figures exist
                    });
                    if (hist.series) {
                        hist.series.setData(f.data);
                        seriesInstance = hist.series;
                        if (series.getPane().paneIndex() !== seriesInstance.getPane().paneIndex()) {
                            seriesInstance.moveToPane(series.getPane().paneIndex());
                        }
                    }
                }
                else {
                    const line = this.handler.createLineSeries(f.title, {
                        color: selectedColor,
                        lineWidth: 2,
                        title: f.title,
                        ...(figures.length > 1 ? { group: ind.name } : {}), // ✅ Only set `group` if multiple figures exist
                    });
                    if (line.series) {
                        line.series.setData(f.data);
                        seriesInstance = line.series;
                        if (series.getPane().paneIndex() !== seriesInstance.getPane().paneIndex()) {
                            seriesInstance.moveToPane(series.getPane().paneIndex());
                        }
                    }
                }
                if (seriesInstance) {
                    // 🎯 Decorate the series instance as an `ISeriesIndicator`
                    const indicatorInstance = decorateSeriesAsIndicator(seriesInstance, series, ind, newMap, count, overrides, recalculateIndicator);
                    // Store the decorated indicator series
                    newMap.set(f.key, indicatorInstance);
                    // If the indicator figure has a pane property, move the series to the appropriate pane.
                    if (f.pane) {
                        // Check if the current pane of the indicator is the same as the source series' pane.
                        if (indicatorInstance.getPane() === series.getPane()) {
                            const currentPane = indicatorInstance.getPane();
                            // Since paneIndex is a function, call it to get a number.
                            const paneIndex = currentPane.paneIndex();
                            // Move the indicator series to a new pane by adding the offset.
                            indicatorInstance.moveToPane(paneIndex + f.pane);
                        }
                    }
                }
            });
            // Store the new indicator in the map.
            this.indicatorSeriesMap.set(ind.name, newMap);
        }
        populateForkLineMainMenu(event, drawing) {
            // Clear the menu container.
            this.div.innerHTML = "";
            // Only applicable if the drawing is a PitchFork.
            if (drawing._type !== "PitchFork")
                return;
            const options = drawing._options;
            if (!options.forkLines) {
                options.forkLines = [];
            }
            const forkLines = options.forkLines;
            // For each fork line, add one menu item that will open its detailed options.
            forkLines.forEach((_, index) => {
                this.addMenuItem(`Fork Line ${index + 1}`, () => {
                    // When clicked, clear the menu and show the options for this fork line.
                    this.populateForkLineOptions(event, drawing, index);
                }, false, true);
            });
            // Add a menu item to add a new fork line.
            this.addMenuItem("Add Fork Line", () => {
                const newForkLine = {
                    value: 0.5, // Default offset value.
                    width: 1, // Default width.
                    style: lightweightCharts.LineStyle.Solid, // Default style (ensure this is valid per your LineStyle)
                    color: "#ffffff", // Default color.
                    fillColor: undefined, // No fill by default.
                };
                forkLines.push(newForkLine);
                if (this.saveDrawings) {
                    this.saveDrawings();
                }
                // Refresh the main fork line menu.
                this.populateForkLineMainMenu(event, drawing);
            }, false, true);
            // Add a back button to return to the drawing menu.
            this.addMenuItem("⤝ Back", () => {
                this.populateDrawingMenu(event, drawing);
            }, false, false);
            this.showMenu(event);
        }
        populateForkLineOptions(event, drawing, index) {
            // Clear the menu container.
            this.div.innerHTML = "";
            const options = drawing._options;
            if (!options.forkLines || !options.forkLines[index])
                return;
            const fork = options.forkLines[index];
            // Add a header for clarity.
            // Add a number input for "value".
            this.addNumberInput("Value", fork.value, (newValue) => {
                fork.value = newValue;
                if (this.saveDrawings) {
                    this.saveDrawings();
                }
            }, 0, // minimum value (adjust as needed)
            10, // maximum value (adjust as needed)
            0.1 // step (adjust as needed)
            );
            // Add a number input for "width".
            this.addNumberInput("Width", fork.width, (newValue) => {
                fork.width = newValue;
                if (this.saveDrawings) {
                    this.saveDrawings();
                }
            }, 1, // minimum width
            10, // maximum width (adjust as needed)
            1);
            // Define allowed styles for fork lines.
            const allowedStyles = [
                { name: "Solid", var: lightweightCharts.LineStyle.Solid },
                { name: "Dotted", var: lightweightCharts.LineStyle.Dotted },
                { name: "Dashed", var: lightweightCharts.LineStyle.Dashed },
                { name: "Large Dashed", var: lightweightCharts.LineStyle.LargeDashed },
                { name: "Sparse Dotted", var: lightweightCharts.LineStyle.SparseDotted },
            ];
            // In your populateForkLineOptions method, for the "Style" menu item:
            this.addSelectInput("Style", 
            // Show the current style name (by matching fork.style with the allowedStyles array)
            allowedStyles.find((styleObj) => styleObj.var === fork.style)?.name ||
                allowedStyles[0].name, 
            // Provide the names as the options for the select input.
            allowedStyles.map((styleObj) => styleObj.name), (newValue) => {
                // When a new style is selected, look it up in allowedStyles.
                const selected = allowedStyles.find((styleObj) => styleObj.name === newValue);
                if (selected) {
                    fork.style = selected.var;
                    if (this.saveDrawings) {
                        this.saveDrawings();
                    }
                }
            });
            // For the main color:
            this.addForkLineColorPickerMenuItem("Color", fork.color, fork, "color");
            // For the fill color (an empty string indicates no fill):
            this.addForkLineColorPickerMenuItem("Fill Color", fork.fillColor || "", fork, "fillColor");
            // Add a menu item to remove this fork line.
            this.addMenuItem("Remove Fork Line", () => {
                options.forkLines.splice(index, 1);
                if (this.saveDrawings) {
                    this.saveDrawings();
                }
                // Return to the main fork line menu.
                this.populateForkLineMainMenu(event, drawing);
            }, false, true);
            // Add a back button to return to the main fork line menu.
            this.addMenuItem("⤝ Back", () => {
                this.populateForkLineMainMenu(event, drawing);
            }, false, false);
            this.showMenu(event);
        }
        /**
         * Unified fork-line color picker menu item.
         *
         * @param label - Display label for the menu item.
         * @param currentColor - The current color value.
         * @param forkLine - The fork line object to update.
         * @param property - The property of the fork line to update ("color" or "fillColor").
         * @returns The created menu item HTMLElement.
         */
        addForkLineColorPickerMenuItem(label, currentColor, forkLine, property) {
            const menuItem = document.createElement("span");
            menuItem.classList.add("context-menu-item");
            menuItem.innerText = label;
            this.div.appendChild(menuItem);
            const applyColor = (newColor) => {
                forkLine[property] = newColor;
                console.log(`Updated fork line ${property} to ${newColor}`);
                if (this.saveDrawings) {
                    this.saveDrawings();
                }
            };
            menuItem.addEventListener("click", (event) => {
                event.stopPropagation();
                if (!this.colorPicker) {
                    this.colorPicker = new ColorPicker(currentColor ?? "#000000", applyColor);
                }
                this.colorPicker.openMenu(event, 225, applyColor);
            });
            return menuItem;
        }
    }

    /**
     * Default grid / crosshair line width in Bitmap sizing
     * @param horizontalPixelRatio - horizontal pixel ratio
     * @returns default grid / crosshair line width in Bitmap sizing
     */
    function gridAndCrosshairBitmapWidth(horizontalPixelRatio) {
        return Math.max(1, Math.floor(horizontalPixelRatio));
    }
    /**
     * Default grid / crosshair line width in Media sizing
     * @param horizontalPixelRatio - horizontal pixel ratio
     * @returns default grid / crosshair line width in Media sizing
     */
    function gridAndCrosshairMediaWidth(horizontalPixelRatio) {
        return (gridAndCrosshairBitmapWidth(horizontalPixelRatio) / horizontalPixelRatio);
    }

    // -------------------------------------
    // Imports
    // -------------------------------------
    // -------------------------------------
    // Constants
    // -------------------------------------
    /**
     * Default color for upward-moving candles.
     * Format: RGBA with 33.3% opacity.
     */
    /**
     * Default color for downward-moving candles.
     * Format: RGBA with 33.3% opacity.
     */
    /**
     * Default line style for candle borders.
     * 1 represents a solid line.
     */
    const DEFAULT_LINE_STYLE = 1;
    /**
     * Default line width for candle borders.
     * 1 pixel.
     */
    const DEFAULT_LINE_WIDTH = 1;
    // -------------------------------------
    // BarDataAggregator Class
    // -------------------------------------
    /**
     * Aggregates raw bar data into grouped bar items based on specified options.
     * Handles the styling and property consolidation for candle rendering.
     */
    class BarDataAggregator {
        /**
         * Configuration options for data aggregation and candle styling.
         */
        _options;
        /**
         * Constructs a new BarDataAggregator instance.
         * @param options - Aggregation and styling options. Can be null to use defaults.
         */
        constructor(options) {
            this._options = options;
        }
        /**
         * Aggregates an array of BarItem objects into grouped BarItem objects.
         * Handles the styling and property consolidation for candle rendering.
         *
         * @param data - The raw bar data to aggregate.
         * @param priceToCoordinate - Function to convert price values to canvas coordinates.
         * @returns An array of aggregated BarItem objects.
         */
        staticAggregate(data, priceToCoordinate) {
            // Determine the number of bars to group based on chandelierSize.
            const groupSize = this._options?.chandelierSize ?? 1;
            const aggregatedBars = [];
            // Iterate over the data in increments of groupSize to create buckets.
            for (let i = 0; i < data.length; i += groupSize) {
                const bucket = data.slice(i, i + groupSize);
                const isInProgress = bucket.length < groupSize && i + bucket.length === data.length;
                // Warn and skip if an empty bucket is encountered.
                if (bucket.length === 0) {
                    console.warn('Empty bucket encountered during aggregation.');
                    continue;
                }
                // Aggregate the current bucket into a single BarItem.
                const aggregatedBar = this._chandelier(bucket, i, i + bucket.length - 1, priceToCoordinate, isInProgress);
                aggregatedBars.push(aggregatedBar);
            }
            if (this._options?.enableVolumeOpacity) {
                // Ensure every aggregated bar has a volume property
                const hasVolumeData = aggregatedBars.every((bar) => bar.volume !== undefined && typeof bar.volume === 'number');
                if (!hasVolumeData) {
                    console.warn("Volume opacity enabled but not all aggregated bars have volume data. Skipping volume-based opacity adjustment.");
                }
                else {
                    // Check alpha of upColor and downColor
                    const upColor = this._options?.upColor || 'rgba(0,255,0,0.333)';
                    const downColor = this._options?.downColor || 'rgba(255,0,0,0.333)';
                    const upAlpha = getAlphaFromColor(upColor);
                    const downAlpha = getAlphaFromColor(downColor);
                    // Proceed only if both alpha values are non-zero
                    if (upAlpha !== 0 && downAlpha !== 0) {
                        // Use a base period from options or default to 20.
                        const basePeriod = this._options.volumeOpacityPeriod ?? 20;
                        // Multiply the base period by the chandelier size (groupSize).
                        const period = basePeriod * groupSize;
                        aggregatedBars.forEach((bar, i, arr) => {
                            if (bar.volume == null) {
                                return;
                            }
                            // Define the sliding window (the last `period` bars or fewer)
                            const windowStart = Math.max(0, i - period + 1);
                            const windowBars = arr.slice(windowStart, i + 1);
                            // Retrieve maxOpacity from options, defaulting to 0.3 if not set
                            const maxOpacity = this._options?.maxOpacity ?? 0.3;
                            let opacity = 1; // Default
                            // Determine opacity based on the selected volumeOpacityMode
                            if (this._options?.volumeOpacityMode === '/ max' || !this._options?.volumeOpacityMode) {
                                // "/ max" mode
                                const maxVolume = windowBars.reduce((max, current) => {
                                    return current.volume !== undefined && current.volume > max
                                        ? current.volume
                                        : max;
                                }, 0);
                                opacity = (maxVolume > 0 ? bar.volume / maxVolume : 1) * maxOpacity;
                            }
                            else if (this._options?.volumeOpacityMode === '> previous') {
                                // "> previous" mode
                                if (i === 0 || !arr[i - 1].volume || arr[i - 1].volume === 0) {
                                    opacity = maxOpacity;
                                }
                                else {
                                    const previousVolume = arr[i - 1].volume ?? 0;
                                    opacity = bar.volume > previousVolume ? maxOpacity : 0;
                                }
                            }
                            else if (this._options?.volumeOpacityMode === '> average') {
                                // "> average" mode
                                const totalVolume = windowBars.reduce((sum, current) => {
                                    return sum + (current.volume !== undefined ? current.volume : 0);
                                }, 0);
                                const averageVolume = windowBars.length > 0 ? totalVolume / windowBars.length : 0;
                                opacity = averageVolume > 0 && bar.volume > averageVolume ? maxOpacity : 0;
                            }
                            else {
                                // Unrecognized mode => default opacity to 0
                                opacity = 0;
                            }
                            // Set the bar's color using upColor or downColor, applying the computed opacity
                            if (bar.isUp) {
                                bar.color = setOpacity(upColor, opacity);
                            }
                            else {
                                bar.color = setOpacity(downColor, opacity);
                            }
                        });
                    }
                    else {
                        console.warn("Volume opacity enabled but upColor/downColor alpha is zero. Skipping volume-based opacity adjustment.");
                    }
                }
            }
            return aggregatedBars;
        }
        dynamicAggregate(data, priceToCoordinate) {
            if (data.length === 0 ||
                typeof this._options?.dynamicTrigger !== "function" ||
                !this._options?.dynamicCandles) {
                return [];
            }
            const aggregatedBars = [];
            let currentBucket = [];
            for (let i = 0; i < data.length; i++) {
                const bar = data[i];
                // Add current bar to the bucket
                currentBucket.push(bar);
                // **Check dynamic trigger** – if it signals a new bar, aggregate the bucket
                const dynamicTriggerActivated = this._options.dynamicTrigger().newBar || data[i].newBar;
                if (dynamicTriggerActivated) {
                    const startIndex = i - currentBucket.length + 1;
                    const endIndex = i;
                    // Aggregate the collected bucket
                    const aggregatedBar = this._chandelier(currentBucket, startIndex, endIndex, priceToCoordinate, false);
                    aggregatedBars.push(aggregatedBar);
                    console.log(`Aggregated candle from index ${startIndex} to ${endIndex} (Trigger: ${this._options.dynamicTrigger().newBar ?? data[i].newBar})`);
                    // Reset bucket for the next candle
                    currentBucket = [];
                }
            }
            return aggregatedBars;
        }
        /**
         * Aggregates a single bucket of BarItem objects into one consolidated BarItem.
         * @param bucket - The group of BarItem objects to aggregate.
         * @param startIndex - The starting index of the bucket in the original data array.
         * @param endIndex - The ending index of the bucket in the original data array.
         * @param priceToCoordinate - Function to convert price values to canvas coordinates.
         * @param isInProgress - Indicates if the aggregation is currently in progress.
         * @returns A single aggregated BarItem.
         * @throws Will throw an error if the bucket is empty.
         */
        _chandelier(bucket, startIndex, endIndex, priceToCoordinate, isInProgress = false) {
            if (bucket.length === 0) {
                throw new Error('Bucket cannot be empty in _chandelier method.');
            }
            // Extract open and close prices from the first and last bars in the bucket.
            const openPrice = bucket[0].originalData?.open ?? bucket[0].open ?? 0;
            const closePrice = bucket[bucket.length - 1].originalData?.close ??
                bucket[bucket.length - 1].close ??
                0;
            // Convert open and close prices to canvas coordinates.
            const open = priceToCoordinate(openPrice) ?? 0;
            const close = priceToCoordinate(closePrice) ?? 0;
            // Extract high and low prices from all bars in the bucket.
            const highPrices = bucket.map((bar) => bar.originalData?.high ?? bar.high);
            const lowPrices = bucket.map((bar) => bar.originalData?.low ?? bar.low);
            // Determine the highest and lowest prices in the bucket.
            const highPrice = highPrices.length > 0 ? Math.max(...highPrices) : 0;
            const lowPrice = lowPrices.length > 0 ? Math.min(...lowPrices) : 0;
            // Convert high and low prices to canvas coordinates.
            const high = priceToCoordinate(highPrice) ?? 0;
            const low = priceToCoordinate(lowPrice) ?? 0;
            // Position of the aggregated bar on the x-axis.
            const x = bucket[0].x;
            // Determine if the aggregated bar represents an upward movement.
            const isUp = closePrice > openPrice;
            // Explicitly map colors based on `isUp` status.
            const color = isUp
                ? (this._options?.upColor || 'rgba(0,255,0,0.333)')
                : (this._options?.downColor || 'rgba(255,0,0,0.333)');
            const borderColor = isUp
                ? (this._options?.borderUpColor || setOpacity(color, 1))
                : (this._options?.borderDownColor || setOpacity(color, 1));
            const wickColor = isUp
                ? (this._options?.wickUpColor || borderColor)
                : (this._options?.wickDownColor || borderColor);
            // Aggregate lineStyle similarly to other properties.
            const lineStyle = bucket.reduce((style, bar) => bar.lineStyle ?? bar.originalData?.lineStyle ?? style, this._options?.lineStyle ?? DEFAULT_LINE_STYLE);
            // Aggregate lineWidth similarly to other properties.
            const lineWidth = bucket.reduce((currentWidth, bar) => bar.lineWidth ?? bar.originalData?.lineWidth ?? currentWidth, this._options?.lineWidth ?? DEFAULT_LINE_WIDTH);
            // Aggregate shape similarly to other properties.
            const shape = bucket.reduce((currentShape, bar) => {
                const parsedShape = bar.shape
                    ? parseCandleShape(bar.shape)
                    : bar.originalData?.shape
                        ? parseCandleShape(bar.originalData.shape)
                        : undefined;
                // If parsing fails, retain the current shape.
                return parsedShape ?? currentShape;
            }, this._options?.shape ?? CandleShape.Rectangle);
            const volume = bucket.reduce((sum, bar) => sum + (bar.originalData?.volume ?? bar.volume ?? 0), 0);
            // Ensure that `shape` is never undefined. If it is, default to Rectangle.
            const finalShape = shape || CandleShape.Rectangle;
            // Return the aggregated BarItem with all consolidated properties.
            return {
                open,
                high,
                low,
                close,
                volume,
                x,
                isUp,
                startIndex,
                endIndex,
                isInProgress,
                color,
                borderColor,
                wickColor,
                shape: finalShape,
                lineStyle,
                lineWidth,
            };
        }
    }
    // -------------------------------------
    // ohlcSeriesRenderer Class
    // -------------------------------------
    /**
     * Custom renderer for candle series, implementing various candle shapes and styles.
     * Utilizes BarDataAggregator for data aggregation and rendering logic for different candle shapes.
     * @template TData - The type of custom candle series data.
     */
    class ohlcSeriesRenderer {
        /**
         * The current data to be rendered.
         */
        _data = null;
        /**
         * The current rendering options.
         */
        _options = null;
        /**
         * The data aggregator instance.
         */
        _aggregator = null;
        /**
         * Draws the candle series onto the provided canvas target.
         * @param target - The canvas rendering target.
         * @param priceConverter - Function to convert price values to canvas coordinates.
         */
        draw(target, priceConverter) {
            target.useBitmapCoordinateSpace((scope) => this._drawImpl(scope, priceConverter));
        }
        /**
         * Updates the renderer with new data and options.
         * @param data - The custom series data to render.
         * @param options - The custom series options for styling and behavior.
         */
        update(data, options) {
            this._data = data;
            this._options = options;
            this._aggregator = new BarDataAggregator(options);
        }
        /**
         * Internal implementation of the drawing logic.
         * Processes data, aggregates bars, and delegates drawing to specific methods.
         * @param renderingScope - The rendering scope containing canvas context and scaling information.
         * @param priceToCoordinate - Function to convert price values to canvas coordinates.
         */
        _drawImpl(renderingScope, priceToCoordinate) {
            // Exit early if there's no data or options to render.
            if (!this._data ||
                this._data.bars.length === 0 ||
                !this._data.visibleRange ||
                !this._options) {
                return;
            }
            // Transform raw data into BarItem objects with initial styling.
            const bars = this._data.bars.map((bar, index) => ({
                open: bar.originalData?.open ?? 0,
                high: bar.originalData?.high ?? 0,
                low: bar.originalData?.low ?? 0,
                close: bar.originalData?.close ?? 0,
                volume: bar.originalData?.volume ?? 0,
                x: bar.x,
                shape: (bar.originalData?.shape ??
                    this._options?.shape ??
                    'Rectangle'),
                lineStyle: bar.originalData?.lineStyle ??
                    this._options?.lineStyle ??
                    1,
                lineWidth: bar.originalData?.lineWidth ??
                    this._options?.lineWidth ??
                    1,
                isUp: (bar.originalData?.close ?? 0) >=
                    (bar.originalData?.open ?? 0),
                color: this._options?.color ?? 'rgba(0,0,0,0)',
                borderColor: this._options?.borderColor ?? 'rgba(0,0,0,0)',
                wickColor: this._options?.wickColor ?? 'rgba(0,0,0,0)',
                startIndex: index,
                endIndex: index,
            }));
            let aggregatedBars;
            // If volume candles are enabled and both volumeMALength and volumeMultiplier are defined, use aggregateByVolume.
            if (this._options.dynamicCandles &&
                typeof this._options.volumeMALength === "number" &&
                typeof this._options.volumeMultiplier === "number") {
                aggregatedBars =
                    this._aggregator?.dynamicAggregate(bars, priceToCoordinate) ?? [];
            }
            else {
                // Otherwise, use the standard aggregation method.
                aggregatedBars = this._aggregator?.staticAggregate(bars, priceToCoordinate) ?? [];
            }
            // Determine the radius for rounded shapes and candle width based on scaling.
            const radius = this._options.radius;
            const { horizontalPixelRatio, verticalPixelRatio } = renderingScope;
            const candleWidth = this._data.barSpacing * horizontalPixelRatio;
            // Delegate drawing of candle bodies and wicks.
            this._drawCandles(renderingScope, aggregatedBars, this._data.visibleRange, radius, candleWidth, horizontalPixelRatio, verticalPixelRatio);
            this._drawWicks(renderingScope, aggregatedBars, this._data.visibleRange);
        }
        /**
         * Draws the wicks (high-low lines) for each aggregated candle.
         * Skips rendering if the candle shape is '3d'.
         * @param renderingScope - The rendering scope containing canvas context and scaling information.
         * @param bars - Array of aggregated BarItem objects to draw wicks for.
         * @param visibleRange - The range of visible bars to render.
         */
        _drawWicks(renderingScope, bars, visibleRange) {
            // Exit early if there's no data or options.
            if (this._data === null || this._options === null) {
                return;
            }
            // Skip wick drawing if the candle shape is '3d'.
            if (this._options.shape === '3d') {
                return;
            }
            const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;
            const candleWidth = this._data.barSpacing * horizontalPixelRatio;
            const wickWidth = gridAndCrosshairMediaWidth(horizontalPixelRatio);
            // Iterate over each aggregated bar to draw its wicks.
            for (const bar of bars) {
                // Skip bars outside the visible range.
                if (bar.startIndex < visibleRange.from ||
                    bar.endIndex > visibleRange.to) {
                    continue;
                }
                // Calculate pixel positions for high, low, open, and close.
                const low = bar.low * verticalPixelRatio;
                const high = bar.high * verticalPixelRatio;
                const openCloseTop = Math.min(bar.open, bar.close) * verticalPixelRatio;
                const openCloseBottom = Math.max(bar.open, bar.close) * verticalPixelRatio;
                // Determine the X position for the wick.
                let wickX = bar.x * horizontalPixelRatio;
                const groupSize = bar.endIndex - bar.startIndex;
                if (groupSize && groupSize > 1) {
                    wickX += candleWidth * Math.max(1, groupSize) / 2;
                }
                // Adjust wick heights for 'Polygon' shape candles.
                let upperWickTop = high;
                let upperWickBottom = openCloseTop;
                let lowerWickTop = openCloseBottom;
                let lowerWickBottom = low;
                if (this._options.shape === 'Polygon') {
                    // For 'Polygon' candles, set halfway points.
                    upperWickBottom = (high + openCloseTop) / 2;
                    lowerWickTop = (low + openCloseBottom) / 2;
                }
                // Set fill and stroke styles for the wick.
                ctx.fillStyle = bar.color;
                ctx.strokeStyle = bar.wickColor ?? bar.color;
                /**
                 * Draws a rounded rectangle or a standard rectangle as a wick.
                 * @param x - The X-coordinate of the top-left corner.
                 * @param y - The Y-coordinate of the top-left corner.
                 * @param width - The width of the rectangle.
                 * @param height - The height of the rectangle.
                 * @param radius - The corner radius for rounded rectangles.
                 */
                const drawRoundedRect = (x, y, width, height, radius) => {
                    if (ctx.roundRect) {
                        ctx.roundRect(x, y, width, height, radius);
                    }
                    else {
                        ctx.rect(x, y, width, height);
                    }
                };
                // Draw the upper wick.
                const upperWickHeight = upperWickBottom - upperWickTop;
                if (upperWickHeight > 0) {
                    ctx.beginPath();
                    drawRoundedRect(wickX - Math.floor(wickWidth / 2), upperWickTop, wickWidth, upperWickHeight, wickWidth / 2 // Radius for rounded corners.
                    );
                    ctx.fill();
                    ctx.stroke();
                }
                // Draw the lower wick.
                const lowerWickHeight = lowerWickBottom - lowerWickTop;
                if (lowerWickHeight > 0) {
                    ctx.beginPath();
                    drawRoundedRect(wickX - Math.floor(wickWidth / 2), lowerWickTop, wickWidth, lowerWickHeight, wickWidth / 2 // Radius for rounded corners.
                    );
                    ctx.fill();
                    ctx.stroke();
                }
            }
        }
        /**
         * Draws the candle bodies based on their specified shapes.
         * Supports multiple shapes like Rectangle, Rounded, Ellipse, Arrow, 3D, and Polygon.
         * @param renderingScope - The rendering scope containing canvas context and scaling information.
         * @param bars - Array of aggregated BarItem objects to draw candles for.
         * @param visibleRange - The range of visible bars to render.
         * @param radius - The radius for rounded candle shapes.
         * @param candleWidth - The width of the candle in pixels.
         * @param horizontalPixelRatio - Scaling factor for horizontal dimensions.
         * @param verticalPixelRatio - Scaling factor for vertical dimensions.
         */
        _drawCandles(renderingScope, bars, visibleRange, radius, candleWidth, horizontalPixelRatio, verticalPixelRatio) {
            const { context: ctx } = renderingScope;
            const barSpace = this._options?.barSpacing ?? 0.8;
            // Save the current canvas state before drawing.
            ctx.save();
            // Iterate over each aggregated bar to draw its body.
            for (const bar of bars) {
                const groupSize = bar.endIndex - bar.startIndex;
                // Calculate the horizontal span of the candle based on grouping.
                const barHorizontalSpan = this._options?.chandelierSize !== 1
                    ? candleWidth * Math.max(1, groupSize + 1) -
                        (1 - barSpace) * candleWidth
                    : candleWidth * barSpace;
                // Determine the X position for the candle.
                const barHorizontalPos = bar.x * horizontalPixelRatio;
                // Calculate the actual width of the candle body.
                const candleBodyWidth = candleWidth * barSpace;
                // Skip rendering if the bar is outside the visible range.
                if (bar.startIndex < visibleRange.from ||
                    bar.endIndex > visibleRange.to) {
                    continue;
                }
                // Calculate vertical positions for the candle body.
                const barVerticalMax = Math.min(bar.open, bar.close) * verticalPixelRatio;
                const barVerticalMin = Math.max(bar.open, bar.close) * verticalPixelRatio;
                const barVerticalSpan = barVerticalMax - barVerticalMin;
                const barY = (barVerticalMax + barVerticalMin) / 2;
                // Precompute common X coordinates for drawing.
                const leftSide = barHorizontalPos - candleBodyWidth / 2;
                const rightSide = leftSide + barHorizontalSpan;
                const middle = leftSide + barHorizontalSpan / 2;
                // Set fill and stroke styles from bar properties.
                ctx.fillStyle =
                    bar.color ?? this._options?.color ?? 'rgba(255,255,255,1)';
                ctx.strokeStyle =
                    bar.borderColor ??
                        this._options?.borderColor ??
                        bar.color ??
                        'rgba(255,255,255,1)';
                setLineStyle(ctx, bar.lineStyle);
                ctx.lineWidth = bar.lineWidth ?? DEFAULT_LINE_WIDTH;
                // Draw the candle based on its specified shape.
                switch (bar.shape) {
                    case 'Rectangle':
                        ohlcRectangle(ctx, leftSide, rightSide, barY, barVerticalSpan);
                        break;
                    case 'Rounded':
                        ohlcRounded(ctx, leftSide, rightSide, barY, barVerticalSpan, radius);
                        break;
                    case 'Ellipse':
                        ohlcEllipse(ctx, leftSide, rightSide, middle, barY, barVerticalSpan);
                        break;
                    case 'Arrow':
                        ohlcArrow(ctx, leftSide, rightSide, middle, barY, barVerticalSpan, bar.high * verticalPixelRatio, bar.low * verticalPixelRatio, bar.isUp);
                        break;
                    case '3d':
                        ohlc3d(ctx, barHorizontalPos, bar.high * verticalPixelRatio, bar.low * verticalPixelRatio, bar.open * verticalPixelRatio, bar.close * verticalPixelRatio, candleBodyWidth, barHorizontalSpan, bar.color ?? this._options?.color ?? 'rgba(255,255,255,1)', bar.borderColor ?? this._options?.borderColor ?? 'rgba(255,255,255,1)', bar.isUp, barSpace);
                        break;
                    case 'Polygon':
                        ohlcPolygon(ctx, leftSide, rightSide, barY, barVerticalSpan, bar.high * verticalPixelRatio, bar.low * verticalPixelRatio, bar.isUp);
                        break;
                    case "Bar":
                        ohlcBar(ctx, leftSide, rightSide, bar.high * verticalPixelRatio, bar.low * verticalPixelRatio, bar.open * verticalPixelRatio, bar.close * verticalPixelRatio);
                        break;
                    case "Slanted":
                        ohlcSlanted(ctx, leftSide, rightSide, barY, // yCenter
                        barVerticalSpan, // candleHeight
                        bar.isUp);
                        break;
                    default:
                        // Fallback to rectangle shape if unknown shape is specified.
                        ohlcRectangle(ctx, leftSide, rightSide, barY, barVerticalSpan);
                        break;
                }
            }
            // Restore the canvas state after drawing.
            ctx.restore();
        }
    }

    //upperUpColor: string|undefined
    //upperDownColor: string|undefined
    //lowerUpColor: string|undefined
    //lowerDownColor: string|undefined
    const ohlcdefaultOptions = {
        ...lightweightCharts.customSeriesDefaultOptions,
        upColor: '#008000',
        downColor: '#8C0000',
        wickVisible: true,
        borderVisible: true,
        borderColor: '#737375',
        borderUpColor: '#008000',
        borderDownColor: '#8C0000',
        wickColor: '#737375',
        wickUpColor: '#008000',
        wickDownColor: '#8C0000',
        radius: .6,
        shape: 'Rounded', // Default shape
        chandelierSize: 1,
        barSpacing: 0.8,
        lineStyle: 0,
        lineWidth: 2,
        enableVolumeOpacity: true,
        volumeOpacityMode: '> previous',
        volumeOpacityPeriod: 21,
        maxOpacity: 0.3,
        dynamicCandles: false,
        dynamicTrigger: () => ({ newBar: true }) // Corrected function implementation
    };
    //upperUpColor: undefined,
    //upperDownColor: undefined,
    //lowerUpColor: undefined,
    //lowerDownColor: undefined,
    class ohlcSeries {
        _renderer;
        constructor() {
            this._renderer = new ohlcSeriesRenderer();
        }
        priceValueBuilder(plotRow) {
            return [plotRow.high, plotRow.low, plotRow.close];
        }
        renderer() {
            return this._renderer;
        }
        isWhitespace(data) {
            return data.close === undefined;
        }
        update(data, options) {
            this._renderer.update(data, options);
        }
        defaultOptions() {
            return ohlcdefaultOptions;
        }
    }
    // ./types.ts

    /**
     * A simple DefaultOptionsManager to store default options in memory.
     *
     * This class provides a single method, `set`, to update the default options for a given key.
     * The defaults are stored in an in-memory Map.
     *
     * Usage:
     *   const manager = new DefaultOptionsManager();
     *   manager.set("area", { title: "Area", lineColor: "#021698", topColor: "rgba(9,32,210,0.4)", bottomColor: "rgba(0,0,0,0.5)" });
     *   const areaDefaults = manager.get("area");
     */
    class DefaultOptionsManager {
        // In-memory storage for default options.
        defaults;
        constructor() {
            this.defaults = new Map();
        }
        /**
          * Sets the default options for the given key.
          * If the provided data is a JSON string, it will be parsed into an object.
          *
          * @param key - A string identifying the default options (e.g., "area", "line").
          * @param data - The default options to store, either as an object or a JSON string.
          */
        set(key, data) {
            let parsedData;
            if (typeof data === 'string') {
                try {
                    parsedData = JSON.parse(data);
                }
                catch (error) {
                    console.error(`Error parsing JSON string for key "${key}":`, error);
                    // Optionally, you can throw an error here or fallback to the raw string.
                    parsedData = data; // fallback: store the string if parsing fails.
                }
            }
            else {
                parsedData = data;
            }
            this.defaults.set(key, parsedData);
            console.log(`Default options for key "${key}" set successfully.`);
            console.log(parsedData);
        }
        /**
         * Retrieves the default options for the given key.
         *
         * @param key - The key identifying the default options.
         * @returns The default options, or undefined if not found.
         */
        get(key) {
            return this.defaults.get(key);
        }
        /**
         * Returns all stored defaults.
         *
         * @returns A Map containing all default options.
         */
        getAll() {
            return this.defaults;
        }
    }

    globalParamInit();
    class Handler {
        id;
        commandFunctions = [];
        static handlers = new Map();
        seriesOriginMap = new WeakMap();
        wrapper;
        div;
        chart;
        scale;
        precision = 2;
        series;
        volumeSeries;
        legend;
        _topBar;
        toolBox;
        spinner;
        _seriesList = [];
        seriesMap = new Map();
        seriesMetadata;
        // Series context menu
        ContextMenu;
        currentMouseEventParams = null;
        defaultsManager;
        // TODO find a better solution rather than the 'position' parameter
        constructor(chartId, innerWidth, innerHeight, position, autoSize) {
            this.reSize = this.reSize.bind(this);
            this.id = chartId;
            this.scale = {
                width: innerWidth,
                height: innerHeight,
            };
            this.defaultsManager = new DefaultOptionsManager();
            Handler.handlers.set(chartId, this);
            this.wrapper = document.createElement('div');
            this.wrapper.classList.add("handler");
            this.wrapper.style.float = position;
            this.div = document.createElement('div');
            this.div.style.position = 'relative';
            this.wrapper.appendChild(this.div);
            window.containerDiv.append(this.wrapper);
            this.chart = this._createChart();
            this.ContextMenu = new ContextMenu(this, Handler.handlers, // handlers: Map<string, Handler>
            () => window.MouseEventParams ?? null // returns null if undefined
            );
            this.legend = new Legend(this);
            // Create series using merged options.
            this.series = this.createCandlestickSeries();
            this.volumeSeries = this.createVolumeSeries();
            // Setup MouseEventParams tracking
            this.chart.subscribeCrosshairMove((param) => {
                this.currentMouseEventParams = param;
                window.MouseEventParams = param;
            });
            document.addEventListener("keydown", (event) => {
                for (let i = 0; i < this.commandFunctions.length; i++) {
                    if (this.commandFunctions[i](event))
                        break;
                }
            });
            window.handlerInFocus = this.id;
            this.wrapper.addEventListener("mouseover", () => {
                window.handlerInFocus = this.id;
                window.MouseEventParams = this.currentMouseEventParams || null;
            });
            this.seriesMetadata = new WeakMap();
            this.reSize();
            if (!autoSize)
                return;
            window.addEventListener("resize", () => this.reSize());
            // Additional MouseEventParams tracking
            this.chart.subscribeCrosshairMove((param) => {
                this.currentMouseEventParams = param;
            });
        }
        reSize() {
            let topBarOffset = this.scale.height !== 0 ? this._topBar?._div.offsetHeight || 0 : 0;
            this.chart.resize(window.innerWidth * this.scale.width, window.innerHeight * this.scale.height - topBarOffset);
            this.wrapper.style.width = `${100 * this.scale.width}%`;
            this.wrapper.style.height = `${100 * this.scale.height}%`;
            // TODO definitely a better way to do this
            if (this.scale.height === 0 || this.scale.width === 0) {
                // if (this.legend.div.style.display == 'flex') this.legend.div.style.display = 'none'
                if (this.toolBox) {
                    this.toolBox.div.style.display = 'none';
                }
            }
            else {
                // this.legend.div.style.display = 'flex'
                if (this.toolBox) {
                    this.toolBox.div.style.display = 'flex';
                }
            }
        }
        primitives = new Map(); // Map of plugin primitive instances by series name
        _createChart() {
            return lightweightCharts.createChart(this.div, {
                width: window.innerWidth * this.scale.width,
                height: window.innerHeight * this.scale.height,
                layout: {
                    textColor: window.pane.color,
                    background: {
                        color: '#000000',
                        type: lightweightCharts.ColorType.Solid,
                    },
                    fontSize: 12
                },
                rightPriceScale: {
                    scaleMargins: { top: 0.3, bottom: 0.25 },
                },
                timeScale: { timeVisible: true, secondsVisible: false },
                crosshair: {
                    mode: lightweightCharts.CrosshairMode.Normal,
                    vertLine: { labelBackgroundColor: 'rgb(46, 46, 46)' },
                    horzLine: { labelBackgroundColor: 'rgb(55, 55, 55)' }
                },
                grid: {
                    vertLines: { color: 'rgba(29, 30, 38, 5)' },
                    horzLines: { color: 'rgba(29, 30, 58, 5)' },
                },
                handleScroll: { vertTouchDrag: true },
            });
        }
        /**
         * Helper method to merge series options.
         * Merge order: { ...getDefaultSeriesOptions(type), ...fileDefaults, ...explicitOptions }
         *
         * @param type - The series type (SupportedSeriesType)
         * @param explicitOptions - Options provided explicitly
         */
        mergeSeriesOptions(type, explicitOptions) {
            // Get built–in defaults (base options)
            const baseOptions = getDefaultSeriesOptions(type);
            // File defaults: lookup by lowercased type (e.g. "line", "area", etc.)
            const fileDefaults = this.defaultsManager.defaults.get(type.toLowerCase()) || {};
            return { ...baseOptions, ...fileDefaults, ...explicitOptions };
        }
        /**
         * Creates a candlestick series using merged options.
         * (No explicit options provided; only built–in and file defaults are merged.)
         */
        createCandlestickSeries() {
            const type = "Candlestick";
            // Merge built–in defaults and file defaults
            const baseOptions = getDefaultSeriesOptions(type);
            const fileDefaults = this.defaultsManager.defaults.get(type.toLowerCase()) || {};
            const mergedOptions = { ...baseOptions, ...fileDefaults };
            const candleSeries = this.chart.addSeries(lightweightCharts.CandlestickSeries, mergedOptions);
            candleSeries.priceScale().applyOptions({ scaleMargins: { top: 0.2, bottom: 0.2 } });
            const decorated = decorateSeries(candleSeries, this.legend);
            decorated.applyOptions({ title: "OHLC" });
            this._seriesList.push(decorated);
            this.seriesMap.set("OHLC", decorated);
            [mergedOptions.upColor, mergedOptions.downColor];
            const legendItem = {
                name: "OHLC",
                series: decorated,
                colors: [mergedOptions.upColor, mergedOptions.downColor],
                legendSymbol: ['⋰', '⋱'],
                seriesType: "Candlestick",
                group: undefined,
            };
            this.legend.addLegendItem(legendItem);
            return decorated;
        }
        createVolumeSeries() {
            const volumeSeries = this.chart.addSeries(lightweightCharts.HistogramSeries, {
                color: "#26a69a",
                priceFormat: { type: "volume" },
                priceScaleId: "volume_scale",
            });
            volumeSeries.priceScale().applyOptions({
                scaleMargins: { top: 0, bottom: 0.2 },
            });
            //volumeSeries.moveToPane(1)
            const decorated = decorateSeries(volumeSeries, this.legend);
            decorated.applyOptions({ title: "Volume" });
            return decorated;
        }
        /**
         * Creates a line series using merged options.
         */
        createLineSeries(name, options) {
            const mergedOptions = this.mergeSeriesOptions("Line", options ?? {});
            const symbol = (() => {
                switch (mergedOptions.lineStyle) {
                    case 0: return '―';
                    case 1: return ':··';
                    case 2: return '--';
                    case 3: return '- -';
                    case 4: return '· ·';
                    default: return '~';
                }
            })();
            const { group, legendSymbol = symbol, ...lineOptions } = mergedOptions;
            const line = this.chart.addSeries(lightweightCharts.LineSeries, lineOptions);
            const decorated = decorateSeries(line, this.legend);
            decorated.applyOptions({ title: name });
            this._seriesList.push(decorated);
            this.seriesMap.set(name, decorated);
            const color = decorated.options().color || "rgba(255,0,0,1)";
            const solidColor = color.startsWith("rgba") ? color.replace(/[^,]+(?=\))/, "1") : color;
            const legendItem = {
                name,
                series: decorated,
                colors: [solidColor],
                legendSymbol: Array.isArray(legendSymbol) ? legendSymbol : legendSymbol ? [legendSymbol] : [],
                seriesType: "Line",
                group,
            };
            this.legend.addLegendItem(legendItem);
            return { name, series: decorated };
        }
        /**
         * Creates a histogram series using merged options.
         */
        createHistogramSeries(name, options) {
            const mergedOptions = this.mergeSeriesOptions("Histogram", options ?? {});
            const { group, legendSymbol = "▨", ...histogramOptions } = mergedOptions;
            const histogram = this.chart.addSeries(lightweightCharts.HistogramSeries, histogramOptions);
            const decorated = decorateSeries(histogram, this.legend);
            decorated.applyOptions({ title: name });
            this._seriesList.push(decorated);
            this.seriesMap.set(name, decorated);
            const color = decorated.options().color || "rgba(255,0,0,1)";
            const solidColor = color.startsWith("rgba") ? color.replace(/[^,]+(?=\))/, "1") : color;
            const legendItem = {
                name,
                series: decorated,
                colors: [solidColor],
                legendSymbol: Array.isArray(legendSymbol) ? legendSymbol : [legendSymbol],
                seriesType: "Histogram",
                group,
            };
            this.legend.addLegendItem(legendItem);
            return { name, series: decorated };
        }
        /**
         * Creates an area series using merged options.
         */
        createAreaSeries(name, options) {
            const mergedOptions = this.mergeSeriesOptions("Area", options ?? {});
            const { group, legendSymbol = "▨", ...areaOptions } = mergedOptions;
            const area = this.chart.addSeries(lightweightCharts.AreaSeries, areaOptions);
            const decorated = decorateSeries(area, this.legend);
            this._seriesList.push(decorated);
            this.seriesMap.set(name, decorated);
            const color = decorated.options().lineColor || "rgba(255,0,0,1)";
            const solidColor = color.startsWith("rgba") ? color.replace(/[^,]+(?=\))/, "1") : color;
            const legendItem = {
                name,
                series: decorated,
                colors: [solidColor],
                legendSymbol: Array.isArray(legendSymbol) ? legendSymbol : legendSymbol ? [legendSymbol] : [],
                seriesType: "Area",
                group,
            };
            this.legend.addLegendItem(legendItem);
            return { name, series: decorated };
        }
        /**
         * Creates a bar series using merged options.
         */
        createBarSeries(name, options) {
            const mergedOptions = this.mergeSeriesOptions("Bar", options ?? {});
            const { group, legendSymbol = ['┌', '└'], ...barOptions } = mergedOptions;
            const bar = this.chart.addSeries(lightweightCharts.BarSeries, barOptions);
            const decorated = decorateSeries(bar, this.legend);
            decorated.applyOptions({ title: name });
            this._seriesList.push(decorated);
            this.seriesMap.set(name, decorated);
            const upColor = decorated.options().upColor || "rgba(0,255,0,1)";
            const downColor = decorated.options().downColor || "rgba(255,0,0,1)";
            const legendItem = {
                name,
                series: decorated,
                colors: [upColor, downColor],
                legendSymbol: Array.isArray(legendSymbol) ? legendSymbol : legendSymbol ? [legendSymbol] : [],
                seriesType: "Bar",
                group,
            };
            this.legend.addLegendItem(legendItem);
            return { name, series: decorated };
        }
        /**
         * Creates a custom OHLC series using merged options.
         */
        createCustomOHLCSeries(name, options) {
            // Merge built–in defaults, file defaults, and explicit options for "Ohlc"
            const base = ohlcdefaultOptions;
            const fileDefaults = this.defaultsManager.defaults.get("ohlc") || {};
            const mergedOptions = {
                ...base,
                ...fileDefaults,
                ...options,
                seriesType: 'Ohlc',
            };
            const { group, legendSymbol = ['⑃', '⑂'], seriesType: _, chandelierSize, ...filteredOptions } = mergedOptions;
            const Instance = new ohlcSeries();
            const ohlcCustomSeries = this.chart.addCustomSeries(Instance, {
                ...filteredOptions,
                chandelierSize,
                title: name
            });
            const decorated = decorateSeries(ohlcCustomSeries, this.legend);
            this._seriesList.push(decorated);
            this.seriesMap.set(name, decorated);
            const borderUpColor = mergedOptions.borderUpColor || mergedOptions.upColor;
            const borderDownColor = mergedOptions.borderDownColor || mergedOptions.downColor;
            const colorsArray = [borderUpColor, borderDownColor];
            const legendItem = {
                name,
                series: decorated,
                colors: colorsArray,
                legendSymbol: Array.isArray(legendSymbol) ? legendSymbol : legendSymbol ? [legendSymbol] : [],
                seriesType: 'Ohlc',
                group,
            };
            this.legend.addLegendItem(legendItem);
            return { name, series: ohlcCustomSeries };
        }
        // /**
        //  * Creates a trade series using merged options.
        //  */
        // createTradeSeries(name: string, options?: Partial<TradeSeriesOptions> = {}): { name: string; series: ISeriesApi<SeriesType> } {
        //     const mergedoptions?: TradeSeriesOptions & { seriesType?: string; group?: string; legendSymbol?: string[] | string; } = {
        //         ...tradeDefaultOptions,
        //         ...this.defaultsManager.defaults.get("trade"),
        //         ...options,
        //         seriesType: 'Trade',
        //     };
        //
        //     const { group, legendSymbol = ['$'], seriesType: _, ...filteredOptions } = mergedOptions;
        //
        //     const instance = new TradeSeries();
        //     const tradeCustomSeries = this.chart.addCustomSeries(instance, filteredOptions);
        //
        //     const decorated = decorateSeries(tradeCustomSeries, this.legend);
        //     this._seriesList.push(decorated);
        //     this.seriesMap.set(name ?? 'Trade', decorated);
        //
        //     const colorsArray = [
        //         mergedOptions.backgroundColorStop,
        //         mergedOptions.backgroundColorTarget
        //     ];
        //     const finalLegendSymbol = Array.isArray(legendSymbol) ? legendSymbol : [legendSymbol];
        //
        //     const legendItem: LegendItem = {
        //         name,
        //         series: decorated,
        //         colors: colorsArray,
        //         legendSymbol: finalLegendSymbol,
        //         seriesType: 'Trade',
        //         group,
        //     };
        //
        //     this.legend.addLegendItem(legendItem);
        //
        //     return { name, series: tradeCustomSeries };
        // }
        /**
         * Creates a fill area between two series.
         */
        createFillArea(name, origin, destination, originColor, destinationColor) {
            const originSeries = this._seriesList.find(s => s.options()?.title === origin);
            const destinationSeries = this._seriesList.find(s => s.options()?.title === destination);
            if (!originSeries) {
                console.warn(`Origin series with title "${origin}" not found.`);
                return undefined;
            }
            if (!destinationSeries) {
                console.warn(`Destination series with title "${destination}" not found.`);
                return undefined;
            }
            const extendedOriginSeries = ensureExtendedSeries(originSeries, this.legend);
            const fillArea = new FillArea(originSeries, destinationSeries, {
                originColor: originColor || null,
                destinationColor: destinationColor || null,
                lineWidth: null,
            });
            extendedOriginSeries.attachPrimitive(fillArea, name);
            return fillArea;
        }
        attachPrimitive(lineColor, primitiveType, series, seriesName) {
            let _series = series;
            try {
                if (seriesName && !series) {
                    _series = this.seriesMap.get(seriesName);
                }
                if (!_series) {
                    console.warn(`Series with the name "${seriesName}" not found.`);
                    return;
                }
                const extendedSeries = ensureExtendedSeries(_series, this.legend);
                let primitiveInstance;
                switch (primitiveType) {
                    case "Tooltip":
                        primitiveInstance = new TooltipPrimitive({ lineColor });
                        break;
                    default:
                        console.warn(`Unknown primitive type: ${primitiveType}`);
                        return;
                }
                extendedSeries.attachPrimitive(primitiveInstance, "Tooltip");
                this.primitives.set(_series, primitiveInstance);
            }
            catch (error) {
                console.error(`Failed to attach ${primitiveType}:`, error);
            }
        }
        removeSeries(series) {
            let seriesName;
            if (isISeriesApi(series)) {
                for (const [key, value] of this.seriesMap.entries()) {
                    if (value === series) {
                        seriesName = key;
                        break;
                    }
                }
            }
            else {
                seriesName = series;
                series = this.seriesMap.get(series);
            }
            if (!series || !seriesName) {
                console.warn(`❌ Series "${series}" does not exist and cannot be removed.`);
                return;
            }
            series = series;
            if (series.primitives && series.primitives.length > 0) {
                series.primitives.forEach((primitive) => {
                    series.detachPrimitive(primitive);
                    console.log(`✅ Detached primitive from series "${seriesName}".`);
                });
            }
            this._seriesList = this._seriesList.filter(s => s !== series);
            this.seriesMap.delete(seriesName);
            console.log(`✅ Series "${seriesName}" removed from internal maps.`);
            try {
                const legendItem = this.legend._items.find((item) => item.series === series);
                if (legendItem) {
                    if (legendItem.primitives && legendItem.primitives.length > 0) {
                        legendItem.primitives.forEach((primitive) => {
                            this.legend.removeLegendPrimitive(primitive);
                            console.log(`✅ Removed primitive from legend for series "${seriesName}".`);
                        });
                    }
                    this.legend.deleteLegendEntry(legendItem.name, legendItem.group ?? undefined);
                    console.log(`✅ Removed series "${seriesName}" from legend.`);
                }
                else {
                    console.warn(`⚠️ Legend item for series "${seriesName}" not found.`);
                }
            }
            catch (error) {
                console.error(`⚠️ Error removing legend entry for "${seriesName}":`, error);
            }
            this.chart.removeSeries(series);
            console.log(`✅ Series "${seriesName}" successfully removed.`);
        }
        createToolBox() {
            this.toolBox = new ToolBox(this, this.id, this.chart, this.series, this.commandFunctions);
            this.div.appendChild(this.toolBox.div);
        }
        createTopBar() {
            this._topBar = new TopBar(this);
            this.wrapper.prepend(this._topBar._div);
            return this._topBar;
        }
        //toJSON() {
        //    // Exclude the chart attribute from serialization
        //    const { chart, ...serialized } = this;
        //    return serialized;
        //}
        /**
         * Extracts data from a series in a format suitable for indicators.
         * @param series - The series to extract data from.
         * @returns An array of arrays containing `time` and `close` values.
         */
        extractSeriesData(series) {
            const seriesData = series.data(); // Ensure this retrieves the data from the series.
            if (!Array.isArray(seriesData)) {
                console.warn("Failed to extract data: series data is not in array format.");
                return [];
            }
            // Convert data into an array of arrays
            return seriesData.map((point) => [
                point.time,
                point.value || point.close || 0,
            ]);
        }
        static syncCharts(childChart, parentChart, crosshairOnly = false) {
            function crosshairHandler(chart, point) {
                //point: BarData | LineData) {
                if (!point) {
                    chart.chart.clearCrosshairPosition();
                    return;
                }
                // TODO fix any point ?
                chart.chart.setCrosshairPosition(point.value || point.close, point.time, chart.series);
                chart.legend.legendHandler(point, true);
            }
            function getPoint(series, param) {
                if (!param.time)
                    return null;
                return param.seriesData.get(series) || null;
            }
            const childTimeScale = childChart.chart.timeScale();
            const parentTimeScale = parentChart.chart.timeScale();
            const setChildRange = (timeRange) => {
                if (timeRange)
                    childTimeScale.setVisibleLogicalRange(timeRange);
            };
            const setParentRange = (timeRange) => {
                if (timeRange)
                    parentTimeScale.setVisibleLogicalRange(timeRange);
            };
            const setParentCrosshair = (param) => {
                crosshairHandler(parentChart, getPoint(childChart.series, param));
            };
            const setChildCrosshair = (param) => {
                crosshairHandler(childChart, getPoint(parentChart.series, param));
            };
            let selected = parentChart;
            function addMouseOverListener(thisChart, otherChart, thisCrosshair, otherCrosshair, thisRange, otherRange) {
                thisChart.wrapper.addEventListener('mouseover', () => {
                    if (selected === thisChart)
                        return;
                    selected = thisChart;
                    otherChart.chart.unsubscribeCrosshairMove(thisCrosshair);
                    thisChart.chart.subscribeCrosshairMove(otherCrosshair);
                    if (crosshairOnly)
                        return;
                    otherChart.chart.timeScale().unsubscribeVisibleLogicalRangeChange(thisRange);
                    thisChart.chart.timeScale().subscribeVisibleLogicalRangeChange(otherRange);
                });
            }
            addMouseOverListener(parentChart, childChart, setParentCrosshair, setChildCrosshair, setParentRange, setChildRange);
            addMouseOverListener(childChart, parentChart, setChildCrosshair, setParentCrosshair, setChildRange, setParentRange);
            parentChart.chart.subscribeCrosshairMove(setChildCrosshair);
            const parentRange = parentTimeScale.getVisibleLogicalRange();
            if (parentRange)
                childTimeScale.setVisibleLogicalRange(parentRange);
            if (crosshairOnly)
                return;
            parentChart.chart.timeScale().subscribeVisibleLogicalRangeChange(setChildRange);
        }
        static makeSearchBox(chart) {
            const searchWindow = document.createElement('div');
            searchWindow.classList.add('searchbox');
            searchWindow.style.display = 'none';
            const magnifyingGlass = document.createElement('div');
            magnifyingGlass.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="24px" viewBox="0 0 24 24" version="1.1"><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:lightgray;stroke-opacity:1;stroke-miterlimit:4;" d="M 15 15 L 21 21 M 10 17 C 6.132812 17 3 13.867188 3 10 C 3 6.132812 6.132812 3 10 3 C 13.867188 3 17 6.132812 17 10 C 17 13.867188 13.867188 17 10 17 Z M 10 17 "/></svg>`;
            const sBox = document.createElement('input');
            sBox.type = 'text';
            searchWindow.appendChild(magnifyingGlass);
            searchWindow.appendChild(sBox);
            chart.div.appendChild(searchWindow);
            chart.commandFunctions.push((event) => {
                if (window.handlerInFocus !== chart.id || window.textBoxFocused)
                    return false;
                if (searchWindow.style.display === 'none') {
                    if (/^[a-zA-Z0-9]$/.test(event.key)) {
                        searchWindow.style.display = 'flex';
                        sBox.focus();
                        return true;
                    }
                    else
                        return false;
                }
                else if (event.key === 'Enter' || event.key === 'Escape') {
                    if (event.key === 'Enter')
                        window.callbackFunction(`search${chart.id}_~_${sBox.value}`);
                    searchWindow.style.display = 'none';
                    sBox.value = '';
                    return true;
                }
                else
                    return false;
            });
            sBox.addEventListener('input', () => sBox.value = sBox.value.toUpperCase());
            return {
                window: searchWindow,
                box: sBox,
            };
        }
        static makeSpinner(chart) {
            chart.spinner = document.createElement('div');
            chart.spinner.classList.add('spinner');
            chart.wrapper.appendChild(chart.spinner);
            // TODO below can be css (animate)
            let rotation = 0;
            const speed = 10;
            function animateSpinner() {
                if (!chart.spinner)
                    return;
                rotation += speed;
                chart.spinner.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
                requestAnimationFrame(animateSpinner);
            }
            animateSpinner();
        }
        static _styleMap = {
            '--bg-color': 'backgroundColor',
            '--hover-bg-color': 'hoverBackgroundColor',
            '--click-bg-color': 'clickBackgroundColor',
            '--active-bg-color': 'activeBackgroundColor',
            '--muted-bg-color': 'mutedBackgroundColor',
            '--border-color': 'borderColor',
            '--color': 'color',
            '--active-color': 'activeColor',
        };
        static setRootStyles(styles) {
            const rootStyle = document.documentElement.style;
            for (const [property, valueKey] of Object.entries(this._styleMap)) {
                rootStyle.setProperty(property, styles[valueKey]);
            }
        }
        /**
         * Serializes the Handler's state into a JSON object.
         *
         * The serialization includes:
         *  - Chart options from the internal chart instance.
         *  - Scale and precision values.
         *
         * @returns A JSON object representing the Handler’s state.
         */
        toJSON() {
            return {
                id: this.id,
                options: this.chart.options(),
                scale: this.scale,
                precision: this.precision,
            };
        }
        /**
         * Restores the Handler’s state from a JSON object.
         *
         * This includes:
         *  - Updating the internal chart’s options via chart.applyOptions.
         *  - Restoring scale and precision.
         *
         * @param json The JSON object containing state.
         */
        fromJSON(json) {
            if (!json) {
                console.warn("No JSON data provided for handler deserialization.");
                return;
            }
            // Update chart options by delegating to the Chart class.
            if (json.options) {
                this.chart.applyOptions(json.options);
            }
            // Restore scale and precision.
            if (json.scale !== undefined) {
                this.scale = json.scale;
            }
            if (json.precision !== undefined) {
                this.precision = json.precision;
            }
        }
        _type = "chart";
        title = "chart";
    }

    class Table {
        _div;
        callbackName;
        borderColor;
        borderWidth;
        table;
        rows = {};
        headings;
        widths;
        alignments;
        footer;
        header;
        constructor(width, height, headings, widths, alignments, position, draggable = false, tableBackgroundColor, borderColor, borderWidth, textColors, backgroundColors) {
            this._div = document.createElement('div');
            this.callbackName = null;
            this.borderColor = borderColor;
            this.borderWidth = borderWidth;
            if (draggable) {
                this._div.style.position = 'absolute';
                this._div.style.cursor = 'move';
            }
            else {
                this._div.style.position = 'relative';
                this._div.style.float = position;
            }
            this._div.style.zIndex = '2000';
            this.reSize(width, height);
            this._div.style.display = 'flex';
            this._div.style.flexDirection = 'column';
            // this._div.style.justifyContent = 'space-between'
            this._div.style.borderRadius = '5px';
            this._div.style.color = 'white';
            this._div.style.fontSize = '12px';
            this._div.style.fontVariantNumeric = 'tabular-nums';
            this.table = document.createElement('table');
            this.table.style.width = '100%';
            this.table.style.borderCollapse = 'collapse';
            this._div.style.overflow = 'hidden';
            this.headings = headings;
            this.widths = widths.map((width) => `${width * 100}%`);
            this.alignments = alignments;
            let head = this.table.createTHead();
            let row = head.insertRow();
            for (let i = 0; i < this.headings.length; i++) {
                let th = document.createElement('th');
                th.textContent = this.headings[i];
                th.style.width = this.widths[i];
                th.style.letterSpacing = '0.03rem';
                th.style.padding = '0.2rem 0px';
                th.style.fontWeight = '500';
                th.style.textAlign = 'center';
                if (i !== 0)
                    th.style.borderLeft = borderWidth + 'px solid ' + borderColor;
                th.style.position = 'sticky';
                th.style.top = '0';
                th.style.backgroundColor = backgroundColors.length > 0 ? backgroundColors[i] : tableBackgroundColor;
                th.style.color = textColors[i];
                row.appendChild(th);
            }
            let overflowWrapper = document.createElement('div');
            overflowWrapper.style.overflowY = 'auto';
            overflowWrapper.style.overflowX = 'hidden';
            overflowWrapper.style.backgroundColor = tableBackgroundColor;
            overflowWrapper.appendChild(this.table);
            this._div.appendChild(overflowWrapper);
            window.containerDiv.appendChild(this._div);
            if (!draggable)
                return;
            let offsetX, offsetY;
            let onMouseDown = (event) => {
                offsetX = event.clientX - this._div.offsetLeft;
                offsetY = event.clientY - this._div.offsetTop;
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            };
            let onMouseMove = (event) => {
                this._div.style.left = (event.clientX - offsetX) + 'px';
                this._div.style.top = (event.clientY - offsetY) + 'px';
            };
            let onMouseUp = () => {
                // Remove the event listeners for dragging
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };
            this._div.addEventListener('mousedown', onMouseDown);
        }
        divToButton(div, callbackString) {
            div.addEventListener('mouseover', () => div.style.backgroundColor = 'rgba(60, 60, 60, 0.6)');
            div.addEventListener('mouseout', () => div.style.backgroundColor = 'transparent');
            div.addEventListener('mousedown', () => div.style.backgroundColor = 'rgba(60, 60, 60)');
            div.addEventListener('click', () => window.callbackFunction(callbackString));
            div.addEventListener('mouseup', () => div.style.backgroundColor = 'rgba(60, 60, 60, 0.6)');
        }
        newRow(id, returnClickedCell = false) {
            let row = this.table.insertRow();
            row.style.cursor = 'default';
            for (let i = 0; i < this.headings.length; i++) {
                let cell = row.insertCell();
                cell.style.width = this.widths[i];
                cell.style.textAlign = this.alignments[i];
                cell.style.border = this.borderWidth + 'px solid ' + this.borderColor;
                if (returnClickedCell) {
                    this.divToButton(cell, `${this.callbackName}_~_${id};;;${this.headings[i]}`);
                }
            }
            if (!returnClickedCell) {
                this.divToButton(row, `${this.callbackName}_~_${id}`);
            }
            this.rows[id] = row;
        }
        deleteRow(id) {
            this.table.deleteRow(this.rows[id].rowIndex);
            delete this.rows[id];
        }
        clearRows() {
            let numRows = Object.keys(this.rows).length;
            for (let i = 0; i < numRows; i++)
                this.table.deleteRow(-1);
            this.rows = {};
        }
        _getCell(rowId, column) {
            return this.rows[rowId].cells[this.headings.indexOf(column)];
        }
        updateCell(rowId, column, val) {
            this._getCell(rowId, column).textContent = val;
        }
        styleCell(rowId, column, styleAttribute, value) {
            const style = this._getCell(rowId, column).style;
            style[styleAttribute] = value;
        }
        makeSection(id, type, numBoxes, func = false) {
            let section = document.createElement('div');
            section.style.display = 'flex';
            section.style.width = '100%';
            section.style.padding = '3px 0px';
            section.style.backgroundColor = 'rgb(30, 30, 30)';
            type === 'footer' ? this._div.appendChild(section) : this._div.prepend(section);
            const textBoxes = [];
            for (let i = 0; i < numBoxes; i++) {
                let textBox = document.createElement('div');
                section.appendChild(textBox);
                textBox.style.flex = '1';
                textBox.style.textAlign = 'center';
                if (func) {
                    this.divToButton(textBox, `${id}_~_${i}`);
                    textBox.style.borderRadius = '2px';
                }
                textBoxes.push(textBox);
            }
            if (type === 'footer') {
                this.footer = textBoxes;
            }
            else {
                this.header = textBoxes;
            }
        }
        reSize(width, height) {
            this._div.style.width = width <= 1 ? width * 100 + '%' : width + 'px';
            this._div.style.height = height <= 1 ? height * 100 + '%' : height + 'px';
        }
    }

    exports.Box = Box;
    exports.CodeEditor = CodeEditor;
    exports.FillArea = FillArea;
    exports.Handler = Handler;
    exports.HorizontalLine = HorizontalLine;
    exports.Legend = Legend;
    exports.RayLine = RayLine;
    exports.Table = Table;
    exports.ToolBox = ToolBox;
    exports.TooltipPrimitive = TooltipPrimitive;
    exports.TopBar = TopBar;
    exports.TrendLine = TrendLine;
    exports.VerticalLine = VerticalLine;
    exports.addPlotToHandler = addPlotToHandler;
    exports.closedEye = closedEye;
    exports.defaultFillAreaOptions = defaultFillAreaOptions;
    exports.globalParamInit = globalParamInit;
    exports.ohlcSeries = ohlcSeries;
    exports.ohlcdefaultOptions = ohlcdefaultOptions;
    exports.openEye = openEye;
    exports.paneStyleDefault = paneStyleDefault;
    exports.setCursor = setCursor;

    return exports;

})({}, LightweightCharts, monaco, url);
//# sourceMappingURL=bundle.js.map
