var Lib = (function (exports, lightweightCharts, monaco) {
    'use strict';

    function _interopNamespaceDefault(e) {
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n.default = e;
        return Object.freeze(n);
    }

    var monaco__namespace = /*#__PURE__*/_interopNamespaceDefault(monaco);

    function ensureDefined(value) {
        if (value === undefined) {
            throw new Error('Value is undefined');
        }
        return value;
    }

    //* PluginBase is a useful base to build a plugin upon which
    //* already handles creating getters for the chart and series,
    //* and provides a requestUpdate method.
    class PluginBase {
        _chart = undefined;
        _series = undefined;
        requestUpdate() {
            if (this._requestUpdate)
                this._requestUpdate();
        }
        _requestUpdate;
        attached({ chart, series, requestUpdate, }) {
            this._chart = chart;
            this._series = series;
            this._series.subscribeDataChanged(this._fireDataUpdated);
            this._requestUpdate = requestUpdate;
            this.requestUpdate();
        }
        detached() {
            this._chart = undefined;
            this._series = undefined;
            this._requestUpdate = undefined;
        }
        get chart() {
            return ensureDefined(this._chart);
        }
        get series() {
            return ensureDefined(this._series);
        }
        _fireDataUpdated(scope) {
            if (this.dataUpdated) {
                this.dataUpdated(scope);
            }
        }
        /**
         * Serializes the plugin state.
         * Default implementation returns an empty object.
         * Subclasses should override this method to export any relevant state.
         *
         * @returns A JSON-compatible representation of the plugin state.
         */
        toJSON() {
            return {};
        }
        /**
         * Restores the plugin state from the provided JSON.
         * Default implementation does nothing.
         * Subclasses should override this method to restore their state.
         *
         * @param json - The JSON object representing the plugin state.
         */
        fromJSON(json) {
            // Default implementation: do nothing.
        }
    }

    // Converts a hex color to RGBA with specified opacity
    function hexToRGBA(hex, opacity) {
        hex = hex.replace(/^#/, '');
        if (!/^([0-9A-F]{3}){1,2}$/i.test(hex)) {
            throw new Error("Invalid hex color format.");
        }
        const getRGB = (h) => {
            return h.length === 3
                ? [parseInt(h[0] + h[0], 16), parseInt(h[1] + h[1], 16), parseInt(h[2] + h[2], 16)]
                : [parseInt(h.slice(0, 2), 16), parseInt(h.slice(2, 4), 16), parseInt(h.slice(4, 6), 16)];
        };
        const [r, g, b] = getRGB(hex);
        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
    // Adjusts the opacity of a color (hex, rgb, or rgba)
    function setOpacity(color, newOpacity) {
        if (color.startsWith('#')) {
            return hexToRGBA(color, newOpacity);
        }
        else {
            // Match rgb or rgba
            const rgbRegex = /^rgb(a)?\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)(?:,\s*([\d.]+))?\)/i;
            const match = color.match(rgbRegex);
            if (match) {
                const r = match[2];
                const g = match[3];
                const b = match[4];
                // If alpha not specified, assume 1.0
                const a = match[1] ? (match[5] ?? '1') : '1';
                return `rgba(${r}, ${g}, ${b}, ${newOpacity ?? a})`;
            }
            else {
                throw new Error("Unsupported color format. Use hex, rgb, or rgba.");
            }
        }
    }
    // Darkens a color (hex or rgba) by a specified amount
    function darkenColor(color, amount = 0.2) {
        const hexToRgb = (hex) => {
            hex = hex.replace(/^#/, '');
            return hex.length === 3
                ? [parseInt(hex[0] + hex[0], 16), parseInt(hex[1] + hex[1], 16), parseInt(hex[2] + hex[2], 16)]
                : [parseInt(hex.slice(0, 2), 16), parseInt(hex.slice(2, 4), 16), parseInt(hex.slice(4, 6), 16)];
        };
        const rgbaToArray = (rgba) => rgba.match(/\d+(\.\d+)?/g).map(Number);
        let [r, g, b, a = 1] = color.startsWith('#')
            ? [...hexToRgb(color), 1]
            : rgbaToArray(color);
        r = Math.max(0, Math.min(255, r * (1 - amount)));
        g = Math.max(0, Math.min(255, g * (1 - amount)));
        b = Math.max(0, Math.min(255, b * (1 - amount)));
        return color.startsWith('#')
            ? `#${((1 << 24) + (Math.round(r) << 16) + (Math.round(g) << 8) + Math.round(b)).toString(16).slice(1)}`
            : `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;
    }
    function generateShades(count) {
        // List of potential base colors.
        const colors = {
            "#ff0000": [
                "#ff0000",
                "#f20000",
                "#e60000",
                "#d90000",
                "#cc0000",
                "#bf0000",
                "#b30000",
                "#a60000",
                "#990000",
                "#8c0000"
            ],
            "#ff8700": [
                "#ff8700",
                "#f28000",
                "#e67a00",
                "#d97300",
                "#cc6c00",
                "#bf6500",
                "#b35f00",
                "#a65800",
                "#995100",
                "#8c4a00"
            ],
            "#ffd300": [
                "#ffd300",
                "#fcca00",
                "#e6c000",
                "#d9b600",
                "#ccb000",
                "#bfaa00",
                "#b3a000",
                "#a69a00",
                "#999000",
                "#8c8600"
            ],
            "#a1ff0a": [
                "#a1ff0a",
                "#97f207",
                "#8ded04",
                "#83e701",
                "#79db00",
                "#6fd200",
                "#65c900",
                "#5bc000",
                "#51b700",
                "#47ae00"
            ],
            "#117a03": [
                "#117a03",
                "#107203",
                "#0e6c03",
                "#0c6603",
                "#0a6003",
                "#085a03",
                "#065403",
                "#044e03",
                "#024803",
                "#004203"
            ],
            "#580aff": [
                "#580aff",
                "#5109f2",
                "#4a08e6",
                "#4307da",
                "#3c06ce",
                "#3505c2",
                "#2e04b6",
                "#2703aa",
                "#2002a0",
                "#190196"
            ],
            "#be0aff": [
                "#be0aff",
                "#b308f2",
                "#aa07e6",
                "#a005da",
                "#9704ce",
                "#8e03c2",
                "#8502b6",
                "#7c01aa",
                "#7300a0",
                "#6a0096"
            ]
        };
        // Tell TypeScript that the keys are exactly those of the colors object.
        const baseColors = Object.keys(colors);
        // Pick a random base color.
        const randomKey = baseColors[Math.floor(Math.random() * baseColors.length)];
        const fullShades = colors[randomKey];
        // If the requested count equals the full set, return it directly.
        if (count === fullShades.length) {
            return fullShades;
        }
        // Otherwise, return an evenly spaced selection of shades.
        const result = [];
        for (let i = 0; i < count; i++) {
            const index = count === 1 ? 0 : Math.round(i * (fullShades.length - 1) / (count - 1));
            result.push(fullShades[index]);
        }
        return result;
    }
    /**
    * Safely extracts the alpha component from an RGBA or HSLA color string.
    * Returns 1.0 if parsing fails or if no alpha is found (e.g. "rgb(...)").
    */
    function getAlphaFromColor(color) {
        // Attempt to parse 'rgba(...)' or 'hsla(...)' format.
        const rgbaMatch = color.match(/rgba?\(([^)]+)\)/i);
        const hslaMatch = color.match(/hsla?\(([^)]+)\)/i);
        let alpha = 1.0; // Default if we fail to parse or if no alpha is present
        if (rgbaMatch) {
            // Extract the comma-separated values inside the parentheses
            const parts = rgbaMatch[1].split(',').map((p) => parseFloat(p.trim()));
            // If there are 4 parts (r, g, b, a), use the last as alpha
            if (parts.length === 4) {
                alpha = parts[3];
            }
        }
        else if (hslaMatch) {
            // Extract the comma-separated values inside the parentheses
            const parts = hslaMatch[1].split(',').map((p) => parseFloat(p.trim()));
            // If there are 4 parts (h, s, l, a), use the last as alpha
            if (parts.length === 4) {
                alpha = parts[3];
            }
        }
        return alpha;
    }
    /**
    * Recursively walk through an object, looking for any key that includes "color".
    * When found, invoke a callback with the key path and value.
    *
    * @param obj The object to inspect (e.g., a series's options object).
    * @param callback A function to call whenever a property name has "color".
    * @param parentKey Internal use: tracks the current path (e.g. "candles.border").
    */
    function findColorOptions(obj, callback, parentKey = "") {
        for (const key of Object.keys(obj)) {
            const fullPath = parentKey ? `${parentKey}.${key}` : key;
            const value = obj[key];
            // If the value is another object, recurse deeper
            if (typeof value === "object" && value !== null) {
                findColorOptions(value, callback, fullPath);
            }
            else {
                // If the key itself contains "color", report it
                if (key.toLowerCase().includes("color")) {
                    callback(fullPath, value);
                }
            }
        }
    }

    class ClosestTimeIndexFinder {
        numbers;
        cache;
        constructor(sortedNumbers) {
            this.numbers = sortedNumbers;
            this.cache = new Map();
        }
        findClosestIndex(target, direction) {
            const cacheKey = `${target}:${direction}`;
            if (this.cache.has(cacheKey)) {
                return this.cache.get(cacheKey);
            }
            const closestIndex = this._performSearch(target, direction);
            this.cache.set(cacheKey, closestIndex);
            return closestIndex;
        }
        _performSearch(target, direction) {
            let low = 0;
            let high = this.numbers.length - 1;
            if (target <= this.numbers[0].time)
                return 0;
            if (target >= this.numbers[high].time)
                return high;
            while (low <= high) {
                const mid = Math.floor((low + high) / 2);
                const num = this.numbers[mid].time;
                if (num === target) {
                    return mid;
                }
                else if (num > target) {
                    high = mid - 1;
                }
                else {
                    low = mid + 1;
                }
            }
            return direction === 'left' ? low : high;
        }
    }

    /**
     * Enumeration for different candle shapes.
     */
    var CandleShape;
    (function (CandleShape) {
        CandleShape["Rectangle"] = "Rectangle";
        CandleShape["Rounded"] = "Rounded";
        CandleShape["Ellipse"] = "Ellipse";
        CandleShape["Arrow"] = "Arrow";
        CandleShape["Cube"] = "3d";
        CandleShape["Polygon"] = "Polygon";
        CandleShape["Bar"] = "Bar";
        CandleShape["Slanted"] = "Slanted";
    })(CandleShape || (CandleShape = {}));
    function parseCandleShape(input) {
        switch (input.trim().toLowerCase()) {
            case 'rectangle':
                return CandleShape.Rectangle;
            case 'rounded':
                return CandleShape.Rounded;
            case 'ellipse':
                return CandleShape.Ellipse;
            case 'arrow':
                return CandleShape.Arrow;
            case '3d':
                return CandleShape.Cube;
            case 'polygon':
                return CandleShape.Polygon;
            case 'bar':
                return CandleShape.Bar;
            case 'slanted':
                return CandleShape.Slanted;
            default:
                console.warn(`Unknown CandleShape: ${input}`);
                return CandleShape.Rectangle;
        }
    }

    function isSolidColor(background) {
        return background.type === lightweightCharts.ColorType.Solid;
    }
    function isVerticalGradientColor(background) {
        return background.type === lightweightCharts.ColorType.VerticalGradient;
    }
    // Type checks for data
    function isSingleValueData(data) {
        return "value" in data;
    }
    function isOHLCData(data) {
        return "close" in data && "open" in data && "high" in data && "low" in data;
    }
    function isWhitespaceData(data) {
        if (!data || typeof data !== "object") {
            return false;
        }
        // Must have time
        if (!("time" in data)) {
            return false;
        }
        if ("value" in data || "open" in data || "close" in data || "high" in data || "low" in data) {
            return false;
        }
        return true;
    }
    function hasColorOption(series) {
        const seriesOptions = series.options();
        return 'lineColor' in seriesOptions || 'color' in seriesOptions;
    }
    // utils/typeGuards.ts
    /**
     * Type guard to check if a primitive is FillArea.
     *
     * @param primitive - The primitive to check.
     * @returns True if primitive is FillArea, else false.
     */
    function isFillArea(primitive) {
        return (primitive.options.originColor !== null &&
            primitive.options.destinationColor !== null);
    }
    function isCandleShape(value) {
        return Object.values(CandleShape).includes(value);
    }
    function isISeriesApi(series) {
        return (typeof series === "object" &&
            series !== null &&
            typeof series.data === "function" &&
            typeof series.options === "function");
    }
    // Type Guard: Check if the series is an ISeriesIndicator
    function isISeriesIndicator(series) {
        return series.figures !== undefined &&
            series.sourceSeries !== undefined &&
            series.indicator !== undefined;
    }

    class FillArea extends PluginBase {
        static type = "Fill Area"; // Explicitly set the type name
        _paneViews;
        _originSeries;
        _destinationSeries;
        _bandsData = [];
        options;
        _timeIndices;
        constructor(originSeries, destinationSeries, options) {
            super();
            // Existing logic for setting colors
            const defaultOriginColor = setOpacity('#0000FF', 0.25); // Blue
            const defaultDestinationColor = setOpacity('#FF0000', 0.25); // Red
            const originSeriesColor = hasColorOption(originSeries)
                ? setOpacity(originSeries.options().lineColor || defaultOriginColor, 0.3)
                : setOpacity(defaultOriginColor, 0.3);
            const destinationSeriesColor = hasColorOption(destinationSeries)
                ? setOpacity(destinationSeries.options().lineColor || defaultDestinationColor, 0.3)
                : setOpacity(defaultDestinationColor, 0.3);
            this.options = {
                ...defaultFillAreaOptions,
                ...options,
                originColor: options.originColor ?? originSeriesColor,
                destinationColor: options.destinationColor ?? destinationSeriesColor,
            };
            this._paneViews = [new FillAreaPaneView(this)];
            this._timeIndices = new ClosestTimeIndexFinder([]);
            this._originSeries = originSeries;
            this._destinationSeries = destinationSeries;
            // Subscribe to data changes in both series
            this._originSeries.subscribeDataChanged(() => {
                console.log("Origin series data has changed. Recalculating bands.");
                this.dataUpdated('full');
                this.updateAllViews();
            });
            this._destinationSeries.subscribeDataChanged(() => {
                console.log("Destination series data has changed. Recalculating bands.");
                this.dataUpdated('full');
                this.updateAllViews();
            });
        }
        updateAllViews() {
            this._paneViews.forEach(pw => pw.update());
        }
        applyOptions(options) {
            this.options = {
                ...this.options,
                ...options,
            };
            this.calculateBands();
            this.updateAllViews();
            super.requestUpdate();
            console.log("FillArea options updated:", this.options);
        }
        paneViews() {
            return this._paneViews;
        }
        attached(p) {
            super.attached(p);
            this.dataUpdated('full');
        }
        dataUpdated(scope) {
            this.calculateBands();
            if (scope === 'full') {
                const originData = this._originSeries.data();
                this._timeIndices = new ClosestTimeIndexFinder([...originData]);
            }
        }
        calculateBands() {
            const originData = this._originSeries.data();
            const destinationData = this._destinationSeries.data();
            // Ensure both datasets have the same length
            const alignedData = this._alignDataLengths([...originData], [...destinationData]);
            const bandData = [];
            for (let i = 0; i < alignedData.origin.length; i++) {
                let points = extractPrices(alignedData.origin[i], alignedData.destination[i]);
                if (points?.originValue === undefined || points?.destinationValue === undefined)
                    continue;
                // Determine which series is upper and lower
                const upper = Math.max(points?.originValue, points?.destinationValue);
                const lower = Math.min(points?.originValue, points?.destinationValue);
                bandData.push({
                    time: alignedData.origin[i].time,
                    origin: points?.originValue,
                    destination: points?.destinationValue,
                    upper,
                    lower,
                });
            }
            this._bandsData = bandData;
        }
        _alignDataLengths(originData, destinationData) {
            const originLength = originData.length;
            const destinationLength = destinationData.length;
            if (originLength > destinationLength) {
                const lastKnown = destinationData[destinationLength - 1];
                while (destinationData.length < originLength) {
                    destinationData.push({ ...lastKnown });
                }
            }
            else if (destinationLength > originLength) {
                const lastKnown = originData[originLength - 1];
                while (originData.length < destinationLength) {
                    originData.push({ ...lastKnown });
                }
            }
            return { origin: originData, destination: destinationData };
        }
        autoscaleInfo(startTimePoint, endTimePoint) {
            const ts = this.chart.timeScale();
            const startTime = (ts.coordinateToTime(ts.logicalToCoordinate(startTimePoint) ?? 0) ?? 0);
            const endTime = (ts.coordinateToTime(ts.logicalToCoordinate(endTimePoint) ?? 5000000000) ?? 5000000000);
            const startIndex = this._timeIndices.findClosestIndex(startTime, 'left');
            const endIndex = this._timeIndices.findClosestIndex(endTime, 'right');
            const range = {
                minValue: Math.min(...this._bandsData.map(b => b.lower).slice(startIndex, endIndex + 1)),
                maxValue: Math.max(...this._bandsData.map(b => b.upper).slice(startIndex, endIndex + 1)),
            };
            return {
                priceRange: {
                    minValue: range.minValue,
                    maxValue: range.maxValue,
                },
            };
        }
    }
    class FillAreaPaneRenderer {
        _viewData;
        _options;
        constructor(data) {
            this._viewData = data;
            this._options = data.options;
        }
        draw() { }
        drawBackground(target) {
            const points = this._viewData.data;
            const options = this._options;
            if (points.length < 2)
                return; // Ensure there are enough points to draw
            target.useBitmapCoordinateSpace((scope) => {
                const ctx = scope.context;
                ctx.scale(scope.horizontalPixelRatio, scope.verticalPixelRatio);
                let currentPathStarted = false;
                let startIndex = 0;
                for (let i = 0; i < points.length - 1; i++) {
                    const current = points[i];
                    const next = points[i + 1];
                    if (!currentPathStarted || current.isOriginAbove !== points[i - 1]?.isOriginAbove) {
                        if (currentPathStarted) {
                            for (let j = i - 1; j >= startIndex; j--) {
                                ctx.lineTo(points[j].x, points[j].destination);
                            }
                            ctx.closePath();
                            ctx.fill();
                        }
                        ctx.beginPath();
                        ctx.moveTo(current.x, current.origin);
                        ctx.fillStyle = current.isOriginAbove
                            ? options.originColor || 'rgba(0, 0, 0, 0)' // Default to transparent if null
                            : options.destinationColor || 'rgba(0, 0, 0, 0)'; // Default to transparent if null
                        startIndex = i;
                        currentPathStarted = true;
                    }
                    ctx.lineTo(next.x, next.origin);
                    if (i === points.length - 2 || next.isOriginAbove !== current.isOriginAbove) {
                        for (let j = i + 1; j >= startIndex; j--) {
                            ctx.lineTo(points[j].x, points[j].destination);
                        }
                        ctx.closePath();
                        ctx.fill();
                        currentPathStarted = false;
                    }
                }
                if (options.lineWidth) {
                    ctx.lineWidth = options.lineWidth;
                    ctx.strokeStyle = options.originColor || 'rgba(0, 0, 0, 0)';
                    ctx.stroke();
                }
            });
        }
    }
    class FillAreaPaneView {
        _source;
        _data;
        constructor(source) {
            this._source = source;
            this._data = {
                data: [],
                options: this._source.options, // Pass the options for the renderer
            };
        }
        update() {
            const timeScale = this._source.chart.timeScale();
            this._data.data = this._source._bandsData.map((d) => ({
                x: timeScale.timeToCoordinate(d.time),
                origin: this._source._originSeries.priceToCoordinate(d.origin),
                destination: this._source._destinationSeries.priceToCoordinate(d.destination),
                isOriginAbove: d.origin > d.destination,
            }));
            // Ensure options are updated in the data
            this._data.options = this._source.options;
        }
        renderer() {
            return new FillAreaPaneRenderer(this._data);
        }
        zOrder() {
            return 'bottom';
        }
    }
    const defaultFillAreaOptions = {
        originColor: null,
        destinationColor: null,
        lineWidth: null,
    };
    function extractPrices(originPoint, destinationPoint) {
        let originPrice;
        let destinationPrice;
        // Extract origin price
        if (originPoint.close !== undefined) {
            const originBar = originPoint;
            originPrice = originBar.close; // Use close price for comparison
        }
        else if (originPoint.value !== undefined) {
            originPrice = originPoint.value; // Use value for LineData
        }
        // Extract destination price
        if (destinationPoint.close !== undefined) {
            const destinationBar = destinationPoint;
            destinationPrice = destinationBar.close; // Use close price for comparison
        }
        else if (destinationPoint.value !== undefined) {
            destinationPrice = destinationPoint.value; // Use value for LineData
        }
        // Ensure both prices are defined
        if (originPrice === undefined || destinationPrice === undefined) {
            return undefined;
        }
        // Handle mixed types and determine the appropriate values to return
        if (originPrice < destinationPrice) {
            // origin > destination: min(open, close) for BarData (if applicable), otherwise value
            const originValue = originPoint.close !== undefined
                ? Math.min(originPoint.open, originPoint.close)
                : originPrice;
            const destinationValue = destinationPoint.close !== undefined
                ? Math.max(destinationPoint.open, destinationPoint.close)
                : destinationPrice;
            return { originValue, destinationValue };
        }
        else {
            // origin <= destination: max(open, close) for BarData (if applicable), otherwise value
            const originValue = originPoint.close !== undefined
                ? Math.max(originPoint.open, originPoint.close)
                : originPrice;
            const destinationValue = destinationPoint.close !== undefined
                ? Math.min(destinationPoint.open, destinationPoint.close)
                : destinationPrice;
            return { originValue, destinationValue };
        }
    }

    const paneStyleDefault = {
        backgroundColor: '#0c0d0f',
        hoverBackgroundColor: '#3c434c',
        clickBackgroundColor: '#50565E',
        activeBackgroundColor: 'rgba(0, 122, 255, 0.7)',
        mutedBackgroundColor: 'rgba(0, 122, 255, 0.3)',
        borderColor: '#3C434C',
        color: '#d8d9db',
        activeColor: '#ececed',
    };
    function globalParamInit() {
        window.pane = {
            ...paneStyleDefault,
        };
        window.containerDiv = document.getElementById("container") || document.createElement('div');
        window.setCursor = (type) => {
            if (type)
                window.cursor = type;
            document.body.style.cursor = window.cursor;
        };
        window.cursor = 'default';
        window.textBoxFocused = false;
    }
    const setCursor = (type) => {
        if (type)
            window.cursor = type;
        document.body.style.cursor = window.cursor;
    };
    const openEye = `
<svg xmlns="http://www.w3.org/2000/svg" width="22" height="16" viewBox="0 0 24 24">
    <path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:#FFF;stroke-opacity:1;stroke-miterlimit:4;" 
          d="M 21.998437 12 C 21.998437 12 18.998437 18 12 18 
             C 5.001562 18 2.001562 12 2.001562 12 
             C 2.001562 12 5.001562 6 12 6 
             C 18.998437 6 21.998437 12 21.998437 12 Z" />
    <path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:#FFF;stroke-opacity:1;stroke-miterlimit:4;" 
          d="M 15 12 
             C 15 13.654687 13.654687 15 12 15 
             C 10.345312 15 9 13.654687 9 12 
             C 9 10.345312 10.345312 9 12 9 
             C 13.654687 9 15 10.345312 15 12 Z" />
</svg>
`;
    const closedEye = `
<svg xmlns="http://www.w3.org/2000/svg" width="22" height="16" viewBox="0 0 24 24">
 <path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:#FFF;stroke-opacity:1;stroke-miterlimit:4;" 
          d="M 3 3 L 21 21" />
    <path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:#FFF;stroke-opacity:1;stroke-miterlimit:4;" 
          d="M 21.998437 12 
             C 21.998437 12 18.998437 18 12 18 
             C 5.001562 18 2.001562 12 2.001562 12 
             C 2.001562 12 5.001562 6 12 6 
             C 14.211 6 16.106 6.897 17.7 8.1" />
    <path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:#FFF;stroke-opacity:1;stroke-miterlimit:4;" 
          d="M 9.9 9.9 
             C 9.367 10.434 9 11.178 9 12 
             C 9 13.654687 10.345312 15 12 15 
             C 12.822 15 13.566 14.633 14.1 14.1" />
</svg>
`;

    // legend-menu.ts
    class LegendMenu {
        contextMenu;
        handler; // Replace with your actual Handler type
        constructor(options) {
            this.contextMenu = options.contextMenu;
            this.handler = options.handler;
        }
        /**
         * Populates the context menu with options specific to a legend item (series or group).
         * @param legendItem The LegendSeries or LegendGroup item that was right-clicked.
         * @param event The MouseEvent triggering the context menu.
         */
        populateLegendMenu(legendItem, event) {
            // Clear existing menu items
            this.contextMenu.clearMenu();
            // Determine if the legendItem is a series or a group
            const isGroup = (item) => {
                return item.seriesList !== undefined;
            };
            if (isGroup(legendItem)) {
                // Populate menu for a LegendGroup
                this.populateGroupMenu(legendItem, event);
            }
            else {
                // Populate menu for a LegendSeries
                this.populateSeriesMenu(legendItem, event);
            }
            // Optionally, add a "Close Menu" option
            this.contextMenu.separator();
            this.contextMenu.addMenuItem("Close Menu", () => this.contextMenu.hideMenu());
            // Position and display the menu
            this.contextMenu.showMenu(event);
        }
        populateGroupMenu(group, event) {
            // Add Group-Specific Options
            this.contextMenu.addMenuItem("Rename", () => {
                const newName = prompt("Enter new group name:", group.name);
                if (newName && newName.trim() !== "") {
                    this.renameGroup(group, newName.trim());
                }
            }, false);
            this.contextMenu.addMenuItem("Remove", () => {
                if (confirm(`Are you sure you want to remove the group "${group.name}"? This will also remove all contained series.`)) {
                    group.seriesList.forEach((seriesItem) => {
                        this.handler.legend.removeLegendSeries(seriesItem.series);
                        this.handler.removeSeries(seriesItem.series);
                    });
                    // Remove the group after all series have been removed
                    this.removeGroup(group);
                }
            });
            this.contextMenu.addMenuItem("Ungroup", () => {
                this.ungroupSeries(group);
            });
            // Add Hybrid Input for moving all series within the group to another pane.
            if (group.seriesList && group.seriesList.length > 0) {
                // Use the first series as reference to get the current pane index.
                const firstSeries = group.seriesList[0].series;
                const currentPaneIndex = firstSeries.getPane().paneIndex();
                const panes = this.handler.chart.panes();
                const currentValue = `Pane ${currentPaneIndex}`;
                // Define the default action:
                // If the series is in the main pane (pane 0), move all to pane 1 (if available) or to a new pane.
                // Otherwise, move them back to the main pane (pane 0).
                const defaultAction = () => {
                    if (currentPaneIndex === 0) {
                        if (panes.length > 1) {
                            group.seriesList.forEach((seriesItem) => {
                                seriesItem.series.moveToPane(1);
                            });
                            console.log(`Default: Moved group "${group.name}" series from pane ${currentPaneIndex} to pane 1.`);
                        }
                        else {
                            group.seriesList.forEach((seriesItem) => {
                                seriesItem.series.moveToPane(panes.length); // creates a new pane
                            });
                            console.log(`Default: Moved group "${group.name}" series from pane ${currentPaneIndex} to a new pane at index ${panes.length}.`);
                        }
                    }
                    else {
                        group.seriesList.forEach((seriesItem) => {
                            seriesItem.series.moveToPane(0);
                        });
                        console.log(`Default: Moved group "${group.name}" series from pane ${currentPaneIndex} back to main pane (0).`);
                    }
                };
                const options = [];
                for (let i = 0; i < panes.length; i++) {
                    options.push({
                        name: `Pane ${i}`,
                        action: () => {
                            group.seriesList.forEach((seriesItem) => {
                                seriesItem.series.moveToPane(i);
                            });
                            console.log(`Moved group "${group.name}" series to existing pane ${i}.`);
                        }
                    });
                }
                options.push({
                    name: "New Pane",
                    action: () => {
                        group.seriesList.forEach((seriesItem) => {
                            seriesItem.series.moveToPane(panes.length);
                        });
                        console.log(`Moved group "${group.name}" series to a new pane at index ${panes.length}.`);
                    }
                });
                // Create the hybrid input using the contextMenu's addMenuInput helper.
                // Make sure to pass the parent element (this.div) and the configuration object.
                this.contextMenu.addMenuInput(this.contextMenu.div, // Parent HTMLElement. Replace this.div with your actual container if needed.
                {
                    type: "hybrid",
                    label: "Move to",
                    sublabel: currentValue,
                    value: currentValue,
                    onChange: (newValue) => {
                        // When the user selects an option, look it up in the options array and execute its action.
                        const selectedOption = options.find(opt => opt.name === newValue);
                        if (selectedOption) {
                            selectedOption.action();
                        }
                    },
                    hybridConfig: {
                        defaultAction: defaultAction,
                        options: options.map(opt => ({
                            name: opt.name,
                            action: opt.action
                        }))
                    }
                });
            }
            // Optionally, add a "Close Menu" option.
            this.contextMenu.separator();
            this.contextMenu.addMenuItem("Close Menu", () => this.contextMenu.hideMenu());
            // Position and display the menu at the event location.
            this.contextMenu.showMenu(event);
        }
        /**
         * Populates the context menu for a LegendSeries.
         * @param seriesItem The LegendSeries to populate the menu for.
         */
        populateSeriesMenu(seriesItem, event) {
            // Add Series-Specific Options
            this.contextMenu.addMenuItem("Open Series Menu", () => {
                // Assuming you have a method to open a detailed series menu
                this.contextMenu.populateSeriesMenu(seriesItem.series, event);
            }, false);
            this.contextMenu.addMenuItem("Move to Group ▸", () => {
                this.populateMoveToGroupMenu(seriesItem);
            }, false);
            this.contextMenu.addMenuItem("Remove Series", () => {
                if (confirm(`Are you sure you want to remove the series "${seriesItem.name}"?`)) {
                    this.handler.legend.removeLegendSeries(seriesItem.series);
                    this.handler.removeSeries(seriesItem.series);
                }
            });
            if (seriesItem.primitives) {
                this.contextMenu.addMenuItem("Remove Primitives", () => {
                    this.removePrimitivesFromSeries(seriesItem);
                });
            }
            if (seriesItem.group) {
                this.contextMenu.addMenuItem("Ungroup", () => {
                    this.ungroupSeriesFromGroup(seriesItem);
                });
            }
            this.contextMenu.showMenu(event);
        }
        /**
         * Populates the "Move to Group" submenu.
         * @param seriesItem The LegendSeries to move.
         */
        populateMoveToGroupMenu(seriesItem) {
            // Clear existing menu items
            this.contextMenu.clearMenu();
            // List existing groups
            const existingGroups = this.handler.legend._groups;
            existingGroups.forEach((group) => {
                this.contextMenu.addMenuItem(group.name, () => {
                    this.handler.legend.moveSeriesToGroup(seriesItem, group);
                });
            });
            // Option to create a new group
            this.contextMenu.addMenuItem("Create New Group...", () => {
                const newGroupName = prompt("Enter new group name:", "New Group");
                if (newGroupName && newGroupName.trim() !== "") {
                    this.createNewGroup(seriesItem, newGroupName.trim());
                }
            });
            if (seriesItem.group) {
                this.contextMenu.addMenuItem("Ungroup", () => {
                    this.ungroupSeriesFromGroup(seriesItem);
                });
            }
        }
        /**
         * Renames a LegendGroup.
         * @param group The LegendGroup to rename.
         * @param newName The new name for the group.
         */
        renameGroup(group, newName) {
            // Update the group's name in the data structure
            group.name = newName;
            group.seriesList.forEach(seriesItem => {
                seriesItem.group = newName;
            });
            // Update the DOM element displaying the group name
            const groupHeader = group.row.querySelector('.group-header span');
            if (groupHeader) {
                groupHeader.textContent = newName;
            }
            console.log(`Group renamed to: ${newName}`);
        }
        /**
         * Removes a LegendGroup and all its contained series.
         * @param group The LegendGroup to remove.
         */
        removeGroup(group) {
            this.handler.legend.removeLegendGroup(group);
            // Remove the group from the internal groups array
            this.handler.legend._groups = this.handler.legend._groups.filter((g) => g !== group);
            console.log(`Group "${group.name}" removed along with its series.`);
        }
        /**
         * Creates a new group and moves the series into it.
         * @param seriesItem The LegendSeries to move.
         * @param newGroupName The name of the new group.
         */
        createNewGroup(seriesItem, newGroupName) {
            this.handler.legend.deleteLegendEntry(seriesItem);
            seriesItem.group = newGroupName;
            this.handler.legend.addLegendItem(seriesItem);
        }
        /**
         * Removes a LegendSeries from its group, making it standalone.
         * @param seriesItem The LegendSeries to ungroup.
         */
        ungroupSeriesFromGroup(seriesItem) {
            const currentGroupName = this.handler.legend.getGroupOfSeries(seriesItem.series);
            if (currentGroupName) {
                this.handler.legend.deleteLegendEntry(seriesItem);
                seriesItem.group = undefined;
                this.handler.legend.addLegendItem(seriesItem);
            }
            console.log(`Series "${seriesItem.name}" removed from its group and is now standalone.`);
        }
        /**
         * Removes all primitives associated with a LegendSeries.
         * @param seriesItem The LegendSeries to remove primitives from.
         */
        removePrimitivesFromSeries(seriesItem) {
            if (seriesItem.series.primitives) {
                Object.values(seriesItem.series.primitives).forEach(primitive => {
                    seriesItem.series.detachPrimitive(primitive); // Assuming a remove method exists
                    console.log(`Primitive removed from series "${seriesItem.name}".`);
                });
                seriesItem.primitives = undefined; // Reset primitives
            }
            console.log(`All primitives removed from series "${seriesItem.name}".`);
        }
        /**
         * Ungroups all series within a LegendGroup, making them standalone.
         * @param group The LegendGroup to ungroup.
         */
        ungroupSeries(group) {
            group.seriesList.forEach(seriesItem => {
                this.handler.legend.deleteLegendEntry(seriesItem);
                seriesItem.group = undefined;
                this.handler.legend.addLegendItem(seriesItem);
                // Add to the main legend container as standalone
            });
            // Remove the group
            this.removeGroup(group);
            console.log(`All series in group "${group.name}" have been ungrouped and are now standalone.`);
        }
    }

    function getLastData(series) {
        return series.data()[series.data().length - 1];
    }
    class Legend {
        handler;
        div;
        seriesContainer;
        legendMenu;
        linesEnabled = false;
        contextMenu;
        text;
        _items = [];
        _lines = [];
        _groups = [];
        constructor(handler) {
            this.handler = handler;
            this.div = document.createElement('div');
            this.div.classList.add("legend");
            this.seriesContainer = document.createElement("div");
            this.text = document.createElement('span');
            this.contextMenu = this.handler.ContextMenu;
            // Initialize LegendMenu
            this.legendMenu = new LegendMenu({
                contextMenu: this.contextMenu,
                handler: handler
            });
            this.setupLegend();
            this.legendHandler = this.legendHandler.bind(this);
            handler.chart.subscribeCrosshairMove(this.legendHandler);
        }
        setupLegend() {
            this.div.style.maxWidth = `${(this.handler.scale.width * 100) - 8}vw`;
            this.div.style.display = 'none';
            const seriesWrapper = document.createElement('div');
            seriesWrapper.style.display = 'flex';
            seriesWrapper.style.flexDirection = 'row';
            this.seriesContainer.classList.add("series-container");
            this.text.style.lineHeight = '1.8';
            seriesWrapper.appendChild(this.seriesContainer);
            this.div.appendChild(this.text);
            this.div.appendChild(seriesWrapper);
            this.handler.div.appendChild(this.div);
        }
        legendItemFormat(num, decimal) {
            if (typeof num !== 'number' || isNaN(num)) {
                return '-'; // Default display when data is missing
            }
            return num.toFixed(decimal).toString().padStart(8, ' ');
        }
        shorthandFormat(num) {
            const absNum = Math.abs(num);
            return absNum >= 1000000 ? (num / 1000000).toFixed(1) + 'M' :
                absNum >= 1000 ? (num / 1000).toFixed(1) + 'K' :
                    num.toString().padStart(8, ' ');
        }
        createSvgIcon(svgContent) {
            const tempContainer = document.createElement('div');
            tempContainer.innerHTML = svgContent.trim();
            const svgElement = tempContainer.querySelector('svg');
            return svgElement;
        }
        /**
         * Adds a LegendItem to the legend, either as a standalone series or within a group.
         * @param item The LegendItem to add.
         * @returns The HTMLDivElement representing the legend entry.
         */
        addLegendItem(item) {
            // Ensure `item` is a series and map it to the `LegendSeries` type
            const seriesItem = this.mapToSeries(item);
            if (seriesItem.group) {
                // If the series belongs to a group, add it to the group
                return this.addItemToGroup(seriesItem, seriesItem.group);
            }
            else {
                // If standalone, create a series row and add it to the container
                const seriesRow = this.makeSeriesRow(seriesItem, this.seriesContainer);
                // Add the series to `_lines` for tracking
                this._lines.push(seriesItem);
                // Add to `_items` for general legend tracking
                this._items.push(seriesItem);
                return seriesRow;
            }
        }
        addLegendPrimitive(series, primitive, name) {
            const primitiveName = name || primitive.constructor.name;
            // Check if the parent series row exists
            const seriesEntry = this._lines.find(line => line.series === series);
            if (!seriesEntry) {
                console.warn(`Parent series not found in legend for primitive: ${primitiveName}`);
                return;
            }
            // Ensure the seriesEntry has a `primitives` array
            if (!seriesEntry.primitives) {
                seriesEntry.primitives = [];
            }
            // Ensure the primitives container exists
            let primitivesContainer = this.seriesContainer.querySelector(`[data-series-id="${seriesEntry.name}"] .primitives-container`);
            if (!primitivesContainer) {
                primitivesContainer = document.createElement('div');
                primitivesContainer.classList.add('primitives-container');
                primitivesContainer.style.display = 'none';
                primitivesContainer.style.marginLeft = '20px';
                primitivesContainer.style.flexDirection = 'column';
                // Insert the container below the series row
                seriesEntry.row.insertAdjacentElement('afterend', primitivesContainer);
            }
            // Check if the primitive already exists in the legend
            const existingPrimitiveRow = Array.from(primitivesContainer.children).find(row => row.getAttribute('data-primitive-type') === primitiveName);
            if (existingPrimitiveRow) {
                console.warn(`Primitive "${primitiveName}" already exists under the parent series.`);
                return existingPrimitiveRow;
            }
            // Create a new row for the primitive
            const primitiveRow = document.createElement('div');
            primitiveRow.classList.add('legend-primitive-row');
            primitiveRow.setAttribute('data-primitive-type', primitiveName);
            primitiveRow.style.display = 'flex';
            primitiveRow.style.justifyContent = 'space-between';
            primitiveRow.style.marginTop = '4px';
            const primitiveLabel = document.createElement('span');
            primitiveLabel.innerText = primitiveName;
            // Add a visibility toggle for the primitive
            const toggle = document.createElement('div');
            toggle.style.cursor = 'pointer';
            toggle.style.display = 'flex';
            toggle.style.alignItems = 'center';
            const onIcon = this.createSvgIcon(openEye);
            const offIcon = this.createSvgIcon(closedEye);
            toggle.appendChild(onIcon.cloneNode(true)); // Start with visible icon
            let visible = true;
            toggle.addEventListener('click', () => {
                visible = !visible;
                toggle.innerHTML = ''; // Clear existing content
                toggle.appendChild(visible ? onIcon.cloneNode(true) : offIcon.cloneNode(true));
                this.togglePrimitive(primitive, visible);
            });
            // Append elements to the primitive row
            primitiveRow.appendChild(primitiveLabel);
            primitiveRow.appendChild(toggle);
            primitivesContainer.appendChild(primitiveRow);
            // Ensure the primitives container is visible
            if (primitivesContainer.children.length > 0) {
                primitivesContainer.style.display = 'block';
            }
            // ✅ Store the primitive in `_items`
            const legendPrimitive = {
                name: primitiveName,
                primitive,
                row: primitiveRow
            };
            this._items.push(legendPrimitive);
            seriesEntry.primitives.push(legendPrimitive); // Track it in the series
            return primitiveRow;
        }
        togglePrimitive(primitive, visible) {
            // Check for options in either "options" or "_options"
            const options = primitive.options || primitive._options;
            if (!options) {
                console.warn("Primitive has no options to update.");
                return;
            }
            const updatedOptions = {};
            // Check if the primitive explicitly exposes a "visible" option.
            if ("visible" in options) {
                updatedOptions["visible"] = visible;
                console.log(`Toggling visible option for primitive: ${primitive.constructor.name} to ${visible}`);
                primitive.applyOptions(updatedOptions);
                // Return early since we have applied the simple visible toggle.
                return;
            }
            // Fallback: using color transparency for toggling visibility.
            const transparentColor = "rgba(0,0,0,0)";
            const originalColorsKey = "_originalColors";
            // Initialize storage for original colors if it doesn't exist,
            // checking again on both possible properties.
            if (!primitive[originalColorsKey]) {
                primitive[originalColorsKey] = {};
            }
            const originalColors = primitive[originalColorsKey];
            for (const key of Object.keys(options)) {
                if (key.toLowerCase().includes("color")) {
                    if (!visible) {
                        // Store the original color if we're toggling visibility off.
                        if (!originalColors[key]) {
                            originalColors[key] = options[key];
                        }
                        updatedOptions[key] = transparentColor;
                    }
                    else {
                        // Restore the original color if we're toggling visibility on.
                        updatedOptions[key] = originalColors[key] || options[key];
                    }
                }
            }
            // Apply the updated options if any changes exist.
            if (Object.keys(updatedOptions).length > 0) {
                console.log(`Updating visibility for primitive: ${primitive.constructor.name}`);
                primitive.applyOptions(updatedOptions);
                // Clear the original colors when visibility is restored.
                if (visible) {
                    delete primitive[originalColorsKey];
                }
            }
        }
        findLegendPrimitive(series, primitive) {
            // Find the parent series
            const seriesEntry = this._lines.find(line => line.series === series);
            if (!seriesEntry || !seriesEntry.primitives) {
                return null; // No associated series or no primitives exist
            }
            // Locate the exact primitive inside the series' `primitives` array
            const legendPrimitive = seriesEntry.primitives.find((p) => p.primitive === primitive);
            return legendPrimitive || null;
        }
        /**
        * Converts a LegendItem into a LegendSeries.
        * @param item The LegendItem to map.
        * @returns The mapped LegendSeries object.
        */
        mapToSeries(item) {
            return {
                name: item.name,
                series: item.series,
                group: item.group || undefined,
                legendSymbol: item.legendSymbol || [],
                colors: item.colors || ['#000'],
                seriesType: item.seriesType || 'Line',
                div: document.createElement('div'), // Default element
                row: document.createElement('div'), // Default element
                toggle: document.createElement('div'), // Default element
                extraData: item.extraData || null
            };
        }
        /**
         * Adds a LegendItem to a specified group, creating the group if it doesn't exist.
         * @param item The LegendItem to add.
         * @param groupName The name of the group to add the item to.
         * @returns The HTMLDivElement representing the group's row.
        */
        addItemToGroup(item, groupName) {
            let group = this._groups.find(g => g.name === groupName);
            if (!group) {
                // Create the group and append the series row to the group's container
                return this.makeSeriesGroup(groupName, [item]);
            }
            else {
                group.seriesList.push(item);
                // Create and append the new series row to the group's container
                this.makeSeriesRow(item, group.div);
                return group.row;
            }
        }
        /**
         * Creates a group in the legend with the provided items.
         * @param groupName The name of the group.
         * @param items The LegendItems to include in the group.
         * @returns The HTMLDivElement representing the group's row.
         */
        makeSeriesGroup(groupName, items) {
            let group = this._groups.find(g => g.name === groupName);
            if (group) {
                group.seriesList.push(...items);
                // Append new series to the existing group div
                items.forEach(item => this.makeSeriesRow(item, group.div));
                return group.row;
            }
            else {
                const newGroup = {
                    name: groupName,
                    seriesList: items,
                    subGroups: [],
                    div: document.createElement('div'),
                    row: document.createElement('div'),
                    toggle: document.createElement('div'),
                };
                this._groups.push(newGroup);
                this.renderGroup(newGroup, this.seriesContainer);
                return newGroup.row;
            }
        }
        // legend.ts
        makeSeriesRow(line, container) {
            const row = document.createElement('div');
            row.classList.add('legend-series-row'); // Add CSS class for styling
            // Use flexbox for layout
            row.style.display = 'flex';
            row.style.alignItems = 'center'; // Vertically center items
            row.style.justifyContent = 'space-between'; // Add space between items
            row.style.marginBottom = '4px'; // Optional spacing between rows
            // **Create Action Button for Series**
            const actionButton = document.createElement('button');
            actionButton.classList.add('legend-action-button');
            actionButton.innerHTML = '◇'; // Default Icon
            actionButton.title = 'Series Actions'; // Tooltip for accessibility
            actionButton.style.marginRight = '0px'; // Space between button and info
            actionButton.style.fontSize = '1em'; // Adjust size as needed
            actionButton.style.border = 'none'; // Remove default border
            actionButton.style.background = 'none'; // Remove default background
            actionButton.style.cursor = 'pointer'; // Indicate it's clickable
            actionButton.style.color = '#ffffff';
            // **Attach Click Listener to Action Button**
            actionButton.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent triggering row click events
                event.preventDefault(); // Prevent default button behavior
                // **Toggle Icon Between ◇ and ◈**
                if (actionButton.innerHTML === '◇') {
                    actionButton.innerHTML = '◈'; // Menu is open
                }
                else {
                    actionButton.innerHTML = '◇'; // Menu is closed
                }
                // **Populate and Show LegendMenu**
                this.legendMenu.populateLegendMenu(line, event);
            });
            // **Create Series Info Div**
            const div = document.createElement('div');
            div.classList.add('series-info'); // Add CSS class for styling
            div.style.flex = '1'; // Allow the text to take up available space
            const displayOCvalues = ['Bar', 'Candlestick', 'Ohlc'].includes(line.seriesType || '');
            if (displayOCvalues) {
                const openPrice = '-';
                const closePrice = '-';
                const upSymbol = line.legendSymbol[0] || '▨';
                const downSymbol = line.legendSymbol[1] || upSymbol;
                const upColor = line.colors[0] || '#00FF00';
                const downColor = line.colors[1] || '#FF0000';
                div.innerHTML = `
            <span style="color: ${upColor};">${upSymbol}</span>
            <span style="color: ${downColor};">${downSymbol}</span>
            ${line.name}: <span style="color: ${downColor};">O ${openPrice}</span>, 
            <span style="color: ${upColor};">C ${closePrice}</span>
        `;
            }
            else {
                div.innerHTML = line.legendSymbol
                    .map((symbol, index) => `<span style="color: ${line.colors[index] || line.colors[0]};">${symbol}</span>`)
                    .join(' ') + ` ${line.name}`;
            }
            // **Toggle Visibility Icon**
            const toggle = document.createElement('div');
            toggle.classList.add('legend-toggle-switch');
            toggle.style.cursor = 'pointer'; // Indicate that this is clickable
            // Use flex styling to keep the toggle inline
            toggle.style.display = 'flex';
            toggle.style.alignItems = 'center';
            const onIcon = this.createSvgIcon(openEye);
            const offIcon = this.createSvgIcon(closedEye);
            toggle.appendChild(onIcon.cloneNode(true));
            let visible = true;
            // Add click listener for toggling visibility
            toggle.addEventListener('click', (event) => {
                visible = !visible;
                line.series.applyOptions({ visible });
                toggle.innerHTML = '';
                toggle.appendChild(visible ? onIcon.cloneNode(true) : offIcon.cloneNode(true));
                // Update ARIA attribute
                toggle.setAttribute('aria-pressed', visible.toString());
                // Update toggle state class
                toggle.classList.toggle('inactive', !visible);
                event.stopPropagation();
            });
            // Set initial ARIA attributes
            toggle.setAttribute('role', 'button');
            toggle.setAttribute('aria-label', `Toggle visibility for ${line.name}`);
            toggle.setAttribute('aria-pressed', visible.toString());
            // **Append Elements to the Row**
            row.appendChild(actionButton); // Add Action Button
            row.appendChild(div); // Add text/info div
            row.appendChild(toggle); // Add visibility toggle
            container.appendChild(row); // Append to the provided container
            // **Attach the contextmenu (right-click) listener**
            row.addEventListener("contextmenu", (event) => {
                event.preventDefault(); // Prevent the default browser context menu
                this.legendMenu.populateLegendMenu(line, event); // Populate and show the legend menu
            });
            // Create LegendSeries and store it
            const legendSeries = {
                ...line,
                div, // Assign the created div
                row, // Assign the created row
                toggle, // Assign the created toggle
            };
            this._lines.push(legendSeries);
            this._items.push(legendSeries);
            return row;
        }
        /** Type guard to detect a LegendPrimitive. */
        isLegendPrimitive(entry) {
            return entry.primitive !== undefined
                && entry.row !== undefined;
        }
        /**
     * Deletes a legend entry, either a standalone series or an entire group.
     * @param seriesName The name of the series to delete.
     * @param groupName The name of the group to delete or from which to delete the series.
     */
        deleteLegendEntry(seriesName, groupName) {
            if (groupName && !seriesName) {
                // Remove entire group
                const groupIndex = this._groups.findIndex(group => group.name === groupName);
                if (groupIndex !== -1) {
                    const legendGroup = this._groups[groupIndex];
                    // Remove the group's DOM elements
                    this.seriesContainer.removeChild(legendGroup.row);
                    // Optionally, remove all series in the group from the chart
                    // legendGroup.seriesList.forEach(item => item.series.remove());
                    // Remove from the _groups array
                    this._groups.splice(groupIndex, 1);
                    // Also remove from _items array
                    this._items = this._items.filter(entry => entry !== legendGroup);
                    console.log(`Group "${groupName}" removed.`);
                }
                else {
                    console.warn(`Legend group with name "${groupName}" not found.`);
                }
            }
            else if (seriesName) {
                // Remove individual series
                let removed = false;
                if (groupName) {
                    // Remove from specific group
                    const group = this._groups.find(g => g.name === groupName);
                    if (group) {
                        const itemIndex = group.seriesList.findIndex(item => item.name === seriesName);
                        if (itemIndex !== -1) {
                            // Remove from the group's seriesList
                            group.seriesList.splice(itemIndex, 1);
                            // If the group is now empty, remove it
                            if (group.seriesList.length === 0) {
                                this.seriesContainer.removeChild(group.row);
                                this._groups = this._groups.filter(g => g !== group);
                                this._items = this._items.filter(entry => entry !== group);
                                console.log(`Group "${groupName}" is empty and has been removed.`);
                            }
                            else {
                                // Re-render the group to update its display
                                this.renderGroup(group, this.seriesContainer);
                            }
                            // Optionally, remove the series from the chart
                            // seriesItem.series.remove();
                            removed = true;
                            console.log(`Series "${seriesName}" removed from group "${groupName}".`);
                        }
                    }
                    else {
                        console.warn(`Legend group with name "${groupName}" not found.`);
                    }
                }
                if (!removed) {
                    // Remove from _lines (individual legend items)
                    const seriesIndex = this._lines.findIndex(series => series.name === seriesName);
                    if (seriesIndex !== -1) {
                        const legendSeries = this._lines[seriesIndex];
                        // Remove the DOM elements
                        this.seriesContainer.removeChild(legendSeries.row);
                        // Remove from the _lines array
                        this._lines.splice(seriesIndex, 1);
                        // Also remove from _items array
                        this._items = this._items.filter(entry => entry !== legendSeries);
                        // Optionally, remove the series from the chart
                        // legendSeries.series.remove();
                        removed = true;
                        console.log(`Series "${seriesName}" removed.`);
                    }
                }
                if (!removed) {
                    console.warn(`Legend item with name "${seriesName}" not found.`);
                }
            }
            else {
                console.warn(`No seriesName or groupName provided for deletion.`);
            }
        }
        /** Removes an entire LegendGroup from the legend. */
        removeLegendGroup(group) {
            // Remove from DOM
            if (this.seriesContainer.contains(group.row)) {
                this.seriesContainer.removeChild(group.row);
            }
            // Remove from _groups
            const gIndex = this._groups.indexOf(group);
            if (gIndex !== -1) {
                this._groups.splice(gIndex, 1);
            }
            // Also remove from _items if needed
            this._items = this._items.filter(item => item !== group);
            // Potentially remove each series from the group if you want
            // group.seriesList.forEach( series => { ... } );
            console.log(`Group "${group.name}" removed from legend.`);
        }
        // Helper method to search all possible locations for a series
        findSeriesAnywhere(series) {
            // Check standalone series first
            const standalone = this._lines.find(s => s.series === series);
            if (standalone)
                return standalone;
            // Search through all groups and subgroups
            for (const group of this._groups) {
                const found = this.findSeriesInGroup(group, series);
                if (found)
                    return found;
            }
            return undefined;
        }
        findSeriesInGroup(group, series) {
            // Check current group's series
            const inCurrentGroup = group.seriesList.find(s => s.series === series);
            if (inCurrentGroup)
                return inCurrentGroup;
            // Recursively check subgroups
            for (const subgroup of group.subGroups) {
                const found = this.findSeriesInGroup(subgroup, series);
                if (found)
                    return found;
            }
            return undefined;
        }
        removeSeriesFromGroupDOM(group, series) {
            if (!group.div || !series.row) {
                console.warn(`⚠️ Cannot remove series "${series.name}" – missing group div or series row.`);
                return false;
            }
            // 🚀 1️⃣ Check if the series exists inside the group div
            if (group.div.contains(series.row)) {
                try {
                    group.div.removeChild(series.row);
                    console.log(`✅ Removed series "${series.name}" from group "${group.name}".`);
                    return true; // Successfully removed from this group
                }
                catch (error) {
                    console.warn(`⚠️ Error removing series "${series.name}" from group "${group.name}":`, error);
                    return false;
                }
            }
            // 🚀 2️⃣ Recursively check subgroups
            return group.subGroups.some(subgroup => this.removeSeriesFromGroupDOM(subgroup, series));
        }
        removeLegendSeries(seriesOrLegend) {
            let legendSeries;
            // 🚀 1️⃣ Identify if it's an ISeriesApi or LegendSeries
            if (!isISeriesApi(seriesOrLegend)) {
                legendSeries = seriesOrLegend;
            }
            else {
                legendSeries = this.findSeriesAnywhere(seriesOrLegend);
            }
            if (!legendSeries) {
                console.warn("⚠️ LegendSeries not found in legend.");
                return;
            }
            // 🚀 2️⃣ Remove from tracking arrays
            this._lines = this._lines.filter(s => s !== legendSeries);
            this._items = this._items.filter(item => item !== legendSeries);
            // 🚀 3️⃣ Handle removal from a group OR standalone series
            if (legendSeries.group) {
                const group = this.findGroup(legendSeries.group);
                if (group) {
                    // 🔥 Remove from the group's series list
                    group.seriesList = group.seriesList.filter(item => item !== legendSeries);
                    // ✅ Remove from group's `div` container in the DOM
                    if (legendSeries.row && group.div.contains(legendSeries.row)) {
                        try {
                            group.div.removeChild(legendSeries.row);
                            console.log(`✅ Removed "${legendSeries.name}" from group "${group.name}".`);
                        }
                        catch (error) {
                            console.warn(`⚠️ Error removing "${legendSeries.name}" from group "${group.name}":`, error);
                        }
                    }
                    // ✅ If the group is now empty, remove it
                    if (group.seriesList.length === 0) {
                        this.removeGroupCompletely(group);
                    }
                }
            }
            else {
                // 🚀 4️⃣ Remove Standalone Series from DOM
                if (legendSeries.row?.parentElement) {
                    try {
                        legendSeries.row.parentElement.removeChild(legendSeries.row);
                        console.log(`✅ Removed row for standalone series: ${legendSeries.name}`);
                    }
                    catch (error) {
                        console.warn(`⚠️ Error removing standalone series row:`, error);
                    }
                }
            }
        }
        removeGroupCompletely(group) {
            // Remove group from DOM only if it exists
            if (group.row.parentElement) {
                try {
                    group.row.parentElement.removeChild(group.row);
                }
                catch (error) {
                    console.warn(`Error removing group "${group.name}":`, error);
                }
            }
            // Clean up tracking arrays
            this._groups = this._groups.filter(g => g !== group);
            this._items = this._items.filter(item => item !== group);
            console.log(`Group "${group.name}" removed as it became empty.`);
        }
        removeLegendPrimitive(primitiveOrLegend) {
            let legendPrimitive;
            if (this.isLegendPrimitive(primitiveOrLegend)) {
                // Case 1: It's already a LegendPrimitive
                legendPrimitive = primitiveOrLegend;
            }
            else {
                // Case 2: It's an ISeriesPrimitive, find its corresponding LegendPrimitive
                legendPrimitive = this._items.find((item) => this.isLegendPrimitive(item) && item.primitive === primitiveOrLegend);
            }
            if (!legendPrimitive) {
                console.warn("❌ LegendPrimitive not found in legend.");
                return;
            }
            // ✅ Ensure the row exists before trying to remove it
            if (legendPrimitive.row && legendPrimitive.row.parentElement) {
                legendPrimitive.row.parentElement.removeChild(legendPrimitive.row);
            }
            else {
                console.warn("❌ LegendPrimitive row not found in the DOM.");
            }
            // ✅ Remove primitive from parent series if applicable
            const parentSeries = this._lines.find(s => s.primitives?.includes(legendPrimitive));
            if (parentSeries) {
                parentSeries.primitives = parentSeries.primitives.filter(p => p !== legendPrimitive);
                console.log(`✅ Removed primitive "${legendPrimitive.name}" from series "${parentSeries.name}".`);
            }
            // ✅ Remove from _items
            this._items = this._items.filter(item => item !== legendPrimitive);
            // ✅ Ensure the underlying chart primitive is detached
            if (legendPrimitive.primitive) {
                try {
                    console.log(`Detaching underlying chart primitive for "${legendPrimitive.name}".`);
                    parentSeries?.series.detachPrimitive(legendPrimitive.primitive);
                }
                catch (error) {
                    console.warn(`⚠️ Failed to detach primitive "${legendPrimitive.name}":`, error);
                }
            }
            console.log(`✅ LegendPrimitive "${legendPrimitive.name}" removed from legend.`);
        }
        /**
         * Retrieves the group name of a given series.
         * @param series The series to find the group for.
         * @returns The name of the group, or undefined if not found.
         */
        getGroupOfSeries(series) {
            for (const group of this._groups) {
                const foundGroupName = this.findGroupOfSeriesRecursive(group, series);
                if (foundGroupName) {
                    return foundGroupName;
                }
            }
            return undefined;
        }
        /**
         * Recursively searches for the group containing the target series.
         * @param group The current group to search within.
         * @param targetSeries The series to find.
         * @returns The group name if found, otherwise undefined.
         */
        findGroupOfSeriesRecursive(group, targetSeries) {
            for (const item of group.seriesList) {
                if (item.series === targetSeries) {
                    return group.name;
                }
            }
            for (const subGroup of group.subGroups) {
                const found = this.findGroupOfSeriesRecursive(subGroup, targetSeries);
                if (found) {
                    return found;
                }
            }
            return undefined;
        }
        /**
         * Moves a series from its current group (or standalone) to a target group.
         * If the series is already in a group, it will be moved from its current group to the new one.
         * If the series is standalone, its row is removed from the main container.
         * @param seriesName The name of the series to move.
         * @param targetGroupName The name of the group to move the series into.
         */
        moveSeriesToGroup(seriesName, targetGroupName) {
            // Find the series in _lines (standalone)
            let foundSeriesIndex = this._lines.findIndex(s => s.name === seriesName);
            let foundSeries = null;
            if (foundSeriesIndex !== -1) {
                foundSeries = this._lines[foundSeriesIndex];
            }
            else {
                // If not found in _lines, search within groups
                for (const group of this._groups) {
                    const idx = group.seriesList.findIndex(item => item.name === seriesName);
                    if (idx !== -1) {
                        foundSeries = group.seriesList[idx];
                        // Remove from current group
                        group.seriesList.splice(idx, 1);
                        // If group becomes empty, remove it
                        if (group.seriesList.length === 0) {
                            this.seriesContainer.removeChild(group.row);
                            this._groups = this._groups.filter(g => g !== group);
                            this._items = this._items.filter(entry => entry !== group);
                            console.log(`Group "${group.name}" is empty and has been removed.`);
                        }
                        else {
                            // Re-render the group to update its display
                            this.renderGroup(group, this.seriesContainer);
                        }
                        break;
                    }
                }
            }
            if (!foundSeries) {
                console.warn(`Series "${seriesName}" not found in legend.`);
                return;
            }
            // If found in _lines, remove it from there
            if (foundSeriesIndex !== -1) {
                // Remove from DOM
                this.seriesContainer.removeChild(foundSeries.row);
                this._lines.splice(foundSeriesIndex, 1);
                this._items = this._items.filter(entry => entry !== foundSeries);
            }
            else {
                // If found in a group, its removal was handled above
                this._items = this._items.filter(entry => entry !== foundSeries);
            }
            // Now add to the target group
            let targetGroup = this.findGroup(targetGroupName);
            if (!targetGroup) {
                // Create the target group if it doesn't exist
                targetGroup = {
                    name: targetGroupName,
                    seriesList: [foundSeries],
                    subGroups: [],
                    div: document.createElement('div'),
                    row: document.createElement('div'),
                    toggle: document.createElement('div'),
                };
                this._groups.push(targetGroup);
                this.renderGroup(targetGroup, this.seriesContainer);
            }
            else {
                targetGroup.seriesList.push(foundSeries);
                // Append the series row to the group's div
                this.makeSeriesRow(foundSeries, targetGroup.div);
                // No need to re-render the entire group
            }
            this._items.push(foundSeries);
            console.log(`Series "${seriesName}" moved to group "${targetGroupName}".`);
        }
        // legend.ts
        renderGroup(group, container) {
            // Clear old row content
            group.row.innerHTML = '';
            group.row.style.display = 'flex';
            group.row.style.flexDirection = 'column';
            group.row.style.width = '100%';
            // **Group Header Setup**
            const header = document.createElement('div');
            header.classList.add('group-header'); // Add CSS class for styling
            header.style.display = 'flex'; // Set header layout to flex
            header.style.alignItems = 'center'; // Align items vertically
            header.style.justifyContent = 'space-between'; // Add space between items
            header.style.cursor = 'pointer'; // Make the header clickable
            // **Create Action Button for Group**
            const groupActionButton = document.createElement('button');
            groupActionButton.classList.add('legend-action-button');
            groupActionButton.innerHTML = '◇'; // Default Icon
            groupActionButton.title = 'Group Actions'; // Tooltip for accessibility
            groupActionButton.style.marginRight = '0px'; // Space between button and info
            groupActionButton.style.fontSize = '1em'; // Adjust size as needed
            groupActionButton.style.border = 'none'; // Remove default border
            groupActionButton.style.background = 'none'; // Remove default background
            groupActionButton.style.cursor = 'pointer'; // Indicate it's clickable
            // **Set Group Action Button Color to Match Group Color**
            // Use the first series' primary color or default to black
            groupActionButton.style.color = '#ffffff';
            // **Attach Click Listener to Group Action Button**
            groupActionButton.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent triggering header click events
                event.preventDefault(); // Prevent default button behavior
                // **Toggle Icon Between ◇ and ◈**
                if (groupActionButton.innerHTML === '◇') {
                    groupActionButton.innerHTML = '◈'; // Menu is open
                }
                else {
                    groupActionButton.innerHTML = '◇'; // Menu is closed
                }
                // **Populate and Show LegendMenu**
                this.legendMenu.populateLegendMenu(group, event);
            });
            // **Group Name and Aggregated Symbols**
            const groupNameSpan = document.createElement('span');
            groupNameSpan.style.fontWeight = 'bold';
            groupNameSpan.innerHTML = group.seriesList
                .map(series => series.legendSymbol.map((symbol, index) => `<span style="color: ${series.colors[index] || series.colors[0]};">${symbol}</span>`).join(' '))
                .join(' ') + ` ${group.name}`;
            // **Custom Toggle Button (next to the group name)**
            const toggleButton = document.createElement('span');
            toggleButton.classList.add('toggle-button'); // Add CSS class for styling
            toggleButton.style.marginLeft = 'auto'; // Push button to the far right
            toggleButton.style.fontSize = '1.2em'; // Make the icon size consistent
            toggleButton.style.cursor = 'pointer'; // Indicate it’s clickable
            toggleButton.innerHTML = '⌲'; // Default expanded state
            toggleButton.setAttribute('aria-expanded', 'true'); // Accessibility
            toggleButton.addEventListener('click', (event) => {
                event.stopPropagation();
                if (group.div.style.display === 'none') {
                    group.div.style.display = 'block';
                    toggleButton.innerHTML = '⌲'; // Expanded icon
                    toggleButton.setAttribute('aria-expanded', 'true');
                }
                else {
                    group.div.style.display = 'none';
                    toggleButton.innerHTML = '☰'; // Collapsed icon
                    toggleButton.setAttribute('aria-expanded', 'false');
                }
            });
            // **Append Group Action Button and Group Name to Header**
            header.appendChild(groupActionButton); // Add Action Button
            header.appendChild(groupNameSpan);
            header.appendChild(toggleButton);
            // **Attach context menu listener to the group header**
            header.addEventListener("contextmenu", (event) => {
                event.preventDefault(); // Prevent the default browser context menu
                this.legendMenu.populateLegendMenu(group, event); // Populate and show the legend menu
            });
            // **Append Header to the Group Row**
            group.row.appendChild(header);
            // **Container for the Group's Items (Series Rows)**
            group.div = document.createElement('div');
            group.div.style.display = 'block';
            group.div.style.marginLeft = '10px'; // Indent for group items
            // **Render Each Series within the Group**
            for (const s of group.seriesList) {
                this.makeSeriesRow(s, group.div);
            }
            // **Render Subgroups Recursively**
            for (const subG of group.subGroups) {
                const subContainer = document.createElement('div');
                subContainer.style.display = 'flex';
                subContainer.style.flexDirection = 'column';
                subContainer.style.paddingLeft = '5px'; // Indent for nested groups
                this.renderGroup(subG, subContainer);
                group.div.appendChild(subContainer);
            }
            // **Append the Group's Items Container to the Group Row**
            group.row.appendChild(group.div);
            // **Append the Group Row to the Container if Not Already Present**
            if (!container.contains(group.row)) {
                container.appendChild(group.row);
            }
            // **Prevent Default Context Menu on the Group Row**
            group.row.oncontextmenu = (event) => {
                event.preventDefault();
            };
        }
        /**
         * Handles crosshair movement events to update the legend display.
         * @param param The mouse event parameters.
         * @param usingPoint Determines whether to use logical indexing.
         */
        legendHandler(param, usingPoint = false) {
            let logical = null;
            //
            //if (usingPoint) {
            //    const timeScale = this.handler.chart.timeScale();
            //    let coordinate = timeScale.timeToCoordinate(param.time)
            //    if (coordinate)
            //        logical = timeScale.coordinateToLogical(coordinate.valueOf())
            //    if (logical)
            //        data = this.handler.series.dataByIndex(logical.valueOf())
            //}
            //else {
            //    data = param.seriesData.get(this.handler.series);
            //}
            //
            //this.candle.style.color = ''
            //let str = '<span style="line-height: 1.8;">'
            //if (data) {
            //    if (this.ohlcEnabled) {
            //        str += `O ${this.legendItemFormat(data.open, this.handler.precision)} `;
            //        str += `| H ${this.legendItemFormat(data.high, this.handler.precision)} `;
            //        str += `| L ${this.legendItemFormat(data.low, this.handler.precision)} `;
            //        str += `| C ${this.legendItemFormat(data.close, this.handler.precision)} `;
            //    }
            //
            //    // Display percentage move if enabled
            //    if (this.percentEnabled) {
            //        const percentMove = ((data.close - data.open) / data.open) * 100;
            //        const color = percentMove > 0 ? options['upColor'] : options['downColor'];
            //        const percentStr = `${percentMove >= 0 ? '+' : ''}${percentMove.toFixed(2)} %`;
            //        str += this.colorBasedOnCandle ? `| <span style="color: ${color};">${percentStr}</span>` : `| ${percentStr}`;
            //    }
            //}
            //
            //this.candle.innerHTML = str + '</span>';
            // Update group legend and series legend
            this.updateGroupDisplay(param, logical, usingPoint);
            this.updateSeriesDisplay(param, logical, usingPoint);
        }
        updateSeriesDisplay(param, logical, usingPoint) {
            if (!this._lines || !this._lines.length) {
                console.error("No lines available to update legend.");
                return;
            }
            this._lines.forEach((e) => {
                const data = param.seriesData.get(e.series) || getLastData(e.series);
                if (!data) {
                    return;
                }
                const seriesType = e.seriesType || 'Line';
                const priceFormat = e.series.options().priceFormat;
                if (seriesType === 'Line' || seriesType === 'Area') {
                    const valueData = data;
                    if (valueData.value == null) {
                        return;
                    }
                    const value = this.legendItemFormat(valueData.value, priceFormat.precision);
                    e.div.innerHTML = `
                    <span style="color: ${e.colors[0]};">${e.legendSymbol[0] || '▨'}</span> 
                    ${e.name}: ${value}`;
                }
                else if (seriesType === 'Bar' || seriesType === 'Candlestick' || seriesType === 'Ohlc') {
                    const { open, close } = data;
                    if (open == null || close == null) {
                        return;
                    }
                    const openPrice = this.legendItemFormat(open, priceFormat.precision);
                    const closePrice = this.legendItemFormat(close, priceFormat.precision);
                    const isUp = close > open;
                    const color = isUp ? e.colors[0] : e.colors[1];
                    const symbol = isUp ? e.legendSymbol[0] : e.legendSymbol[1];
                    e.div.innerHTML = `
                    <span style="color: ${color};">${symbol || '▨'}</span>
                    ${e.name}: 
                    <span style="color: ${color};">O ${openPrice}</span>, 
                    <span style="color: ${color};">C ${closePrice}</span>`;
                }
            });
        }
        /**
         * Updates the display for grouped series based on the crosshair position.
         * @param param The mouse event parameters.
         * @param logical The logical index of the data point.
         * @param usingPoint Determines whether to use logical indexing.
         */
        updateGroupDisplay(param, logical, usingPoint) {
            this._groups.forEach((group) => {
                if (!this.linesEnabled) {
                    group.row.style.display = 'none';
                    return;
                }
                group.row.style.display = 'flex';
                // Iterate through each series in the group and update its display
                group.seriesList.forEach((seriesItem) => {
                    const data = param.seriesData.get(seriesItem.series) || getLastData(seriesItem.series);
                    if (!data) {
                        return;
                    }
                    const seriesType = seriesItem.seriesType || 'Line';
                    const name = seriesItem.name;
                    const priceFormat = seriesItem.series.options().priceFormat;
                    // Check if the series type supports OHLC values
                    const isOHLC = ['Bar', 'Candlestick', 'Ohlc'].includes(seriesType);
                    if (isOHLC) {
                        const { open, close, high, low } = data;
                        if (open == null || close == null || high == null || low == null) {
                            return;
                        }
                        const openPrice = this.legendItemFormat(open, priceFormat.precision);
                        const closePrice = this.legendItemFormat(close, priceFormat.precision);
                        const isUp = close > open;
                        const color = isUp ? seriesItem.colors[0] : seriesItem.colors[1];
                        const symbol = isUp ? seriesItem.legendSymbol[0] : seriesItem.legendSymbol[1];
                        seriesItem.div.innerHTML = `
                        <span style="color: ${color};">${symbol || '▨'}</span>
                        ${name}: 
                        <span style="color: ${color};">O ${openPrice}</span>, 
                        <span style="color: ${color};">C ${closePrice}</span>
                    `;
                    }
                    else {
                        // Handle series types with a single 'value' property
                        const valueData = data;
                        const value = 'value' in valueData ? valueData.value : undefined;
                        if (value == null) {
                            return;
                        }
                        const formattedValue = this.legendItemFormat(value, priceFormat.precision);
                        const color = seriesItem.colors[0];
                        const symbol = seriesItem.legendSymbol[0] || '▨';
                        seriesItem.div.innerHTML = `
                        <span style="color: ${color};">${symbol}</span>
                        ${name}: ${formattedValue}
                    `;
                    }
                });
            });
        }
        /**
         * Finds a group by name within the legend hierarchy.
         * @param groupName The name of the group to find.
         * @param groups The current group list to search within.
         * @returns The LegendGroup if found, undefined otherwise.
         */
        findGroup(groupName, groups = this._groups) {
            for (const group of groups) {
                if (group.name === groupName) {
                    return group;
                }
                const foundInSub = this.findGroup(groupName, group.subGroups);
                if (foundInSub) {
                    return foundInSub;
                }
            }
            return undefined;
        }
    }

    const defaultOptions$3 = {
        lineColor: '#1E80F0',
        lineStyle: lightweightCharts.LineStyle.Solid,
        width: 4,
    };

    var InteractionState;
    (function (InteractionState) {
        InteractionState[InteractionState["NONE"] = 0] = "NONE";
        InteractionState[InteractionState["HOVERING"] = 1] = "HOVERING";
        InteractionState[InteractionState["DRAGGING"] = 2] = "DRAGGING";
        InteractionState[InteractionState["DRAGGINGP1"] = 3] = "DRAGGINGP1";
        InteractionState[InteractionState["DRAGGINGP2"] = 4] = "DRAGGINGP2";
        InteractionState[InteractionState["DRAGGINGP3"] = 5] = "DRAGGINGP3";
        InteractionState[InteractionState["DRAGGINGP4"] = 6] = "DRAGGINGP4";
    })(InteractionState || (InteractionState = {}));
    class Drawing extends PluginBase {
        _paneViews = [];
        _options;
        _points = [];
        _state = InteractionState.NONE;
        _startDragPoint = null;
        _latestHoverPoint = null;
        static _mouseIsDown = false;
        static hoveredObject = null;
        static lastHoveredObject = null;
        _listeners = [];
        constructor(options) {
            super();
            this._options = {
                ...defaultOptions$3,
                ...options,
            };
        }
        updateAllViews() {
            this._paneViews.forEach(pw => pw.update());
        }
        paneViews() {
            return this._paneViews;
        }
        applyOptions(options) {
            this._options = {
                ...this._options,
                ...options,
            };
            this.requestUpdate();
        }
        updatePoints(...points) {
            for (let i = 0; i < this.points.length; i++) {
                if (points[i] == null)
                    continue;
                this.points[i] = points[i];
            }
            this.requestUpdate();
        }
        detach() {
            this._options.lineColor = 'transparent';
            this.requestUpdate();
            this.series.detachPrimitive(this);
            for (const s of this._listeners) {
                document.body.removeEventListener(s.name, s.listener);
            }
        }
        get points() {
            return this._points;
        }
        _subscribe(name, listener) {
            document.body.addEventListener(name, listener);
            this._listeners.push({ name: name, listener: listener });
        }
        _unsubscribe(name, callback) {
            document.body.removeEventListener(name, callback);
            const toRemove = this._listeners.find((x) => x.name === name && x.listener === callback);
            this._listeners.splice(this._listeners.indexOf(toRemove), 1);
        }
        _handleHoverInteraction(param) {
            this._latestHoverPoint = param.point;
            if (Drawing._mouseIsDown) {
                this._handleDragInteraction(param);
            }
            else {
                if (this._mouseIsOverDrawing(param)) {
                    if (this._state != InteractionState.NONE)
                        return;
                    this._moveToState(InteractionState.HOVERING);
                    Drawing.hoveredObject = Drawing.lastHoveredObject = this;
                }
                else {
                    if (this._state == InteractionState.NONE)
                        return;
                    this._moveToState(InteractionState.NONE);
                    if (Drawing.hoveredObject === this)
                        Drawing.hoveredObject = null;
                }
            }
        }
        static _eventToPoint(param, series) {
            if (!series || !param.point || !param.logical)
                return null;
            const barPrice = series.coordinateToPrice(param.point.y);
            if (barPrice == null)
                return null;
            return {
                time: param.time || null,
                logical: param.logical,
                price: barPrice.valueOf(),
            };
        }
        static _getDiff(p1, p2) {
            const diff = {
                logical: p1.logical - p2.logical,
                price: p1.price - p2.price,
            };
            return diff;
        }
        _addDiffToPoint(point, logicalDiff, priceDiff) {
            if (!point)
                return;
            point.logical = point.logical + logicalDiff;
            point.price = point.price + priceDiff;
            point.time = this.series.dataByIndex(point.logical)?.time || null;
        }
        _handleMouseDownInteraction = () => {
            // if (Drawing._mouseIsDown) return;
            Drawing._mouseIsDown = true;
            this._onMouseDown();
        };
        _handleMouseUpInteraction = () => {
            // if (!Drawing._mouseIsDown) return;
            Drawing._mouseIsDown = false;
            this._moveToState(InteractionState.HOVERING);
        };
        _handleDragInteraction(param) {
            if (this._state != InteractionState.DRAGGING &&
                this._state != InteractionState.DRAGGINGP1 &&
                this._state != InteractionState.DRAGGINGP2 &&
                this._state != InteractionState.DRAGGINGP3 &&
                this._state != InteractionState.DRAGGINGP4) {
                return;
            }
            const mousePoint = Drawing._eventToPoint(param, this.series);
            if (!mousePoint)
                return;
            this._startDragPoint = this._startDragPoint || mousePoint;
            const diff = Drawing._getDiff(mousePoint, this._startDragPoint);
            this._onDrag(diff);
            this.requestUpdate();
            this._startDragPoint = mousePoint;
        }
    }

    function buildOptions(optionPath, value) {
        const keys = optionPath.split(".");
        const options = {};
        let current = options;
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (i === keys.length - 1) {
                current[key] = value;
            }
            else {
                current[key] = {};
                current = current[key];
            }
        }
        return options;
    }
    /**
     * Utility function to convert camelCase to Title Case
     * @param inputString The camelCase string.
     * @returns The Title Case string.
     */
    function camelToTitle(inputString) {
        return inputString
            .replace(/([A-Z])/g, " $1")
            .replace(/^./, (str) => str.toUpperCase());
    }
    /**
     * Converts points between DrawingPoint (logical/price coordinates)
     * and CanvasPoint (pixel coordinates).
     *
     * @param point - A DrawingPoint or a CanvasPoint.
     * @param chart - The chart API providing time scale conversions.
     * @param series - The series API for y-axis conversions (price ↔ canvas coordinates).
     * @returns The converted point or null if conversion fails.
     */
    function convertPoint(point, chart, series) {
        const timeScale = chart.timeScale();
        const targetSeries = series ?? chart.addSeries(lightweightCharts.LineSeries); // Fallback to adding a new series if one wasn't provided
        if (!targetSeries) {
            console.warn('No series found. Cannot perform y-axis conversions.');
            return null;
        }
        // Determine if the input point is a DrawingPoint by checking for the "logical" property.
        const isDrawingPoint = 'logical' in point;
        if (isDrawingPoint) {
            // Convert DrawingPoint to CanvasPoint:
            const drawingPoint = point;
            const canvasX = timeScale.logicalToCoordinate(drawingPoint.logical);
            const canvasY = targetSeries.priceToCoordinate(drawingPoint.price);
            if (canvasX === null || canvasY === null)
                return null;
            return { x: canvasX, y: canvasY };
        }
        else {
            // Convert CanvasPoint to DrawingPoint:
            const canvasPoint = point;
            const logical = timeScale.coordinateToLogical(canvasPoint.x);
            const time = timeScale.coordinateToTime(canvasPoint.x);
            const price = targetSeries.coordinateToPrice(canvasPoint.y);
            if (logical === null || price === null)
                return null;
            // Note: Since the original DrawingPoint interface optionally includes a time property,
            // we are returning an object with just logical and price.
            return { time, logical, price };
        }
    } /**
     * Converts an object to JSON while filtering out circular references.
     * This helper uses a WeakSet to track seen objects.
     *
     * @param obj The object to stringify.
     * @returns A JSON string.
     */

    /**
     * Draws a rectangle-shaped candle.
     * @param ctx - The canvas rendering context.
     * @param leftSide - The X-coordinate of the left edge of the candle.
     * @param rightSide - The X-coordinate of the right edge of the candle.
     * @param yCenter - The Y-coordinate of the center of the candle.
     * @param candleHeight - The height of the candle in pixels.
     */
    function ohlcRectangle(ctx, leftSide, rightSide, yCenter, candleHeight) {
        const topEdge = yCenter - candleHeight / 2;
        const bottomEdge = yCenter + candleHeight / 2;
        // Begin drawing the candle rectangle.
        ctx.beginPath();
        ctx.moveTo(leftSide, topEdge);
        ctx.lineTo(leftSide, bottomEdge);
        ctx.lineTo(rightSide, bottomEdge);
        ctx.lineTo(rightSide, topEdge);
        ctx.closePath();
        // Fill and stroke the rectangle.
        ctx.fill();
        ctx.stroke();
    }
    /**
     * Draws a rounded rectangle-shaped candle with clamped corner radius.
     * @param ctx - The canvas rendering context.
     * @param leftSide - The X-coordinate of the left edge of the candle.
     * @param rightSide - The X-coordinate of the right edge of the candle.
     * @param yCenter - The Y-coordinate of the center of the candle.
     * @param candleHeight - The height of the candle in pixels.
     * @param radius - A float from 0..1 that we clamp to an appropriate max.
     */
    function ohlcRounded(ctx, leftSide, rightSide, yCenter, candleHeight, radius) {
        const width = rightSide - leftSide;
        // Optionally clamp radius if it's supposed to be 0..1
        const rawRadius = radius * Math.min(Math.abs(width), Math.abs(candleHeight));
        const effectiveRadius = Math.abs(Math.min(rawRadius, width / 2, candleHeight / 2));
        const topEdge = yCenter - candleHeight / 2;
        ctx.beginPath();
        if (typeof ctx.roundRect === 'function') {
            ctx.roundRect(leftSide, topEdge, width, candleHeight, effectiveRadius);
        }
        else {
            // Fallback: manually draw arcs or just do rect
            ctx.moveTo(leftSide + effectiveRadius, topEdge);
            ctx.lineTo(rightSide - effectiveRadius, topEdge);
            ctx.quadraticCurveTo(rightSide, topEdge, rightSide, topEdge + effectiveRadius);
            ctx.lineTo(rightSide, topEdge + candleHeight - effectiveRadius);
            ctx.quadraticCurveTo(rightSide, topEdge + candleHeight, rightSide - effectiveRadius, topEdge + candleHeight);
            ctx.lineTo(leftSide + effectiveRadius, topEdge + candleHeight);
            ctx.quadraticCurveTo(leftSide, topEdge + candleHeight, leftSide, topEdge + candleHeight - effectiveRadius);
            ctx.lineTo(leftSide, topEdge + effectiveRadius);
            ctx.quadraticCurveTo(leftSide, topEdge, leftSide + effectiveRadius, topEdge);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }
    /**
     * Draws an ellipse-shaped candle.
     * @param ctx - The canvas rendering context.
     * @param xCenter - The X-coordinate of the center of the ellipse.
     * @param yCenter - The Y-coordinate of the center of the ellipse.
     * @param candleWidth - The width of the ellipse in pixels.
     * @param candleHeight - The height of the ellipse in pixels.
     */
    function ohlcEllipse(ctx, leftSide, rightSide, middle, yCenter, candleHeight) {
        const xCenter = leftSide + (rightSide - leftSide) / 2;
        const candleWidth = rightSide - leftSide;
        ctx.beginPath();
        ctx.ellipse(xCenter, // X-coordinate of the center.
        yCenter, // Y-coordinate of the center.
        Math.abs(candleWidth / 2), // Horizontal radius.
        Math.abs(candleHeight / 2), // Vertical radius.
        0, // Rotation angle.
        0, // Start angle.
        Math.PI * 2 // End angle.
        );
        ctx.fill();
        ctx.stroke();
    }
    /**
     * Draws a 3D-shaped candle, providing a depth effect.
     * @param ctx - The canvas rendering context.
     * @param xCenter - The X-coordinate of the candle's center.
     * @param yHigh - The Y-coordinate of the highest point of the candle.
     * @param yLow - The Y-coordinate of the lowest point of the candle.
     * @param yOpen - The Y-coordinate of the opening price.
     * @param yClose - The Y-coordinate of the closing price.
     * @param candleWidth - The width of the candle.
     * @param combinedWidth - The combined width for depth effect.
     * @param fillColor - The fill color of the candle.
     * @param borderColor - The border color of the candle.
     * @param isUp - Indicates if the candle is upward-moving.
     * @param barSpacing - The spacing factor between bars.
     */
    function ohlc3d(ctx, xCenter, yHigh, yLow, yOpen, yClose, candleWidth, combinedWidth, fillColor, borderColor, isUp, barSpacing) {
        const xOffset = -Math.max(combinedWidth, 1) * (1 - barSpacing);
        const insideColor = darkenColor(fillColor, 0.666); // Darker side color
        const sideColor = darkenColor(fillColor, 0.333);
        const topColor = darkenColor(fillColor, 0.2); // Slightly lighter top face
        // Calculate front face X coordinates using candleWidth
        const frontLeftX = xCenter - candleWidth / 2;
        const frontRightX = frontLeftX + combinedWidth + xOffset;
        // Calculate back face X coordinates with combined width for depth effect
        const backLeftX = frontLeftX - xOffset;
        const backRightX = frontRightX - xOffset;
        // Set Y coordinates for front and back faces based on candle direction
        let frontTop, frontBottom, backTop, backBottom;
        if (!isUp) {
            // Up candle: front face uses open/high, back face uses low/close
            frontTop = yOpen;
            frontBottom = yHigh;
            backTop = yLow;
            backBottom = yClose;
        }
        else {
            // Down candle: front face uses open/low, back face uses high/close
            frontTop = yOpen;
            frontBottom = yLow;
            backTop = yHigh;
            backBottom = yClose;
        }
        // Draw back (shadow) rectangle
        ctx.fillStyle = sideColor;
        ctx.strokeStyle = borderColor;
        ctx.beginPath();
        ctx.rect(backLeftX, backTop, combinedWidth + xOffset - candleWidth / 2, backBottom - backTop);
        ctx.fill();
        ctx.stroke();
        // Draw top face between front and back
        ctx.fillStyle = topColor;
        if (isUp) {
            // Draw bottom face first for up candles
            ctx.fillStyle = insideColor;
            ctx.beginPath();
            ctx.moveTo(frontLeftX, frontBottom); // Bottom-left corner at the front
            ctx.lineTo(backLeftX, backBottom); // Bottom-left corner at the back
            ctx.lineTo(backRightX, backBottom); // Bottom-right corner at the back
            ctx.lineTo(frontRightX, frontBottom); // Bottom-right corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Draw left side face for up candles
            ctx.fillStyle = insideColor;
            ctx.beginPath();
            ctx.moveTo(frontLeftX, frontTop); // Top-left corner at the front
            ctx.lineTo(backLeftX, backTop); // Top-left corner at the back
            ctx.lineTo(backLeftX, backBottom); // Bottom-left corner at the back
            ctx.lineTo(frontLeftX, frontBottom); // Bottom-left corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Draw right side face for up candles
            ctx.fillStyle = insideColor;
            ctx.beginPath();
            ctx.moveTo(frontRightX, frontTop); // Top-right corner at the front
            ctx.lineTo(backRightX, backTop); // Top-right corner at the back
            ctx.lineTo(backRightX, backBottom); // Bottom-right corner at the back
            ctx.lineTo(frontRightX, frontBottom); // Bottom-right corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Draw top face last for up candles
            ctx.fillStyle = topColor;
            ctx.beginPath();
            ctx.moveTo(frontLeftX, frontTop); // Top-left corner at the front
            ctx.lineTo(backLeftX, backTop); // Top-left corner at the back
            ctx.lineTo(backRightX, backTop); // Top-right corner at the back
            ctx.lineTo(frontRightX, frontTop); // Top-right corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        else {
            // Draw top face first for down candles
            ctx.fillStyle = topColor;
            ctx.beginPath();
            ctx.moveTo(frontLeftX, frontTop); // Top-left corner at the front
            ctx.lineTo(backLeftX, backTop); // Top-left corner at the back
            ctx.lineTo(backRightX, backTop); // Top-right corner at the back
            ctx.lineTo(frontRightX, frontTop); // Top-right corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Draw right side face for down candles
            ctx.fillStyle = sideColor;
            ctx.beginPath();
            ctx.moveTo(frontRightX, frontTop); // Top-right corner at the front
            ctx.lineTo(backRightX, backTop); // Top-right corner at the back
            ctx.lineTo(backRightX, backBottom); // Bottom-right corner at the back
            ctx.lineTo(frontRightX, frontBottom); // Bottom-right corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Draw left side face for down candles
            ctx.fillStyle = sideColor;
            ctx.beginPath();
            ctx.moveTo(frontLeftX, frontTop); // Top-left corner at the front
            ctx.lineTo(backLeftX, backTop); // Top-left corner at the back
            ctx.lineTo(backLeftX, backBottom); // Bottom-left corner at the back
            ctx.lineTo(frontLeftX, frontBottom); // Bottom-left corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Draw bottom face last for down candles
            ctx.fillStyle = sideColor;
            ctx.beginPath();
            ctx.moveTo(frontLeftX, frontBottom); // Bottom-left corner at the front
            ctx.lineTo(backLeftX, backBottom); // Bottom-left corner at the back
            ctx.lineTo(backRightX, backBottom); // Bottom-right corner at the back
            ctx.lineTo(frontRightX, frontBottom); // Bottom-right corner at the front
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
    }
    /**
     * Draws a polygon-shaped candle.
     * @param ctx - The canvas rendering context.
     * @param leftSide - The X-coordinate of the left edge of the polygon.
     * @param rightSide - The X-coordinate of the right edge of the polygon.
     * @param yCenter - The Y-coordinate of the center of the polygon.
     * @param candleHeight - The height of the polygon in pixels.
     * @param highY - The Y-coordinate of the highest point of the polygon.
     * @param lowY - The Y-coordinate of the lowest point of the polygon.
     * @param isUp - Indicates if the polygon points upwards.
     */
    function ohlcPolygon(ctx, leftSide, rightSide, yCenter, candleHeight, highY, lowY, isUp) {
        const openCloseTop = yCenter + candleHeight / 2;
        const openCloseBottom = yCenter - candleHeight / 2;
        // Save the current canvas state before drawing.
        ctx.save();
        ctx.beginPath();
        if (isUp) {
            // Define the path for an upward-pointing polygon.
            ctx.moveTo(leftSide, openCloseTop);
            ctx.lineTo(rightSide, highY);
            ctx.lineTo(rightSide, openCloseBottom);
            ctx.lineTo(leftSide, lowY);
        }
        else {
            // Define the path for a downward-pointing polygon.
            ctx.moveTo(leftSide, highY);
            ctx.lineTo(rightSide, openCloseTop);
            ctx.lineTo(rightSide, lowY);
            ctx.lineTo(leftSide, openCloseBottom);
        }
        // Complete the path and apply styles.
        ctx.closePath();
        ctx.stroke();
        ctx.fill();
        // Restore the canvas state after drawing.
        ctx.restore();
    }
    /**
     * Draws an arrow-shaped candle.
     * @param ctx - The canvas rendering context.
     * @param leftSide - The X-coordinate of the left edge of the arrow.
     * @param rightSide - The X-coordinate of the right edge of the arrow.
     * @param middle - The X-coordinate of the tip of the arrow.
     * @param yCenter - The Y-coordinate of the center of the arrow.
     * @param candleHeight - The height of the arrow in pixels.
     * @param highY - The Y-coordinate of the highest point of the arrow.
     * @param lowY - The Y-coordinate of the lowest point of the arrow.
     * @param isUp - Indicates if the arrow points upwards.
     */
    function ohlcArrow(ctx, leftSide, rightSide, middle, yCenter, candleHeight, highY, lowY, isUp) {
        // Save the current canvas state before drawing.
        ctx.save();
        ctx.beginPath();
        if (isUp) {
            // Define the path for an upward-pointing arrow.
            ctx.moveTo(leftSide, lowY);
            ctx.lineTo(leftSide, yCenter + candleHeight / 2);
            ctx.lineTo(middle, highY);
            ctx.lineTo(rightSide, yCenter + candleHeight / 2);
            ctx.lineTo(rightSide, lowY);
            ctx.lineTo(middle, yCenter - candleHeight / 2);
            ctx.lineTo(leftSide, lowY);
        }
        else {
            // Define the path for a downward-pointing arrow.
            ctx.moveTo(leftSide, highY);
            ctx.lineTo(leftSide, yCenter - candleHeight / 2);
            ctx.lineTo(middle, lowY);
            ctx.lineTo(rightSide, yCenter - candleHeight / 2);
            ctx.lineTo(rightSide, highY);
            ctx.lineTo(middle, yCenter + candleHeight / 2);
            ctx.lineTo(leftSide, highY);
        }
        // Complete the path and apply styles.
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        // Restore the canvas state after drawing.
        ctx.restore();
    }
    /**
     * Draws a traditional OHLC bar using leftSide and rightSide coordinates.
     *
     * The vertical line is drawn at the midpoint between leftSide and rightSide,
     * spanning from the high to the low. An open tick is drawn from leftSide to the center
     * at the open price, and a close tick is drawn from the center to rightSide at the close price.
     *
     * @param ctx - The canvas rendering context.
     * @param leftSide - The X-coordinate for the left edge of the bar.
     * @param rightSide - The X-coordinate for the right edge of the bar.
     * @param high - The Y-coordinate for the high price.
     * @param low - The Y-coordinate for the low price.
     * @param open - The Y-coordinate for the open price.
     * @param close - The Y-coordinate for the close price.
     */
    function ohlcBar(ctx, leftSide, rightSide, high, low, open, close) {
        // Compute the center X coordinate of the bar.
        const centerX = (leftSide + rightSide) / 2;
        // Draw the vertical line (from high to low) at the center.
        ctx.beginPath();
        ctx.moveTo(centerX, high);
        ctx.lineTo(centerX, low);
        ctx.stroke();
        // Draw the open tick from leftSide to center at the open price.
        ctx.beginPath();
        ctx.moveTo(leftSide, open);
        ctx.lineTo(centerX, open);
        ctx.stroke();
        // Draw the close tick from center to rightSide at the close price.
        ctx.beginPath();
        ctx.moveTo(centerX, close);
        ctx.lineTo(rightSide, close);
        ctx.stroke();
    }
    function ohlcSlanted(ctx, leftSide, rightSide, yCenter, candleHeight, isUp) {
        // Calculate the top and bottom edges of the candle.
        const topY = yCenter - candleHeight / 2;
        const bottomY = yCenter + candleHeight / 2;
        // Optional: You can tweak the slantOffset to control how "tilted" the parallelogram is.
        const slantOffset = Math.abs(rightSide - leftSide) * 0.9;
        // Save the current canvas state before drawing.
        ctx.save();
        ctx.beginPath();
        if (isUp) {
            // Forward slash (/): top-left to top-right is left-aligned,
            // bottom-left to bottom-right is right-aligned.
            ctx.moveTo(leftSide, topY);
            ctx.lineTo(leftSide + slantOffset, topY);
            ctx.lineTo(rightSide, bottomY);
            ctx.lineTo(rightSide - slantOffset, bottomY);
        }
        else {
            // Backslash (\): top-left to top-right is right-aligned,
            // bottom-left to bottom-right is left-aligned.
            ctx.moveTo(rightSide - slantOffset, topY);
            ctx.lineTo(rightSide, topY);
            ctx.lineTo(leftSide + slantOffset, bottomY);
            ctx.lineTo(leftSide, bottomY);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }

    class DrawingPaneRenderer {
        _options;
        constructor(options) {
            this._options = options;
        }
    }
    class TwoPointDrawingPaneRenderer extends DrawingPaneRenderer {
        _p1;
        _p2;
        _hovered;
        constructor(p1, p2, options, hovered) {
            super(options);
            this._p1 = p1;
            this._p2 = p2;
            this._hovered = hovered;
        }
        _getScaledCoordinates(scope) {
            if (this._p1.x === null || this._p1.y === null ||
                this._p2.x === null || this._p2.y === null)
                return null;
            return {
                x1: Math.round(this._p1.x * scope.horizontalPixelRatio),
                y1: Math.round(this._p1.y * scope.verticalPixelRatio),
                x2: Math.round(this._p2.x * scope.horizontalPixelRatio),
                y2: Math.round(this._p2.y * scope.verticalPixelRatio),
            };
        }
        // _drawTextLabel(scope: BitmapCoordinatesRenderingScope, text: string, x: number, y: number, left: boolean) {
        //  scope.context.font = '24px Arial';
        //  scope.context.beginPath();
        //  const offset = 5 * scope.horizontalPixelRatio;
        //  const textWidth = scope.context.measureText(text);
        //  const leftAdjustment = left ? textWidth.width + offset * 4 : 0;
        //  scope.context.fillStyle = this._options.labelBackgroundColor;
        //  scope.context.roundRect(x + offset - leftAdjustment, y - 24, textWidth.width + offset * 2,  24 + offset, 5);
        //  scope.context.fill();
        //  scope.context.beginPath();
        //  scope.context.fillStyle = this._options.labelTextColor;
        //  scope.context.fillText(text, x + offset * 2 - leftAdjustment, y);
        // }
        _drawEndCircle(scope, x, y) {
            const radius = 9;
            scope.context.fillStyle = '#000';
            scope.context.beginPath();
            scope.context.arc(x, y, radius, 0, 2 * Math.PI);
            scope.context.stroke();
            scope.context.fill();
            // scope.context.strokeStyle = this._options.lineColor;
        }
    }
    class ThreePointDrawingPaneRenderer extends DrawingPaneRenderer {
        _p1;
        _p2;
        _p3;
        _hovered;
        constructor(p1, p2, p3, options, hovered) {
            super(options);
            this._p1 = p1;
            this._p2 = p2;
            this._p3 = p3;
            this._hovered = hovered;
        }
        _getScaledCoordinates(scope) {
            if (this._p1.x === null || this._p1.y === null ||
                this._p2.x === null || this._p2.y === null ||
                this._p3.x === null || this._p3.y === null)
                return null;
            return {
                x1: Math.round(this._p1.x * scope.horizontalPixelRatio),
                y1: Math.round(this._p1.y * scope.verticalPixelRatio),
                x2: Math.round(this._p2.x * scope.horizontalPixelRatio),
                y2: Math.round(this._p2.y * scope.verticalPixelRatio),
                x3: Math.round(this._p3.x * scope.horizontalPixelRatio),
                y3: Math.round(this._p3.y * scope.verticalPixelRatio),
            };
        }
        _drawEndCircle(scope, x, y) {
            const radius = 9;
            scope.context.fillStyle = '#000';
            scope.context.beginPath();
            scope.context.arc(x, y, radius, 0, 2 * Math.PI);
            scope.context.stroke();
            scope.context.fill();
        }
    }

    const tradeDefaultOptions = {
        ...lightweightCharts.customSeriesDefaultOptions,
        side: 'long',
        mode: 'relative',
        auto: false,
        entryColor: '#FFFF00',
        stopColor: '#FF0000',
        targetColor: '#00FF00',
        backgroundColorStop: 'rgba(255,0,0,0.25)',
        backgroundColorTarget: 'rgba(0,255,0,0.25)',
        lineWidth: 1,
        lineStyle: 3, // Default to solid
        partialClosureLineColor: '#FFFFFF',
        partialClosureLineWidth: 1,
        partialClosureLineDash: [4, 2],
        infoTextColor: '#FFFFFF',
        infoFont: '12px Arial',
        positionChangeColor: '#FFFFFF'
    };

    function decorateSeries(original, legend // Optional Legend instance to handle primitives
    ) {
        // Check if the series is already decorated
        if (original._isDecorated) {
            console.warn("Series is already decorated. Skipping decoration.");
            return original;
        }
        // Mark the series as decorated
        original._isDecorated = true;
        const decorated = true;
        const originalSetData = original.setData.bind(original);
        // Array to store attached primitives
        const primitives = [];
        // Reference to the most recently attached primitive
        let lastAttachedPrimitive = null;
        // Hook into the original `detachPrimitive` if it exists
        const originalDetachPrimitive = original.detachPrimitive?.bind(original);
        const originalAttachPrimitive = original.attachPrimitive?.bind(original);
        const originalData = original.data?.bind(original);
        /**
         * Helper function to convert data items.
         *
         * @param sourceItem - The raw source item (must contain a `time` property).
         * @param keys - Optional list of property names to copy. Defaults to ['time'].
         * @param copy - If true, copies all properties from sourceItem, overriding `keys`.
         * @returns A partial data item or null if `time` is missing.
         */
        const _type = original.seriesType();
        const title = original.options().title;
        // Implement a pane function that moves the series to a specified pane.
        // We add it as a property on the decorated object.
        function sync(series) {
            // 1) Determine the type from the series’ own options
            //    (Ensure "seriesType" is indeed on the options, otherwise provide fallback)
            const options = series.options();
            const targetType = options.seriesType ?? "Line"; // fallback to "Line" if undefined
            // 2) Perform initial synchronization from "originalData"
            const sourceData = originalData();
            if (!sourceData) {
                console.warn("Source data is missing for synchronization.");
                return;
            }
            const targetData = [...series.data()];
            for (let i = targetData.length; i < sourceData.length; i++) {
                // Now call your convertDataItem with the discovered type:
                const newItem = convertDataItem(series, targetType, i);
                if (newItem) {
                    if (newItem && 'time' in newItem && 'value' in newItem) {
                        targetData.push(newItem);
                    }
                    else {
                        console.warn('Invalid data item:', newItem);
                    }
                }
            }
            series.setData(targetData);
            console.log(`Synchronized series of type ${series.seriesType}`);
            // 3) Subscribe for future changes
            series.subscribeDataChanged(() => {
                const updatedSourceData = [...originalData()];
                if (!updatedSourceData || updatedSourceData.length === 0) {
                    console.warn("Source data is missing for synchronization.");
                    return;
                }
                // Get the last bar from the target series
                const lastTargetBar = series.data().slice(-1)[0];
                // The last index from updatedSourceData
                const lastSourceIndex = updatedSourceData.length - 1;
                // If the new item has a time >= last target bar’s time, we update/append
                if (!lastTargetBar ||
                    updatedSourceData[lastSourceIndex].time >= lastTargetBar.time) {
                    const newItem = convertDataItem(series, targetType, lastSourceIndex);
                    if (newItem) {
                        series.update(newItem);
                        console.log(`Updated/added bar via "update()" for series type ${series.seriesType}`);
                    }
                }
            });
        }
        function attachPrimitive(primitive, name, replace = true, addToLegend = false) {
            const primitiveType = primitive.constructor.type || primitive.constructor.name;
            // Detach existing primitives if `replace` is true
            if (replace) {
                detachPrimitives();
            }
            else {
                // Check if a primitive of the same type is already attached
                const existingIndex = primitives.findIndex((p) => p.constructor.type === primitiveType);
                if (existingIndex !== -1) {
                    detachPrimitive(primitives[existingIndex]);
                }
            }
            // Attach the primitive to the series
            if (originalAttachPrimitive) {
                originalAttachPrimitive(primitive);
            }
            // Add the new primitive to the list
            primitives.push(primitive);
            lastAttachedPrimitive = primitive;
            console.log(`Primitive of type "${primitiveType}" attached.`);
            // Add the primitive to the legend if required
            if (legend && addToLegend) {
                legend.addLegendPrimitive(original, primitive, name);
            }
        }
        function detachPrimitive(primitive) {
            const index = primitives.indexOf(primitive);
            if (index === -1) {
                return;
            }
            // Remove the primitive from the array
            primitives.splice(index, 1);
            if (lastAttachedPrimitive === primitive) {
                lastAttachedPrimitive = null;
            }
            // Detach the primitive using the original method
            if (originalDetachPrimitive) {
                originalDetachPrimitive(primitive);
            }
            // Remove the primitive from the legend if it exists
            if (legend) {
                legend.removeLegendPrimitive(primitive);
                console.log(`Removed primitive of type "${primitive.constructor.name}" from legend.`);
            }
        }
        function detachPrimitives() {
            console.log("Detaching all primitives.");
            while (primitives.length > 0) {
                const primitive = primitives.pop();
                detachPrimitive(primitive);
            }
            console.log("All primitives detached.");
        }
        function setData(data) {
            originalSetData(data);
        }
        return Object.assign(original, {
            setData,
            primitives,
            sync,
            attachPrimitive,
            detachPrimitive,
            detachPrimitives,
            decorated,
            _type,
            title,
            get primitive() {
                return lastAttachedPrimitive;
            },
            toJSON() {
                return {
                    options: original.options(),
                    data: originalData(),
                };
            },
            fromJSON(json) {
                // If data is provided, update the series' data.
                if (json.data) {
                    originalSetData(json.data);
                }
                // If options are provided, iterate over each property and apply it.
                if (json.options) {
                    // Cast json.options to a plain record.
                    const opts = json.options;
                    for (const key in opts) {
                        if (Object.prototype.hasOwnProperty.call(opts, key)) {
                            // Cast key to string (since TS sometimes infers symbol too).
                            const typedKey = key;
                            original.applyOptions({ [typedKey]: opts[typedKey] });
                        }
                    }
                }
            },
        });
    }
    function getDefaultSeriesOptions(type //| "Ohlc" | "Trade"
    ) {
        const common = {
        // Define any common default options that apply to all series types here
        };
        switch (type) {
            case "Line":
                return {
                    ...common,
                    title: type,
                    color: "#195200",
                    lineWidth: 2,
                    crosshairMarkerVisible: true,
                };
            case "Histogram":
                return {
                    ...common,
                    title: type,
                    color: "#9ACF01",
                    base: 0,
                };
            case "Area":
                return {
                    ...common,
                    title: type,
                    lineColor: "#021698",
                    topColor: "rgba(9, 32, 210, 0.4)",
                    bottomColor: "rgba(0, 0, 0, 0.5)",
                };
            case "Bar":
                return {
                    ...common,
                    title: type,
                    upColor: "#006721",
                    downColor: "#6E0000",
                    borderUpColor: "#006721",
                    borderDownColor: "#6E0000",
                };
            case "Candlestick":
                return {
                    ...common,
                    title: type,
                    upColor: "rgba(0, 103, 33, 0.33)",
                    downColor: "rgba(110, 0, 0, 0.33)",
                    borderUpColor: "#006721",
                    borderDownColor: "#6E0000",
                    wickUpColor: "#006721",
                    wickDownColor: "#6E0000",
                };
            case "Ohlc":
                return {
                    ...common,
                    title: type,
                    upColor: "rgba(0, 103, 33, 0.33)",
                    downColor: "rgba(110, 0, 0, 0.33)",
                    borderUpColor: "#006721",
                    borderDownColor: "#6E0000",
                    wickUpColor: "#006721",
                    wickDownColor: "#6E0000",
                    shape: "Rounded",
                    chandelierSize: 1,
                    barSpacing: 0.777,
                    lineStyle: 0,
                    lineWidth: 1,
                };
            case "Trade":
                return {
                    ...common,
                    ...tradeDefaultOptions,
                };
            default:
                throw new Error(`Unsupported series type: ${type}`);
        }
    }
    /**
     * Converts one specific data item (by `index`) to the target series type.
     */
    function convertDataItem(series, targetType, index) {
        // 1) get the data array
        const data = series.data();
        if (!data || data.length === 0) {
            console.warn("No data available in the source series.");
            return null;
        }
        // 2) pick the individual item
        const item = data[index];
        // 3) switch on targetType, then use type guards on `item`
        switch (targetType) {
            // Single-value shapes: "Line", "Histogram", "Area"
            case "Line": {
                // line expects { time, value }
                if (isOHLCData(item)) {
                    // Use item.close for value
                    return {
                        time: item.time,
                        value: item.close,
                    };
                }
                else if (isSingleValueData(item)) {
                    // Already has { time, value }
                    return {
                        time: item.time,
                        value: item.value,
                    };
                }
                else if (isWhitespaceData(item)) {
                    // It's valid whitespace data => return as-is
                    return {
                        time: item.time,
                    };
                }
                // else it's something else => can't convert
                break;
            }
            case "Histogram": {
                // histogram expects { time, value }, possibly color
                if (isOHLCData(item)) {
                    return {
                        time: item.time,
                        value: item.close,
                    };
                }
                else if (isSingleValueData(item)) {
                    return {
                        time: item.time,
                        value: item.value,
                    };
                }
                else if (isWhitespaceData(item)) {
                    return {
                        time: item.time,
                    };
                }
                break;
            }
            case "Area": {
                // area expects { time, value }
                if (isOHLCData(item)) {
                    return {
                        time: item.time,
                        value: item.close,
                    };
                }
                else if (isSingleValueData(item)) {
                    return {
                        time: item.time,
                        value: item.value,
                    };
                }
                else if (isWhitespaceData(item)) {
                    return {
                        time: item.time,
                    };
                }
                break;
            }
            // OHLC shapes: "Bar", "Candlestick", "Ohlc"
            case "Bar": {
                // { time, open, high, low, close }
                if (isOHLCData(item)) {
                    return {
                        time: item.time,
                        open: item.open,
                        high: item.high,
                        low: item.low,
                        close: item.close,
                    };
                }
                else if (isWhitespaceData(item)) {
                    return {
                        time: item.time,
                    };
                }
                break;
            }
            case "Candlestick": {
                // shape = { time, open, high, low, close }
                if (isOHLCData(item)) {
                    return {
                        time: item.time,
                        open: item.open,
                        high: item.high,
                        low: item.low,
                        close: item.close,
                    };
                }
                else if (isWhitespaceData(item)) {
                    return {
                        time: item.time,
                    };
                }
                break;
            }
            case "Ohlc": {
                // your custom type or just treat it as BarData
                if (isOHLCData(item)) {
                    return {
                        time: item.time,
                        open: item.open,
                        high: item.high,
                        low: item.low,
                        close: item.close,
                    };
                }
                else if (isWhitespaceData(item)) {
                    return {
                        time: item.time,
                    };
                }
                break;
            }
            case "Trade": {
                return {
                    time: item.time,
                    action: item.action ?? undefined,
                };
            }
            default:
                console.error(`Unsupported target type: ${targetType}`);
                return null;
        }
        // If we reach here, no conversion was possible
        console.warn("Could not convert data to the target type.");
        return null;
    }
    /**
     * Returns true if the given dot-separated key path exists in the defaults.
     * Special case: if the key is "color" or "lineColor", and either exists in defaults,
     * the function returns true.
     *
     * @param path The dot-separated key path.
     * @param defaults The defaults object.
     */
    function isOptionInDefaults(path, defaults) {
        const keys = path.split(".");
        let obj = defaults;
        for (const key of keys) {
            if (!(key in obj)) {
                // Check the interchangeable case for color vs lineColor.
                if ((key === "color" || key === "lineColor") && ("color" in obj || "lineColor" in obj)) {
                    return true;
                }
                return false;
            }
            obj = obj[key];
        }
        return true;
    }
    /**
     * Clones an existing series into a new series of a specified type.
     *
     * @param series - The series to clone.
     * @param handler - The chart handler.
     * @param type - The target type for the cloned series.
     * @param options - Additional options to merge with default options.
     * @returns The cloned series, or null if cloning fails.
     */
    function cloneSeriesAsType(series, handler, type, options) {
        try {
            // Get current series options.
            const seriesOptions = series.options();
            // Get default options for the specified type.
            const defaultOptions = getDefaultSeriesOptions(type);
            // Merge with any extra provided options.
            const mergedOptions = { ...defaultOptions, ...options };
            const name = series.options().title ?? type;
            let clonedSeries;
            console.log(`Cloning ${series.seriesType()} as ${type}...`);
            // Create the new series using the handler.
            switch (type) {
                case 'Line':
                    clonedSeries = handler.createLineSeries(`${name}<${type}>`, undefined, series.getPane().paneIndex());
                    break;
                case 'Histogram':
                    clonedSeries = handler.createHistogramSeries(`${name}<${type}>`, undefined, series.getPane().paneIndex());
                    break;
                case 'Area':
                    clonedSeries = handler.createAreaSeries(`${name}<${type}>`, undefined, series.getPane().paneIndex());
                    break;
                case 'Bar':
                    clonedSeries = handler.createBarSeries(`${name}<${type}>`, undefined, series.getPane().paneIndex());
                    break;
                case 'Candlestick':
                    clonedSeries = {
                        name: `${name}<${type}>`,
                        series: handler.createCandlestickSeries(),
                    };
                    break;
                case 'Ohlc':
                    clonedSeries = handler.createCustomOHLCSeries(`${name}<${type}>`, undefined, series.getPane().paneIndex());
                    break;
                default:
                    console.error(`Unsupported series type: ${type}`);
                    return null;
            }
            // Convert and set data on the cloned series.
            const originalData = series.data();
            let transformedData = originalData
                .map((_, i) => convertDataItem(series, type, i))
                .filter((item) => item !== null);
            clonedSeries.series.setData(transformedData);
            // Transfer color options iteratively.
            findColorOptions(seriesOptions, (fullPath, value) => {
                // Only update the cloned series if the default options contain this key.
                if (isOptionInDefaults(fullPath, defaultOptions)) {
                    if (fullPath === "lineColor" || fullPath === "color") {
                        // Handle the interchangeable case.
                        const hasLineColor = "lineColor" in defaultOptions || "lineColor" in mergedOptions;
                        const hasColor = "color" in defaultOptions || "color" in mergedOptions;
                        if (hasLineColor && hasColor) {
                            setOptionByPath(clonedSeries.series, "lineColor", value);
                            setOptionByPath(clonedSeries.series, "color", value);
                        }
                        else if (hasLineColor) {
                            setOptionByPath(clonedSeries.series, "lineColor", value);
                        }
                        else if (hasColor) {
                            setOptionByPath(clonedSeries.series, "color", value);
                        }
                    }
                    else {
                        // For any other color option, simply update the cloned series.
                        setOptionByPath(clonedSeries.series, fullPath, value);
                    }
                }
            });
            // Iterate over all keys of mergedOptions
            Object.keys(mergedOptions).forEach((key) => {
                // Only process keys that include "color"
                if (key.toString().toLowerCase().includes("color")) {
                    // Create a small object containing only this key/value pair
                    const optionObj = { [key]: mergedOptions[key] };
                    // Use findColorOptions to process this object
                    findColorOptions(optionObj, (fullPath, value) => {
                        console.log(`Found color option: ${fullPath} = ${value}`);
                        // Here you could call setOptionByPath or any other function as needed.
                    });
                }
            });
            // Subscribe to data changes on the original series to keep the clone updated.
            series.subscribeDataChanged(() => {
                const updatedData = series.data();
                const newTransformed = updatedData
                    .map((_, i) => convertDataItem(series, type, i))
                    .filter((item) => item !== null);
                clonedSeries.series.setData(newTransformed);
                console.log(`Updated synced series of type ${type}`);
            });
            return clonedSeries.series;
        }
        catch (error) {
            console.error("Error cloning series:", error);
            return null;
        }
    }
    function setOptionByPath(target, path, value) {
        const currentOptions = target.options();
        const keys = path.split(".");
        let obj = currentOptions; // cast to any so we can index by string
        for (let i = 0; i < keys.length - 1; i++) {
            if (!(keys[i] in obj)) {
                obj[keys[i]] = {};
            }
            obj = obj[keys[i]];
        }
        obj[keys[keys.length - 1]] = value;
        target.applyOptions(currentOptions);
    }
    // series-types.ts
    var SeriesTypeEnum;
    (function (SeriesTypeEnum) {
        SeriesTypeEnum["Line"] = "Line";
        SeriesTypeEnum["Histogram"] = "Histogram";
        SeriesTypeEnum["Area"] = "Area";
        SeriesTypeEnum["Bar"] = "Bar";
        SeriesTypeEnum["Candlestick"] = "Candlestick";
        SeriesTypeEnum["Ohlc"] = "Ohlc";
        SeriesTypeEnum["Trade"] = "Trade";
    })(SeriesTypeEnum || (SeriesTypeEnum = {}));
    // A helper that, given a “default” object, picks only those keys 
    // from an incoming options object that are present in the default.
    function pickCommonOptions(defaults, opts) {
        const result = {};
        for (const key in defaults) {
            if (Object.prototype.hasOwnProperty.call(opts, key)) {
                result[key] = opts[key];
            }
        }
        return result;
    }
    function ensureExtendedSeries(series, legend // Assuming `Legend` is the type of the legend instance
    ) {
        // Type guard to check if the series is already extended
        const isExtendedSeries = (series) => {
            return series.primitives !== undefined;
        };
        // If the series is already extended, return it
        if (isExtendedSeries(series)) {
            return series;
        }
        // Otherwise, decorate the series dynamically
        console.log("Decorating the series dynamically.");
        return decorateSeries(series, legend);
    }
    function decorateSeriesAsIndicator(series, sourceSeries, ind, figures, figureCount, paramMap, recalculateIndicator) {
        const indicatorSeries = Object.assign(series, {
            sourceSeries,
            indicator: ind,
            figures,
            paramMap,
            figureCount, // NEW: stores the global figure count
            recalculate: function (overrides) {
                recalculateIndicator(this, overrides);
            },
        });
        // Subscribe to data changes on the source series to trigger automatic recalculation.
        if (typeof sourceSeries.subscribeDataChanged === "function") {
            sourceSeries.subscribeDataChanged(() => {
                if (sourceSeries.data()[sourceSeries.data().length - 1].time > series.data()[series.data().length - 1].time) {
                    recalculateIndicator(indicatorSeries);
                }
            });
        }
        return indicatorSeries;
    }
    function recalculateIndicator(indicatorSeries, overrides) {
        // Merge new overrides into the stored parameters to get the current parameters.
        const updatedParams = { ...indicatorSeries.paramMap, ...overrides };
        // Retrieve the source series data.
        const rawData = [...indicatorSeries.sourceSeries.data()];
        if (!rawData || !Array.isArray(rawData) || rawData.length === 0) {
            return;
        }
        // If the raw data is already in OHLC format, use it;
        // otherwise, convert each data point using singleToOhlcData.
        let data;
        if (rawData.every(isOHLCData)) {
            data = rawData;
        }
        else {
            data = rawData.map(singleToOhlcData);
        }
        // Run the indicator's calculation with the updated parameters.
        const newFigures = indicatorSeries.indicator.calc(data, updatedParams);
        // For each calculated figure, update the corresponding series if it exists.
        newFigures.forEach((newFigure) => {
            const existingSeries = indicatorSeries.figures.get(newFigure.key);
            if (existingSeries) {
                existingSeries.setData(newFigure.data);
                existingSeries.applyOptions({ title: newFigure.title });
                if (newFigure.pane) {
                    // Check if the current pane of the series is the same as the source series' pane.
                    if (existingSeries.getPane() === indicatorSeries.sourceSeries.getPane()) {
                        const currentPane = existingSeries.getPane();
                        const paneIndex = currentPane.paneIndex(); // Call the function to get a number
                        existingSeries.moveToPane(paneIndex + newFigure.pane);
                    }
                }
            }
        });
        // Store the current (merged) parameters for future recalculations.
        indicatorSeries.paramMap = updatedParams;
    }
    /**
     * Converts a SingleValueData object to an OhlcData object by assigning
     * the `value` property to the open, high, low, and close prices.
     *
     * @param data - The single value data point.
     * @returns An OhlcData object with open, high, low, and close set to data.value.
     */
    function singleToOhlcData(data) {
        return {
            time: data.time,
            open: data.value,
            high: data.value,
            low: data.value,
            close: data.value,
        };
    }

    function setLineStyle(ctx, style) {
        const dashPatterns = {
            [lightweightCharts.LineStyle.Solid]: [],
            [lightweightCharts.LineStyle.Dotted]: [ctx.lineWidth, ctx.lineWidth],
            [lightweightCharts.LineStyle.Dashed]: [2 * ctx.lineWidth, 2 * ctx.lineWidth],
            [lightweightCharts.LineStyle.LargeDashed]: [6 * ctx.lineWidth, 6 * ctx.lineWidth],
            [lightweightCharts.LineStyle.SparseDotted]: [ctx.lineWidth, 4 * ctx.lineWidth],
        };
        const dashPattern = dashPatterns[style];
        ctx.setLineDash(dashPattern);
    }

    const defaultSequenceOptions = {
        visible: true,
        autoScale: false,
        xScaleLock: false,
        yScaleLock: false,
        color: '#737375',
        lineWidth: 1,
        upColor: 'rgba(0,255,0,.25)',
        downColor: 'rgba(255,0,0,.25)',
        wickVisible: true,
        borderVisible: true,
        borderColor: '#737375',
        borderUpColor: '#1c9d1c',
        borderDownColor: '#d5160c',
        wickColor: '#737375',
        wickUpColor: '#1c9d1c',
        wickDownColor: '#d5160c',
        radius: 100,
        shape: 'Rounded',
        chandelierSize: 1,
        barSpacing: 0.7,
        lineStyle: 0,
        lineColor: '#ffffff',
        width: 1,
    };
    /* ============================================================================
      HELPER CLASS: Sequence
    ============================================================================ */
    /**
     * The Sequence class now slices the data ONLY ONCE in the constructor
     * (using _originalP1, _originalP2). Then it applies scale/shift to that
     * already-sliced data whenever p1 or p2 changes.
     */
    class Sequence {
        handler;
        get data() {
            return this.convertAndAggregateDataPoints();
        }
        get sourceData() {
            return this._originalData;
        }
        _originalP1;
        _originalP2;
        _barWidth = 0.8;
        p1;
        p2;
        _options;
        series;
        _originalData = [];
        _originalSlice = [];
        offset;
        /**
         * This array holds only the slice from _originalP1 to _originalP2,
         * so we never repeatedly slice the entire series data again.
         */
        onComplete;
        get spatial() {
            return this.recalculateSpatial();
        }
        transform = {
            scale: { x: 1, y: 1 },
            shift: { x: 0, y: 0 }
        };
        constructor(handler, series, p1, p2, options, pOffset) {
            this.handler = handler;
            this._options = { ...options, ...defaultSequenceOptions };
            let left, right;
            if (Math.min(p1.logical, p2.logical) === p1.logical) {
                left = p1;
                right = p2;
            }
            else {
                left = p2;
                right = p1;
            }
            this._originalP1 = { ...left };
            this._originalP2 = { ...right };
            this.offset = pOffset ?? 0;
            this.p1 = p1;
            this.p2 = p2;
            if (isISeriesApi(series)) {
                this.series = series;
                this._originalData = this.series.data().map((data, index) => ({
                    ...data,
                    x1: index,
                    x2: index
                }));
            }
            else {
                this.series = this.handler.series || this.handler._seriesList[0];
                this._originalData = series._originalData;
            }
            /**
             * We find the min and max of the original points' logical indexes
             * and slice the data range. We store that in _originalData so subsequent
             * calls only transform, not re-slice.
             */
            const x1 = Math.min(this._originalP1.logical, this._originalP2.logical);
            const x2 = Math.max(this._originalP1.logical, this._originalP2.logical);
            if (pOffset && pOffset > 0) {
                this._originalSlice = this._originalData.slice(x2, Math.min(this.series.data().length - 1, x2 + 1 + pOffset));
                console.log("Data Sliced with Offset", x1, x2, pOffset, "Offset Point:", Math.min(this.series.data().length - 1, x2 + 1 + pOffset));
            }
            else {
                this._originalSlice = this._originalData.slice(x1, x2 + 1);
                console.log("Data Sliced:", x1, x2);
            }
            // If a pOffset is provided, adjust each bar in the slice by adding the offset to x1 and x2.
            if (pOffset && pOffset > 0) {
                this._originalSlice = this._originalSlice.map((bar) => ({
                    ...bar,
                    x1: bar.x1 + pOffset,
                    x2: bar.x2 + pOffset
                }));
                console.log("Adjusted originalSlice with pOffset:", pOffset);
            }
            // Adjust this once initially
            this.transform = this.recalculateSpatial();
            if (this.p1 && this.p2) {
                this.setPoints(this.p1, this.p2);
            }
        }
        setData(data) {
            this._originalSlice = data;
        }
        setPoints(p1, p2) {
            let left, right;
            if (Math.min(p1.logical, p2.logical) === p1.logical) {
                left = p1;
                right = p2;
            }
            else {
                left = p2;
                right = p1;
            }
            if (this._originalP1 === null) {
                this._originalP1 = { ...left };
                console.log('First point (p1) set:', this._originalP1);
            }
            else if (this._originalP2 === null) {
                this._originalP2 = { ...right };
                console.log('Second point (p2) set:', this._originalP2);
            }
            this.p1 = left;
            this.p2 = right;
            this.recalculateSpatial(); // Ensure we just recalc scale/shift
            this.processSequence();
        }
        updatePoint(pointIndex, newPoint) {
            if (pointIndex === 1) {
                this.p1 = newPoint;
            }
            else if (pointIndex === 2) {
                if (!this._originalP2) {
                    this._originalP2 = newPoint;
                }
                this.p2 = newPoint;
            }
            this.recalculateSpatial(); // Ensure we just recalc scale/shift
            this.processSequence();
        }
        recalculateSpatial() {
            if (!this.p1 || !this.p2 || !this._originalP1 || !this._originalP2) {
                console.warn('Cannot recalc spatial without valid p1/p2.');
                return {
                    scale: { x: 1, y: 1 },
                    shift: { x: 0, y: 0 }
                };
            }
            const dxOrig = Math.abs(this._originalP1.logical - this._originalP2.logical);
            const dyOrig = Math.abs(this._originalP1.price - this._originalP2.price);
            if (dxOrig === 0 || dyOrig === 0) {
                console.warn('Cannot recalc scale if original points are zero difference.');
                return {
                    scale: { x: 1, y: 1 },
                    shift: { x: 0, y: 0 }
                };
            }
            const dxNew = Math.abs(this.p1.logical - this.p2.logical);
            const dyNew = ((this._originalP2.price > this._originalP1.price ? this.p2.price : this.p1.price)
                - (this._originalP2.price > this._originalP1.price ? this.p1.price : this.p2.price));
            const scaleX = dxNew / dxOrig;
            const scaleY = dyNew / dyOrig;
            if (!this._options.xScaleLock) {
                this.transform.scale.x = scaleX;
            }
            if (!this._options.yScaleLock) {
                this.transform.scale.y = scaleY;
            }
            if (this._options.autoScale) {
                if (scaleX > -1 && scaleX < 1) {
                    this._options.chandelierSize = Math.abs(Math.ceil(1 / scaleX));
                }
            }
            const spatial = {
                scale: {
                    x: scaleX !== 0 ? Math.round(scaleX * 100) / 100 : 1,
                    y: scaleY !== 0 ? Math.round(scaleY * 100) / 100 : 1
                },
                shift: {
                    x: (this._originalP1.logical - this.p1.logical),
                    y: this._originalP1.price - this.p1.price
                }
            };
            this._barWidth = Math.abs(this.p1.logical - this.p2.logical) / this._originalData.length;
            console.log('Spatial recalculated:', 'scaleX=', spatial.scale.x, 'scaleY=', spatial.scale.y, 'shiftX=', spatial.shift.x, 'shiftY=', spatial.shift.y);
            if (spatial.scale.x === 0 || spatial.scale.y === 0) {
                console.warn('Scale factors cannot be zero.');
                return {
                    scale: { x: 1, y: 1 },
                    shift: { x: 0, y: 0 }
                };
            }
            return spatial;
        }
        processSequence() {
            if (!this.p1 || !this.p2) {
                console.warn('Cannot process sequence without valid p1/p2.');
                return;
            }
            this.convertAndAggregateDataPoints(); // Simply triggers the creation of data
            if (this.onComplete) {
                this.onComplete();
            }
        }
        convertAndAggregateDataPoints() {
            // 1) Find min/max among all relevant fields (open, high, etc.) in _originalSlice
            let dataMin = Number.POSITIVE_INFINITY;
            let dataMax = Number.NEGATIVE_INFINITY;
            const transform = { ...this.spatial };
            this._originalSlice.forEach(orig => {
                // We check whichever fields matter to you: open, high, low, close, value...
                const values = [];
                if (orig.open !== undefined) {
                    values.push(orig.open);
                }
                if (orig.high !== undefined) {
                    values.push(orig.high);
                }
                if (orig.low !== undefined) {
                    values.push(orig.low);
                }
                if (orig.close !== undefined) {
                    values.push(orig.close);
                }
                if (orig.value !== undefined) {
                    values.push(orig.value);
                }
                for (const v of values) {
                    if (v < dataMin)
                        dataMin = v;
                    if (v > dataMax)
                        dataMax = v;
                }
            });
            // If dataMin===dataMax, ensure dataRange is 1 so we avoid dividing by 0
            const dataRange = (dataMax === dataMin) ? 1 : (dataMax - dataMin);
            // 2) The base X origin is (originalP1.logical + shift.x)
            //    We rely on `index` for local indexing in the already-sliced data.
            const originX = this.p1.logical;
            // 3) Map each item, normalizing its Y fields into [0..1], then scaling
            const dataPoints = this._originalSlice.map((orig, index) => {
                // X dimension logic
                const barX = originX + index;
                // Y dimension logic with min–max normalization
                function normalizeY(val, spatial) {
                    if (val === undefined)
                        return undefined;
                    const rel = (val - dataMin) / dataRange; // yields 0..1
                    // Then we scale by (spatial.scale.y * dataRange) and add spatial.shift.y
                    return (dataMin - spatial.shift.y) + (rel * spatial.scale.y * dataRange);
                }
                // Apply normalization to each relevant field
                const openPrice = normalizeY(orig.open, transform);
                const closePrice = normalizeY(orig.close, transform);
                const highPrice = normalizeY(orig.high, transform);
                const lowPrice = normalizeY(orig.low, transform);
                const valuePrice = normalizeY(orig.value, transform);
                // Decide if we have OHLC or single-value
                if (openPrice !== undefined ||
                    closePrice !== undefined ||
                    highPrice !== undefined ||
                    lowPrice !== undefined) {
                    // This bar is OHLC data
                    const isUp = (closePrice ?? 0) > (openPrice ?? 0);
                    // Construct your color/border/wick logic
                    const color = isUp
                        ? (this._options.upColor || 'rgba(0,255,0,0.333)')
                        : (this._options.downColor || 'rgba(255,0,0,0.333)');
                    const borderColor = isUp
                        ? (this._options.borderUpColor || setOpacity(color, 1))
                        : (this._options.borderDownColor || setOpacity(color, 1));
                    const wickColor = isUp
                        ? (this._options.wickUpColor || borderColor)
                        : (this._options.wickDownColor || borderColor);
                    // You might compute lineStyle, lineWidth, shape, etc. for each bar if needed
                    // For now, let's keep it simpler and not mention "bucket" here.
                    // (bucket logic is in your aggregator below.)
                    return {
                        open: openPrice,
                        close: closePrice,
                        high: highPrice,
                        low: lowPrice,
                        isUp,
                        x1: barX + this.offset,
                        x2: barX + this.offset,
                        isInProgress: false,
                        originalData: { ...orig, x1: index },
                        barSpacing: this._barWidth,
                        // Optional style fields
                        color,
                        borderColor,
                        wickColor,
                        lineStyle: this._options.lineStyle,
                        lineWidth: this._options.lineWidth,
                        shape: this._options.shape ?? 'Rounded'
                    };
                }
                else {
                    // Single-value data
                    // If your single-value doesn't need normalization, you could skip that step,
                    // but here we use `valuePrice`.
                    return {
                        value: valuePrice,
                        isUp: undefined,
                        x1: barX + this.offset,
                        x2: barX + this.offset,
                        isInProgress: false,
                        originalData: orig,
                        barSpacing: this._options.barSpacing ?? 0.8
                    };
                }
            });
            // 4) Optional aggregator step (e.g., chandelier)
            const groupSize = this._options.chandelierSize ?? 1;
            if (groupSize <= 1) {
                return dataPoints;
            }
            const aggregatedBars = [];
            for (let i = 0; i < dataPoints.length; i += groupSize) {
                const bucket = dataPoints.slice(i, i + groupSize);
                if (bucket.length === 0)
                    continue;
                const isInProgress = bucket.length < groupSize && (i + bucket.length === dataPoints.length);
                const aggregatedBar = this._chandelier(bucket, isInProgress, groupSize);
                aggregatedBars.push(aggregatedBar);
            }
            return aggregatedBars;
        }
        _chandelier(bucket, isInProgress = false, chandelierSize) {
            if (bucket.length === 0) {
                throw new Error('Bucket cannot be empty in _chandelier method.');
            }
            const aggregatedx1 = bucket[0].x1;
            const aggregatedx2 = bucket[bucket.length - 1].x2;
            // If it's an OHLC bucket:
            if (bucket[0].originalData?.open !== undefined) {
                const openPrice = bucket[0].open ?? 0;
                const closePrice = bucket[bucket.length - 1].close ?? 0;
                const highPrice = bucket.reduce((acc, cur) => Math.max(acc, cur.high || 0), 0);
                const lowPrice = bucket.reduce((acc, cur) => Math.min(acc, cur.low || Infinity), Infinity);
                const isUp = closePrice > openPrice;
                const color = isUp
                    ? this._options.upColor || 'rgba(0,255,0,0.333)'
                    : this._options.downColor || 'rgba(255,0,0,0.333)';
                const borderColor = isUp
                    ? this._options.borderUpColor || setOpacity(color, 1)
                    : this._options.borderDownColor || setOpacity(color, 1);
                const wickColor = isUp
                    ? this._options.wickUpColor || borderColor
                    : this._options.wickDownColor || borderColor;
                const lineStyle = bucket.reduce((style, bar) => bar.lineStyle ?? bar.originalData?.lineStyle ?? style, this._options.lineStyle);
                const lineWidth = bucket.reduce((currentWidth, bar) => bar.lineWidth ?? bar.originalData?.lineWidth ?? currentWidth, this._options.lineWidth ?? 1);
                const shape = this._options.shape ?? "Rounded";
                return {
                    open: openPrice,
                    high: highPrice,
                    low: lowPrice,
                    close: closePrice,
                    isUp,
                    x1: aggregatedx1,
                    x2: aggregatedx2,
                    isInProgress,
                    color,
                    borderColor,
                    wickColor,
                    shape,
                    lineStyle,
                    lineWidth
                };
            }
            else {
                // Single-value version for aggregation.
                const openVal = bucket[0].value ?? 0;
                const closeVal = bucket[bucket.length - 1].value ?? 0;
                const isUp = closeVal > openVal;
                const color = isUp
                    ? this._options.upColor || 'rgba(0,255,0,0.333)'
                    : this._options.downColor || 'rgba(255,0,0,0.333)';
                const borderColor = isUp
                    ? this._options.borderUpColor || setOpacity(color, 1)
                    : this._options.borderDownColor || setOpacity(color, 1);
                isUp
                    ? this._options.wickUpColor || borderColor
                    : this._options.wickDownColor || borderColor;
                const lineStyle = bucket.reduce((style, bar) => bar.lineStyle ?? bar.originalData?.lineStyle ?? style, this._options.lineStyle);
                const lineWidth = bucket.reduce((currentWidth, bar) => bar.lineWidth ?? bar.originalData?.lineWidth ?? currentWidth, this._options.lineWidth ?? 1);
                this._options.shape ?? "Rounded";
                return {
                    value: openVal,
                    isUp,
                    x1: aggregatedx1,
                    x2: aggregatedx2,
                    color,
                    lineStyle,
                    lineWidth
                };
            }
        }
        applyOptions(options) {
            this._options = {
                ...this._options,
                ...options,
            };
            this.processSequence();
        }
    }

    /* ============================================================================
      TYPE & INTERFACE DEFINITIONS
    ============================================================================ */
    /* ============================================================================
      TRENDTRACE PLUGIN CLASS
    ============================================================================ */
    class TrendTrace extends PluginBase {
        _type = "TrendTrace";
        _paneViews;
        _sequence;
        _options;
        _state = InteractionState.NONE;
        _handler;
        _source;
        _originalP1 = null;
        _originalP2 = null;
        p1 = null;
        p2 = null;
        _points = [];
        title = "";
        static _type = "Trend-Trace";
        _startDragPoint = null;
        _latestHoverPoint = null;
        static _mouseIsDown = false;
        static hoveredObject = null;
        static lastHoveredObject = null;
        _listeners = [];
        _hovered = false;
        constructor(handler, source, p1, p2, options, pOffset) {
            super();
            this._handler = handler;
            this._source = source;
            // Initialize original points
            this._originalP1 = { ...p1 };
            this._originalP2 = { ...p2 };
            const sourceOptions = this._source.options();
            // Step 2. Filter both seriesOpts and the explicit options to include only keys
            // that exist in our default options.
            const filteredSeriesOpts = pickCommonOptions(defaultSequenceOptions, sourceOptions);
            // Merge in order: defaults < series options < explicit options.
            this._options = {
                ...filteredSeriesOpts,
                ...options,
            };
            // Create and store the sequence
            this._sequence = this._createSequence({ p1, p2 }, this._options, pOffset);
            this.p1 = this._sequence.p1;
            this.p2 = this._sequence.p2;
            // Initialize pane views
            // this._hovered = false
            // Subscribe to chart or global events
            this._subscribeEvents();
            this._paneViews = [new TrendTracePaneView(this)];
        }
        /**
         * Serializes the Sequence instance to a JSON object.
         *
         * @returns An object representing the Sequence data and options.
         */
        toJSON() {
            return {
                data: this._sequence.data,
                p1: this._sequence._originalP1,
                p2: this._sequence._originalP2,
                options: this._sequence._options,
            };
        }
        /**
         * Deserializes a JSON object to update the current Sequence instance.
         *
         * @param json - The JSON object containing optional Sequence data and options.
         */
        fromJSON(json) {
            // If data is provided, update the sequence's data.
            if (json.data) {
                this._sequence.setData(json.data);
            }
            if (json.options) {
                // Cast json.options as a generic record to satisfy the index signature.
                const options = json.options;
                for (const key in options) {
                    if (Object.prototype.hasOwnProperty.call(options, key)) {
                        // Cast key to keyof SequenceOptions.
                        const typedKey = key;
                        this.applyOptions({ [typedKey]: options[typedKey] });
                    }
                }
            }
            // Optionally update the logical points if provided.
            if (json.p1) {
                this.p1 = json.p1;
            }
            if (json.p2) {
                this.p2 = json.p2;
            }
        }
        // ...existing code...
        attached(params) {
            super.attached(params);
            if (this._originalP1 && this._originalP2) {
                this._createSequence({ p1: this._originalP1, p2: this._originalP2 });
            }
            this._source = ensureExtendedSeries(params.series, this._handler.legend);
            this.title = params.series.options().title;
            // Call the function to get the class and then instantiate it
            const HorzScaleBehaviorClass = lightweightCharts.defaultHorzScaleBehavior();
            const horzScaleBehaviorInstance = new HorzScaleBehaviorClass();
            return {
                chart: params.chart,
                series: params.series,
                requestUpdate: params.requestUpdate,
                horzScaleBehavior: horzScaleBehaviorInstance
            };
        }
        // ...existing code...
        paneViews() {
            return this._paneViews;
        }
        detached() {
            super.detached();
            // Clear all event listeners
            this._listeners.forEach(({ name, listener }) => {
                document.body.removeEventListener(name, listener);
            });
            // Reset the listeners array
            this._listeners = [];
            // Unsubscribe from chart events
            if (this._handler?.chart) {
                this._handler.chart.unsubscribeCrosshairMove(this._handleMouseMove);
                this._handler.chart.unsubscribeClick(this._handleMouseDownOrUp);
            }
            // Clear references
            this._paneViews = [];
            this._sequence = null;
            this._options = null;
            this._source = null;
            this._originalP1 = null;
            this._originalP2 = null;
            this.p1 = null;
            this.p2 = null;
            console.log("✅ All listeners and references successfully detached.");
        }
        _createSequence(source, options, offset) {
            let sequence;
            if ('p1' in source && 'p2' in source) {
                sequence = new Sequence(this._handler, this._source, source.p1, source.p2, options ?? this._options, offset);
                sequence.onComplete = () => this.updateViewFromSequence();
                this.updateViewFromSequence();
                return sequence;
            }
            else {
                sequence = new Sequence(this._handler, source.data, source.data._originalP1, source.data._originalP2, options ?? this._options, offset);
                sequence.onComplete = () => this.updateViewFromSequence();
                this.updateViewFromSequence();
                return sequence;
            }
        }
        applyOptions(options) {
            // Destructure to separate spatial properties from all other options.
            // We assume that the spatial properties (if any) are provided under the keys "scale" and "shift".
            // The rest of the properties are our sequence options.
            // Update our options: only the explicitly provided fields are merged.
            this._options = {
                ...this._options,
                ...options,
            };
            // Relay the changes to our underlying sequence.
            if (this._sequence) {
                this._sequence.applyOptions(this._options);
            }
            // Finally, trigger an update (or reprocess the sequence).
            this.requestUpdate();
        }
        _pendingUpdate = false;
        updateViewFromSequence() {
            if (!this._pendingUpdate) {
                this._pendingUpdate = true;
                requestAnimationFrame(() => {
                    super.requestUpdate();
                    console.log("Updating view with sequence data:", this._sequence?.data);
                    this._pendingUpdate = false;
                });
            }
        }
        getOptions() {
            return this._options;
        }
        /**
         * Subscribe to relevant events, e.g. crosshair move, chart click.
         * If your framework differs, adapt accordingly.
         */
        _subscribeEvents() {
            this._handler.chart.subscribeCrosshairMove(this._handleMouseMove);
            this._handler.chart.subscribeClick(this._handleMouseDownOrUp);
        }
        /** Use the local methods to subscribe/unsubscribe from DOM events if needed. */
        _subscribe(name, listener) {
            document.body.addEventListener(name, listener);
            this._listeners.push({ name, listener });
        }
        _unsubscribe(name, callback) {
            document.body.removeEventListener(name, callback);
            const toRemove = this._listeners.find((x) => x.name === name && x.listener === callback);
            this._listeners.splice(this._listeners.indexOf(toRemove), 1);
        }
        _handleHoverInteraction(param) {
            this._latestHoverPoint = param.point;
            if (TrendTrace._mouseIsDown) {
                this._handleDragInteraction(param);
            }
            else {
                if (this._mouseIsOverSequence(param)) {
                    if (this._state != InteractionState.NONE)
                        return;
                    this._moveToState(InteractionState.HOVERING);
                    TrendTrace.hoveredObject = TrendTrace.lastHoveredObject = this;
                }
                else {
                    if (this._state == InteractionState.NONE)
                        return;
                    this._moveToState(InteractionState.NONE);
                    if (TrendTrace.hoveredObject === this)
                        TrendTrace.hoveredObject = null;
                }
            }
        }
        /**
         * A pseudo-click handler that toggles mouseDown state
         * If user is already down, we finalize a mouse up, etc.
         */
        _handleMouseDownOrUp = () => {
            // If we're not "over" anything, do nothing
            if (!this._latestHoverPoint) {
                return;
            }
            TrendTrace._mouseIsDown = !TrendTrace._mouseIsDown;
            if (TrendTrace._mouseIsDown) {
                // Mouse just went down => set DRAGGING or DRAGGING_P1 or DRAGGING_P2
                this._onMouseDown();
            }
            else {
                // Mouse just went up => finalize the drag
                this._onMouseUp();
            }
        };
        /**
         * A pseudo-mouse-move/crosshair-move handler
         * We do hover detection or if mouse is down, do drag.
         */
        _handleMouseMove = (param) => {
            const mousePoint = this._eventToPoint(param, this._source);
            this._latestHoverPoint = mousePoint;
            if (TrendTrace._mouseIsDown) {
                // If user is dragging
                this._handleDragInteraction(param);
            }
            else {
                // Check if user is near p1/p2 or inside the "body"
                if (this._mouseIsOverPoint(param, 1) ||
                    this._mouseIsOverPoint(param, 2)) {
                    if (this._state === InteractionState.NONE) {
                        this._moveToState(InteractionState.HOVERING);
                    }
                }
                else if (this._mouseIsOverSequence(param)) {
                    if (this._state === InteractionState.NONE) {
                        this._moveToState(InteractionState.HOVERING);
                    }
                }
                else {
                    // Not over anything
                    if (this._state !== InteractionState.NONE) {
                        this._moveToState(InteractionState.NONE);
                    }
                }
            }
        };
        _onMouseUp() {
            TrendTrace._mouseIsDown = false;
            this.chart.applyOptions({ handleScroll: true });
            this._moveToState(InteractionState.HOVERING);
            this._startDragPoint = null;
        }
        _handleDragInteraction(param) {
            if (this._state !== InteractionState.DRAGGING &&
                this._state !== InteractionState.DRAGGINGP1 &&
                this._state !== InteractionState.DRAGGINGP2) {
                return;
            }
            const mousePoint = this._eventToPoint(param, this.series);
            if (!mousePoint || !this._startDragPoint)
                return;
            // Compute difference
            const diff = this._getDiff(mousePoint, this._startDragPoint);
            // Apply the difference to p1 or p2 or entire shape
            this._onDrag(diff);
            this._startDragPoint = mousePoint; // update reference
            this.requestUpdate();
        }
        _mouseIsOverPoint(param, which) {
            // Define a tolerance factor (e.g., 5% of the pane width/height)
            const toleranceFactor = 0.05;
            // Determine which target canvas point to check (p1 or p2)
            const targetCanvasPoint = which === 1
                ? { x: this._paneViews[0]._p1.x, y: this._paneViews[0]._p1.y }
                : { x: this._paneViews[0]._p2.x, y: this._paneViews[0]._p2.y };
            // Ensure chart is defined.
            if (!this.chart)
                return false;
            // Use the isPointCloseCanvas function
            return isPointCloseCanvas(param, targetCanvasPoint, toleranceFactor, this.chart);
        }
        _mouseIsOverSequence(param) {
            // Validate the presence of necessary properties in param
            if (!param.logical || !param.point) {
                console.warn('Invalid MouseEventParams: Missing logical or point.');
                return false;
            }
            // Convert the Y-coordinate of the mouse point to a price
            const mousePrice = this._source.coordinateToPrice?.(param.point.y);
            if (mousePrice == null) {
                console.warn('Mouse price could not be determined.');
                return false;
            }
            // Attempt to find the corresponding bar by time
            let bar = param.time
                ? this._sequence.data.find((d) => d.time === param.time)
                : undefined;
            // If no bar is found by time, attempt to find by logical
            if (!bar) {
                bar = this._sequence.data.find((d) => Math.round(d.x1) === Math.round(param.logical));
            }
            // If no matching bar is found, return false
            if (!bar) {
                console.warn('No matching bar found for the given parameters.');
                return false;
            }
            // Check if the mouse price is within the bar's price range
            if (bar.low != null && bar.high != null) {
                // Apply a small tolerance to account for minor discrepancies
                const tolerance = (bar.high - bar.low) * 0.05;
                return mousePrice >= bar.low - tolerance && mousePrice <= bar.high + tolerance;
            }
            // For single-value data, apply a 5% tolerance
            if (bar.value != null) {
                const tolerance = bar.value * 0.05;
                return mousePrice >= bar.value - tolerance && mousePrice <= bar.value + tolerance;
            }
            // If bar lacks necessary price information, return false
            console.warn('Bar lacks price information.');
            return false;
        }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._hovered = false;
                    this.requestUpdate();
                    this._unsubscribe("mousedown", this._handleMouseDownInteraction);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._hovered = true;
                    this.requestUpdate();
                    this._subscribe("mousedown", this._handleMouseDownInteraction);
                    this._unsubscribe("mouseup", this._handleMouseDownInteraction);
                    this.chart.applyOptions({ handleScroll: true });
                    break;
                case InteractionState.DRAGGINGP1:
                case InteractionState.DRAGGINGP2:
                case InteractionState.DRAGGING:
                    document.body.style.cursor = "grabbing";
                    this._subscribe("mouseup", this._handleMouseUpInteraction);
                    this.chart.applyOptions({ handleScroll: false });
                    break;
            }
            this._state = state;
        }
        _addDiffToPoint(point, logicalDiff, priceDiff) {
            if (!point)
                return;
            point.logical = (point.logical + logicalDiff);
            point.price = point.price + priceDiff;
            point.time = this.series.dataByIndex(point.logical)?.time || null;
        }
        _onDrag(diff) {
            if (this._state == InteractionState.DRAGGING ||
                this._state == InteractionState.DRAGGINGP1) {
                this._addDiffToPoint(this._sequence.p1, this._options.xScaleLock && this._state == InteractionState.DRAGGINGP1
                    ? 0
                    : diff.logical, this._options.yScaleLock && this._state == InteractionState.DRAGGINGP1
                    ? 0
                    : diff.price);
            }
            if (this._state == InteractionState.DRAGGING ||
                this._state == InteractionState.DRAGGINGP2) {
                this._addDiffToPoint(this._sequence.p2, this._options.xScaleLock && this._state == InteractionState.DRAGGINGP2
                    ? 0
                    : diff.logical, this._options.yScaleLock && this._state == InteractionState.DRAGGINGP2
                    ? 0
                    : diff.price);
            }
        }
        _onMouseDown() {
            this._startDragPoint = null;
            const hoverPoint = this._latestHoverPoint;
            if (!hoverPoint)
                return;
            const p1 = this._paneViews[0]._p1;
            const p2 = this._paneViews[0]._p2;
            if (!p1.x || !p2.x || !p1.y || !p2.y)
                return this._moveToState(InteractionState.DRAGGING);
            const tolerance = 20;
            if (Math.abs(hoverPoint.x - p1.x) < tolerance &&
                Math.abs(hoverPoint.y - p1.y) < tolerance) {
                this.chart.applyOptions({ handleScroll: false });
                this._moveToState(InteractionState.DRAGGINGP1);
            }
            else if (Math.abs(hoverPoint.x - p2.x) < tolerance &&
                Math.abs(hoverPoint.y - p2.y) < tolerance) {
                this.chart.applyOptions({ handleScroll: false });
                this._moveToState(InteractionState.DRAGGINGP2);
            }
            else {
                this.chart.applyOptions({ handleScroll: false });
                this._moveToState(InteractionState.DRAGGING);
            }
        }
        _handleMouseDownInteraction = () => {
            this._onMouseDown();
        };
        _handleMouseUpInteraction = () => {
            this._onMouseUp();
        };
        /**
         * Utility: diff in logical & price between two points
         */
        _getDiff(p1, p2) {
            return {
                logical: p1.logical - p2.logical,
                price: p1.price - p2.price,
            };
        }
        /**
         * Convert the mouse event to a LogicalPoint (with price).
         */
        _eventToPoint(param, series) {
            if (!series || !param.point || !param.logical)
                return null;
            const barPrice = series.coordinateToPrice(param.point.y);
            if (barPrice == null)
                return null;
            return {
                time: param.time || null,
                logical: param.logical,
                price: barPrice.valueOf(),
            };
        }
    }
    /* ============================================================================
      TRENDTRACE PANE VIEW
    ============================================================================ */
    class TrendTracePaneView {
        _p1 = { x: null, y: null };
        _p2 = { x: null, y: null };
        _plugin;
        constructor(plugin) {
            this._plugin = plugin;
        }
        renderer() {
            if (!this._plugin._sequence) {
                throw new Error("No sequence available for rendering.");
            }
            return new TrendTracePaneRenderer(this._plugin, this._plugin._options, false);
        }
    }
    class TrendTracePaneRenderer extends TwoPointDrawingPaneRenderer {
        _source;
        _options;
        constructor(source, options, hovered) {
            super(convertPoint(source._sequence.p1, source.chart, source._source), convertPoint(source._sequence.p2, source.chart, source._source), options, hovered);
            this._source = source;
            this._options = options;
        }
        draw(target) {
            target.useBitmapCoordinateSpace((scope) => {
                const ctx = scope.context;
                const { chart } = this._source;
                ctx.save();
                const { horizontalPixelRatio } = scope;
                const data = this._source._sequence.data;
                const timeScale = this._source.chart.timeScale();
                const series = this._source._source;
                const visibleRange = chart.timeScale().getVisibleLogicalRange();
                const barSpace = chart.options().width /
                    ((visibleRange?.to ?? data.length) - (visibleRange?.from ?? 0));
                console.log("barSpace:", barSpace);
                if (!series || !timeScale || data.length === 0) {
                    ctx.restore();
                    return;
                }
                const firstX = data[0].x1;
                const lastX = data[data.length - 1].x1;
                const canvasX1 = chart.timeScale().logicalToCoordinate(firstX) ?? 0;
                const canvasX2 = chart.timeScale().logicalToCoordinate(lastX) ?? canvasX1;
                const _firstX = canvasX1 * horizontalPixelRatio;
                const _lastX = canvasX2 * horizontalPixelRatio;
                const inverted = (this._source._sequence._originalP2.logical >
                    this._source._sequence._originalP1.logical &&
                    this._source._sequence.p2.logical >
                        this._source._sequence.p1.logical) ||
                    (this._source._sequence._originalP2.logical <
                        this._source._sequence._originalP1.logical &&
                        this._source._sequence.p2.logical <
                            this._source._sequence.p1.logical);
                const scaledBars = data
                    .map((bar, index) => {
                    const scaledX1 = _firstX +
                        (inverted ? 1 : -1) *
                            (index *
                                ((_lastX - _firstX) / data.length) *
                                this._source._sequence.spatial.scale.x);
                    const scaledX2 = _firstX +
                        (inverted ? 1 : -1) *
                            ((index + 1) *
                                ((_lastX - _firstX) / data.length) *
                                this._source._sequence.spatial.scale.x);
                    const color = !bar.isUp
                        ? inverted
                            ? this._options.downColor
                            : this._options.upColor
                        : inverted
                            ? this._options.upColor
                            : this._options.downColor;
                    const borderColor = !bar.isUp
                        ? inverted
                            ? this._options.borderDownColor
                            : this._options.borderUpColor
                        : inverted
                            ? this._options.borderUpColor
                            : this._options.borderDownColor;
                    const wickColor = !bar.isUp
                        ? inverted
                            ? this._options.wickDownColor
                            : this._options.wickUpColor
                        : inverted
                            ? this._options.wickUpColor
                            : this._options.wickDownColor;
                    // Include all required properties in the returned object
                    return {
                        ...bar,
                        scaledX1: inverted ? scaledX1 : scaledX2,
                        scaledX2: inverted ? scaledX2 : scaledX1,
                        color,
                        borderColor,
                        wickColor,
                    };
                })
                    .filter((bar) => bar !== null);
                console.log("Scaled bars:", scaledBars);
                // Continue with drawing logic using `scaledBars`...
                //const firstPoint = scaledBars[0];
                //const lastPoint = scaledBars[scaledBars.length - 1];
                if (this.isOHLCData(data)) {
                    if (this._options.wickVisible) {
                        this._drawWicks(scope, scaledBars, barSpace);
                    }
                    this._drawCandles(scope, scaledBars, barSpace);
                    //// Draw end circles
                    //this._drawEndCircle(
                    //	scope,
                    //	firstPoint.scaledX1,
                    //	series.priceToCoordinate(lastPoint.open??lastPoint.close??lastPoint.value??0) ??0 * verticalPixelRatio				);
                    //this._drawEndCircle(
                    //	scope,
                    //	lastPoint.scaledX2,
                    //	series.priceToCoordinate(lastPoint.close??lastPoint.open??lastPoint.value??0) ??0 * verticalPixelRatio
                    //);
                }
                else if (this.isSingleValueData(data)) {
                    this._drawSingleValueData(scope, scaledBars);
                    //// Draw end circles
                    //this._drawEndCircle(
                    //	scope,
                    //	firstPoint.scaledX1,
                    //	series.priceToCoordinate(firstPoint.value!) ?? 0 * verticalPixelRatio
                    //);
                    //this._drawEndCircle(
                    //	scope,
                    //	lastPoint.scaledX2,
                    //	series.priceToCoordinate(lastPoint.value!) ?? 0 * verticalPixelRatio
                    //);
                }
                ctx.restore();
            });
        }
        /**
         * Draws data points and connecting lines on the bitmap canvas.
         * Each point is drawn at its scaledX1 coordinate and the lines connect consecutive
         * points directly from scaledX1 to scaledX1.
         *
         * @param scope - Contains the canvas context and pixel ratios.
         * @param data - Array of data points with pre-calculated scaled coordinates.
         */
        _drawSingleValueData(scope, data) {
            const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = scope;
            // Set the line appearance once, before drawing
            ctx.lineWidth = this._options.lineWidth ?? 1;
            setLineStyle(ctx, (this._options.lineStyle ?? 1));
            ctx.strokeStyle = this._options.visible
                ? this._options.lineColor ?? "#ffffff"
                : "rgba(0,0,0,0)";
            ctx.beginPath();
            data.forEach((point) => {
                // Skip point if there's no valid logical x value.
                if (point.x1 === null || point.x1 === undefined)
                    return;
                // Calculate the current point's coordinates using scaledX1.
                const scaledX1 = point.scaledX1 * horizontalPixelRatio;
                const scaledValue = (this._source._source?.priceToCoordinate(point.value ?? 0) ?? 0) *
                    verticalPixelRatio;
                ctx.lineTo(scaledX1, scaledValue);
                ctx.stroke();
            });
        }
        _drawWicks(scope, bars, barSpace) {
            const { context: ctx, verticalPixelRatio } = scope;
            const inverted = (this._source._sequence._originalP2.price >
                this._source._sequence._originalP1.price &&
                this._source._sequence.p2.price > this._source._sequence.p1.price) ||
                (this._source._sequence._originalP2.price <
                    this._source._sequence._originalP1.price &&
                    this._source._sequence.p2.price < this._source._sequence.p1.price);
            bars.forEach((bar) => {
                const candleBodyWidth = (this._options.barSpacing ?? 0.8) * (bar.scaledX2 - bar.scaledX1);
                const leftSide = bar.scaledX1; //-  Math.abs((( candleWidth) * ((this._options.barSpacing ?? 0.8)))/2);
                const rightSide = leftSide + candleBodyWidth;
                const middle = (leftSide + rightSide) / 2; //const scaledHigh =
                //  (this._source.series.priceToCoordinate( (inverted? bar.high??0:bar.low??0)) ?? 0) *
                //  verticalPixelRatio;
                //const scaledLow =
                //  (this._source.series.priceToCoordinate((inverted?bar.low??0:bar.high??0)) ?? 0) *
                //  verticalPixelRatio;
                const scaledHigh = (this._source.series.priceToCoordinate(bar.high ?? 0) ?? 0) *
                    verticalPixelRatio;
                const scaledLow = (this._source.series.priceToCoordinate(bar.low ?? 0) ?? 0) *
                    verticalPixelRatio;
                // Calculate the top and bottom parts of the wick based on max(open, close) and min(open, close)
                const scaledOpen = (this._source.series.priceToCoordinate(bar.open ?? 0) ?? 0) *
                    verticalPixelRatio;
                const scaledClose = (this._source.series.priceToCoordinate(bar.close ?? 0) ?? 0) *
                    verticalPixelRatio;
                //const topWick = inverted
                //  ? Math.min(scaledOpen, scaledClose)
                //  : Math.max(scaledOpen, scaledClose);
                //const bottomWick = inverted
                //  ? Math.max(scaledOpen, scaledClose)
                //  : Math.min(scaledOpen, scaledClose);
                const topWick = inverted ? Math.min(scaledOpen, scaledClose) : Math.max(scaledOpen, scaledClose);
                const bottomWick = inverted ? Math.max(scaledOpen, scaledClose) : Math.min(scaledOpen, scaledClose);
                ctx.strokeStyle = this._options.visible
                    ? bar.wickColor ?? "#ffffff"
                    : "rgba(0,0,0,0)";
                // Draw the top wick (high to max(open, close))
                ctx.beginPath();
                ctx.moveTo(middle, scaledHigh);
                ctx.lineTo(middle, topWick);
                ctx.stroke();
                // Draw the bottom wick (min(open, close) to low)
                ctx.beginPath();
                ctx.moveTo(middle, bottomWick);
                ctx.lineTo(middle, scaledLow);
                ctx.stroke();
            });
        }
        _drawCandles(scope, bars, barSpace) {
            const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = scope;
            ctx.save();
            bars.forEach((bar) => {
                const candleBodyWidth = (this._options.barSpacing ?? 0.8) * (bar.scaledX2 - bar.scaledX1);
                if (!bar) {
                    return;
                }
                const scaledOpen = (this._source.series.priceToCoordinate(bar.open) ?? 0) *
                    verticalPixelRatio;
                const scaledClose = (this._source.series.priceToCoordinate(bar.close) ?? 0) *
                    verticalPixelRatio;
                const scaledHigh = (this._source.series.priceToCoordinate(bar.high) ?? 0) *
                    verticalPixelRatio;
                const scaledLow = (this._source.series.priceToCoordinate(bar.low) ?? 0) *
                    verticalPixelRatio;
                const isUp = scaledClose >= scaledOpen;
                const barVerticalMax = Math.min(scaledOpen, scaledClose);
                const barVerticalMin = Math.max(scaledOpen, scaledClose);
                const barVerticalSpan = barVerticalMax - barVerticalMin;
                const barY = (barVerticalMax + barVerticalMin) / 2;
                const leftSide = bar.scaledX1; //-  Math.abs((( candleWidth) * ((this._options.barSpacing ?? 0.8)))/2);
                const rightSide = leftSide + candleBodyWidth; // this._options.chandelierSize??1  > 1? 
                //leftSide +   (candleWidth*(this._options.chandelierSize??1 )) - Math.abs((((this._options.barSpacing ?? 0.8))*(candleWidth)))  : leftSide +  Math.abs(1-((this._options.barSpacing??0.8 * candleWidth)/2));
                const middle = (leftSide + rightSide) / 2; //const scaledHigh =
                ctx.fillStyle = this._options.visible
                    ? bar.color ?? "#ffffff"
                    : "rgba(0,0,0,0)";
                ctx.strokeStyle = this._options.visible
                    ? (this._options.borderVisible ? bar.borderColor : bar.color) ??
                        "#ffffff"
                    : "rgba(0,0,0,0)";
                ctx.lineWidth = bar.lineWidth ?? 1;
                setLineStyle(ctx, bar.lineStyle);
                const shape = this._options?.shape
                    || CandleShape.Rounded; // Use the enum value for defaults
                console.log("Selected candle shape:", shape);
                switch (shape) {
                    case CandleShape.Rectangle:
                        ohlcRectangle(ctx, leftSide, rightSide, barY, barVerticalSpan);
                        break;
                    case CandleShape.Rounded:
                        ohlcRounded(ctx, leftSide, rightSide, barY, barVerticalSpan, 5);
                        break;
                    case CandleShape.Ellipse:
                        ohlcEllipse(ctx, leftSide, rightSide, middle, barY, barVerticalSpan);
                        break;
                    case CandleShape.Arrow:
                        ohlcArrow(ctx, leftSide, rightSide, middle, barY, barVerticalSpan, scaledHigh, scaledLow, isUp);
                        break;
                    case CandleShape.Polygon:
                        ohlcPolygon(ctx, leftSide, rightSide, barY, barVerticalSpan, scaledHigh, scaledLow, isUp);
                        break;
                    case CandleShape.Bar:
                        ohlcBar(ctx, leftSide, rightSide, scaledHigh, scaledLow, scaledOpen, scaledClose);
                        break;
                    case 'Slanted':
                        // Add your newly created slanted candle.
                        ohlcSlantedCandle(ctx, leftSide, rightSide, barY, barVerticalSpan, bar.isUp);
                        break;
                    default:
                        console.warn(`Unknown shape '${shape}', using default Rectangle`);
                        ohlcRectangle(ctx, leftSide, rightSide, barY, barVerticalSpan);
                        break;
                }
                ctx.restore();
            });
        }
        _drawEndCircle(scope, x, y) {
            const ctx = scope.context;
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = this._options.visible
                ? this._options?.color ?? "#FF0000"
                : "rgba(0,0,0,0)";
            ctx.fill();
            ctx.strokeStyle = this._source._sequence._options.lineColor ?? "#000";
            ctx.stroke();
            ctx.restore();
        }
        isOHLCData(data) {
            return data.every((point) => point.open !== undefined &&
                point.high !== undefined &&
                point.low !== undefined &&
                point.close !== undefined);
        }
        isSingleValueData(data) {
            return data.every((point) => point.value !== undefined);
        }
    }

    /**
     * Given a target LogicalPoint, a tolerance factor (for example, 0.05 means 5%),
     * the chart, the series, and the current MouseEventParams, this function checks
     * whether the current mouse event is “close” to the target. The idea is to compute
     * the visible logical and price spans and then use the tolerance factor to derive a
     * threshold for each.
     *
     * @param target The LogicalPoint (for example, an endpoint) to test.
     * @param toleranceFactor A fraction (e.g. 0.05 for 5%) of the visible span.
     * @param chart The chart API.
     * @param series The series API used for the price conversion.
     * @param param The MouseEventParams from the chart.
     * @returns True if the mouse event’s logical and price are within the tolerance thresholds.
     */
    /**
     * Measures the visible pane size from the chart.
     */
    function _measurePaneSize(chart) {
        if (!chart)
            return null;
        const paneSize = chart.paneSize();
        return {
            width: paneSize.width,
            height: paneSize.height,
        };
    }
    /**
    * Converts MouseEventParams to canvas coordinates.
    */
    function eventToCanvasPoint(event, chart) {
        if (!event)
            return null;
        return {
            x: event.x,
            y: event.y,
        };
    }
    // Helper: convert the input (which may be MouseEventParams or a native MouseEvent)
    // to a CanvasPoint. If the input has a 'point' property already, we use that;
    // otherwise, if it’s a MouseEvent, we convert it.
    function getCanvasCoordinates(input, chart) {
        // Check if input is a native MouseEvent by testing for the existence
        // of the "target" property from the DOM event
        if (input instanceof MouseEvent) {
            return eventToCanvasPoint(input);
        }
        // Else, if it’s MouseEventParams and has a "point" property, assume that’s in canvas space.
        if ("point" in input && input.point) {
            return input.point;
        }
        return null;
    }
    /**
     * Determines if the target CanvasPoint is close to the mouse position within the tolerance factor.
     *
     * @param input - A MouseEvent or MouseEventParams object.
     * @param target - The CanvasPoint (or ViewPoint) to compare against.
     * @param toleranceFactor - Fraction of the visible spans (for example, 0.05 for 5%).
     * @param chart - The chart instance.
     * @returns True if within tolerance; otherwise, false.
     */
    function isPointCloseCanvas(input, target, toleranceFactor, chart) {
        const paneSize = _measurePaneSize(chart);
        if (!paneSize)
            return false;
        // Compute visible spans from the pane
        const visibleWidth = paneSize.width;
        const visibleHeight = paneSize.height;
        // Set tolerance thresholds (in canvas coordinate units)
        const xTolerance = visibleWidth * toleranceFactor;
        const yTolerance = visibleHeight * toleranceFactor;
        // Get the canvas point from the input
        const mousePoint = getCanvasCoordinates(input);
        if (!mousePoint || mousePoint.x == null || mousePoint.y == null ||
            target.x == null || target.y == null) {
            return false;
        }
        // Compute the differences in canvas space
        const dx = Math.abs(target.x - mousePoint.x);
        const dy = Math.abs(target.y - mousePoint.y);
        return dx <= xTolerance && dy <= yTolerance;
    }
    const PluginRegistry = {
        "TrendTrace": TrendTrace,
        // Add other plugin types as needed...
    };

    class TwoPointDrawing extends Drawing {
        _paneViews = [];
        _hovered = false;
        linkedObjects = [];
        constructor(p1, p2, options) {
            super();
            this.points.push(p1);
            this.points.push(p2);
            this._options = {
                ...defaultOptions$3,
                ...options,
            };
        }
        setFirstPoint(point) {
            this.updatePoints(point);
        }
        setSecondPoint(point) {
            this.updatePoints(null, point);
        }
        detach() {
            this.linkedObjects.forEach((primitive) => {
                const series = primitive.series;
                if (series) {
                    series.detachPrimitive(primitive);
                }
            });
            this.linkedObjects = []; // Clear linked objects after detaching
            super.detach();
        }
        get p1() { return this.points[0]; }
        get p2() { return this.points[1]; }
        get hovered() { return this._hovered; }
        /**
          * Serializes the drawing’s configuration.
          * Exports points, options, and the linked objects’ state.
          */
        toJSON() {
            return {
                points: this.points,
                _options: this._options,
                linkedObjects: this.linkedObjects.map(obj => typeof obj.toJSON === 'function' ? obj.toJSON() : {}),
            };
        }
        /**
         * Restores the drawing’s configuration from JSON.
         * This updates the drawing’s points, options, and rebuilds linked objects.
         *
         * @param json - The JSON object representing the state.
         */
        fromJSON(json) {
            if (!json)
                return;
            // Restore points.
            if (json.points && Array.isArray(json.points) && json.points.length >= 2) {
                this.updatePoints(json.points[0], json.points[1]);
            }
            // Restore options.
            if (json._options) {
                this._options = { ...this._options, ...json._options };
            }
            // Rebuild linked objects from the JSON array.
            if (json.linkedObjects && Array.isArray(json.linkedObjects)) {
                this.linkedObjects = json.linkedObjects.map((objJson) => {
                    // Determine the plugin type. We assume the JSON object contains a _type property.
                    const type = objJson._type;
                    if (!type) {
                        console.warn("Linked object JSON missing _type property.");
                        return null;
                    }
                    const PluginConstructor = PluginRegistry[type];
                    if (!PluginConstructor) {
                        console.warn(`No constructor found in registry for type: ${type}`);
                        return null;
                    }
                    // Create a new instance and restore its state.
                    const instance = new PluginConstructor();
                    if (typeof instance.fromJSON === "function") {
                        instance.fromJSON(objJson);
                    }
                    return instance;
                }).filter((obj) => obj !== null);
            }
            // Trigger a re-render/update.
            this.requestUpdate();
        }
    }

    class ThreePointDrawing extends Drawing {
        _paneViews = [];
        _hovered = false;
        linkedObjects = [];
        detach() {
            this.linkedObjects.forEach((primitive) => {
                const series = primitive.series;
                if (series) {
                    series.detachPrimitive(primitive);
                }
            });
            this.linkedObjects = []; // Clear linked objects after detaching
            super.detach();
        }
        constructor(p1, p2, p3, options) {
            super();
            this.points.push(p1);
            this.points.push(p2);
            this.points.push(p3);
            this._options = {
                ...defaultOptions$3,
                ...options,
            };
        }
        setFirstPoint(point) {
            this.updatePoints(point);
        }
        setSecondPoint(point) {
            this.updatePoints(null, point);
        }
        setThirdPoint(point) {
            this.updatePoints(null, null, point);
        }
        get p1() { return this.points[0]; }
        get p2() { return this.points[1]; }
        get p3() { return this.points[2]; }
        get hovered() { return this._hovered; }
        /**
          * Serializes the drawing’s configuration.
          * Exports points, options, and the linked objects’ state.
          */
        toJSON() {
            return {
                points: this.points,
                _options: this._options,
                linkedObjects: this.linkedObjects.map(obj => typeof obj.toJSON === 'function' ? obj.toJSON() : {}),
            };
        }
        /**
         * Restores the drawing’s configuration from JSON.
         * This updates the drawing’s points, options, and rebuilds linked objects.
         *
         * @param json - The JSON object representing the state.
         */
        fromJSON(json) {
            if (!json)
                return;
            // Restore points.
            if (json.points && Array.isArray(json.points) && json.points.length >= 2) {
                this.updatePoints(json.points[0], json.points[1]);
            }
            // Restore options.
            if (json._options) {
                this._options = { ...this._options, ...json._options };
            }
            // Rebuild linked objects from the JSON array.
            if (json.linkedObjects && Array.isArray(json.linkedObjects)) {
                this.linkedObjects = json.linkedObjects.map((objJson) => {
                    // Determine the plugin type. We assume the JSON object contains a _type property.
                    const type = objJson._type;
                    if (!type) {
                        console.warn("Linked object JSON missing _type property.");
                        return null;
                    }
                    const PluginConstructor = PluginRegistry[type];
                    if (!PluginConstructor) {
                        console.warn(`No constructor found in registry for type: ${type}`);
                        return null;
                    }
                    // Create a new instance and restore its state.
                    const instance = new PluginConstructor();
                    if (typeof instance.fromJSON === "function") {
                        instance.fromJSON(objJson);
                    }
                    return instance;
                }).filter((obj) => obj !== null);
            }
            // Trigger a re-render/update.
            this.requestUpdate();
        }
    }

    class FourPointDrawing extends Drawing {
        _paneViews = [];
        _hovered = false;
        linkedObjects = [];
        detach() {
            this.linkedObjects.forEach((primitive) => {
                const series = primitive.series;
                if (series) {
                    series.detachPrimitive(primitive);
                }
            });
            this.linkedObjects = []; // Clear linked objects after detaching
            super.detach();
        }
        constructor(p1, p2, p3, p4, options) {
            super();
            this.points.push(p1);
            this.points.push(p2);
            this.points.push(p3);
            this.points.push(p4);
            this._options = {
                ...defaultOptions$3,
                ...options,
            };
        }
        setFirstPoint(point) {
            this.updatePoints(point);
        }
        setSecondPoint(point) {
            this.updatePoints(null, point);
        }
        setThirdPoint(point) {
            this.updatePoints(null, null, point);
        }
        setFourthPoint(point) {
            this.updatePoints(null, null, null, point);
        }
        get p1() { return this.points[0]; }
        get p2() { return this.points[1]; }
        get p3() { return this.points[2]; }
        get p4() { return this.points[3]; }
        get hovered() { return this._hovered; }
    }

    class DrawingTool {
        _chart;
        _series;
        _finishDrawingCallback = null;
        _drawings = [];
        _activeDrawing = null;
        _isDrawing = false;
        _drawingType = null;
        // Temporary storage for multi-click drawings.
        // For three-point drawings we only need the first point.
        // For four-point drawings we need both the first and second temporary points.
        _tempStartPoint = null;
        _tempSecondPoint = null;
        // Track the number of clicks for the active drawing.
        _clickCount = 0;
        constructor(chart, series, finishDrawingCallback = null) {
            this._chart = chart;
            this._series = series;
            this._finishDrawingCallback = finishDrawingCallback;
            this._chart.subscribeClick(this._clickHandler);
            this._chart.subscribeCrosshairMove(this._moveHandler);
        }
        _clickHandler = (param) => this._onClick(param);
        _moveHandler = (param) => this._onMouseMove(param);
        beginDrawing(DrawingType) {
            this._drawingType = DrawingType;
            this._isDrawing = true;
            this._tempStartPoint = null;
            this._tempSecondPoint = null;
            this._clickCount = 0;
        }
        stopDrawing() {
            this._isDrawing = false;
            this._activeDrawing = null;
            this._tempStartPoint = null;
            this._tempSecondPoint = null;
            this._clickCount = 0;
        }
        get drawings() {
            return this._drawings;
        }
        addNewDrawing(drawing) {
            this._series.attachPrimitive(drawing);
            this._drawings.push(drawing);
        }
        delete(d) {
            if (d == null)
                return;
            const idx = this._drawings.indexOf(d);
            if (idx == -1)
                return;
            this._drawings.splice(idx, 1);
            d.detach();
        }
        clearDrawings() {
            for (const d of this._drawings)
                d.detach();
            this._drawings = [];
        }
        repositionOnTime() {
            for (const drawing of this.drawings) {
                const newPoints = [];
                for (const point of drawing.points) {
                    if (!point) {
                        newPoints.push(point);
                        continue;
                    }
                    const logical = point.time
                        ? this._chart.timeScale().coordinateToLogical(this._chart.timeScale().timeToCoordinate(point.time) || 0)
                        : point.logical;
                    newPoints.push({
                        time: point.time,
                        logical: logical,
                        price: point.price,
                    });
                }
                drawing.updatePoints(...newPoints);
            }
        }
        _onClick(param) {
            if (!this._isDrawing)
                return;
            const point = Drawing._eventToPoint(param, this._series);
            if (!point)
                return;
            // 1) Determine the required number of points based on the drawing type.
            let requiredPoints;
            if (this._drawingType) {
                if (this._drawingType.prototype instanceof FourPointDrawing) {
                    requiredPoints = 4;
                }
                else if (this._drawingType.prototype instanceof ThreePointDrawing) {
                    requiredPoints = 3;
                }
                else if (this._drawingType.prototype instanceof TwoPointDrawing) {
                    requiredPoints = 2;
                }
                else {
                    // default to 2 if unknown
                    requiredPoints = 2;
                }
            }
            else {
                return;
            }
            // 2) Handle drawing creation based on the required points.
            if (requiredPoints === 3) {
                // --- Three-point drawing logic ---
                if (this._activeDrawing == null) {
                    // First click: store temporary starting point.
                    if (this._tempStartPoint == null) {
                        this._tempStartPoint = point;
                        this._clickCount = 1;
                        return;
                    }
                    else {
                        // Second click: create the drawing with p1 and p2.
                        this._activeDrawing = new this._drawingType(this._tempStartPoint, point, null);
                        this._series.attachPrimitive(this._activeDrawing);
                        this._clickCount = 2;
                        // Clear temporary storage so that we can set the third point next.
                        this._tempStartPoint = null;
                        return;
                    }
                }
                else {
                    // Third click: set p3 and finalize.
                    if (this._clickCount === 2) {
                        this._activeDrawing.setThirdPoint(point);
                        this._clickCount = 3;
                        this._drawings.push(this._activeDrawing);
                        this.stopDrawing();
                        if (this._finishDrawingCallback) {
                            this._finishDrawingCallback();
                        }
                    }
                }
            }
            else if (requiredPoints === 4) {
                // --- Four-point drawing logic (initialize on click 3) ---
                if (this._activeDrawing == null) {
                    // No active drawing yet.
                    if (this._tempStartPoint == null) {
                        // Click 1: store first point.
                        this._tempStartPoint = point;
                        this._clickCount = 1;
                        return;
                    }
                    else if (this._tempSecondPoint == null) {
                        // Click 2: store second point.
                        this._tempSecondPoint = point;
                        this._clickCount = 2;
                        return;
                    }
                    else {
                        // Click 3: initialize the active drawing using the stored first two points
                        // and the current point as the third point. p4 remains null.
                        this._activeDrawing = new this._drawingType(this._tempStartPoint, this._tempSecondPoint, point, null);
                        this._series.attachPrimitive(this._activeDrawing);
                        this._clickCount = 3;
                        // Clear temporary storage.
                        this._tempStartPoint = null;
                        this._tempSecondPoint = null;
                        return;
                    }
                }
                else {
                    // Active drawing is already initialized.
                    // Click 4: set p4 and finalize.
                    if (this._clickCount === 3) {
                        this._activeDrawing.setFourthPoint(point);
                        this._clickCount = 4;
                        this._drawings.push(this._activeDrawing);
                        this.stopDrawing();
                        if (this._finishDrawingCallback) {
                            this._finishDrawingCallback();
                        }
                    }
                }
            }
            else {
                // --- Two-point drawing logic ---
                if (this._activeDrawing == null) {
                    // First click: create drawing with (p1, p2 = same).
                    this._activeDrawing = new this._drawingType(point, point);
                    this._series.attachPrimitive(this._activeDrawing);
                    this._clickCount = 1;
                }
                else {
                    // Second click: finalize p2.
                    this._activeDrawing.setSecondPoint(point);
                    this._clickCount = 2;
                    this._drawings.push(this._activeDrawing);
                    this.stopDrawing();
                    if (this._finishDrawingCallback) {
                        this._finishDrawingCallback();
                    }
                }
            }
        }
        /**
         * Called whenever the user moves the mouse on the chart (crosshair).
         * Used for real-time preview of the current drawing.
         */
        _onMouseMove(param) {
            if (!param)
                return;
            // 1) Hover logic for all existing drawings.
            for (const d of this._drawings) {
                d._handleHoverInteraction(param);
            }
            // 2) If we are in the middle of drawing, update the last "live" point.
            if (!this._isDrawing || !this._activeDrawing)
                return;
            const point = Drawing._eventToPoint(param, this._series);
            if (!point)
                return;
            // Determine if the drawing is two-, three-, or four-point.
            const isThreePoint = this._drawingType && (this._drawingType.prototype instanceof ThreePointDrawing);
            const isFourPoint = this._drawingType && (this._drawingType.prototype instanceof FourPointDrawing);
            if (isFourPoint) {
                // For four-point drawing:
                // - If click count is 2 (waiting for the third click), preview the third point.
                // - If click count is 3 (active drawing created and waiting for p4), preview the fourth point.
                if (this._clickCount === 2) {
                    this._activeDrawing.updatePoints(null, null, point, null);
                }
                else if (this._clickCount === 3) {
                    this._activeDrawing.updatePoints(null, null, null, point);
                }
            }
            else if (isThreePoint) {
                // For three-point drawing: preview the third point if click count is 2.
                if (this._clickCount === 2) {
                    this._activeDrawing.updatePoints(null, null, point);
                }
            }
            else {
                // For two-point drawing: preview the second point.
                this._activeDrawing.setSecondPoint(point);
            }
        }
    }

    class TrendLinePaneRenderer extends TwoPointDrawingPaneRenderer {
        constructor(p1, p2, options, hovered) {
            super(p1, p2, options, hovered);
        }
        draw(target) {
            target.useBitmapCoordinateSpace(scope => {
                if (this._p1.x === null ||
                    this._p1.y === null ||
                    this._p2.x === null ||
                    this._p2.y === null)
                    return;
                const ctx = scope.context;
                const scaled = this._getScaledCoordinates(scope);
                if (!scaled)
                    return;
                ctx.lineWidth = this._options.width;
                ctx.strokeStyle = this._options.lineColor;
                setLineStyle(ctx, this._options.lineStyle);
                ctx.beginPath();
                ctx.moveTo(scaled.x1, scaled.y1);
                ctx.lineTo(scaled.x2, scaled.y2);
                ctx.stroke();
                // this._drawTextLabel(scope, this._text1, x1Scaled, y1Scaled, true);
                // this._drawTextLabel(scope, this._text2, x2Scaled, y2Scaled, false);
                if (!this._hovered)
                    return;
                this._drawEndCircle(scope, scaled.x1, scaled.y1);
                this._drawEndCircle(scope, scaled.x2, scaled.y2);
            });
        }
    }

    class DrawingPaneView {
        _source;
        constructor(source) {
            this._source = source;
        }
    }
    class TwoPointDrawingPaneView extends DrawingPaneView {
        _p1 = { x: null, y: null };
        _p2 = { x: null, y: null };
        _source;
        constructor(source) {
            super(source);
            this._source = source;
        }
        update() {
            if (!this._source.p1 || !this._source.p2)
                return;
            const series = this._source.series;
            const y1 = series.priceToCoordinate(this._source.p1.price);
            const y2 = series.priceToCoordinate(this._source.p2.price);
            const x1 = this._getX(this._source.p1);
            const x2 = this._getX(this._source.p2);
            this._p1 = { x: x1, y: y1 };
            this._p2 = { x: x2, y: y2 };
            if (!x1 || !x2 || !y1 || !y2)
                return;
        }
        _getX(p) {
            const timeScale = this._source.chart.timeScale();
            return timeScale.logicalToCoordinate(p.logical);
        }
    }
    class ThreePointDrawingPaneView extends DrawingPaneView {
        _p1 = { x: null, y: null };
        _p2 = { x: null, y: null };
        _p3 = { x: null, y: null };
        _source;
        constructor(source) {
            super(source);
            this._source = source;
        }
        update() {
            if (!this._source.p1 || !this._source.p2 || !this._source.p3)
                return;
            const series = this._source.series;
            const y1 = series.priceToCoordinate(this._source.p1.price);
            const y2 = series.priceToCoordinate(this._source.p2.price);
            const y3 = series.priceToCoordinate(this._source.p3.price);
            const x1 = this._getX(this._source.p1);
            const x2 = this._getX(this._source.p2);
            const x3 = this._getX(this._source.p3);
            this._p1 = { x: x1, y: y1 };
            this._p2 = { x: x2, y: y2 };
            this._p3 = { x: x3, y: y3 };
            if (!x1 || !x2 || !x3 || !y1 || !y2 || !y3)
                return;
        }
        _getX(p) {
            const timeScale = this._source.chart.timeScale();
            return timeScale.logicalToCoordinate(p.logical);
        }
    }

    class TrendLinePaneView extends TwoPointDrawingPaneView {
        constructor(source) {
            super(source);
        }
        renderer() {
            return new TrendLinePaneRenderer(this._p1, this._p2, this._source._options, this._source.hovered);
        }
    }

    class TrendLine extends TwoPointDrawing {
        _type = "TrendLine";
        constructor(p1, p2, options) {
            super(p1, p2, options);
            this._paneViews = [new TrendLinePaneView(this)];
        }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._hovered = false;
                    this.requestUpdate();
                    this._unsubscribe("mousedown", this._handleMouseDownInteraction);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._hovered = true;
                    this.requestUpdate();
                    this._subscribe("mousedown", this._handleMouseDownInteraction);
                    this._unsubscribe("mouseup", this._handleMouseDownInteraction);
                    this.chart.applyOptions({ handleScroll: true });
                    break;
                case InteractionState.DRAGGINGP1:
                case InteractionState.DRAGGINGP2:
                case InteractionState.DRAGGING:
                    document.body.style.cursor = "grabbing";
                    this._subscribe("mouseup", this._handleMouseUpInteraction);
                    this.chart.applyOptions({ handleScroll: false });
                    break;
            }
            this._state = state;
        }
        _onDrag(diff) {
            if (this._state == InteractionState.DRAGGING || this._state == InteractionState.DRAGGINGP1) {
                this._addDiffToPoint(this.p1, diff.logical, diff.price);
            }
            if (this._state == InteractionState.DRAGGING || this._state == InteractionState.DRAGGINGP2) {
                this._addDiffToPoint(this.p2, diff.logical, diff.price);
            }
        }
        _onMouseDown() {
            this._startDragPoint = null;
            const hoverPoint = this._latestHoverPoint;
            if (!hoverPoint)
                return;
            const p1 = this._paneViews[0]._p1;
            const p2 = this._paneViews[0]._p2;
            if (!p1.x || !p2.x || !p1.y || !p2.y)
                return this._moveToState(InteractionState.DRAGGING);
            const tolerance = 10;
            if (Math.abs(hoverPoint.x - p1.x) < tolerance && Math.abs(hoverPoint.y - p1.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP1);
            }
            else if (Math.abs(hoverPoint.x - p2.x) < tolerance && Math.abs(hoverPoint.y - p2.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP2);
            }
            else {
                this._moveToState(InteractionState.DRAGGING);
            }
        }
        _mouseIsOverDrawing(param, tolerance = 4) {
            if (!param.point)
                return false;
            const x1 = this._paneViews[0]._p1.x;
            const y1 = this._paneViews[0]._p1.y;
            const x2 = this._paneViews[0]._p2.x;
            const y2 = this._paneViews[0]._p2.y;
            if (!x1 || !x2 || !y1 || !y2)
                return false;
            const mouseX = param.point.x;
            const mouseY = param.point.y;
            if (mouseX <= Math.min(x1, x2) - tolerance ||
                mouseX >= Math.max(x1, x2) + tolerance) {
                return false;
            }
            const distance = Math.abs((y2 - y1) * mouseX - (x2 - x1) * mouseY + x2 * y1 - y2 * x1) / Math.sqrt((y2 - y1) ** 2 + (x2 - x1) ** 2);
            return distance <= tolerance;
        }
    }

    class BoxPaneRenderer extends TwoPointDrawingPaneRenderer {
        constructor(p1, p2, options, showCircles) {
            super(p1, p2, options, showCircles);
        }
        draw(target) {
            target.useBitmapCoordinateSpace(scope => {
                const ctx = scope.context;
                const scaled = this._getScaledCoordinates(scope);
                if (!scaled)
                    return;
                ctx.lineWidth = this._options.width;
                ctx.strokeStyle = this._options.lineColor;
                setLineStyle(ctx, this._options.lineStyle);
                ctx.fillStyle = this._options.fillColor;
                const mainX = Math.min(scaled.x1, scaled.x2);
                const mainY = Math.min(scaled.y1, scaled.y2);
                const width = Math.abs(scaled.x1 - scaled.x2);
                const height = Math.abs(scaled.y1 - scaled.y2);
                ctx.strokeRect(mainX, mainY, width, height);
                ctx.fillRect(mainX, mainY, width, height);
                if (!this._hovered)
                    return;
                this._drawEndCircle(scope, mainX, mainY);
                this._drawEndCircle(scope, mainX + width, mainY);
                this._drawEndCircle(scope, mainX + width, mainY + height);
                this._drawEndCircle(scope, mainX, mainY + height);
            });
        }
    }

    class BoxPaneView extends TwoPointDrawingPaneView {
        constructor(source) {
            super(source);
        }
        renderer() {
            return new BoxPaneRenderer(this._p1, this._p2, this._source._options, this._source.hovered);
        }
    }

    const defaultBoxOptions = {
        fillEnabled: true,
        fillColor: 'rgba(255, 255, 255, 0.2)',
        ...defaultOptions$3
    };
    class Box extends TwoPointDrawing {
        _type = "Box";
        constructor(p1, p2, options) {
            super(p1, p2, options);
            this._options = {
                ...defaultBoxOptions,
                ...options,
            };
            this._paneViews = [new BoxPaneView(this)];
        }
        // autoscaleInfo(startTimePoint: Logical, endTimePoint: Logical): AutoscaleInfo | null {
        // const p1Index = this._pointIndex(this._p1);
        // const p2Index = this._pointIndex(this._p2);
        // if (p1Index === null || p2Index === null) return null;
        // if (endTimePoint < p1Index || startTimePoint > p2Index) return null;
        // return {
        //  priceRange: {
        //      minValue: this._minPrice,
        //      maxValue: this._maxPrice,
        //  },
        // };
        // }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._hovered = false;
                    this._unsubscribe("mousedown", this._handleMouseDownInteraction);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._hovered = true;
                    this._unsubscribe("mouseup", this._handleMouseUpInteraction);
                    this._subscribe("mousedown", this._handleMouseDownInteraction);
                    this.chart.applyOptions({ handleScroll: true });
                    break;
                case InteractionState.DRAGGINGP1:
                case InteractionState.DRAGGINGP2:
                case InteractionState.DRAGGINGP3:
                case InteractionState.DRAGGINGP4:
                case InteractionState.DRAGGING:
                    document.body.style.cursor = "grabbing";
                    document.body.addEventListener("mouseup", this._handleMouseUpInteraction);
                    this._subscribe("mouseup", this._handleMouseUpInteraction);
                    this.chart.applyOptions({ handleScroll: false });
                    break;
            }
            this._state = state;
        }
        _onDrag(diff) {
            if (this._state == InteractionState.DRAGGING || this._state == InteractionState.DRAGGINGP1) {
                this._addDiffToPoint(this.p1, diff.logical, diff.price);
            }
            if (this._state == InteractionState.DRAGGING || this._state == InteractionState.DRAGGINGP2) {
                this._addDiffToPoint(this.p2, diff.logical, diff.price);
            }
            if (this._state != InteractionState.DRAGGING) {
                if (this._state == InteractionState.DRAGGINGP3) {
                    this._addDiffToPoint(this.p1, diff.logical, 0);
                    this._addDiffToPoint(this.p2, 0, diff.price);
                }
                if (this._state == InteractionState.DRAGGINGP4) {
                    this._addDiffToPoint(this.p1, 0, diff.price);
                    this._addDiffToPoint(this.p2, diff.logical, 0);
                }
            }
        }
        _onMouseDown() {
            this._startDragPoint = null;
            const hoverPoint = this._latestHoverPoint;
            const p1 = this._paneViews[0]._p1;
            const p2 = this._paneViews[0]._p2;
            if (!p1.x || !p2.x || !p1.y || !p2.y)
                return this._moveToState(InteractionState.DRAGGING);
            const tolerance = 10;
            if (Math.abs(hoverPoint.x - p1.x) < tolerance && Math.abs(hoverPoint.y - p1.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP1);
            }
            else if (Math.abs(hoverPoint.x - p2.x) < tolerance && Math.abs(hoverPoint.y - p2.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP2);
            }
            else if (Math.abs(hoverPoint.x - p1.x) < tolerance && Math.abs(hoverPoint.y - p2.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP3);
            }
            else if (Math.abs(hoverPoint.x - p2.x) < tolerance && Math.abs(hoverPoint.y - p1.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP4);
            }
            else {
                this._moveToState(InteractionState.DRAGGING);
            }
        }
        _mouseIsOverDrawing(param, tolerance = 4) {
            if (!param.point)
                return false;
            const x1 = this._paneViews[0]._p1.x;
            const y1 = this._paneViews[0]._p1.y;
            const x2 = this._paneViews[0]._p2.x;
            const y2 = this._paneViews[0]._p2.y;
            if (!x1 || !x2 || !y1 || !y2)
                return false;
            const mouseX = param.point.x;
            const mouseY = param.point.y;
            const mainX = Math.min(x1, x2);
            const mainY = Math.min(y1, y2);
            const width = Math.abs(x1 - x2);
            const height = Math.abs(y1 - y2);
            const halfTolerance = tolerance / 2;
            return mouseX > mainX - halfTolerance && mouseX < mainX + width + halfTolerance &&
                mouseY > mainY - halfTolerance && mouseY < mainY + height + halfTolerance;
        }
    }

    class HorizontalLinePaneRenderer extends DrawingPaneRenderer {
        _point = { x: null, y: null };
        constructor(point, options) {
            super(options);
            this._point = point;
        }
        draw(target) {
            target.useBitmapCoordinateSpace(scope => {
                if (this._point.y == null)
                    return;
                const ctx = scope.context;
                const scaledY = Math.round(this._point.y * scope.verticalPixelRatio);
                const scaledX = this._point.x ? this._point.x * scope.horizontalPixelRatio : 0;
                ctx.lineWidth = this._options.width;
                ctx.strokeStyle = this._options.lineColor;
                setLineStyle(ctx, this._options.lineStyle);
                ctx.beginPath();
                ctx.moveTo(scaledX, scaledY);
                ctx.lineTo(scope.bitmapSize.width, scaledY);
                ctx.stroke();
            });
        }
    }

    class HorizontalLinePaneView extends DrawingPaneView {
        _source;
        _point = { x: null, y: null };
        constructor(source) {
            super(source);
            this._source = source;
        }
        update() {
            const point = this._source._point;
            const timeScale = this._source.chart.timeScale();
            const series = this._source.series;
            if (this._source._type == "RayLine") {
                this._point.x = point.time ? timeScale.timeToCoordinate(point.time) : timeScale.logicalToCoordinate(point.logical);
            }
            this._point.y = series.priceToCoordinate(point.price);
        }
        renderer() {
            return new HorizontalLinePaneRenderer(this._point, this._source._options);
        }
    }

    class HorizontalLineAxisView {
        _source;
        _y = null;
        _price = null;
        constructor(source) {
            this._source = source;
        }
        update() {
            if (!this._source.series || !this._source._point)
                return;
            this._y = this._source.series.priceToCoordinate(this._source._point.price);
            const priceFormat = this._source.series.options().priceFormat;
            const precision = priceFormat.precision;
            this._price = this._source._point.price.toFixed(precision).toString();
        }
        visible() {
            return true;
        }
        tickVisible() {
            return true;
        }
        coordinate() {
            return this._y ?? 0;
        }
        text() {
            return this._source._options.text || this._price || '';
        }
        textColor() {
            return 'white';
        }
        backColor() {
            return this._source._options.lineColor;
        }
    }

    class HorizontalLine extends Drawing {
        _type = 'HorizontalLine';
        _paneViews;
        _point;
        _callbackName;
        _priceAxisViews;
        _startDragPoint = null;
        constructor(point, options, callbackName = null) {
            super(options);
            this._point = point;
            this._point.time = null; // time is null for horizontal lines
            this._paneViews = [new HorizontalLinePaneView(this)];
            this._priceAxisViews = [new HorizontalLineAxisView(this)];
            this._callbackName = callbackName;
        }
        get points() {
            return [this._point];
        }
        updatePoints(...points) {
            for (const p of points)
                if (p)
                    this._point.price = p.price;
            this.requestUpdate();
        }
        updateAllViews() {
            this._paneViews.forEach((pw) => pw.update());
            this._priceAxisViews.forEach((tw) => tw.update());
        }
        priceAxisViews() {
            return this._priceAxisViews;
        }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._unsubscribe("mousedown", this._handleMouseDownInteraction);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._unsubscribe("mouseup", this._childHandleMouseUpInteraction);
                    this._subscribe("mousedown", this._handleMouseDownInteraction);
                    this.chart.applyOptions({ handleScroll: true });
                    break;
                case InteractionState.DRAGGING:
                    document.body.style.cursor = "grabbing";
                    this._subscribe("mouseup", this._childHandleMouseUpInteraction);
                    this.chart.applyOptions({ handleScroll: false });
                    break;
            }
            this._state = state;
        }
        _onDrag(diff) {
            this._addDiffToPoint(this._point, 0, diff.price);
            this.requestUpdate();
        }
        _mouseIsOverDrawing(param, tolerance = 4) {
            if (!param.point)
                return false;
            const y = this.series.priceToCoordinate(this._point.price);
            if (!y)
                return false;
            return (Math.abs(y - param.point.y) < tolerance);
        }
        _onMouseDown() {
            this._startDragPoint = null;
            const hoverPoint = this._latestHoverPoint;
            if (!hoverPoint)
                return;
            return this._moveToState(InteractionState.DRAGGING);
        }
        _childHandleMouseUpInteraction = () => {
            this._handleMouseUpInteraction();
            if (!this._callbackName)
                return;
            window.callbackFunction(`${this._callbackName}_~_${this._point.price.toFixed(8)}`);
        };
    }

    class RayLine extends HorizontalLine {
        _type = 'RayLine';
        constructor(point, options) {
            super({ ...point }, options);
            this._point.time = point.time;
        }
        updatePoints(...points) {
            for (const p of points)
                if (p)
                    this._point = p;
            this.requestUpdate();
        }
        _onDrag(diff) {
            this._addDiffToPoint(this._point, diff.logical, diff.price);
            this.requestUpdate();
        }
        _mouseIsOverDrawing(param, tolerance = 4) {
            if (!param.point)
                return false;
            const y = this.series.priceToCoordinate(this._point.price);
            const x = this._point.time ? this.chart.timeScale().timeToCoordinate(this._point.time) : null;
            if (!y || !x)
                return false;
            return (Math.abs(y - param.point.y) < tolerance && param.point.x > x - tolerance);
        }
    }

    class VerticalLinePaneRenderer extends DrawingPaneRenderer {
        _point = { x: null, y: null };
        constructor(point, options) {
            super(options);
            this._point = point;
        }
        draw(target) {
            target.useBitmapCoordinateSpace(scope => {
                if (this._point.x == null)
                    return;
                const ctx = scope.context;
                const scaledX = this._point.x * scope.horizontalPixelRatio;
                ctx.lineWidth = this._options.width;
                ctx.strokeStyle = this._options.lineColor;
                setLineStyle(ctx, this._options.lineStyle);
                ctx.beginPath();
                ctx.moveTo(scaledX, 0);
                ctx.lineTo(scaledX, scope.bitmapSize.height);
                ctx.stroke();
            });
        }
    }

    class VerticalLinePaneView extends DrawingPaneView {
        _source;
        _point = { x: null, y: null };
        constructor(source) {
            super(source);
            this._source = source;
        }
        update() {
            const point = this._source._point;
            const timeScale = this._source.chart.timeScale();
            const series = this._source.series;
            this._point.x = point.time ? timeScale.timeToCoordinate(point.time) : timeScale.logicalToCoordinate(point.logical);
            this._point.y = series.priceToCoordinate(point.price);
        }
        renderer() {
            return new VerticalLinePaneRenderer(this._point, this._source._options);
        }
    }

    class VerticalLineTimeAxisView {
        _source;
        _x = null;
        constructor(source) {
            this._source = source;
        }
        update() {
            if (!this._source.chart || !this._source._point)
                return;
            const point = this._source._point;
            const timeScale = this._source.chart.timeScale();
            this._x = point.time ? timeScale.timeToCoordinate(point.time) : timeScale.logicalToCoordinate(point.logical);
        }
        visible() {
            return !!this._source._options.text;
        }
        tickVisible() {
            return true;
        }
        coordinate() {
            return this._x ?? 0;
        }
        text() {
            return this._source._options.text || '';
        }
        textColor() {
            return "white";
        }
        backColor() {
            return this._source._options.lineColor;
        }
    }

    class VerticalLine extends Drawing {
        _type = 'VerticalLine';
        _paneViews;
        _timeAxisViews;
        _point;
        _callbackName;
        _startDragPoint = null;
        constructor(point, options, callbackName = null) {
            super(options);
            this._point = point;
            this._paneViews = [new VerticalLinePaneView(this)];
            this._callbackName = callbackName;
            this._timeAxisViews = [new VerticalLineTimeAxisView(this)];
        }
        updateAllViews() {
            this._paneViews.forEach(pw => pw.update());
            this._timeAxisViews.forEach(tw => tw.update());
        }
        timeAxisViews() {
            return this._timeAxisViews;
        }
        updatePoints(...points) {
            for (const p of points) {
                if (!p)
                    continue;
                if (!p.time && p.logical) {
                    p.time = this.series.dataByIndex(p.logical)?.time || null;
                }
                this._point = p;
            }
            this.requestUpdate();
        }
        get points() {
            return [this._point];
        }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._unsubscribe("mousedown", this._handleMouseDownInteraction);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._unsubscribe("mouseup", this._childHandleMouseUpInteraction);
                    this._subscribe("mousedown", this._handleMouseDownInteraction);
                    this.chart.applyOptions({ handleScroll: true });
                    break;
                case InteractionState.DRAGGING:
                    document.body.style.cursor = "grabbing";
                    this._subscribe("mouseup", this._childHandleMouseUpInteraction);
                    this.chart.applyOptions({ handleScroll: false });
                    break;
            }
            this._state = state;
        }
        _onDrag(diff) {
            this._addDiffToPoint(this._point, diff.logical, 0);
            this.requestUpdate();
        }
        _mouseIsOverDrawing(param, tolerance = 4) {
            if (!param.point)
                return false;
            const timeScale = this.chart.timeScale();
            let x;
            if (this._point.time) {
                x = timeScale.timeToCoordinate(this._point.time);
            }
            else {
                x = timeScale.logicalToCoordinate(this._point.logical);
            }
            if (!x)
                return false;
            return (Math.abs(x - param.point.x) < tolerance);
        }
        _onMouseDown() {
            this._startDragPoint = null;
            const hoverPoint = this._latestHoverPoint;
            if (!hoverPoint)
                return;
            return this._moveToState(InteractionState.DRAGGING);
        }
        _childHandleMouseUpInteraction = () => {
            this._handleMouseUpInteraction();
            if (!this._callbackName)
                return;
            window.callbackFunction(`${this._callbackName}_~_${this._point.price.toFixed(8)}`);
        };
    }

    /**
     * Renderer class for drawing Pitch Forks.
     *
     * Responsibilities:
     * - Compute geometric positions based on input view points.
     * - Render all parts of the pitchfork including the baseline, median, and fork-lines.
     *
     * SOLID Considerations:
     * - Single Responsibility: Each helper (e.g. computing anchor point, intersection) has one task.
     * - Open/Closed: New drawing variants can be added by extending without modifying existing logic.
     * - Liskov Substitution: Derived classes can be substituted without altering behavior.
     * - Interface Segregation: The public API remains minimal.
     * - Dependency Inversion: Drawing relies on abstract canvas operations.
     */
    class PitchForkPaneRenderer extends ThreePointDrawingPaneRenderer {
        options;
        variant;
        /**
         * Constructs a new PitchForkPaneRenderer instance.
         *
         * @param p1 - The first view point.
         * @param p2 - The second view point.
         * @param p3 - The third view point.
         * @param options - Options for drawing the pitchfork.
         * @param hovered - Indicates whether the pitchfork is hovered.
         */
        constructor(p1, p2, p3, options, hovered) {
            super(p1, p2, p3, options, hovered);
            this.options = options;
            this.variant = options.variant ?? "standard";
        }
        /**
         * Draws the pitchfork on the provided canvas rendering target.
         *
         * The method computes key geometric points and draws the baseline, median, fork-lines,
         * and optionally fills the area and draws hover circles.
         *
         * @param target - The canvas rendering target.
         */
        draw(target) {
            target.useBitmapCoordinateSpace((scope) => {
                if (this._p1.x === null || this._p1.y === null ||
                    this._p2.x === null || this._p2.y === null ||
                    this._p3.x === null || this._p3.y === null) {
                    return;
                }
                const ctx = scope.context;
                const scaled = this._getScaledCoordinates(scope);
                if (!scaled)
                    return;
                const { x1, y1, x2, y2, x3, y3 } = scaled;
                // 1) Compute the midpoint of p2→p3.
                const midP2P3X = (x2 + x3) / 2;
                const midP2P3Y = (y2 + y3) / 2;
                let medianStartX, medianStartY;
                let medianEndX, medianEndY;
                let vx, vy; // median vector
                // The horizontal extension is 2× the difference between p2.x and p1.x.
                const dxExtension = (this._options.length ?? 1) * (x2 - x1);
                if (this.variant === "inside") {
                    // For the "inside" variant:
                    // - The median starts at the midpoint of p2 and p3.
                    // - Its direction is defined by the vector from p3 to the midpoint of p1 and p2.
                    medianStartX = midP2P3X;
                    medianStartY = midP2P3Y;
                    const midP1P2X = (x1 + x2) / 2;
                    const midP1P2Y = (y1 + y2) / 2;
                    // Compute the direction from p3 to the midpoint of p1 and p2.
                    const deltaX = midP1P2X - x3;
                    const deltaY = midP1P2Y - y3;
                    let angle = Math.atan2(deltaY, deltaX);
                    // Ensure the extension goes rightwards: if the horizontal component is negative, flip the angle.
                    if (Math.cos(angle) < 0) {
                        angle += Math.PI;
                    }
                    medianEndX = medianStartX + dxExtension * Math.cos(angle);
                    medianEndY = medianStartY + dxExtension * Math.sin(angle);
                }
                else {
                    // For other variants:
                    // 2) Compute the variant-based anchor point from p1 and p2.
                    const { anchorX, anchorY } = this._computeAnchorPoint(this.variant, x1, y1, x2, y2);
                    // 3) Compute the intersection of L1 (p1→p2) and L2 (from midpoint of p2→p3 towards the anchor).
                    const intersect = this._lineIntersection(x1, y1, x2, y2, midP2P3X, midP2P3Y, anchorX, anchorY);
                    if (intersect) {
                        [medianStartX, medianStartY] = intersect;
                    }
                    else {
                        // Fallback: if no intersection, use p1.
                        medianStartX = x1;
                        medianStartY = y1;
                    }
                    // 4) Compute the slope from the median start to the midpoint of p2 and p3.
                    const dxForSlope = midP2P3X - medianStartX;
                    const slope = Math.abs(dxForSlope) > 1e-9 ? (midP2P3Y - medianStartY) / dxForSlope : 0;
                    medianEndX = medianStartX + dxExtension;
                    medianEndY = medianStartY + slope * dxExtension;
                }
                // Compute the median vector.
                vx = medianEndX - medianStartX;
                vy = medianEndY - medianStartY;
                // 5) Optional fill: draw a quadrilateral from the baseline (p2→p3) offset by the median vector.
                //if (this.options.fillColor) {
                //  ctx.save();
                //  ctx.fillStyle = this.options.fillColor;
                //  ctx.beginPath();
                //  ctx.moveTo(x2, y2);
                //  ctx.lineTo(x3, y3);
                //  ctx.lineTo(x3 + vx, y3 + vy);
                //  ctx.lineTo(x2 + vx, y2 + vy);
                //  ctx.closePath();
                //  ctx.fill();
                //  ctx.restore();
                //}
                // 6) Set line style and draw the primary lines.
                ctx.lineWidth = this.options.width;
                ctx.strokeStyle = this.options.lineColor;
                setLineStyle(ctx, this.options.lineStyle);
                // 7) Draw the primary lines.
                // (a) Baseline: p2→p3.
                setLineStyle(ctx, lightweightCharts.LineStyle.Solid);
                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x3, y3);
                ctx.stroke();
                setLineStyle(ctx, this.options.lineStyle);
                // (b) p1→p2 (always drawn).
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                // (c) Median line.
                ctx.beginPath();
                ctx.moveTo(medianStartX, medianStartY);
                ctx.lineTo(medianEndX, medianEndY);
                ctx.stroke();
                // (d) Parallels: lines through p2 and p3 using the median vector.
                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 + vx, y2 + vy);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x3, y3);
                ctx.lineTo(x3 + vx, y3 + vy);
                ctx.stroke();
                // 8) Draw additional fork-lines parallel to the median and fill between them if fillColor is set.
                if (this.options.forkLines && this.options.forkLines.length > 0) {
                    const forkLines = this.options.forkLines;
                    for (let i = 0; i < forkLines.length; i++) {
                        const fork = forkLines[i];
                        // Compute the current fork's starting point: p3 offset by fork.value * (p2 - p3)
                        const forkStartX = x3 + fork.value * (x2 - x3);
                        const forkStartY = y3 + fork.value * (y2 - y3);
                        // Extend the fork-line using the same median vector.
                        const forkEndX = forkStartX + vx;
                        const forkEndY = forkStartY + vy;
                        // Draw the current fork line.
                        ctx.lineWidth = fork.width;
                        ctx.strokeStyle = fork.color;
                        setLineStyle(ctx, fork.style);
                        ctx.beginPath();
                        ctx.moveTo(forkStartX, forkStartY);
                        ctx.lineTo(forkEndX, forkEndY);
                        ctx.stroke();
                        // If the current fork line has a fillColor and there's a fork line below it, fill the area.
                        if (fork.fillColor && i < forkLines.length - 1) {
                            const nextFork = forkLines[i + 1];
                            const nextForkStartX = x3 + nextFork.value * (x2 - x3);
                            const nextForkStartY = y3 + nextFork.value * (y2 - y3);
                            const nextForkEndX = nextForkStartX + vx;
                            const nextForkEndY = nextForkStartY + vy;
                            ctx.save();
                            ctx.fillStyle = fork.fillColor;
                            ctx.beginPath();
                            ctx.moveTo(forkStartX, forkStartY);
                            ctx.lineTo(forkEndX, forkEndY);
                            ctx.lineTo(nextForkEndX, nextForkEndY);
                            ctx.lineTo(nextForkStartX, nextForkStartY);
                            ctx.closePath();
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                }
                // 9) If hovered, draw circles at the pivot points.
                if (this._hovered) {
                    ctx.lineWidth = this.options.width + 1;
                    ctx.strokeStyle = this.options.lineColor;
                    setLineStyle(ctx, lightweightCharts.LineStyle.Solid);
                    this._drawEndCircle(scope, x1, y1);
                    this._drawEndCircle(scope, x2, y2);
                    this._drawEndCircle(scope, x3, y3);
                }
            });
        }
        /**
         * Computes the anchor point based on the pitchfork variant.
         *
         * @param variant - The pitchfork variant.
         * @param x1 - x-coordinate of p1.
         * @param y1 - y-coordinate of p1.
         * @param x2 - x-coordinate of p2.
         * @param y2 - y-coordinate of p2.
         * @returns The computed anchor point.
         */
        _computeAnchorPoint(variant, x1, y1, x2, y2) {
            switch (variant) {
                case "standard":
                    return { anchorX: x1, anchorY: y1 };
                case "schiff":
                    return { anchorX: x1, anchorY: (y1 + y2) / 2 };
                case "modifiedSchiff":
                    return { anchorX: (x1 + x2) / 2, anchorY: (y1 + y2) / 2 };
                case "inside":
                    // Although the "inside" variant computes its median differently,
                    // we still provide an anchor for consistency.
                    return { anchorX: x1 + 0.5 * (x2 - x1), anchorY: y1 + 0.5 * (y2 - y1) };
            }
        }
        /**
         * Calculates the intersection point of two infinite lines:
         * - Line 1: from (x1, y1) to (x2, y2)
         * - Line 2: from (x3, y3) to (x4, y4)
         *
         * @returns A tuple [xi, yi] representing the intersection point, or null if the lines are parallel.
         */
        _lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (Math.abs(denom) < 1e-9)
                return null;
            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            const ix = x1 + ua * (x2 - x1);
            const iy = y1 + ua * (y2 - y1);
            return [ix, iy];
        }
    }

    class PitchForkPaneView extends ThreePointDrawingPaneView {
        constructor(source) {
            super(source);
        }
        renderer() {
            return new PitchForkPaneRenderer(this._p1, this._p2, this._p3, this._source._options, this._source.hovered);
        }
    }

    const defaultPitchForkOptions = {
        lineColor: "#ffffff",
        lineStyle: lightweightCharts.LineStyle.LargeDashed,
        width: 1,
        variant: "standard",
        forkLines: [
            {
                value: 1.0,
                width: 2,
                style: lightweightCharts.LineStyle.Solid,
                color: "#ff0000",
                fillColor: undefined,
            },
            {
                value: 0.786,
                width: 1,
                style: lightweightCharts.LineStyle.SparseDotted,
                color: "#000fff",
                fillColor: undefined,
            },
            {
                value: 0.618,
                width: 1,
                style: lightweightCharts.LineStyle.LargeDashed,
                color: "#ffffff",
                fillColor: undefined,
            },
            {
                value: 0.5,
                width: 2,
                style: lightweightCharts.LineStyle.Solid,
                color: "#ff0000",
                fillColor: undefined,
            },
            {
                value: 0.382,
                width: 1,
                style: lightweightCharts.LineStyle.LargeDashed,
                color: "#ffffff",
                fillColor: undefined,
            },
            {
                value: 0.236,
                width: 1,
                style: lightweightCharts.LineStyle.SparseDotted,
                color: "#000fff",
                fillColor: undefined,
            },
            {
                value: 0,
                width: 2,
                style: lightweightCharts.LineStyle.Solid,
                color: "#ff0000",
                fillColor: undefined,
            },
        ],
        length: 1.0, // default logical length for extensions
    };
    class PitchFork extends ThreePointDrawing {
        _type = "PitchFork";
        variant;
        constructor(p1, p2, p3, options) {
            super(p1, p2, p3, { ...defaultPitchForkOptions, ...options });
            this.variant = options?.variant || "standard";
            this._paneViews = [new PitchForkPaneView(this)];
        }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._hovered = false;
                    this.requestUpdate();
                    this._unsubscribe("mousedown", this._handleMouseDownInteraction);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._hovered = true;
                    this.requestUpdate();
                    this._subscribe("mousedown", this._handleMouseDownInteraction);
                    this._unsubscribe("mouseup", this._handleMouseDownInteraction);
                    this.chart.applyOptions({ handleScroll: true });
                    break;
                case InteractionState.DRAGGINGP1:
                case InteractionState.DRAGGINGP2:
                case InteractionState.DRAGGINGP3:
                case InteractionState.DRAGGING:
                    document.body.style.cursor = "grabbing";
                    this._subscribe("mouseup", this._handleMouseUpInteraction);
                    this.chart.applyOptions({ handleScroll: false });
                    break;
            }
            this._state = state;
        }
        _onDrag(diff) {
            if (this._state == InteractionState.DRAGGING ||
                this._state == InteractionState.DRAGGINGP1) {
                this._addDiffToPoint(this.p1, diff.logical, diff.price);
            }
            if (this._state == InteractionState.DRAGGING ||
                this._state == InteractionState.DRAGGINGP2) {
                this._addDiffToPoint(this.p2, diff.logical, diff.price);
            }
            if (this._state == InteractionState.DRAGGING ||
                this._state == InteractionState.DRAGGINGP3) {
                this._addDiffToPoint(this.p3, diff.logical, diff.price);
            }
        }
        _onMouseDown() {
            this._startDragPoint = null;
            const hoverPoint = this._latestHoverPoint;
            if (!hoverPoint)
                return;
            const p1 = this._paneViews[0]._p1;
            const p2 = this._paneViews[0]._p2;
            const p3 = this._paneViews[0]._p3;
            if (!p1.x || !p2.x || !p3.x || !p1.y || !p2.y || !p3.y)
                return this._moveToState(InteractionState.DRAGGING);
            const tolerance = 10;
            if (Math.abs(hoverPoint.x - p1.x) < tolerance &&
                Math.abs(hoverPoint.y - p1.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP1);
            }
            else if (Math.abs(hoverPoint.x - p2.x) < tolerance &&
                Math.abs(hoverPoint.y - p2.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP2);
            }
            else if (Math.abs(hoverPoint.x - p3.x) < tolerance &&
                Math.abs(hoverPoint.y - p3.y) < tolerance) {
                this._moveToState(InteractionState.DRAGGINGP3);
            }
            else {
                this._moveToState(InteractionState.DRAGGING);
            }
        }
        _mouseIsOverDrawing(param, tolerance = 4) {
            if (!param.point)
                return false;
            const x1 = this._paneViews[0]._p1.x;
            const y1 = this._paneViews[0]._p1.y;
            const x2 = this._paneViews[0]._p2.x;
            const y2 = this._paneViews[0]._p2.y;
            const x3 = this._paneViews[0]._p3.x;
            const y3 = this._paneViews[0]._p3.y;
            if (x1 == null ||
                y1 == null ||
                x2 == null ||
                y2 == null ||
                x3 == null ||
                y3 == null)
                return false;
            const mouseX = param.point.x;
            const mouseY = param.point.y;
            // Check bounding box of the three points
            if (mouseX < Math.min(x1, x2, x3) - tolerance ||
                mouseX > Math.max(x1, x2, x3) + tolerance) {
                return false;
            }
            // Check distance to each segment: p1->p2, p2->p3, and p1->p3
            const d1 = this._distanceFromSegment(x1, y1, x2, y2, mouseX, mouseY);
            const d2 = this._distanceFromSegment(x2, y2, x3, y3, mouseX, mouseY);
            const d3 = this._distanceFromSegment(x1, y1, x3, y3, mouseX, mouseY);
            return d1 <= tolerance || d2 <= tolerance || d3 <= tolerance;
        }
        _distanceFromSegment(xA, yA, xB, yB, x, y) {
            const A = x - xA, B = y - yA, C = xB - xA, D = yB - yA;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = lenSq !== 0 ? dot / lenSq : -1;
            let xx, yy;
            if (param < 0) {
                xx = xA;
                yy = yA;
            }
            else if (param > 1) {
                xx = xB;
                yy = yB;
            }
            else {
                xx = xA + param * C;
                yy = yA + param * D;
            }
            const dx = x - xx, dy = y - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        /**
         * Deserializes a JSON object to update the current Sequence instance.
         *
         * @param json - The JSON object containing optional Sequence data and options.
         */
        fromJSON(json) {
            if (json.options) {
                // Cast json.options as a generic record to satisfy the index signature.
                const options = json.options;
                for (const key in options) {
                    if (Object.prototype.hasOwnProperty.call(options, key)) {
                        // Cast key to keyof SequenceOptions.
                        const typedKey = key;
                        this.applyOptions({ [typedKey]: options[typedKey] });
                    }
                }
            }
        }
        toJSON() {
            return {
                options: this._options,
            };
        }
        title = "PitchFork";
    }

    class ToolBox {
        static TREND_SVG = '<rect x="3.84" y="13.67" transform="matrix(0.7071 -0.7071 0.7071 0.7071 -5.9847 14.4482)" width="21.21" height="1.56"/><path d="M23,3.17L20.17,6L23,8.83L25.83,6L23,3.17z M23,7.41L21.59,6L23,4.59L24.41,6L23,7.41z"/><path d="M6,20.17L3.17,23L6,25.83L8.83,23L6,20.17z M6,24.41L4.59,23L6,21.59L7.41,23L6,24.41z"/>';
        static HORZ_SVG = '<rect x="4" y="14" width="9" height="1"/><rect x="16" y="14" width="9" height="1"/><path d="M11.67,14.5l2.83,2.83l2.83-2.83l-2.83-2.83L11.67,14.5z M15.91,14.5l-1.41,1.41l-1.41-1.41l1.41-1.41L15.91,14.5z"/>';
        static RAY_SVG = '<rect x="8" y="14" width="17" height="1"/><path d="M3.67,14.5l2.83,2.83l2.83-2.83L6.5,11.67L3.67,14.5z M7.91,14.5L6.5,15.91L5.09,14.5l1.41-1.41L7.91,14.5z"/>';
        static BOX_SVG = '<rect x="8" y="6" width="12" height="1"/><rect x="9" y="22" width="11" height="1"/><path d="M3.67,6.5L6.5,9.33L9.33,6.5L6.5,3.67L3.67,6.5z M7.91,6.5L6.5,7.91L5.09,6.5L6.5,5.09L7.91,6.5z"/><path d="M19.67,6.5l2.83,2.83l2.83-2.83L22.5,3.67L19.67,6.5z M23.91,6.5L22.5,7.91L21.09,6.5l1.41-1.41L23.91,6.5z"/><path d="M19.67,22.5l2.83,2.83l2.83-2.83l-2.83-2.83L19.67,22.5z M23.91,22.5l-1.41,1.41l-1.41-1.41l1.41-1.41L23.91,22.5z"/><path d="M3.67,22.5l2.83,2.83l2.83-2.83L6.5,19.67L3.67,22.5z M7.91,22.5L6.5,23.91L5.09,22.5l1.41-1.41L7.91,22.5z"/><rect x="22" y="9" width="1" height="11"/><rect x="6" y="9" width="1" height="11"/>';
        static VERT_SVG = ToolBox.RAY_SVG;
        // Add new static SVG icons for pitchfork tools:
        static PITCHFORK_SVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><g fill="#ffffff" fill-rule="nonzero"><path d="M7.275 21.432l12.579-12.579-.707-.707-12.579 12.579z"/><path d="M6.69 13.397l7.913 7.913.707-.707-7.913-7.913z"/><path d="M7.149 10.558l7.058-7.058-.707-.707-7.058 7.058z" id="Line"/><path d="M20.149 21.558l7.058-7.058-.707-.707-7.058 7.558z"/><path d="M5.5 23h11v-1h-11z"/><path d="M4.5 24c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm0 1c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5z"/></g></svg>';
        //sprivate static readonly SCHIFF_PITCHFORK_SVG: string = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><g fill="#ffffff" fill-rule="nonzero"><path d="M7.354 21.354l14-14-.707-.707-14 14z"/><path d="M8.336 13.043l8.621 8.621.707-.707-8.621-8.621z"/><path d="M9.149 10.558l7.058-7.058-.707-.707-7.058 7.058z" id="Line"/><path d="M20.149 21.558l7.058-7.058-.707-.707-7.058 7.558z"/><path d="M5.5 23h10v-1h-10z"/><path d="M4.5 24c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm0 1c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5z"/></g></svg>';
        //sprivate static readonly MODIFIED_SCHIFF_PITCHFORK_SVG: string = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><g fill="#ffffff" fill-rule="nonzero"><path d="M10.275 20.432l11.579-11.579-.707-.707-11.579 11.579z"/><path d="M6.69 13.397l7.913 7.913.707-.707-7.913-7.913z"/><path d="M7.149 10.558l7.058-7.058-.707-.707-7.058 7.058z" id="Line"/><path d="M20.149 21.558l7.058-7.058-.707-.707-7.058 7.558z"/><path d="M5.5 23h11v-1h-11z"/><path d="M4.5 24c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm0 1c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5z"/></g></svg>';
        //sprivate static readonly INSIDE_PITCHFORK_SVG: string = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><g fill="#ffffff" fill-rule="nonzero"><path d="M6.5 23h12v-1h-12z" id="Line"/><path d="M21.596 20.715l3.091-9.66-.952-.305-3.091 9.66z"/><path d="M8.413 22.664l1.95-6.094-.952-.305-1.95 6.094z"/><path d="M11.602 12.695l3.085-9.641-.952-.305-3.085 9.641z"/><path d="M11.783 16.167l6.817 5.454.625-.781-6.817-5.454z"/><path d="M15.976 18.652l3.711-11.598-.952-.305-3.711 11.598z"/><path d="M4.5 24c.828 0 1.5-.672 1.5-1.5s-.672-1.5-1.5-1.5-1.5.672-1.5 1.5.672 1.5 1.5 1.5zm0 1c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5z"/></g></svg>';
        //sprivate static readonly SEGMENT_SVG: string = '<line x1="5" y1="10" x2="25" y2="10" stroke="black" stroke-width="1"/>';
        //sprivate static readonly EXTENSION_SVG: string = '<line x1="5" y1="10" x2="25" y2="10" stroke="black" stroke-width="1" stroke-dasharray="4,2"/>';
        //sprivate static readonly CIRCLE_SVG: string = '<circle cx="15" cy="15" r="10" stroke="black" stroke-width="1" fill="none"/>';
        //sprivate static readonly SPIRAL_SVG: string = '<path d="M15 15 m -10,0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0" fill="none" stroke="black" stroke-width="1"/>';
        //sprivate static readonly GANN_SVG: string = '<rect x="8" y="8" width="12" height="12" stroke="black" fill="none" stroke-width="1"/><line x1="8" y1="8" x2="20" y2="20" stroke="black" stroke-width="1"/><line x1="20" y1="8" x2="8" y2="20" stroke="black" stroke-width="1"/>';
        div;
        activeIcon = null;
        buttons = [];
        _commandFunctions;
        _handlerID;
        _drawingTool;
        handler;
        constructor(handler, handlerID, chart, series, commandFunctions) {
            this._handlerID = handlerID;
            this._commandFunctions = commandFunctions;
            this._drawingTool = new DrawingTool(chart, series, () => this.removeActiveAndSave());
            this.div = this._makeToggleToolBox();
            this.handler = handler;
            this.handler.ContextMenu.setupDrawingTools(this.saveDrawings, this._drawingTool);
            commandFunctions.push((event) => {
                if ((event.metaKey || event.ctrlKey) && event.code === 'KeyZ') {
                    const drawingToDelete = this._drawingTool.drawings.pop();
                    if (drawingToDelete)
                        this._drawingTool.delete(drawingToDelete);
                    return true;
                }
                return false;
            });
        }
        toJSON() {
            // Exclude the chart attribute from serialization
            const { ...serialized } = this;
            return serialized;
        }
        _makeToggleToolBox() {
            const outerDiv = document.createElement('div');
            outerDiv.classList.add('flyout-toolbox');
            // Position the container absolutely at the top center.
            outerDiv.style.position = 'absolute';
            outerDiv.style.top = '0';
            outerDiv.style.left = '50%';
            outerDiv.style.transform = 'translateX(-50%)';
            outerDiv.style.zIndex = '1000';
            outerDiv.style.overflow = 'hidden';
            outerDiv.style.transition = 'height 0.3s ease';
            // Create the container for the toolbox content (the buttons).
            const contentDiv = document.createElement('div');
            contentDiv.classList.add('toolbox-content');
            // Use inline-flex so its width is determined by its content.
            contentDiv.style.display = 'inline-flex';
            contentDiv.style.flexDirection = 'row';
            contentDiv.style.justifyContent = 'center';
            contentDiv.style.alignItems = 'center';
            contentDiv.style.padding = '5px';
            contentDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            // Initially, content is hidden.
            contentDiv.style.display = 'none';
            // Create toolbox buttons using your existing method.
            this.buttons = [];
            this.buttons.push(this._makeToolBoxElement(TrendLine, 'KeyT', ToolBox.TREND_SVG));
            this.buttons.push(this._makeToolBoxElement(HorizontalLine, 'KeyH', ToolBox.HORZ_SVG));
            this.buttons.push(this._makeToolBoxElement(RayLine, 'KeyR', ToolBox.RAY_SVG));
            this.buttons.push(this._makeToolBoxElement(Box, 'KeyB', ToolBox.BOX_SVG));
            this.buttons.push(this._makeToolBoxElement(VerticalLine, 'KeyV', ToolBox.VERT_SVG, true));
            this.buttons.push(this._makeToolBoxElement(PitchFork, 'KeyP', ToolBox.PITCHFORK_SVG));
            // Append each button to the content container.
            for (const button of this.buttons) {
                contentDiv.appendChild(button);
            }
            // Create the toggle tab that will always be visible and is attached to the bottom.
            const toggleTab = document.createElement('div');
            toggleTab.textContent = '▼'; // Down arrow for collapsed state.
            toggleTab.style.width = '15px';
            toggleTab.style.height = '10px';
            toggleTab.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            toggleTab.style.color = '#fff';
            toggleTab.style.textAlign = 'center';
            toggleTab.style.lineHeight = '15px';
            toggleTab.style.cursor = 'pointer';
            // No extra margin needed since we want it attached.
            // Append both content and toggle tab to the outer container.
            outerDiv.appendChild(contentDiv);
            outerDiv.appendChild(toggleTab);
            // Define heights.
            const tabHeight = 15; // Height of the toggle tab.
            let expanded = false;
            // When collapsed, outerDiv's height is exactly the toggle tab's height.
            outerDiv.style.height = `${tabHeight}px`;
            // Toggle behavior: clicking the tab shows or hides the content.
            toggleTab.onclick = () => {
                expanded = !expanded;
                if (expanded) {
                    // Show content.
                    contentDiv.style.display = 'inline-flex';
                    // Force reflow to measure the content height.
                    const contentHeight = contentDiv.scrollHeight;
                    // Set the outer container's height to content + tab height.
                    outerDiv.style.height = `${tabHeight + contentHeight}px`;
                    toggleTab.textContent = '▲'; // Up arrow indicates expanded.
                }
                else {
                    // Hide content.
                    contentDiv.style.display = 'none';
                    outerDiv.style.height = `${tabHeight}px`;
                    toggleTab.textContent = '▼'; // Down arrow indicates collapsed.
                }
            };
            return outerDiv;
        }
        _makeToolBoxElement(DrawingType, keyCmd, paths, rotate = false) {
            const elem = document.createElement('div');
            elem.classList.add("toolbox-button");
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("width", "29");
            svg.setAttribute("height", "29");
            const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
            group.innerHTML = paths;
            group.setAttribute("fill", window.pane.color);
            svg.appendChild(group);
            elem.appendChild(svg);
            const icon = { div: elem, group: group, type: DrawingType };
            elem.addEventListener('click', () => this._onIconClick(icon));
            this._commandFunctions.push((event) => {
                if (this._handlerID !== window.handlerInFocus)
                    return false;
                if (event.altKey && event.code === keyCmd) {
                    event.preventDefault();
                    this._onIconClick(icon);
                    return true;
                }
                return false;
            });
            if (rotate == true) {
                svg.style.transform = 'rotate(90deg)';
                svg.style.transformBox = 'fill-box';
                svg.style.transformOrigin = 'center';
            }
            return elem;
        }
        _onIconClick(icon) {
            if (this.activeIcon) {
                this.activeIcon.div.classList.remove('active-toolbox-button');
                window.setCursor('crosshair');
                this._drawingTool?.stopDrawing();
                if (this.activeIcon === icon) {
                    this.activeIcon = null;
                    return;
                }
            }
            this.activeIcon = icon;
            this.activeIcon.div.classList.add('active-toolbox-button');
            window.setCursor('crosshair');
            this._drawingTool?.beginDrawing(this.activeIcon.type);
        }
        removeActiveAndSave = () => {
            window.setCursor('default');
            if (this.activeIcon)
                this.activeIcon.div.classList.remove('active-toolbox-button');
            this.activeIcon = null;
            this.saveDrawings();
        };
        addNewDrawing(d) {
            this._drawingTool.addNewDrawing(d);
        }
        clearDrawings() {
            this._drawingTool.clearDrawings();
        }
        saveDrawings = () => {
            const drawingMeta = [];
            for (const d of this._drawingTool.drawings) {
                drawingMeta.push({
                    type: d._type,
                    points: d.points,
                    options: d._options
                });
            }
            const string = JSON.stringify(drawingMeta);
            window.callbackFunction(`save_drawings${this._handlerID}_~_${string}`);
        };
        loadDrawings(drawings) {
            drawings.forEach((d) => {
                switch (d.type) {
                    case "Box":
                        this._drawingTool.addNewDrawing(new Box(d.points[0], d.points[1], d.options));
                        break;
                    case "TrendLine":
                        this._drawingTool.addNewDrawing(new TrendLine(d.points[0], d.points[1], d.options));
                        break;
                    case "HorizontalLine":
                        this._drawingTool.addNewDrawing(new HorizontalLine(d.points[0], d.options));
                        break;
                    case "RayLine":
                        this._drawingTool.addNewDrawing(new RayLine(d.points[0], d.options));
                        break;
                    case "VerticalLine":
                        this._drawingTool.addNewDrawing(new VerticalLine(d.points[0], d.options));
                        break;
                    // Add cases for pitchfork types if needed:
                    case "PitchFork":
                        this._drawingTool.addNewDrawing(new PitchFork(d.points[0], d.points[1], d.points[2], d.options));
                        break;
                    //case "SchiffPitchfork":
                    //    this._drawingTool.addNewDrawing(new PitchFork(d.points[0], d.points[1], d.points[2], {...d.options, variant: "schiff"}));
                    //    break;
                    //case "ModifiedSchiffPitchfork":
                    //    this._drawingTool.addNewDrawing(new PitchFork(d.points[0], d.points[1], d.points[2], {...d.options, variant: "modifiedSchiff"}));
                    //    break;
                    //case "InsidePitchfork":
                    //    this._drawingTool.addNewDrawing(new PitchFork(d.points[0], d.points[1], d.points[2], {...d.options, variant: "inside"}));
                    //    break;
                    //case "FibonacciSegment":
                    //    this._drawingTool.addNewDrawing(new FibonacciSegmentDrawing(d.points[0], d.points[1], d.options));
                    //    break;
                    //case "FibonacciExtension":
                    //    this._drawingTool.addNewDrawing(new FibonacciExtensionDrawing(d.points[0], d.points[1], d.options));
                    //    break;
                    //case "FibonacciCircle":
                    //    this._drawingTool.addNewDrawing(new FibonacciCircleDrawing(d.points[0], d.points[1], d.options));
                    //    break;
                    //case "FibonacciSpiral":
                    //    this._drawingTool.addNewDrawing(new FibonacciSpiralDrawing(d.points[0], d.points[1], d.options));
                    //    break;
                    //case "GannBox":
                    //    this._drawingTool.addNewDrawing(new GannBoxDrawing(d.points[0], d.points[1], d.points[2], d.points[3], d.options));
                    //    break;
                }
            });
        }
    }

    // This file was generated. Do not modify manually!
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

    // This file was generated. Do not modify manually!
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];

    // This file was generated. Do not modify manually!
    var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";

    // This file was generated. Do not modify manually!
    var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7cd\ua7d0\ua7d1\ua7d3\ua7d5-\ua7dc\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

    // These are a run-length and offset encoded representation of the
    // >0xffff code points that are a valid part of identifiers. The
    // offset starts at 0x10000, and each pair of numbers represents an
    // offset to the next range, and then a size of the range.

    // Reserved word lists for various dialects of the language

    var reservedWords = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };

    // And the keywords

    var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

    var keywords$1 = {
      5: ecma5AndLessKeywords,
      "5module": ecma5AndLessKeywords + " export import",
      6: ecma5AndLessKeywords + " const class extends export import super"
    };

    var keywordRelationalOperator = /^in(stanceof)?$/;

    // ## Character categories

    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

    // This has a complexity linear to the value of the code. The
    // assumption is that looking up astral identifier characters is
    // rare.
    function isInAstralSet(code, set) {
      var pos = 0x10000;
      for (var i = 0; i < set.length; i += 2) {
        pos += set[i];
        if (pos > code) { return false }
        pos += set[i + 1];
        if (pos >= code) { return true }
      }
      return false
    }

    // Test whether a given character code starts an identifier.

    function isIdentifierStart(code, astral) {
      if (code < 65) { return code === 36 }
      if (code < 91) { return true }
      if (code < 97) { return code === 95 }
      if (code < 123) { return true }
      if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
      if (astral === false) { return false }
      return isInAstralSet(code, astralIdentifierStartCodes)
    }

    // Test whether a given character is part of an identifier.

    function isIdentifierChar(code, astral) {
      if (code < 48) { return code === 36 }
      if (code < 58) { return true }
      if (code < 65) { return false }
      if (code < 91) { return true }
      if (code < 97) { return code === 95 }
      if (code < 123) { return true }
      if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
      if (astral === false) { return false }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
    }

    // ## Token types

    // The assignment of fine-grained, information-carrying type objects
    // allows the tokenizer to store the information it has about a
    // token in a way that is very cheap for the parser to look up.

    // All token type variables start with an underscore, to make them
    // easy to recognize.

    // The `beforeExpr` property is used to disambiguate between regular
    // expressions and divisions. It is set on all token types that can
    // be followed by an expression (thus, a slash after them would be a
    // regular expression).
    //
    // The `startsExpr` property is used to check if the token ends a
    // `yield` expression. It is set on all token types that either can
    // directly start an expression (like a quotation mark) or can
    // continue an expression (like the body of a string).
    //
    // `isLoop` marks a keyword as starting a loop, which is important
    // to know when parsing a label, in order to allow or disallow
    // continue jumps to that label.

    var TokenType = function TokenType(label, conf) {
      if ( conf === void 0 ) conf = {};

      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };

    function binop(name, prec) {
      return new TokenType(name, {beforeExpr: true, binop: prec})
    }
    var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

    // Map keyword names to token types.

    var keywords = {};

    // Succinct definitions of keyword token types
    function kw(name, options) {
      if ( options === void 0 ) options = {};

      options.keyword = name;
      return keywords[name] = new TokenType(name, options)
    }

    var types$1 = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      privateId: new TokenType("privateId", startsExpr),
      eof: new TokenType("eof"),

      // Punctuation token types.
      bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      questionDot: new TokenType("?."),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      invalidTemplate: new TokenType("invalidTemplate"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

      // Operators. These carry several kinds of properties to help the
      // parser use them properly (the presence of these properties is
      // what categorizes them as operators).
      //
      // `binop`, when present, specifies that this operator is a binary
      // operator, and will refer to its precedence.
      //
      // `prefix` and `postfix` mark the operator as a prefix or postfix
      // unary operator.
      //
      // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
      // binary operators with a very low precedence, that should result
      // in AssignmentExpression nodes.

      eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
      assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
      incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
      prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=/===/!==", 6),
      relational: binop("</>/<=/>=", 7),
      bitShift: binop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10),
      starstar: new TokenType("**", {beforeExpr: true}),
      coalesce: binop("??", 1),

      // Keyword token types.
      _break: kw("break"),
      _case: kw("case", beforeExpr),
      _catch: kw("catch"),
      _continue: kw("continue"),
      _debugger: kw("debugger"),
      _default: kw("default", beforeExpr),
      _do: kw("do", {isLoop: true, beforeExpr: true}),
      _else: kw("else", beforeExpr),
      _finally: kw("finally"),
      _for: kw("for", {isLoop: true}),
      _function: kw("function", startsExpr),
      _if: kw("if"),
      _return: kw("return", beforeExpr),
      _switch: kw("switch"),
      _throw: kw("throw", beforeExpr),
      _try: kw("try"),
      _var: kw("var"),
      _const: kw("const"),
      _while: kw("while", {isLoop: true}),
      _with: kw("with"),
      _new: kw("new", {beforeExpr: true, startsExpr: true}),
      _this: kw("this", startsExpr),
      _super: kw("super", startsExpr),
      _class: kw("class", startsExpr),
      _extends: kw("extends", beforeExpr),
      _export: kw("export"),
      _import: kw("import", startsExpr),
      _null: kw("null", startsExpr),
      _true: kw("true", startsExpr),
      _false: kw("false", startsExpr),
      _in: kw("in", {beforeExpr: true, binop: 7}),
      _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
      _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
      _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
      _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
    };

    // Matches a whole line break (where CRLF is considered a single
    // line break). Used to count lines.

    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    var lineBreakG = new RegExp(lineBreak.source, "g");

    function isNewLine(code) {
      return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
    }

    function nextLineBreak(code, from, end) {
      if ( end === void 0 ) end = code.length;

      for (var i = from; i < end; i++) {
        var next = code.charCodeAt(i);
        if (isNewLine(next))
          { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
      }
      return -1
    }

    var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

    var ref = Object.prototype;
    var hasOwnProperty = ref.hasOwnProperty;
    var toString = ref.toString;

    var hasOwn = Object.hasOwn || (function (obj, propName) { return (
      hasOwnProperty.call(obj, propName)
    ); });

    var isArray = Array.isArray || (function (obj) { return (
      toString.call(obj) === "[object Array]"
    ); });

    var regexpCache = Object.create(null);

    function wordsRegexp(words) {
      return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"))
    }

    function codePointToString(code) {
      // UTF-16 Decoding
      if (code <= 0xFFFF) { return String.fromCharCode(code) }
      code -= 0x10000;
      return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
    }

    var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

    // These are used when `options.locations` is on, for the
    // `startLoc` and `endLoc` properties.

    var Position = function Position(line, col) {
      this.line = line;
      this.column = col;
    };

    Position.prototype.offset = function offset (n) {
      return new Position(this.line, this.column + n)
    };

    var SourceLocation = function SourceLocation(p, start, end) {
      this.start = start;
      this.end = end;
      if (p.sourceFile !== null) { this.source = p.sourceFile; }
    };

    // The `getLineInfo` function is mostly useful when the
    // `locations` option is off (for performance reasons) and you
    // want to find the line/column position for a given character
    // offset. `input` should be the code string that the offset refers
    // into.

    function getLineInfo(input, offset) {
      for (var line = 1, cur = 0;;) {
        var nextBreak = nextLineBreak(input, cur, offset);
        if (nextBreak < 0) { return new Position(line, offset - cur) }
        ++line;
        cur = nextBreak;
      }
    }

    // A second argument must be given to configure the parser process.
    // These options are recognized (only `ecmaVersion` is required):

    var defaultOptions$2 = {
      // `ecmaVersion` indicates the ECMAScript version to parse. Must be
      // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
      // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
      // (the latest version the library supports). This influences
      // support for strict mode, the set of reserved words, and support
      // for new syntax features.
      ecmaVersion: null,
      // `sourceType` indicates the mode the code should be parsed in.
      // Can be either `"script"` or `"module"`. This influences global
      // strict mode and parsing of `import` and `export` declarations.
      sourceType: "script",
      // `onInsertedSemicolon` can be a callback that will be called when
      // a semicolon is automatically inserted. It will be passed the
      // position of the inserted semicolon as an offset, and if
      // `locations` is enabled, it is given the location as a `{line,
      // column}` object as second argument.
      onInsertedSemicolon: null,
      // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
      // trailing commas.
      onTrailingComma: null,
      // By default, reserved words are only enforced if ecmaVersion >= 5.
      // Set `allowReserved` to a boolean value to explicitly turn this on
      // an off. When this option has the value "never", reserved words
      // and keywords can also not be used as property names.
      allowReserved: null,
      // When enabled, a return at the top level is not considered an
      // error.
      allowReturnOutsideFunction: false,
      // When enabled, import/export statements are not constrained to
      // appearing at the top of the program, and an import.meta expression
      // in a script isn't considered an error.
      allowImportExportEverywhere: false,
      // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
      // When enabled, await identifiers are allowed to appear at the top-level scope,
      // but they are still not allowed in non-async functions.
      allowAwaitOutsideFunction: null,
      // When enabled, super identifiers are not constrained to
      // appearing in methods and do not raise an error when they appear elsewhere.
      allowSuperOutsideMethod: null,
      // When enabled, hashbang directive in the beginning of file is
      // allowed and treated as a line comment. Enabled by default when
      // `ecmaVersion` >= 2023.
      allowHashBang: false,
      // By default, the parser will verify that private properties are
      // only used in places where they are valid and have been declared.
      // Set this to false to turn such checks off.
      checkPrivateFields: true,
      // When `locations` is on, `loc` properties holding objects with
      // `start` and `end` properties in `{line, column}` form (with
      // line being 1-based and column 0-based) will be attached to the
      // nodes.
      locations: false,
      // A function can be passed as `onToken` option, which will
      // cause Acorn to call that function with object in the same
      // format as tokens returned from `tokenizer().getToken()`. Note
      // that you are not allowed to call the parser from the
      // callback—that will corrupt its internal state.
      onToken: null,
      // A function can be passed as `onComment` option, which will
      // cause Acorn to call that function with `(block, text, start,
      // end)` parameters whenever a comment is skipped. `block` is a
      // boolean indicating whether this is a block (`/* */`) comment,
      // `text` is the content of the comment, and `start` and `end` are
      // character offsets that denote the start and end of the comment.
      // When the `locations` option is on, two more parameters are
      // passed, the full `{line, column}` locations of the start and
      // end of the comments. Note that you are not allowed to call the
      // parser from the callback—that will corrupt its internal state.
      // When this option has an array as value, objects representing the
      // comments are pushed to it.
      onComment: null,
      // Nodes have their start and end characters offsets recorded in
      // `start` and `end` properties (directly on the node, rather than
      // the `loc` object, which holds line/column data. To also add a
      // [semi-standardized][range] `range` property holding a `[start,
      // end]` array with the same numbers, set the `ranges` option to
      // `true`.
      //
      // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
      ranges: false,
      // It is possible to parse multiple files into a single AST by
      // passing the tree produced by parsing the first file as
      // `program` option in subsequent parses. This will add the
      // toplevel forms of the parsed file to the `Program` (top) node
      // of an existing parse tree.
      program: null,
      // When `locations` is on, you can pass this to record the source
      // file in every node's `loc` object.
      sourceFile: null,
      // This value, if given, is stored in every node, whether
      // `locations` is on or off.
      directSourceFile: null,
      // When enabled, parenthesized expressions are represented by
      // (non-standard) ParenthesizedExpression nodes
      preserveParens: false
    };

    // Interpret and default an options object

    var warnedAboutEcmaVersion = false;

    function getOptions(opts) {
      var options = {};

      for (var opt in defaultOptions$2)
        { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions$2[opt]; }

      if (options.ecmaVersion === "latest") {
        options.ecmaVersion = 1e8;
      } else if (options.ecmaVersion == null) {
        if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
          warnedAboutEcmaVersion = true;
          console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
        }
        options.ecmaVersion = 11;
      } else if (options.ecmaVersion >= 2015) {
        options.ecmaVersion -= 2009;
      }

      if (options.allowReserved == null)
        { options.allowReserved = options.ecmaVersion < 5; }

      if (!opts || opts.allowHashBang == null)
        { options.allowHashBang = options.ecmaVersion >= 14; }

      if (isArray(options.onToken)) {
        var tokens = options.onToken;
        options.onToken = function (token) { return tokens.push(token); };
      }
      if (isArray(options.onComment))
        { options.onComment = pushComment(options, options.onComment); }

      return options
    }

    function pushComment(options, array) {
      return function(block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? "Block" : "Line",
          value: text,
          start: start,
          end: end
        };
        if (options.locations)
          { comment.loc = new SourceLocation(this, startLoc, endLoc); }
        if (options.ranges)
          { comment.range = [start, end]; }
        array.push(comment);
      }
    }

    // Each scope gets a bitset that may contain these flags
    var
        SCOPE_TOP = 1,
        SCOPE_FUNCTION = 2,
        SCOPE_ASYNC = 4,
        SCOPE_GENERATOR = 8,
        SCOPE_ARROW = 16,
        SCOPE_SIMPLE_CATCH = 32,
        SCOPE_SUPER = 64,
        SCOPE_DIRECT_SUPER = 128,
        SCOPE_CLASS_STATIC_BLOCK = 256,
        SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

    function functionFlags(async, generator) {
      return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
    }

    // Used in checkLVal* and declareName to determine the type of a binding
    var
        BIND_NONE = 0, // Not a binding
        BIND_VAR = 1, // Var-style binding
        BIND_LEXICAL = 2, // Let- or const-style binding
        BIND_FUNCTION = 3, // Function declaration
        BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
        BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

    var Parser = function Parser(options, input, startPos) {
      this.options = options = getOptions(options);
      this.sourceFile = options.sourceFile;
      this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
      var reserved = "";
      if (options.allowReserved !== true) {
        reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
        if (options.sourceType === "module") { reserved += " await"; }
      }
      this.reservedWords = wordsRegexp(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
      this.reservedWordsStrict = wordsRegexp(reservedStrict);
      this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
      this.input = String(input);

      // Used to signal to callers of `readWord1` whether the word
      // contained any escape sequences. This is needed because words with
      // escape sequences must not be interpreted as keywords.
      this.containsEsc = false;

      // Set up token state

      // The current position of the tokenizer in the input.
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }

      // Properties of the current token:
      // Its type
      this.type = types$1.eof;
      // For tokens that include more information than their type, the value
      this.value = null;
      // Its start and end offset
      this.start = this.end = this.pos;
      // And, if locations are used, the {line, column} object
      // corresponding to those offsets
      this.startLoc = this.endLoc = this.curPosition();

      // Position information for the previous token
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;

      // The context stack is used to superficially track syntactic
      // context to predict whether a regular expression is allowed in a
      // given position.
      this.context = this.initialContext();
      this.exprAllowed = true;

      // Figure out if it's a module code.
      this.inModule = options.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);

      // Used to signify the start of a potential arrow function
      this.potentialArrowAt = -1;
      this.potentialArrowInForAwait = false;

      // Positions to delayed-check that yield/await does not exist in default parameters.
      this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
      // Labels in scope.
      this.labels = [];
      // Thus-far undefined exports.
      this.undefinedExports = Object.create(null);

      // If enabled, skip leading hashbang line.
      if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
        { this.skipLineComment(2); }

      // Scope tracking for duplicate variable names (see scope.js)
      this.scopeStack = [];
      this.enterScope(SCOPE_TOP);

      // For RegExp validation
      this.regexpState = null;

      // The stack of private names.
      // Each element has two properties: 'declared' and 'used'.
      // When it exited from the outermost class definition, all used private names must be declared.
      this.privateNameStack = [];
    };

    var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

    Parser.prototype.parse = function parse () {
      var node = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node)
    };

    prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

    prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };

    prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };

    prototypeAccessors.canAwait.get = function () {
      for (var i = this.scopeStack.length - 1; i >= 0; i--) {
        var scope = this.scopeStack[i];
        if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }
        if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }
      }
      return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
    };

    prototypeAccessors.allowSuper.get = function () {
      var ref = this.currentThisScope();
        var flags = ref.flags;
        var inClassFieldInit = ref.inClassFieldInit;
      return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
    };

    prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

    prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

    prototypeAccessors.allowNewDotTarget.get = function () {
      var ref = this.currentThisScope();
        var flags = ref.flags;
        var inClassFieldInit = ref.inClassFieldInit;
      return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
    };

    prototypeAccessors.inClassStaticBlock.get = function () {
      return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
    };

    Parser.extend = function extend () {
        var plugins = [], len = arguments.length;
        while ( len-- ) plugins[ len ] = arguments[ len ];

      var cls = this;
      for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
      return cls
    };

    Parser.parse = function parse (input, options) {
      return new this(options, input).parse()
    };

    Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
      var parser = new this(options, input, pos);
      parser.nextToken();
      return parser.parseExpression()
    };

    Parser.tokenizer = function tokenizer (input, options) {
      return new this(options, input)
    };

    Object.defineProperties( Parser.prototype, prototypeAccessors );

    var pp$9 = Parser.prototype;

    // ## Parser utilities

    var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
    pp$9.strictDirective = function(start) {
      if (this.options.ecmaVersion < 5) { return false }
      for (;;) {
        // Try to find string literal.
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match = literal.exec(this.input.slice(start));
        if (!match) { return false }
        if ((match[1] || match[2]) === "use strict") {
          skipWhiteSpace.lastIndex = start + match[0].length;
          var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
          var next = this.input.charAt(end);
          return next === ";" || next === "}" ||
            (lineBreak.test(spaceAfter[0]) &&
             !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
        }
        start += match[0].length;

        // Skip semicolon, if any.
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        if (this.input[start] === ";")
          { start++; }
      }
    };

    // Predicate that tests whether the next token is of the given
    // type, and if yes, consumes it as a side effect.

    pp$9.eat = function(type) {
      if (this.type === type) {
        this.next();
        return true
      } else {
        return false
      }
    };

    // Tests whether parsed token is a contextual keyword.

    pp$9.isContextual = function(name) {
      return this.type === types$1.name && this.value === name && !this.containsEsc
    };

    // Consumes contextual keyword if possible.

    pp$9.eatContextual = function(name) {
      if (!this.isContextual(name)) { return false }
      this.next();
      return true
    };

    // Asserts that following token is given contextual keyword.

    pp$9.expectContextual = function(name) {
      if (!this.eatContextual(name)) { this.unexpected(); }
    };

    // Test whether a semicolon can be inserted at the current position.

    pp$9.canInsertSemicolon = function() {
      return this.type === types$1.eof ||
        this.type === types$1.braceR ||
        lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
    };

    pp$9.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon)
          { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
        return true
      }
    };

    // Consume a semicolon, or, failing that, see if we are allowed to
    // pretend that there is a semicolon at this position.

    pp$9.semicolon = function() {
      if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
    };

    pp$9.afterTrailingComma = function(tokType, notNext) {
      if (this.type === tokType) {
        if (this.options.onTrailingComma)
          { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
        if (!notNext)
          { this.next(); }
        return true
      }
    };

    // Expect a token of a given type. If found, consume it, otherwise,
    // raise an unexpected token error.

    pp$9.expect = function(type) {
      this.eat(type) || this.unexpected();
    };

    // Raise an unexpected token error.

    pp$9.unexpected = function(pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };

    var DestructuringErrors = function DestructuringErrors() {
      this.shorthandAssign =
      this.trailingComma =
      this.parenthesizedAssign =
      this.parenthesizedBind =
      this.doubleProto =
        -1;
    };

    pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) { return }
      if (refDestructuringErrors.trailingComma > -1)
        { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
    };

    pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      if (!refDestructuringErrors) { return false }
      var shorthandAssign = refDestructuringErrors.shorthandAssign;
      var doubleProto = refDestructuringErrors.doubleProto;
      if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
      if (shorthandAssign >= 0)
        { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
      if (doubleProto >= 0)
        { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
    };

    pp$9.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
        { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
      if (this.awaitPos)
        { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
    };

    pp$9.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression")
        { return this.isSimpleAssignTarget(expr.expression) }
      return expr.type === "Identifier" || expr.type === "MemberExpression"
    };

    var pp$8 = Parser.prototype;

    // ### Statement parsing

    // Parse a program. Initializes the parser, reads any number of
    // statements, and wraps them in a Program node.  Optionally takes a
    // `program` argument.  If present, the statements will be appended
    // to its body instead of creating a new node.

    pp$8.parseTopLevel = function(node) {
      var exports = Object.create(null);
      if (!node.body) { node.body = []; }
      while (this.type !== types$1.eof) {
        var stmt = this.parseStatement(null, true, exports);
        node.body.push(stmt);
      }
      if (this.inModule)
        { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
          {
            var name = list[i];

            this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
          } }
      this.adaptDirectivePrologue(node.body);
      this.next();
      node.sourceType = this.options.sourceType;
      return this.finishNode(node, "Program")
    };

    var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

    pp$8.isLet = function(context) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      // For ambiguous cases, determine if a LexicalDeclaration (or only a
      // Statement) is allowed here. If context is not empty then only a Statement
      // is allowed. However, `let [` is an explicit negative lookahead for
      // ExpressionStatement, so special-case it first.
      if (nextCh === 91 || nextCh === 92) { return true } // '[', '\'
      if (context) { return false }

      if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral
      if (isIdentifierStart(nextCh, true)) {
        var pos = next + 1;
        while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
        if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) { return true }
      }
      return false
    };

    // check 'async [no LineTerminator here] function'
    // - 'async /*foo*/ function' is OK.
    // - 'async /*\n*/ function' is invalid.
    pp$8.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
        { return false }

      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, after;
      return !lineBreak.test(this.input.slice(this.pos, next)) &&
        this.input.slice(next, next + 8) === "function" &&
        (next + 8 === this.input.length ||
         !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
    };

    // Parse a single statement.
    //
    // If expecting a statement and finding a slash operator, parse a
    // regular expression literal. This is to handle cases like
    // `if (foo) /blah/.exec(foo)`, where looking at the previous token
    // does not help.

    pp$8.parseStatement = function(context, topLevel, exports) {
      var starttype = this.type, node = this.startNode(), kind;

      if (this.isLet(context)) {
        starttype = types$1._var;
        kind = "let";
      }

      // Most types of statements are recognized by the keyword they
      // start with. Many are trivial to parse, some require a bit of
      // complexity.

      switch (starttype) {
      case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
      case types$1._debugger: return this.parseDebuggerStatement(node)
      case types$1._do: return this.parseDoStatement(node)
      case types$1._for: return this.parseForStatement(node)
      case types$1._function:
        // Function as sole body of either an if statement or a labeled statement
        // works, but not when it is part of a labeled statement that is the sole
        // body of an if statement.
        if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
        return this.parseFunctionStatement(node, false, !context)
      case types$1._class:
        if (context) { this.unexpected(); }
        return this.parseClass(node, true)
      case types$1._if: return this.parseIfStatement(node)
      case types$1._return: return this.parseReturnStatement(node)
      case types$1._switch: return this.parseSwitchStatement(node)
      case types$1._throw: return this.parseThrowStatement(node)
      case types$1._try: return this.parseTryStatement(node)
      case types$1._const: case types$1._var:
        kind = kind || this.value;
        if (context && kind !== "var") { this.unexpected(); }
        return this.parseVarStatement(node, kind)
      case types$1._while: return this.parseWhileStatement(node)
      case types$1._with: return this.parseWithStatement(node)
      case types$1.braceL: return this.parseBlock(true, node)
      case types$1.semi: return this.parseEmptyStatement(node)
      case types$1._export:
      case types$1._import:
        if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
          if (nextCh === 40 || nextCh === 46) // '(' or '.'
            { return this.parseExpressionStatement(node, this.parseExpression()) }
        }

        if (!this.options.allowImportExportEverywhere) {
          if (!topLevel)
            { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
          if (!this.inModule)
            { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
        }
        return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)

        // If the statement does not start with a statement keyword or a
        // brace, it's an ExpressionStatement or LabeledStatement. We
        // simply start parsing an expression, and afterwards, if the
        // next token is a colon and the expression was a simple
        // Identifier node, we switch to interpreting it as a label.
      default:
        if (this.isAsyncFunction()) {
          if (context) { this.unexpected(); }
          this.next();
          return this.parseFunctionStatement(node, true, !context)
        }

        var maybeName = this.value, expr = this.parseExpression();
        if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
          { return this.parseLabeledStatement(node, maybeName, expr, context) }
        else { return this.parseExpressionStatement(node, expr) }
      }
    };

    pp$8.parseBreakContinueStatement = function(node, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
      else if (this.type !== types$1.name) { this.unexpected(); }
      else {
        node.label = this.parseIdent();
        this.semicolon();
      }

      // Verify that there is an actual destination to break or
      // continue to.
      var i = 0;
      for (; i < this.labels.length; ++i) {
        var lab = this.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
          if (node.label && isBreak) { break }
        }
      }
      if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
    };

    pp$8.parseDebuggerStatement = function(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement")
    };

    pp$8.parseDoStatement = function(node) {
      this.next();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("do");
      this.labels.pop();
      this.expect(types$1._while);
      node.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6)
        { this.eat(types$1.semi); }
      else
        { this.semicolon(); }
      return this.finishNode(node, "DoWhileStatement")
    };

    // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
    // loop is non-trivial. Basically, we have to parse the init `var`
    // statement or expression, disallowing the `in` operator (see
    // the second parameter to `parseExpression`), and then check
    // whether the next token is `in` or `of`. When there is no init
    // part (semicolon immediately after the opening parenthesis), it
    // is a regular `for` loop.

    pp$8.parseForStatement = function(node) {
      this.next();
      var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
      this.labels.push(loopLabel);
      this.enterScope(0);
      this.expect(types$1.parenL);
      if (this.type === types$1.semi) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
        return this.parseFor(node, null)
      }
      var isLet = this.isLet();
      if (this.type === types$1._var || this.type === types$1._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) { this.unexpected(awaitAt); }
            } else { node.await = awaitAt > -1; }
          }
          return this.parseForIn(node, init$1)
        }
        if (awaitAt > -1) { this.unexpected(awaitAt); }
        return this.parseFor(node, init$1)
      }
      var startsWithLet = this.isContextual("let"), isForOf = false;
      var containsEsc = this.containsEsc;
      var refDestructuringErrors = new DestructuringErrors;
      var initPos = this.start;
      var init = awaitAt > -1
        ? this.parseExprSubscripts(refDestructuringErrors, "await")
        : this.parseExpression(true, refDestructuringErrors);
      if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        if (awaitAt > -1) { // implies `ecmaVersion >= 9` (see declaration of awaitAt)
          if (this.type === types$1._in) { this.unexpected(awaitAt); }
          node.await = true;
        } else if (isForOf && this.options.ecmaVersion >= 8) {
          if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") { this.unexpected(); }
          else if (this.options.ecmaVersion >= 9) { node.await = false; }
        }
        if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
        this.toAssignable(init, false, refDestructuringErrors);
        this.checkLValPattern(init);
        return this.parseForIn(node, init)
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init)
    };

    pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
    };

    pp$8.parseIfStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      // allow function declarations in branches, but only in non-strict mode
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement")
    };

    pp$8.parseReturnStatement = function(node) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction)
        { this.raise(this.start, "'return' outside of function"); }
      this.next();

      // In `return` (and `break`/`continue`), the keywords with
      // optional arguments, we eagerly look for a semicolon or the
      // possibility to insert one.

      if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
      else { node.argument = this.parseExpression(); this.semicolon(); }
      return this.finishNode(node, "ReturnStatement")
    };

    pp$8.parseSwitchStatement = function(node) {
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.expect(types$1.braceL);
      this.labels.push(switchLabel);
      this.enterScope(0);

      // Statements under must be grouped (by label) in SwitchCase
      // nodes. `cur` is used to keep the node that we are currently
      // adding statements to.

      var cur;
      for (var sawDefault = false; this.type !== types$1.braceR;) {
        if (this.type === types$1._case || this.type === types$1._default) {
          var isCase = this.type === types$1._case;
          if (cur) { this.finishNode(cur, "SwitchCase"); }
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types$1.colon);
        } else {
          if (!cur) { this.unexpected(); }
          cur.consequent.push(this.parseStatement(null));
        }
      }
      this.exitScope();
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      this.next(); // Closing brace
      this.labels.pop();
      return this.finishNode(node, "SwitchStatement")
    };

    pp$8.parseThrowStatement = function(node) {
      this.next();
      if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
        { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement")
    };

    // Reused empty array added for node fields that are always empty.

    var empty$1 = [];

    pp$8.parseCatchClauseParam = function() {
      var param = this.parseBindingAtom();
      var simple = param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types$1.parenR);

      return param
    };

    pp$8.parseTryStatement = function(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.type === types$1._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types$1.parenL)) {
          clause.param = this.parseCatchClauseParam();
        } else {
          if (this.options.ecmaVersion < 10) { this.unexpected(); }
          clause.param = null;
          this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer)
        { this.raise(node.start, "Missing catch or finally clause"); }
      return this.finishNode(node, "TryStatement")
    };

    pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
      this.next();
      this.parseVar(node, false, kind, allowMissingInitializer);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration")
    };

    pp$8.parseWhileStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("while");
      this.labels.pop();
      return this.finishNode(node, "WhileStatement")
    };

    pp$8.parseWithStatement = function(node) {
      if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement("with");
      return this.finishNode(node, "WithStatement")
    };

    pp$8.parseEmptyStatement = function(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement")
    };

    pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
      for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
        {
        var label = list[i$1];

        if (label.name === maybeName)
          { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
      } }
      var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
      for (var i = this.labels.length - 1; i >= 0; i--) {
        var label$1 = this.labels[i];
        if (label$1.statementStart === node.start) {
          // Update information about previous labels on this node
          label$1.statementStart = this.start;
          label$1.kind = kind;
        } else { break }
      }
      this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement")
    };

    pp$8.parseExpressionStatement = function(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement")
    };

    // Parse a semicolon-enclosed block of statements, handling `"use
    // strict"` declarations when `allowStrict` is true (used for
    // function bodies).

    pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
      if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
      if ( node === void 0 ) node = this.startNode();

      node.body = [];
      this.expect(types$1.braceL);
      if (createNewLexicalScope) { this.enterScope(0); }
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
      }
      if (exitStrict) { this.strict = false; }
      this.next();
      if (createNewLexicalScope) { this.exitScope(); }
      return this.finishNode(node, "BlockStatement")
    };

    // Parse a regular `for` loop. The disambiguation code in
    // `parseStatement` will already have parsed the init statement or
    // expression.

    pp$8.parseFor = function(node, init) {
      node.init = init;
      this.expect(types$1.semi);
      node.test = this.type === types$1.semi ? null : this.parseExpression();
      this.expect(types$1.semi);
      node.update = this.type === types$1.parenR ? null : this.parseExpression();
      this.expect(types$1.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, "ForStatement")
    };

    // Parse a `for`/`in` and `for`/`of` loop, which are almost
    // same from parser's perspective.

    pp$8.parseForIn = function(node, init) {
      var isForIn = this.type === types$1._in;
      this.next();

      if (
        init.type === "VariableDeclaration" &&
        init.declarations[0].init != null &&
        (
          !isForIn ||
          this.options.ecmaVersion < 8 ||
          this.strict ||
          init.kind !== "var" ||
          init.declarations[0].id.type !== "Identifier"
        )
      ) {
        this.raise(
          init.start,
          ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
        );
      }
      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types$1.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
    };

    // Parse a list of variable declarations.

    pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
      node.declarations = [];
      node.kind = kind;
      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types$1.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
          this.unexpected();
        } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types$1.comma)) { break }
      }
      return node
    };

    pp$8.parseVarId = function(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };

    var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

    // Parse a function declaration or literal (depending on the
    // `statement & FUNC_STATEMENT`).

    // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
    pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
      this.initFunction(node);
      if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
          { this.unexpected(); }
        node.generator = this.eat(types$1.star);
      }
      if (this.options.ecmaVersion >= 8)
        { node.async = !!isAsync; }

      if (statement & FUNC_STATEMENT) {
        node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();
        if (node.id && !(statement & FUNC_HANGING_STATEMENT))
          // If it is a regular function declaration in sloppy mode, then it is
          // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
          // mode depends on properties of the current scope (see
          // treatFunctionsAsVar).
          { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
      }

      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(node.async, node.generator));

      if (!(statement & FUNC_STATEMENT))
        { node.id = this.type === types$1.name ? this.parseIdent() : null; }

      this.parseFunctionParams(node);
      this.parseFunctionBody(node, allowExpressionBody, false, forInit);

      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
    };

    pp$8.parseFunctionParams = function(node) {
      this.expect(types$1.parenL);
      node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };

    // Parse a class declaration or literal (depending on the
    // `isStatement` parameter).

    pp$8.parseClass = function(node, isStatement) {
      this.next();

      // ecma-262 14.6 Class Definitions
      // A class definition is always strict mode code.
      var oldStrict = this.strict;
      this.strict = true;

      this.parseClassId(node, isStatement);
      this.parseClassSuper(node);
      var privateNameMap = this.enterClassBody();
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types$1.braceL);
      while (this.type !== types$1.braceR) {
        var element = this.parseClassElement(node.superClass !== null);
        if (element) {
          classBody.body.push(element);
          if (element.type === "MethodDefinition" && element.kind === "constructor") {
            if (hadConstructor) { this.raiseRecoverable(element.start, "Duplicate constructor in the same class"); }
            hadConstructor = true;
          } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
            this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
          }
        }
      }
      this.strict = oldStrict;
      this.next();
      node.body = this.finishNode(classBody, "ClassBody");
      this.exitClassBody();
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
    };

    pp$8.parseClassElement = function(constructorAllowsSuper) {
      if (this.eat(types$1.semi)) { return null }

      var ecmaVersion = this.options.ecmaVersion;
      var node = this.startNode();
      var keyName = "";
      var isGenerator = false;
      var isAsync = false;
      var kind = "method";
      var isStatic = false;

      if (this.eatContextual("static")) {
        // Parse static init block
        if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
          this.parseClassStaticBlock(node);
          return node
        }
        if (this.isClassElementNameStart() || this.type === types$1.star) {
          isStatic = true;
        } else {
          keyName = "static";
        }
      }
      node.static = isStatic;
      if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
        if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
          isAsync = true;
        } else {
          keyName = "async";
        }
      }
      if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
        isGenerator = true;
      }
      if (!keyName && !isAsync && !isGenerator) {
        var lastValue = this.value;
        if (this.eatContextual("get") || this.eatContextual("set")) {
          if (this.isClassElementNameStart()) {
            kind = lastValue;
          } else {
            keyName = lastValue;
          }
        }
      }

      // Parse element name
      if (keyName) {
        // 'async', 'get', 'set', or 'static' were not a keyword contextually.
        // The last token is any of those. Make it the element name.
        node.computed = false;
        node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
        node.key.name = keyName;
        this.finishNode(node.key, "Identifier");
      } else {
        this.parseClassElementName(node);
      }

      // Parse element value
      if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
        var isConstructor = !node.static && checkKeyName(node, "constructor");
        var allowsDirectSuper = isConstructor && constructorAllowsSuper;
        // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
        if (isConstructor && kind !== "method") { this.raise(node.key.start, "Constructor can't have get/set modifier"); }
        node.kind = isConstructor ? "constructor" : kind;
        this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
      } else {
        this.parseClassField(node);
      }

      return node
    };

    pp$8.isClassElementNameStart = function() {
      return (
        this.type === types$1.name ||
        this.type === types$1.privateId ||
        this.type === types$1.num ||
        this.type === types$1.string ||
        this.type === types$1.bracketL ||
        this.type.keyword
      )
    };

    pp$8.parseClassElementName = function(element) {
      if (this.type === types$1.privateId) {
        if (this.value === "constructor") {
          this.raise(this.start, "Classes can't have an element named '#constructor'");
        }
        element.computed = false;
        element.key = this.parsePrivateIdent();
      } else {
        this.parsePropertyName(element);
      }
    };

    pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
      // Check key and flags
      var key = method.key;
      if (method.kind === "constructor") {
        if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
        if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
      } else if (method.static && checkKeyName(method, "prototype")) {
        this.raise(key.start, "Classes may not have a static property named prototype");
      }

      // Parse value
      var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);

      // Check value
      if (method.kind === "get" && value.params.length !== 0)
        { this.raiseRecoverable(value.start, "getter should have no params"); }
      if (method.kind === "set" && value.params.length !== 1)
        { this.raiseRecoverable(value.start, "setter should have exactly one param"); }
      if (method.kind === "set" && value.params[0].type === "RestElement")
        { this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"); }

      return this.finishNode(method, "MethodDefinition")
    };

    pp$8.parseClassField = function(field) {
      if (checkKeyName(field, "constructor")) {
        this.raise(field.key.start, "Classes can't have a field named 'constructor'");
      } else if (field.static && checkKeyName(field, "prototype")) {
        this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
      }

      if (this.eat(types$1.eq)) {
        // To raise SyntaxError if 'arguments' exists in the initializer.
        var scope = this.currentThisScope();
        var inClassFieldInit = scope.inClassFieldInit;
        scope.inClassFieldInit = true;
        field.value = this.parseMaybeAssign();
        scope.inClassFieldInit = inClassFieldInit;
      } else {
        field.value = null;
      }
      this.semicolon();

      return this.finishNode(field, "PropertyDefinition")
    };

    pp$8.parseClassStaticBlock = function(node) {
      node.body = [];

      var oldLabels = this.labels;
      this.labels = [];
      this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
      }
      this.next();
      this.exitScope();
      this.labels = oldLabels;

      return this.finishNode(node, "StaticBlock")
    };

    pp$8.parseClassId = function(node, isStatement) {
      if (this.type === types$1.name) {
        node.id = this.parseIdent();
        if (isStatement)
          { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
      } else {
        if (isStatement === true)
          { this.unexpected(); }
        node.id = null;
      }
    };

    pp$8.parseClassSuper = function(node) {
      node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
    };

    pp$8.enterClassBody = function() {
      var element = {declared: Object.create(null), used: []};
      this.privateNameStack.push(element);
      return element.declared
    };

    pp$8.exitClassBody = function() {
      var ref = this.privateNameStack.pop();
      var declared = ref.declared;
      var used = ref.used;
      if (!this.options.checkPrivateFields) { return }
      var len = this.privateNameStack.length;
      var parent = len === 0 ? null : this.privateNameStack[len - 1];
      for (var i = 0; i < used.length; ++i) {
        var id = used[i];
        if (!hasOwn(declared, id.name)) {
          if (parent) {
            parent.used.push(id);
          } else {
            this.raiseRecoverable(id.start, ("Private field '#" + (id.name) + "' must be declared in an enclosing class"));
          }
        }
      }
    };

    function isPrivateNameConflicted(privateNameMap, element) {
      var name = element.key.name;
      var curr = privateNameMap[name];

      var next = "true";
      if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
        next = (element.static ? "s" : "i") + element.kind;
      }

      // `class { get #a(){}; static set #a(_){} }` is also conflict.
      if (
        curr === "iget" && next === "iset" ||
        curr === "iset" && next === "iget" ||
        curr === "sget" && next === "sset" ||
        curr === "sset" && next === "sget"
      ) {
        privateNameMap[name] = "true";
        return false
      } else if (!curr) {
        privateNameMap[name] = next;
        return false
      } else {
        return true
      }
    }

    function checkKeyName(node, name) {
      var computed = node.computed;
      var key = node.key;
      return !computed && (
        key.type === "Identifier" && key.name === name ||
        key.type === "Literal" && key.value === name
      )
    }

    // Parses module export declaration.

    pp$8.parseExportAllDeclaration = function(node, exports) {
      if (this.options.ecmaVersion >= 11) {
        if (this.eatContextual("as")) {
          node.exported = this.parseModuleExportName();
          this.checkExport(exports, node.exported, this.lastTokStart);
        } else {
          node.exported = null;
        }
      }
      this.expectContextual("from");
      if (this.type !== types$1.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16)
        { node.attributes = this.parseWithClause(); }
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration")
    };

    pp$8.parseExport = function(node, exports) {
      this.next();
      // export * from '...'
      if (this.eat(types$1.star)) {
        return this.parseExportAllDeclaration(node, exports)
      }
      if (this.eat(types$1._default)) { // export default ...
        this.checkExport(exports, "default", this.lastTokStart);
        node.declaration = this.parseExportDefaultDeclaration();
        return this.finishNode(node, "ExportDefaultDeclaration")
      }
      // export var|const|let|function|class ...
      if (this.shouldParseExportStatement()) {
        node.declaration = this.parseExportDeclaration(node);
        if (node.declaration.type === "VariableDeclaration")
          { this.checkVariableExport(exports, node.declaration.declarations); }
        else
          { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
        node.specifiers = [];
        node.source = null;
      } else { // export { x, y as z } [from '...']
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers(exports);
        if (this.eatContextual("from")) {
          if (this.type !== types$1.string) { this.unexpected(); }
          node.source = this.parseExprAtom();
          if (this.options.ecmaVersion >= 16)
            { node.attributes = this.parseWithClause(); }
        } else {
          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
            // check for keywords used as local names
            var spec = list[i];

            this.checkUnreserved(spec.local);
            // check if export is defined
            this.checkLocalExport(spec.local);

            if (spec.local.type === "Literal") {
              this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
          }

          node.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node, "ExportNamedDeclaration")
    };

    pp$8.parseExportDeclaration = function(node) {
      return this.parseStatement(null)
    };

    pp$8.parseExportDefaultDeclaration = function() {
      var isAsync;
      if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) { this.next(); }
        return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync)
      } else if (this.type === types$1._class) {
        var cNode = this.startNode();
        return this.parseClass(cNode, "nullableID")
      } else {
        var declaration = this.parseMaybeAssign();
        this.semicolon();
        return declaration
      }
    };

    pp$8.checkExport = function(exports, name, pos) {
      if (!exports) { return }
      if (typeof name !== "string")
        { name = name.type === "Identifier" ? name.name : name.value; }
      if (hasOwn(exports, name))
        { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
      exports[name] = true;
    };

    pp$8.checkPatternExport = function(exports, pat) {
      var type = pat.type;
      if (type === "Identifier")
        { this.checkExport(exports, pat, pat.start); }
      else if (type === "ObjectPattern")
        { for (var i = 0, list = pat.properties; i < list.length; i += 1)
          {
            var prop = list[i];

            this.checkPatternExport(exports, prop);
          } }
      else if (type === "ArrayPattern")
        { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
          var elt = list$1[i$1];

            if (elt) { this.checkPatternExport(exports, elt); }
        } }
      else if (type === "Property")
        { this.checkPatternExport(exports, pat.value); }
      else if (type === "AssignmentPattern")
        { this.checkPatternExport(exports, pat.left); }
      else if (type === "RestElement")
        { this.checkPatternExport(exports, pat.argument); }
    };

    pp$8.checkVariableExport = function(exports, decls) {
      if (!exports) { return }
      for (var i = 0, list = decls; i < list.length; i += 1)
        {
        var decl = list[i];

        this.checkPatternExport(exports, decl.id);
      }
    };

    pp$8.shouldParseExportStatement = function() {
      return this.type.keyword === "var" ||
        this.type.keyword === "const" ||
        this.type.keyword === "class" ||
        this.type.keyword === "function" ||
        this.isLet() ||
        this.isAsyncFunction()
    };

    // Parses a comma-separated list of module exports.

    pp$8.parseExportSpecifier = function(exports) {
      var node = this.startNode();
      node.local = this.parseModuleExportName();

      node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
      this.checkExport(
        exports,
        node.exported,
        node.exported.start
      );

      return this.finishNode(node, "ExportSpecifier")
    };

    pp$8.parseExportSpecifiers = function(exports) {
      var nodes = [], first = true;
      // export { x, y as z } [from '...']
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) { break }
        } else { first = false; }

        nodes.push(this.parseExportSpecifier(exports));
      }
      return nodes
    };

    // Parses import declaration.

    pp$8.parseImport = function(node) {
      this.next();

      // import '...'
      if (this.type === types$1.string) {
        node.specifiers = empty$1;
        node.source = this.parseExprAtom();
      } else {
        node.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
      }
      if (this.options.ecmaVersion >= 16)
        { node.attributes = this.parseWithClause(); }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration")
    };

    // Parses a comma-separated list of module imports.

    pp$8.parseImportSpecifier = function() {
      var node = this.startNode();
      node.imported = this.parseModuleExportName();

      if (this.eatContextual("as")) {
        node.local = this.parseIdent();
      } else {
        this.checkUnreserved(node.imported);
        node.local = node.imported;
      }
      this.checkLValSimple(node.local, BIND_LEXICAL);

      return this.finishNode(node, "ImportSpecifier")
    };

    pp$8.parseImportDefaultSpecifier = function() {
      // import defaultObj, { x, y as z } from '...'
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLValSimple(node.local, BIND_LEXICAL);
      return this.finishNode(node, "ImportDefaultSpecifier")
    };

    pp$8.parseImportNamespaceSpecifier = function() {
      var node = this.startNode();
      this.next();
      this.expectContextual("as");
      node.local = this.parseIdent();
      this.checkLValSimple(node.local, BIND_LEXICAL);
      return this.finishNode(node, "ImportNamespaceSpecifier")
    };

    pp$8.parseImportSpecifiers = function() {
      var nodes = [], first = true;
      if (this.type === types$1.name) {
        nodes.push(this.parseImportDefaultSpecifier());
        if (!this.eat(types$1.comma)) { return nodes }
      }
      if (this.type === types$1.star) {
        nodes.push(this.parseImportNamespaceSpecifier());
        return nodes
      }
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) { break }
        } else { first = false; }

        nodes.push(this.parseImportSpecifier());
      }
      return nodes
    };

    pp$8.parseWithClause = function() {
      var nodes = [];
      if (!this.eat(types$1._with)) {
        return nodes
      }
      this.expect(types$1.braceL);
      var attributeKeys = {};
      var first = true;
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) { break }
        } else { first = false; }

        var attr = this.parseImportAttribute();
        var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
        if (hasOwn(attributeKeys, keyName))
          { this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'"); }
        attributeKeys[keyName] = true;
        nodes.push(attr);
      }
      return nodes
    };

    pp$8.parseImportAttribute = function() {
      var node = this.startNode();
      node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      this.expect(types$1.colon);
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.value = this.parseExprAtom();
      return this.finishNode(node, "ImportAttribute")
    };

    pp$8.parseModuleExportName = function() {
      if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
        var stringLiteral = this.parseLiteral(this.value);
        if (loneSurrogate.test(stringLiteral.value)) {
          this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
        }
        return stringLiteral
      }
      return this.parseIdent(true)
    };

    // Set `ExpressionStatement#directive` property for directive prologues.
    pp$8.adaptDirectivePrologue = function(statements) {
      for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
        statements[i].directive = statements[i].expression.raw.slice(1, -1);
      }
    };
    pp$8.isDirectiveCandidate = function(statement) {
      return (
        this.options.ecmaVersion >= 5 &&
        statement.type === "ExpressionStatement" &&
        statement.expression.type === "Literal" &&
        typeof statement.expression.value === "string" &&
        // Reject parenthesized strings.
        (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
      )
    };

    var pp$7 = Parser.prototype;

    // Convert existing expression atom to assignable pattern
    // if possible.

    pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 6 && node) {
        switch (node.type) {
        case "Identifier":
          if (this.inAsync && node.name === "await")
            { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
          break

        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break

        case "ObjectExpression":
          node.type = "ObjectPattern";
          if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
          for (var i = 0, list = node.properties; i < list.length; i += 1) {
            var prop = list[i];

          this.toAssignable(prop, isBinding);
            // Early error:
            //   AssignmentRestProperty[Yield, Await] :
            //     `...` DestructuringAssignmentTarget[Yield, Await]
            //
            //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
            if (
              prop.type === "RestElement" &&
              (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
            ) {
              this.raise(prop.argument.start, "Unexpected token");
            }
          }
          break

        case "Property":
          // AssignmentProperty has type === "Property"
          if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
          this.toAssignable(node.value, isBinding);
          break

        case "ArrayExpression":
          node.type = "ArrayPattern";
          if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
          this.toAssignableList(node.elements, isBinding);
          break

        case "SpreadElement":
          node.type = "RestElement";
          this.toAssignable(node.argument, isBinding);
          if (node.argument.type === "AssignmentPattern")
            { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
          break

        case "AssignmentExpression":
          if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left, isBinding);
          break

        case "ParenthesizedExpression":
          this.toAssignable(node.expression, isBinding, refDestructuringErrors);
          break

        case "ChainExpression":
          this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
          break

        case "MemberExpression":
          if (!isBinding) { break }

        default:
          this.raise(node.start, "Assigning to rvalue");
        }
      } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      return node
    };

    // Convert list of expression atoms to binding list.

    pp$7.toAssignableList = function(exprList, isBinding) {
      var end = exprList.length;
      for (var i = 0; i < end; i++) {
        var elt = exprList[i];
        if (elt) { this.toAssignable(elt, isBinding); }
      }
      if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
          { this.unexpected(last.argument.start); }
      }
      return exprList
    };

    // Parses spread element.

    pp$7.parseSpread = function(refDestructuringErrors) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node, "SpreadElement")
    };

    pp$7.parseRestBinding = function() {
      var node = this.startNode();
      this.next();

      // RestElement inside of a function parameter must be an identifier
      if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
        { this.unexpected(); }

      node.argument = this.parseBindingAtom();

      return this.finishNode(node, "RestElement")
    };

    // Parses lvalue (assignable) atom.

    pp$7.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) {
        switch (this.type) {
        case types$1.bracketL:
          var node = this.startNode();
          this.next();
          node.elements = this.parseBindingList(types$1.bracketR, true, true);
          return this.finishNode(node, "ArrayPattern")

        case types$1.braceL:
          return this.parseObj(true)
        }
      }
      return this.parseIdent()
    };

    pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (first) { first = false; }
        else { this.expect(types$1.comma); }
        if (allowEmpty && this.type === types$1.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close)) {
          break
        } else if (this.type === types$1.ellipsis) {
          var rest = this.parseRestBinding();
          this.parseBindingListItem(rest);
          elts.push(rest);
          if (this.type === types$1.comma) { this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"); }
          this.expect(close);
          break
        } else {
          elts.push(this.parseAssignableListItem(allowModifiers));
        }
      }
      return elts
    };

    pp$7.parseAssignableListItem = function(allowModifiers) {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      return elem
    };

    pp$7.parseBindingListItem = function(param) {
      return param
    };

    // Parses assignment pattern around given atom if possible.

    pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern")
    };

    // The following three functions all verify that a node is an lvalue —
    // something that can be bound, or assigned to. In order to do so, they perform
    // a variety of checks:
    //
    // - Check that none of the bound/assigned-to identifiers are reserved words.
    // - Record name declarations for bindings in the appropriate scope.
    // - Check duplicate argument names, if checkClashes is set.
    //
    // If a complex binding pattern is encountered (e.g., object and array
    // destructuring), the entire pattern is recursively checked.
    //
    // There are three versions of checkLVal*() appropriate for different
    // circumstances:
    //
    // - checkLValSimple() shall be used if the syntactic construct supports
    //   nothing other than identifiers and member expressions. Parenthesized
    //   expressions are also correctly handled. This is generally appropriate for
    //   constructs for which the spec says
    //
    //   > It is a Syntax Error if AssignmentTargetType of [the production] is not
    //   > simple.
    //
    //   It is also appropriate for checking if an identifier is valid and not
    //   defined elsewhere, like import declarations or function/class identifiers.
    //
    //   Examples where this is used include:
    //     a += …;
    //     import a from '…';
    //   where a is the node to be checked.
    //
    // - checkLValPattern() shall be used if the syntactic construct supports
    //   anything checkLValSimple() supports, as well as object and array
    //   destructuring patterns. This is generally appropriate for constructs for
    //   which the spec says
    //
    //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
    //   > an ArrayLiteral and AssignmentTargetType of [the production] is not
    //   > simple.
    //
    //   Examples where this is used include:
    //     (a = …);
    //     const a = …;
    //     try { … } catch (a) { … }
    //   where a is the node to be checked.
    //
    // - checkLValInnerPattern() shall be used if the syntactic construct supports
    //   anything checkLValPattern() supports, as well as default assignment
    //   patterns, rest elements, and other constructs that may appear within an
    //   object or array destructuring pattern.
    //
    //   As a special case, function parameters also use checkLValInnerPattern(),
    //   as they also support defaults and rest constructs.
    //
    // These functions deliberately support both assignment and binding constructs,
    // as the logic for both is exceedingly similar. If the node is the target of
    // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
    // should be set to the appropriate BIND_* constant, like BIND_VAR or
    // BIND_LEXICAL.
    //
    // If the function is called with a non-BIND_NONE bindingType, then
    // additionally a checkClashes object may be specified to allow checking for
    // duplicate argument names. checkClashes is ignored if the provided construct
    // is an assignment (i.e., bindingType is BIND_NONE).

    pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
      if ( bindingType === void 0 ) bindingType = BIND_NONE;

      var isBind = bindingType !== BIND_NONE;

      switch (expr.type) {
      case "Identifier":
        if (this.strict && this.reservedWordsStrictBind.test(expr.name))
          { this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
        if (isBind) {
          if (bindingType === BIND_LEXICAL && expr.name === "let")
            { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
          if (checkClashes) {
            if (hasOwn(checkClashes, expr.name))
              { this.raiseRecoverable(expr.start, "Argument name clash"); }
            checkClashes[expr.name] = true;
          }
          if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
        }
        break

      case "ChainExpression":
        this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
        break

      case "MemberExpression":
        if (isBind) { this.raiseRecoverable(expr.start, "Binding member expression"); }
        break

      case "ParenthesizedExpression":
        if (isBind) { this.raiseRecoverable(expr.start, "Binding parenthesized expression"); }
        return this.checkLValSimple(expr.expression, bindingType, checkClashes)

      default:
        this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
      }
    };

    pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
      if ( bindingType === void 0 ) bindingType = BIND_NONE;

      switch (expr.type) {
      case "ObjectPattern":
        for (var i = 0, list = expr.properties; i < list.length; i += 1) {
          var prop = list[i];

        this.checkLValInnerPattern(prop, bindingType, checkClashes);
        }
        break

      case "ArrayPattern":
        for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
          var elem = list$1[i$1];

        if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }
        }
        break

      default:
        this.checkLValSimple(expr, bindingType, checkClashes);
      }
    };

    pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
      if ( bindingType === void 0 ) bindingType = BIND_NONE;

      switch (expr.type) {
      case "Property":
        // AssignmentProperty has type === "Property"
        this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
        break

      case "AssignmentPattern":
        this.checkLValPattern(expr.left, bindingType, checkClashes);
        break

      case "RestElement":
        this.checkLValPattern(expr.argument, bindingType, checkClashes);
        break

      default:
        this.checkLValPattern(expr, bindingType, checkClashes);
      }
    };

    // The algorithm used to determine whether a regexp can appear at a
    // given point in the program is loosely based on sweet.js' approach.
    // See https://github.com/mozilla/sweet.js/wiki/design


    var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };

    var types = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", false),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
      f_stat: new TokContext("function", false),
      f_expr: new TokContext("function", true),
      f_expr_gen: new TokContext("function", true, false, null, true),
      f_gen: new TokContext("function", false, false, null, true)
    };

    var pp$6 = Parser.prototype;

    pp$6.initialContext = function() {
      return [types.b_stat]
    };

    pp$6.curContext = function() {
      return this.context[this.context.length - 1]
    };

    pp$6.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types.f_expr || parent === types.f_stat)
        { return true }
      if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
        { return !parent.isExpr }

      // The check for `tt.name && exprAllowed` detects whether we are
      // after a `yield` or `of` construct. See the `updateContext` for
      // `tt.name`.
      if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
        { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
      if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
        { return true }
      if (prevType === types$1.braceL)
        { return parent === types.b_stat }
      if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
        { return false }
      return !this.exprAllowed
    };

    pp$6.inGeneratorContext = function() {
      for (var i = this.context.length - 1; i >= 1; i--) {
        var context = this.context[i];
        if (context.token === "function")
          { return context.generator }
      }
      return false
    };

    pp$6.updateContext = function(prevType) {
      var update, type = this.type;
      if (type.keyword && prevType === types$1.dot)
        { this.exprAllowed = false; }
      else if (update = type.updateContext)
        { update.call(this, prevType); }
      else
        { this.exprAllowed = type.beforeExpr; }
    };

    // Used to handle edge cases when token context could not be inferred correctly during tokenization phase

    pp$6.overrideContext = function(tokenCtx) {
      if (this.curContext() !== tokenCtx) {
        this.context[this.context.length - 1] = tokenCtx;
      }
    };

    // Token-specific context update code

    types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return
      }
      var out = this.context.pop();
      if (out === types.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      this.exprAllowed = !out.isExpr;
    };

    types$1.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
      this.exprAllowed = true;
    };

    types$1.dollarBraceL.updateContext = function() {
      this.context.push(types.b_tmpl);
      this.exprAllowed = true;
    };

    types$1.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
      this.context.push(statementParens ? types.p_stat : types.p_expr);
      this.exprAllowed = true;
    };

    types$1.incDec.updateContext = function() {
      // tokExprAllowed stays unchanged
    };

    types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types$1._else &&
          !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
          !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
          !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
        { this.context.push(types.f_expr); }
      else
        { this.context.push(types.f_stat); }
      this.exprAllowed = false;
    };

    types$1.colon.updateContext = function() {
      if (this.curContext().token === "function") { this.context.pop(); }
      this.exprAllowed = true;
    };

    types$1.backQuote.updateContext = function() {
      if (this.curContext() === types.q_tmpl)
        { this.context.pop(); }
      else
        { this.context.push(types.q_tmpl); }
      this.exprAllowed = false;
    };

    types$1.star.updateContext = function(prevType) {
      if (prevType === types$1._function) {
        var index = this.context.length - 1;
        if (this.context[index] === types.f_expr)
          { this.context[index] = types.f_expr_gen; }
        else
          { this.context[index] = types.f_gen; }
      }
      this.exprAllowed = true;
    };

    types$1.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
        if (this.value === "of" && !this.exprAllowed ||
            this.value === "yield" && this.inGeneratorContext())
          { allowed = true; }
      }
      this.exprAllowed = allowed;
    };

    // A recursive descent parser operates by defining functions for all
    // syntactic elements, and recursively calling those, each function
    // advancing the input stream and returning an AST node. Precedence
    // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
    // instead of `(!x)[1]` is handled by the fact that the parser
    // function that parses unary prefix operators is called first, and
    // in turn calls the function that parses `[]` subscripts — that
    // way, it'll receive the node for `x[1]` already parsed, and wraps
    // *that* in the unary operator node.
    //
    // Acorn uses an [operator precedence parser][opp] to handle binary
    // operator precedence, because it is much more compact than using
    // the technique outlined above, which uses different, nesting
    // functions to specify precedence, for all of the ten binary
    // precedence levels that JavaScript defines.
    //
    // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser


    var pp$5 = Parser.prototype;

    // Check if property name clashes with already added.
    // Object/class getters and setters are not allowed to clash —
    // either with each other or with an init property — and in
    // strict mode, init properties are also not allowed to be repeated.

    pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
        { return }
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
        { return }
      var key = prop.key;
      var name;
      switch (key.type) {
      case "Identifier": name = key.name; break
      case "Literal": name = String(key.value); break
      default: return
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
          if (propHash.proto) {
            if (refDestructuringErrors) {
              if (refDestructuringErrors.doubleProto < 0) {
                refDestructuringErrors.doubleProto = key.start;
              }
            } else {
              this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
            }
          }
          propHash.proto = true;
        }
        return
      }
      name = "$" + name;
      var other = propHash[name];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition)
          { this.raiseRecoverable(key.start, "Redefinition of property"); }
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };

    // ### Expression parsing

    // These nest, from the most general expression type at the top to
    // 'atomic', nondivisible expression types at the bottom. Most of
    // the functions will simply let the function(s) below them parse,
    // and, *if* the syntactic construct they handle is present, wrap
    // the AST node that the inner parser gave them in another node.

    // Parse a full expression. The optional arguments are used to
    // forbid the `in` operator (in for loops initalization expressions)
    // and provide reference for storing '=' operator inside shorthand
    // property assignment in contexts where both object expression
    // and object pattern might appear (so it's possible to raise
    // delayed syntax error at correct position).

    pp$5.parseExpression = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
      if (this.type === types$1.comma) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];
        while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
        return this.finishNode(node, "SequenceExpression")
      }
      return expr
    };

    // Parse an assignment expression. This includes applications of
    // operators like `+=`.

    pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) { return this.parseYield(forInit) }
        // The tokenizer will assume an expression is allowed after
        // `yield`, but this isn't that kind of yield
        else { this.exprAllowed = false; }
      }

      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        oldDoubleProto = refDestructuringErrors.doubleProto;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors;
        ownDestructuringErrors = true;
      }

      var startPos = this.start, startLoc = this.startLoc;
      if (this.type === types$1.parenL || this.type === types$1.name) {
        this.potentialArrowAt = this.start;
        this.potentialArrowInForAwait = forInit === "await";
      }
      var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
      if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
      if (this.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        if (this.type === types$1.eq)
          { left = this.toAssignable(left, false, refDestructuringErrors); }
        if (!ownDestructuringErrors) {
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
        }
        if (refDestructuringErrors.shorthandAssign >= left.start)
          { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
        if (this.type === types$1.eq)
          { this.checkLValPattern(left); }
        else
          { this.checkLValSimple(left); }
        node.left = left;
        this.next();
        node.right = this.parseMaybeAssign(forInit);
        if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
        return this.finishNode(node, "AssignmentExpression")
      } else {
        if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
      }
      if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
      if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
      return left
    };

    // Parse a ternary conditional (`?:`) operator.

    pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(forInit, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      if (this.eat(types$1.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types$1.colon);
        node.alternate = this.parseMaybeAssign(forInit);
        return this.finishNode(node, "ConditionalExpression")
      }
      return expr
    };

    // Start the precedence parser.

    pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)
    };

    // Parse binary operators with the operator precedence parsing
    // algorithm. `left` is the left-hand side of the operator.
    // `minPrec` provides context that allows the function to stop and
    // defer further parser to one of its callers when it encounters an
    // operator that has a lower precedence than the set it is parsing.

    pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
      var prec = this.type.binop;
      if (prec != null && (!forInit || this.type !== types$1._in)) {
        if (prec > minPrec) {
          var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
          var coalesce = this.type === types$1.coalesce;
          if (coalesce) {
            // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
            // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
            prec = types$1.logicalAND.binop;
          }
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
          var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
          if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
            this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
          }
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
        }
      }
      return left
    };

    pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.operator = op;
      node.right = right;
      return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
    };

    // Parse unary operators, both prefix and postfix.

    pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.isContextual("await") && this.canAwait) {
        expr = this.parseAwait(forInit);
        sawUnary = true;
      } else if (this.type.prefix) {
        var node = this.startNode(), update = this.type === types$1.incDec;
        node.operator = this.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary(null, true, update, forInit);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) { this.checkLValSimple(node.argument); }
        else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument))
          { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
        else if (node.operator === "delete" && isPrivateFieldAccess(node.argument))
          { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
        else { sawUnary = true; }
        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      } else if (!sawUnary && this.type === types$1.privateId) {
        if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) { this.unexpected(); }
        expr = this.parsePrivateIdent();
        // only could be private fields in 'in', such as #x in obj
        if (this.type !== types$1._in) { this.unexpected(); }
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.operator = this.value;
          node$1.prefix = false;
          node$1.argument = expr;
          this.checkLValSimple(expr);
          this.next();
          expr = this.finishNode(node$1, "UpdateExpression");
        }
      }

      if (!incDec && this.eat(types$1.starstar)) {
        if (sawUnary)
          { this.unexpected(this.lastTokStart); }
        else
          { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false) }
      } else {
        return expr
      }
    };

    function isLocalVariableAccess(node) {
      return (
        node.type === "Identifier" ||
        node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression)
      )
    }

    function isPrivateFieldAccess(node) {
      return (
        node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" ||
        node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) ||
        node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression)
      )
    }

    // Parse call, dot, and `[]`-subscript expressions.

    pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors, forInit);
      if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
        { return expr }
      var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
      if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
        if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
        if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }
      }
      return result
    };

    pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
          this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
          this.potentialArrowAt === base.start;
      var optionalChained = false;

      while (true) {
        var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);

        if (element.optional) { optionalChained = true; }
        if (element === base || element.type === "ArrowFunctionExpression") {
          if (optionalChained) {
            var chainNode = this.startNodeAt(startPos, startLoc);
            chainNode.expression = element;
            element = this.finishNode(chainNode, "ChainExpression");
          }
          return element
        }

        base = element;
      }
    };

    pp$5.shouldParseAsyncArrow = function() {
      return !this.canInsertSemicolon() && this.eat(types$1.arrow)
    };

    pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)
    };

    pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
      var optionalSupported = this.options.ecmaVersion >= 11;
      var optional = optionalSupported && this.eat(types$1.questionDot);
      if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

      var computed = this.eat(types$1.bracketL);
      if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        if (computed) {
          node.property = this.parseExpression();
          this.expect(types$1.bracketR);
        } else if (this.type === types$1.privateId && base.type !== "Super") {
          node.property = this.parsePrivateIdent();
        } else {
          node.property = this.parseIdent(this.options.allowReserved !== "never");
        }
        node.computed = !!computed;
        if (optionalSupported) {
          node.optional = optional;
        }
        base = this.finishNode(node, "MemberExpression");
      } else if (!noCalls && this.eat(types$1.parenL)) {
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (this.awaitIdentPos > 0)
            { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit)
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.callee = base;
        node$1.arguments = exprList;
        if (optionalSupported) {
          node$1.optional = optional;
        }
        base = this.finishNode(node$1, "CallExpression");
      } else if (this.type === types$1.backQuote) {
        if (optional || optionalChained) {
          this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        }
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base;
        node$2.quasi = this.parseTemplate({isTagged: true});
        base = this.finishNode(node$2, "TaggedTemplateExpression");
      }
      return base
    };

    // Parse an atomic expression — either a single token that is an
    // expression, an expression started by a keyword like `function` or
    // `new`, or an expression wrapped in punctuation like `()`, `[]`,
    // or `{}`.

    pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
      // If a division operator appears in an expression position, the
      // tokenizer got confused, and we force it to read a regexp instead.
      if (this.type === types$1.slash) { this.readRegexp(); }

      var node, canBeArrow = this.potentialArrowAt === this.start;
      switch (this.type) {
      case types$1._super:
        if (!this.allowSuper)
          { this.raise(this.start, "'super' keyword outside a method"); }
        node = this.startNode();
        this.next();
        if (this.type === types$1.parenL && !this.allowDirectSuper)
          { this.raise(node.start, "super() call outside constructor of a subclass"); }
        // The `super` keyword can appear at below:
        // SuperProperty:
        //     super [ Expression ]
        //     super . IdentifierName
        // SuperCall:
        //     super ( Arguments )
        if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
          { this.unexpected(); }
        return this.finishNode(node, "Super")

      case types$1._this:
        node = this.startNode();
        this.next();
        return this.finishNode(node, "ThisExpression")

      case types$1.name:
        var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
        var id = this.parseIdent(false);
        if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
          this.overrideContext(types.f_expr);
          return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
        }
        if (canBeArrow && !this.canInsertSemicolon()) {
          if (this.eat(types$1.arrow))
            { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
          if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
              (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
            id = this.parseIdent(false);
            if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
              { this.unexpected(); }
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
          }
        }
        return id

      case types$1.regexp:
        var value = this.value;
        node = this.parseLiteral(value.value);
        node.regex = {pattern: value.pattern, flags: value.flags};
        return node

      case types$1.num: case types$1.string:
        return this.parseLiteral(this.value)

      case types$1._null: case types$1._true: case types$1._false:
        node = this.startNode();
        node.value = this.type === types$1._null ? null : this.type === types$1._true;
        node.raw = this.type.keyword;
        this.next();
        return this.finishNode(node, "Literal")

      case types$1.parenL:
        var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
        if (refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
            { refDestructuringErrors.parenthesizedAssign = start; }
          if (refDestructuringErrors.parenthesizedBind < 0)
            { refDestructuringErrors.parenthesizedBind = start; }
        }
        return expr

      case types$1.bracketL:
        node = this.startNode();
        this.next();
        node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
        return this.finishNode(node, "ArrayExpression")

      case types$1.braceL:
        this.overrideContext(types.b_expr);
        return this.parseObj(false, refDestructuringErrors)

      case types$1._function:
        node = this.startNode();
        this.next();
        return this.parseFunction(node, 0)

      case types$1._class:
        return this.parseClass(this.startNode(), false)

      case types$1._new:
        return this.parseNew()

      case types$1.backQuote:
        return this.parseTemplate()

      case types$1._import:
        if (this.options.ecmaVersion >= 11) {
          return this.parseExprImport(forNew)
        } else {
          return this.unexpected()
        }

      default:
        return this.parseExprAtomDefault()
      }
    };

    pp$5.parseExprAtomDefault = function() {
      this.unexpected();
    };

    pp$5.parseExprImport = function(forNew) {
      var node = this.startNode();

      // Consume `import` as an identifier for `import.meta`.
      // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
      if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
      this.next();

      if (this.type === types$1.parenL && !forNew) {
        return this.parseDynamicImport(node)
      } else if (this.type === types$1.dot) {
        var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
        meta.name = "import";
        node.meta = this.finishNode(meta, "Identifier");
        return this.parseImportMeta(node)
      } else {
        this.unexpected();
      }
    };

    pp$5.parseDynamicImport = function(node) {
      this.next(); // skip `(`

      // Parse node.source.
      node.source = this.parseMaybeAssign();

      if (this.options.ecmaVersion >= 16) {
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            node.options = this.parseMaybeAssign();
            if (!this.eat(types$1.parenR)) {
              this.expect(types$1.comma);
              if (!this.afterTrailingComma(types$1.parenR)) {
                this.unexpected();
              }
            }
          } else {
            node.options = null;
          }
        } else {
          node.options = null;
        }
      } else {
        // Verify ending.
        if (!this.eat(types$1.parenR)) {
          var errorPos = this.start;
          if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
      }

      return this.finishNode(node, "ImportExpression")
    };

    pp$5.parseImportMeta = function(node) {
      this.next(); // skip `.`

      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);

      if (node.property.name !== "meta")
        { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
      if (containsEsc)
        { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
      if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
        { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

      return this.finishNode(node, "MetaProperty")
    };

    pp$5.parseLiteral = function(value) {
      var node = this.startNode();
      node.value = value;
      node.raw = this.input.slice(this.start, this.end);
      if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
      this.next();
      return this.finishNode(node, "Literal")
    };

    pp$5.parseParenExpression = function() {
      this.expect(types$1.parenL);
      var val = this.parseExpression();
      this.expect(types$1.parenR);
      return val
    };

    pp$5.shouldParseArrow = function(exprList) {
      return !this.canInsertSemicolon()
    };

    pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();

        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        // Do not save awaitIdentPos to allow checking awaits nested in parameters
        while (this.type !== types$1.parenR) {
          first ? first = false : this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
            lastIsComma = true;
            break
          } else if (this.type === types$1.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRestBinding()));
            if (this.type === types$1.comma) {
              this.raiseRecoverable(
                this.start,
                "Comma is not permitted after the rest element"
              );
            }
            break
          } else {
            exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          }
        }
        var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
        this.expect(types$1.parenR);

        if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList, forInit)
        }

        if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
        if (spreadStart) { this.unexpected(spreadStart); }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;

        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }

      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression")
      } else {
        return val
      }
    };

    pp$5.parseParenItem = function(item) {
      return item
    };

    pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
    };

    // New's precedence is slightly tricky. It must allow its argument to
    // be a `[]` or dot subscript expression, but not a call — at least,
    // not without wrapping it in parentheses. Thus, it uses the noCalls
    // argument to parseSubscripts to prevent it from consuming the
    // argument list.

    var empty = [];

    pp$5.parseNew = function() {
      if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
      var node = this.startNode();
      this.next();
      if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
        var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
        meta.name = "new";
        node.meta = this.finishNode(meta, "Identifier");
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "target")
          { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
        if (containsEsc)
          { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
        if (!this.allowNewDotTarget)
          { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
        return this.finishNode(node, "MetaProperty")
      }
      var startPos = this.start, startLoc = this.startLoc;
      node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
      if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
      else { node.arguments = empty; }
      return this.finishNode(node, "NewExpression")
    };

    // Parse template expression.

    pp$5.parseTemplateElement = function(ref) {
      var isTagged = ref.isTagged;

      var elem = this.startNode();
      if (this.type === types$1.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value.replace(/\r\n?/g, "\n"),
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types$1.backQuote;
      return this.finishNode(elem, "TemplateElement")
    };

    pp$5.parseTemplate = function(ref) {
      if ( ref === void 0 ) ref = {};
      var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement({isTagged: isTagged});
      node.quasis = [curElt];
      while (!curElt.tail) {
        if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
        this.expect(types$1.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types$1.braceR);
        node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
      }
      this.next();
      return this.finishNode(node, "TemplateLiteral")
    };

    pp$5.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
        (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
        !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
    };

    // Parse an object literal or binding pattern.

    pp$5.parseObj = function(isPattern, refDestructuringErrors) {
      var node = this.startNode(), first = true, propHash = {};
      node.properties = [];
      this.next();
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
        } else { first = false; }

        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
        node.properties.push(prop);
      }
      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
    };

    pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
      var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
      if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
        if (isPattern) {
          prop.argument = this.parseIdent(false);
          if (this.type === types$1.comma) {
            this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
          }
          return this.finishNode(prop, "RestElement")
        }
        // Parse argument.
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        // To disallow trailing comma via `this.toAssignable()`.
        if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
        // Finish
        return this.finishNode(prop, "SpreadElement")
      }
      if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
          startPos = this.start;
          startLoc = this.startLoc;
        }
        if (!isPattern)
          { isGenerator = this.eat(types$1.star); }
      }
      var containsEsc = this.containsEsc;
      this.parsePropertyName(prop);
      if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
        this.parsePropertyName(prop);
      } else {
        isAsync = false;
      }
      this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
      return this.finishNode(prop, "Property")
    };

    pp$5.parseGetterSetter = function(prop) {
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get")
          { this.raiseRecoverable(start, "getter should have no params"); }
        else
          { this.raiseRecoverable(start, "setter should have exactly one param"); }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
          { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
      }
    };

    pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
      if ((isGenerator || isAsync) && this.type === types$1.colon)
        { this.unexpected(); }

      if (this.eat(types$1.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
        if (isPattern) { this.unexpected(); }
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
      } else if (!isPattern && !containsEsc &&
                 this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
                 (prop.key.name === "get" || prop.key.name === "set") &&
                 (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
        if (isGenerator || isAsync) { this.unexpected(); }
        this.parseGetterSetter(prop);
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) { this.unexpected(); }
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos)
          { this.awaitIdentPos = startPos; }
        prop.kind = "init";
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else if (this.type === types$1.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0)
            { refDestructuringErrors.shorthandAssign = this.start; }
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else {
          prop.value = this.copyNode(prop.key);
        }
        prop.shorthand = true;
      } else { this.unexpected(); }
    };

    pp$5.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types$1.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types$1.bracketR);
          return prop.key
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
    };

    // Initialize empty function node.

    pp$5.initFunction = function(node) {
      node.id = null;
      if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
      if (this.options.ecmaVersion >= 8) { node.async = false; }
    };

    // Parse object or class method.

    pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
      var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

      this.initFunction(node);
      if (this.options.ecmaVersion >= 6)
        { node.generator = isGenerator; }
      if (this.options.ecmaVersion >= 8)
        { node.async = !!isAsync; }

      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

      this.expect(types$1.parenL);
      node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node, false, true, false);

      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "FunctionExpression")
    };

    // Parse arrow function expression with given parameters.

    pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

      this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
      this.initFunction(node);
      if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;

      node.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node, true, false, forInit);

      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "ArrowFunctionExpression")
    };

    // Parse function body and check parameters.

    pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
      var isExpression = isArrowFunction && this.type !== types$1.braceL;
      var oldStrict = this.strict, useStrict = false;

      if (isExpression) {
        node.body = this.parseMaybeAssign(forInit);
        node.expression = true;
        this.checkParams(node, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          // If this is a strict mode function, verify that argument names
          // are not repeated, and it does not try to bind the words `eval`
          // or `arguments`.
          if (useStrict && nonSimple)
            { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
        }
        // Start a new scope with regard to labels and the `inFunction`
        // flag (restore them to their old value afterwards).
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) { this.strict = true; }

        // Add the params to varDeclaredNames to ensure that an error is thrown
        // if a let/const declaration in the function clashes with one of the params.
        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
        // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
        if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }
        node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
        node.expression = false;
        this.adaptDirectivePrologue(node.body.body);
        this.labels = oldLabels;
      }
      this.exitScope();
    };

    pp$5.isSimpleParamList = function(params) {
      for (var i = 0, list = params; i < list.length; i += 1)
        {
        var param = list[i];

        if (param.type !== "Identifier") { return false
      } }
      return true
    };

    // Checks function params for various disallowed patterns such as using "eval"
    // or "arguments" and duplicate parameters.

    pp$5.checkParams = function(node, allowDuplicates) {
      var nameHash = Object.create(null);
      for (var i = 0, list = node.params; i < list.length; i += 1)
        {
        var param = list[i];

        this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
      }
    };

    // Parses a comma-separated list of expressions, and returns them as
    // an array. `close` is the token type that ends the list, and
    // `allowEmpty` can be turned on to allow subsequent commas with
    // nothing in between them to be parsed as `null` (which is needed
    // for array literals).

    pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (!first) {
          this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(close)) { break }
        } else { first = false; }

        var elt = (void 0);
        if (allowEmpty && this.type === types$1.comma)
          { elt = null; }
        else if (this.type === types$1.ellipsis) {
          elt = this.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
            { refDestructuringErrors.trailingComma = this.start; }
        } else {
          elt = this.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts
    };

    pp$5.checkUnreserved = function(ref) {
      var start = ref.start;
      var end = ref.end;
      var name = ref.name;

      if (this.inGenerator && name === "yield")
        { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
      if (this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
      if (this.currentThisScope().inClassFieldInit && name === "arguments")
        { this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"); }
      if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
        { this.raise(start, ("Cannot use " + name + " in class static initialization block")); }
      if (this.keywords.test(name))
        { this.raise(start, ("Unexpected keyword '" + name + "'")); }
      if (this.options.ecmaVersion < 6 &&
        this.input.slice(start, end).indexOf("\\") !== -1) { return }
      var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re.test(name)) {
        if (!this.inAsync && name === "await")
          { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
        this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
      }
    };

    // Parse the next token as an identifier. If `liberal` is true (used
    // when parsing properties), it will also convert keywords into
    // identifiers.

    pp$5.parseIdent = function(liberal) {
      var node = this.parseIdentNode();
      this.next(!!liberal);
      this.finishNode(node, "Identifier");
      if (!liberal) {
        this.checkUnreserved(node);
        if (node.name === "await" && !this.awaitIdentPos)
          { this.awaitIdentPos = node.start; }
      }
      return node
    };

    pp$5.parseIdentNode = function() {
      var node = this.startNode();
      if (this.type === types$1.name) {
        node.name = this.value;
      } else if (this.type.keyword) {
        node.name = this.type.keyword;

        // To fix https://github.com/acornjs/acorn/issues/575
        // `class` and `function` keywords push new context into this.context.
        // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
        // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
        if ((node.name === "class" || node.name === "function") &&
          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
          this.context.pop();
        }
        this.type = types$1.name;
      } else {
        this.unexpected();
      }
      return node
    };

    pp$5.parsePrivateIdent = function() {
      var node = this.startNode();
      if (this.type === types$1.privateId) {
        node.name = this.value;
      } else {
        this.unexpected();
      }
      this.next();
      this.finishNode(node, "PrivateIdentifier");

      // For validating existence
      if (this.options.checkPrivateFields) {
        if (this.privateNameStack.length === 0) {
          this.raise(node.start, ("Private field '#" + (node.name) + "' must be declared in an enclosing class"));
        } else {
          this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
        }
      }

      return node
    };

    // Parses yield expression inside generator.

    pp$5.parseYield = function(forInit) {
      if (!this.yieldPos) { this.yieldPos = this.start; }

      var node = this.startNode();
      this.next();
      if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types$1.star);
        node.argument = this.parseMaybeAssign(forInit);
      }
      return this.finishNode(node, "YieldExpression")
    };

    pp$5.parseAwait = function(forInit) {
      if (!this.awaitPos) { this.awaitPos = this.start; }

      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeUnary(null, true, false, forInit);
      return this.finishNode(node, "AwaitExpression")
    };

    var pp$4 = Parser.prototype;

    // This function is used to raise exceptions on parse errors. It
    // takes an offset integer (into the current `input`) to indicate
    // the location of the error, attaches the position to the end
    // of the error message, and then raises a `SyntaxError` with that
    // message.

    pp$4.raise = function(pos, message) {
      var loc = getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
      throw err
    };

    pp$4.raiseRecoverable = pp$4.raise;

    pp$4.curPosition = function() {
      if (this.options.locations) {
        return new Position(this.curLine, this.pos - this.lineStart)
      }
    };

    var pp$3 = Parser.prototype;

    var Scope = function Scope(flags) {
      this.flags = flags;
      // A list of var-declared names in the current lexical scope
      this.var = [];
      // A list of lexically-declared names in the current lexical scope
      this.lexical = [];
      // A list of lexically-declared FunctionDeclaration names in the current lexical scope
      this.functions = [];
      // A switch to disallow the identifier reference 'arguments'
      this.inClassFieldInit = false;
    };

    // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

    pp$3.enterScope = function(flags) {
      this.scopeStack.push(new Scope(flags));
    };

    pp$3.exitScope = function() {
      this.scopeStack.pop();
    };

    // The spec says:
    // > At the top level of a function, or script, function declarations are
    // > treated like var declarations rather than like lexical declarations.
    pp$3.treatFunctionsAsVarInScope = function(scope) {
      return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
    };

    pp$3.declareName = function(name, bindingType, pos) {
      var redeclared = false;
      if (bindingType === BIND_LEXICAL) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
        scope.lexical.push(name);
        if (this.inModule && (scope.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
      } else if (bindingType === BIND_SIMPLE_CATCH) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name);
      } else if (bindingType === BIND_FUNCTION) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar)
          { redeclared = scope$2.lexical.indexOf(name) > -1; }
        else
          { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
        scope$2.functions.push(name);
      } else {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          var scope$3 = this.scopeStack[i];
          if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
              !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
            redeclared = true;
            break
          }
          scope$3.var.push(name);
          if (this.inModule && (scope$3.flags & SCOPE_TOP))
            { delete this.undefinedExports[name]; }
          if (scope$3.flags & SCOPE_VAR) { break }
        }
      }
      if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
    };

    pp$3.checkLocalExport = function(id) {
      // scope.functions must be empty as Module code is always strict.
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
          this.scopeStack[0].var.indexOf(id.name) === -1) {
        this.undefinedExports[id.name] = id;
      }
    };

    pp$3.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1]
    };

    pp$3.currentVarScope = function() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR) { return scope }
      }
    };

    // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
    pp$3.currentThisScope = function() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
      }
    };

    var Node = function Node(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser.options.locations)
        { this.loc = new SourceLocation(parser, loc); }
      if (parser.options.directSourceFile)
        { this.sourceFile = parser.options.directSourceFile; }
      if (parser.options.ranges)
        { this.range = [pos, 0]; }
    };

    // Start an AST node, attaching a start offset.

    var pp$2 = Parser.prototype;

    pp$2.startNode = function() {
      return new Node(this, this.start, this.startLoc)
    };

    pp$2.startNodeAt = function(pos, loc) {
      return new Node(this, pos, loc)
    };

    // Finish an AST node, adding `type` and `end` properties.

    function finishNodeAt(node, type, pos, loc) {
      node.type = type;
      node.end = pos;
      if (this.options.locations)
        { node.loc.end = loc; }
      if (this.options.ranges)
        { node.range[1] = pos; }
      return node
    }

    pp$2.finishNode = function(node, type) {
      return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
    };

    // Finish node at given position

    pp$2.finishNodeAt = function(node, type, pos, loc) {
      return finishNodeAt.call(this, node, type, pos, loc)
    };

    pp$2.copyNode = function(node) {
      var newNode = new Node(this, node.start, this.startLoc);
      for (var prop in node) { newNode[prop] = node[prop]; }
      return newNode
    };

    // This file was generated by "bin/generate-unicode-script-values.js". Do not modify manually!
    var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";

    // This file contains Unicode properties extracted from the ECMAScript specification.
    // The lists are extracted like so:
    // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

    // #table-binary-unicode-properties
    var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    var ecma11BinaryProperties = ecma10BinaryProperties;
    var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
    var ecma13BinaryProperties = ecma12BinaryProperties;
    var ecma14BinaryProperties = ecma13BinaryProperties;

    var unicodeBinaryProperties = {
      9: ecma9BinaryProperties,
      10: ecma10BinaryProperties,
      11: ecma11BinaryProperties,
      12: ecma12BinaryProperties,
      13: ecma13BinaryProperties,
      14: ecma14BinaryProperties
    };

    // #table-binary-unicode-properties-of-strings
    var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";

    var unicodeBinaryPropertiesOfStrings = {
      9: "",
      10: "",
      11: "",
      12: "",
      13: "",
      14: ecma14BinaryPropertiesOfStrings
    };

    // #table-unicode-general-category-values
    var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

    // #table-unicode-script-values
    var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
    var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
    var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;

    var unicodeScriptValues = {
      9: ecma9ScriptValues,
      10: ecma10ScriptValues,
      11: ecma11ScriptValues,
      12: ecma12ScriptValues,
      13: ecma13ScriptValues,
      14: ecma14ScriptValues
    };

    var data = {};
    function buildUnicodeData(ecmaVersion) {
      var d = data[ecmaVersion] = {
        binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
        binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
        nonBinary: {
          General_Category: wordsRegexp(unicodeGeneralCategoryValues),
          Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
        }
      };
      d.nonBinary.Script_Extensions = d.nonBinary.Script;

      d.nonBinary.gc = d.nonBinary.General_Category;
      d.nonBinary.sc = d.nonBinary.Script;
      d.nonBinary.scx = d.nonBinary.Script_Extensions;
    }

    for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
      var ecmaVersion = list[i];

      buildUnicodeData(ecmaVersion);
    }

    var pp$1 = Parser.prototype;

    // Track disjunction structure to determine whether a duplicate
    // capture group name is allowed because it is in a separate branch.
    var BranchID = function BranchID(parent, base) {
      // Parent disjunction branch
      this.parent = parent;
      // Identifies this set of sibling branches
      this.base = base || this;
    };

    BranchID.prototype.separatedFrom = function separatedFrom (alt) {
      // A branch is separate from another branch if they or any of
      // their parents are siblings in a given disjunction
      for (var self = this; self; self = self.parent) {
        for (var other = alt; other; other = other.parent) {
          if (self.base === other.base && self !== other) { return true }
        }
      }
      return false
    };

    BranchID.prototype.sibling = function sibling () {
      return new BranchID(this.parent, this.base)
    };

    var RegExpValidationState = function RegExpValidationState(parser) {
      this.parser = parser;
      this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
      this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
      this.source = "";
      this.flags = "";
      this.start = 0;
      this.switchU = false;
      this.switchV = false;
      this.switchN = false;
      this.pos = 0;
      this.lastIntValue = 0;
      this.lastStringValue = "";
      this.lastAssertionIsQuantifiable = false;
      this.numCapturingParens = 0;
      this.maxBackReference = 0;
      this.groupNames = Object.create(null);
      this.backReferenceNames = [];
      this.branchID = null;
    };

    RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
      var unicodeSets = flags.indexOf("v") !== -1;
      var unicode = flags.indexOf("u") !== -1;
      this.start = start | 0;
      this.source = pattern + "";
      this.flags = flags;
      if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
        this.switchU = true;
        this.switchV = true;
        this.switchN = true;
      } else {
        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
        this.switchV = false;
        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
      }
    };

    RegExpValidationState.prototype.raise = function raise (message) {
      this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
    };

    // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
    // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
    RegExpValidationState.prototype.at = function at (i, forceU) {
        if ( forceU === void 0 ) forceU = false;

      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return -1
      }
      var c = s.charCodeAt(i);
      if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
        return c
      }
      var next = s.charCodeAt(i + 1);
      return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
    };

    RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
        if ( forceU === void 0 ) forceU = false;

      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return l
      }
      var c = s.charCodeAt(i), next;
      if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
          (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
        return i + 1
      }
      return i + 2
    };

    RegExpValidationState.prototype.current = function current (forceU) {
        if ( forceU === void 0 ) forceU = false;

      return this.at(this.pos, forceU)
    };

    RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
        if ( forceU === void 0 ) forceU = false;

      return this.at(this.nextIndex(this.pos, forceU), forceU)
    };

    RegExpValidationState.prototype.advance = function advance (forceU) {
        if ( forceU === void 0 ) forceU = false;

      this.pos = this.nextIndex(this.pos, forceU);
    };

    RegExpValidationState.prototype.eat = function eat (ch, forceU) {
        if ( forceU === void 0 ) forceU = false;

      if (this.current(forceU) === ch) {
        this.advance(forceU);
        return true
      }
      return false
    };

    RegExpValidationState.prototype.eatChars = function eatChars (chs, forceU) {
        if ( forceU === void 0 ) forceU = false;

      var pos = this.pos;
      for (var i = 0, list = chs; i < list.length; i += 1) {
        var ch = list[i];

          var current = this.at(pos, forceU);
        if (current === -1 || current !== ch) {
          return false
        }
        pos = this.nextIndex(pos, forceU);
      }
      this.pos = pos;
      return true
    };

    /**
     * Validate the flags part of a given RegExpLiteral.
     *
     * @param {RegExpValidationState} state The state to validate RegExp.
     * @returns {void}
     */
    pp$1.validateRegExpFlags = function(state) {
      var validFlags = state.validFlags;
      var flags = state.flags;

      var u = false;
      var v = false;

      for (var i = 0; i < flags.length; i++) {
        var flag = flags.charAt(i);
        if (validFlags.indexOf(flag) === -1) {
          this.raise(state.start, "Invalid regular expression flag");
        }
        if (flags.indexOf(flag, i + 1) > -1) {
          this.raise(state.start, "Duplicate regular expression flag");
        }
        if (flag === "u") { u = true; }
        if (flag === "v") { v = true; }
      }
      if (this.options.ecmaVersion >= 15 && u && v) {
        this.raise(state.start, "Invalid regular expression flag");
      }
    };

    function hasProp(obj) {
      for (var _ in obj) { return true }
      return false
    }

    /**
     * Validate the pattern part of a given RegExpLiteral.
     *
     * @param {RegExpValidationState} state The state to validate RegExp.
     * @returns {void}
     */
    pp$1.validateRegExpPattern = function(state) {
      this.regexp_pattern(state);

      // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
      // parsing contains a |GroupName|, reparse with the goal symbol
      // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
      // exception if _P_ did not conform to the grammar, if any elements of _P_
      // were not matched by the parse, or if any Early Error conditions exist.
      if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
        state.switchN = true;
        this.regexp_pattern(state);
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
    pp$1.regexp_pattern = function(state) {
      state.pos = 0;
      state.lastIntValue = 0;
      state.lastStringValue = "";
      state.lastAssertionIsQuantifiable = false;
      state.numCapturingParens = 0;
      state.maxBackReference = 0;
      state.groupNames = Object.create(null);
      state.backReferenceNames.length = 0;
      state.branchID = null;

      this.regexp_disjunction(state);

      if (state.pos !== state.source.length) {
        // Make the same messages as V8.
        if (state.eat(0x29 /* ) */)) {
          state.raise("Unmatched ')'");
        }
        if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
          state.raise("Lone quantifier brackets");
        }
      }
      if (state.maxBackReference > state.numCapturingParens) {
        state.raise("Invalid escape");
      }
      for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
        var name = list[i];

        if (!state.groupNames[name]) {
          state.raise("Invalid named capture referenced");
        }
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
    pp$1.regexp_disjunction = function(state) {
      var trackDisjunction = this.options.ecmaVersion >= 16;
      if (trackDisjunction) { state.branchID = new BranchID(state.branchID, null); }
      this.regexp_alternative(state);
      while (state.eat(0x7C /* | */)) {
        if (trackDisjunction) { state.branchID = state.branchID.sibling(); }
        this.regexp_alternative(state);
      }
      if (trackDisjunction) { state.branchID = state.branchID.parent; }

      // Make the same message as V8.
      if (this.regexp_eatQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      if (state.eat(0x7B /* { */)) {
        state.raise("Lone quantifier brackets");
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
    pp$1.regexp_alternative = function(state) {
      while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
    pp$1.regexp_eatTerm = function(state) {
      if (this.regexp_eatAssertion(state)) {
        // Handle `QuantifiableAssertion Quantifier` alternative.
        // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
        // is a QuantifiableAssertion.
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
          // Make the same message as V8.
          if (state.switchU) {
            state.raise("Invalid quantifier");
          }
        }
        return true
      }

      if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true
      }

      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
    pp$1.regexp_eatAssertion = function(state) {
      var start = state.pos;
      state.lastAssertionIsQuantifiable = false;

      // ^, $
      if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
        return true
      }

      // \b \B
      if (state.eat(0x5C /* \ */)) {
        if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
          return true
        }
        state.pos = start;
      }

      // Lookahead / Lookbehind
      if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) {
          lookbehind = state.eat(0x3C /* < */);
        }
        if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
          this.regexp_disjunction(state);
          if (!state.eat(0x29 /* ) */)) {
            state.raise("Unterminated group");
          }
          state.lastAssertionIsQuantifiable = !lookbehind;
          return true
        }
      }

      state.pos = start;
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
    pp$1.regexp_eatQuantifier = function(state, noError) {
      if ( noError === void 0 ) noError = false;

      if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(0x3F /* ? */);
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
    pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
      return (
        state.eat(0x2A /* * */) ||
        state.eat(0x2B /* + */) ||
        state.eat(0x3F /* ? */) ||
        this.regexp_eatBracedQuantifier(state, noError)
      )
    };
    pp$1.regexp_eatBracedQuantifier = function(state, noError) {
      var start = state.pos;
      if (state.eat(0x7B /* { */)) {
        var min = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
          min = state.lastIntValue;
          if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
            max = state.lastIntValue;
          }
          if (state.eat(0x7D /* } */)) {
            // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
            if (max !== -1 && max < min && !noError) {
              state.raise("numbers out of order in {} quantifier");
            }
            return true
          }
        }
        if (state.switchU && !noError) {
          state.raise("Incomplete quantifier");
        }
        state.pos = start;
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
    pp$1.regexp_eatAtom = function(state) {
      return (
        this.regexp_eatPatternCharacters(state) ||
        state.eat(0x2E /* . */) ||
        this.regexp_eatReverseSolidusAtomEscape(state) ||
        this.regexp_eatCharacterClass(state) ||
        this.regexp_eatUncapturingGroup(state) ||
        this.regexp_eatCapturingGroup(state)
      )
    };
    pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
      var start = state.pos;
      if (state.eat(0x5C /* \ */)) {
        if (this.regexp_eatAtomEscape(state)) {
          return true
        }
        state.pos = start;
      }
      return false
    };
    pp$1.regexp_eatUncapturingGroup = function(state) {
      var start = state.pos;
      if (state.eat(0x28 /* ( */)) {
        if (state.eat(0x3F /* ? */)) {
          if (this.options.ecmaVersion >= 16) {
            var addModifiers = this.regexp_eatModifiers(state);
            var hasHyphen = state.eat(0x2D /* - */);
            if (addModifiers || hasHyphen) {
              for (var i = 0; i < addModifiers.length; i++) {
                var modifier = addModifiers.charAt(i);
                if (addModifiers.indexOf(modifier, i + 1) > -1) {
                  state.raise("Duplicate regular expression modifiers");
                }
              }
              if (hasHyphen) {
                var removeModifiers = this.regexp_eatModifiers(state);
                if (!addModifiers && !removeModifiers && state.current() === 0x3A /* : */) {
                  state.raise("Invalid regular expression modifiers");
                }
                for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
                  var modifier$1 = removeModifiers.charAt(i$1);
                  if (
                    removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 ||
                    addModifiers.indexOf(modifier$1) > -1
                  ) {
                    state.raise("Duplicate regular expression modifiers");
                  }
                }
              }
            }
          }
          if (state.eat(0x3A /* : */)) {
            this.regexp_disjunction(state);
            if (state.eat(0x29 /* ) */)) {
              return true
            }
            state.raise("Unterminated group");
          }
        }
        state.pos = start;
      }
      return false
    };
    pp$1.regexp_eatCapturingGroup = function(state) {
      if (state.eat(0x28 /* ( */)) {
        if (this.options.ecmaVersion >= 9) {
          this.regexp_groupSpecifier(state);
        } else if (state.current() === 0x3F /* ? */) {
          state.raise("Invalid group");
        }
        this.regexp_disjunction(state);
        if (state.eat(0x29 /* ) */)) {
          state.numCapturingParens += 1;
          return true
        }
        state.raise("Unterminated group");
      }
      return false
    };
    // RegularExpressionModifiers ::
    //   [empty]
    //   RegularExpressionModifiers RegularExpressionModifier
    pp$1.regexp_eatModifiers = function(state) {
      var modifiers = "";
      var ch = 0;
      while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
        modifiers += codePointToString(ch);
        state.advance();
      }
      return modifiers
    };
    // RegularExpressionModifier :: one of
    //   `i` `m` `s`
    function isRegularExpressionModifier(ch) {
      return ch === 0x69 /* i */ || ch === 0x6d /* m */ || ch === 0x73 /* s */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
    pp$1.regexp_eatExtendedAtom = function(state) {
      return (
        state.eat(0x2E /* . */) ||
        this.regexp_eatReverseSolidusAtomEscape(state) ||
        this.regexp_eatCharacterClass(state) ||
        this.regexp_eatUncapturingGroup(state) ||
        this.regexp_eatCapturingGroup(state) ||
        this.regexp_eatInvalidBracedQuantifier(state) ||
        this.regexp_eatExtendedPatternCharacter(state)
      )
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
    pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
      if (this.regexp_eatBracedQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
    pp$1.regexp_eatSyntaxCharacter = function(state) {
      var ch = state.current();
      if (isSyntaxCharacter(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }
      return false
    };
    function isSyntaxCharacter(ch) {
      return (
        ch === 0x24 /* $ */ ||
        ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
        ch === 0x2E /* . */ ||
        ch === 0x3F /* ? */ ||
        ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
        ch >= 0x7B /* { */ && ch <= 0x7D /* } */
      )
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
    // But eat eager.
    pp$1.regexp_eatPatternCharacters = function(state) {
      var start = state.pos;
      var ch = 0;
      while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
        state.advance();
      }
      return state.pos !== start
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
    pp$1.regexp_eatExtendedPatternCharacter = function(state) {
      var ch = state.current();
      if (
        ch !== -1 &&
        ch !== 0x24 /* $ */ &&
        !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
        ch !== 0x2E /* . */ &&
        ch !== 0x3F /* ? */ &&
        ch !== 0x5B /* [ */ &&
        ch !== 0x5E /* ^ */ &&
        ch !== 0x7C /* | */
      ) {
        state.advance();
        return true
      }
      return false
    };

    // GroupSpecifier ::
    //   [empty]
    //   `?` GroupName
    pp$1.regexp_groupSpecifier = function(state) {
      if (state.eat(0x3F /* ? */)) {
        if (!this.regexp_eatGroupName(state)) { state.raise("Invalid group"); }
        var trackDisjunction = this.options.ecmaVersion >= 16;
        var known = state.groupNames[state.lastStringValue];
        if (known) {
          if (trackDisjunction) {
            for (var i = 0, list = known; i < list.length; i += 1) {
              var altID = list[i];

              if (!altID.separatedFrom(state.branchID))
                { state.raise("Duplicate capture group name"); }
            }
          } else {
            state.raise("Duplicate capture group name");
          }
        }
        if (trackDisjunction) {
          (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
        } else {
          state.groupNames[state.lastStringValue] = true;
        }
      }
    };

    // GroupName ::
    //   `<` RegExpIdentifierName `>`
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$1.regexp_eatGroupName = function(state) {
      state.lastStringValue = "";
      if (state.eat(0x3C /* < */)) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
          return true
        }
        state.raise("Invalid capture group name");
      }
      return false
    };

    // RegExpIdentifierName ::
    //   RegExpIdentifierStart
    //   RegExpIdentifierName RegExpIdentifierPart
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$1.regexp_eatRegExpIdentifierName = function(state) {
      state.lastStringValue = "";
      if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
        }
        return true
      }
      return false
    };

    // RegExpIdentifierStart ::
    //   UnicodeIDStart
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[+U]
    pp$1.regexp_eatRegExpIdentifierStart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);

      if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierStart(ch)) {
        state.lastIntValue = ch;
        return true
      }

      state.pos = start;
      return false
    };
    function isRegExpIdentifierStart(ch) {
      return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
    }

    // RegExpIdentifierPart ::
    //   UnicodeIDContinue
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[+U]
    //   <ZWNJ>
    //   <ZWJ>
    pp$1.regexp_eatRegExpIdentifierPart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);

      if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierPart(ch)) {
        state.lastIntValue = ch;
        return true
      }

      state.pos = start;
      return false
    };
    function isRegExpIdentifierPart(ch) {
      return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
    pp$1.regexp_eatAtomEscape = function(state) {
      if (
        this.regexp_eatBackReference(state) ||
        this.regexp_eatCharacterClassEscape(state) ||
        this.regexp_eatCharacterEscape(state) ||
        (state.switchN && this.regexp_eatKGroupName(state))
      ) {
        return true
      }
      if (state.switchU) {
        // Make the same message as V8.
        if (state.current() === 0x63 /* c */) {
          state.raise("Invalid unicode escape");
        }
        state.raise("Invalid escape");
      }
      return false
    };
    pp$1.regexp_eatBackReference = function(state) {
      var start = state.pos;
      if (this.regexp_eatDecimalEscape(state)) {
        var n = state.lastIntValue;
        if (state.switchU) {
          // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
          if (n > state.maxBackReference) {
            state.maxBackReference = n;
          }
          return true
        }
        if (n <= state.numCapturingParens) {
          return true
        }
        state.pos = start;
      }
      return false
    };
    pp$1.regexp_eatKGroupName = function(state) {
      if (state.eat(0x6B /* k */)) {
        if (this.regexp_eatGroupName(state)) {
          state.backReferenceNames.push(state.lastStringValue);
          return true
        }
        state.raise("Invalid named reference");
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
    pp$1.regexp_eatCharacterEscape = function(state) {
      return (
        this.regexp_eatControlEscape(state) ||
        this.regexp_eatCControlLetter(state) ||
        this.regexp_eatZero(state) ||
        this.regexp_eatHexEscapeSequence(state) ||
        this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
        (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
        this.regexp_eatIdentityEscape(state)
      )
    };
    pp$1.regexp_eatCControlLetter = function(state) {
      var start = state.pos;
      if (state.eat(0x63 /* c */)) {
        if (this.regexp_eatControlLetter(state)) {
          return true
        }
        state.pos = start;
      }
      return false
    };
    pp$1.regexp_eatZero = function(state) {
      if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
    pp$1.regexp_eatControlEscape = function(state) {
      var ch = state.current();
      if (ch === 0x74 /* t */) {
        state.lastIntValue = 0x09; /* \t */
        state.advance();
        return true
      }
      if (ch === 0x6E /* n */) {
        state.lastIntValue = 0x0A; /* \n */
        state.advance();
        return true
      }
      if (ch === 0x76 /* v */) {
        state.lastIntValue = 0x0B; /* \v */
        state.advance();
        return true
      }
      if (ch === 0x66 /* f */) {
        state.lastIntValue = 0x0C; /* \f */
        state.advance();
        return true
      }
      if (ch === 0x72 /* r */) {
        state.lastIntValue = 0x0D; /* \r */
        state.advance();
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
    pp$1.regexp_eatControlLetter = function(state) {
      var ch = state.current();
      if (isControlLetter(ch)) {
        state.lastIntValue = ch % 0x20;
        state.advance();
        return true
      }
      return false
    };
    function isControlLetter(ch) {
      return (
        (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
        (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
      )
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
    pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
      if ( forceU === void 0 ) forceU = false;

      var start = state.pos;
      var switchU = forceU || state.switchU;

      if (state.eat(0x75 /* u */)) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
          var lead = state.lastIntValue;
          if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
            var leadSurrogateEnd = state.pos;
            if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
              var trail = state.lastIntValue;
              if (trail >= 0xDC00 && trail <= 0xDFFF) {
                state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
                return true
              }
            }
            state.pos = leadSurrogateEnd;
            state.lastIntValue = lead;
          }
          return true
        }
        if (
          switchU &&
          state.eat(0x7B /* { */) &&
          this.regexp_eatHexDigits(state) &&
          state.eat(0x7D /* } */) &&
          isValidUnicode(state.lastIntValue)
        ) {
          return true
        }
        if (switchU) {
          state.raise("Invalid unicode escape");
        }
        state.pos = start;
      }

      return false
    };
    function isValidUnicode(ch) {
      return ch >= 0 && ch <= 0x10FFFF
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
    pp$1.regexp_eatIdentityEscape = function(state) {
      if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) {
          return true
        }
        if (state.eat(0x2F /* / */)) {
          state.lastIntValue = 0x2F; /* / */
          return true
        }
        return false
      }

      var ch = state.current();
      if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }

      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
    pp$1.regexp_eatDecimalEscape = function(state) {
      state.lastIntValue = 0;
      var ch = state.current();
      if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
        do {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
          state.advance();
        } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
        return true
      }
      return false
    };

    // Return values used by character set parsing methods, needed to
    // forbid negation of sets that can match strings.
    var CharSetNone = 0; // Nothing parsed
    var CharSetOk = 1; // Construct parsed, cannot contain strings
    var CharSetString = 2; // Construct parsed, can contain strings

    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
    pp$1.regexp_eatCharacterClassEscape = function(state) {
      var ch = state.current();

      if (isCharacterClassEscape(ch)) {
        state.lastIntValue = -1;
        state.advance();
        return CharSetOk
      }

      var negate = false;
      if (
        state.switchU &&
        this.options.ecmaVersion >= 9 &&
        ((negate = ch === 0x50 /* P */) || ch === 0x70 /* p */)
      ) {
        state.lastIntValue = -1;
        state.advance();
        var result;
        if (
          state.eat(0x7B /* { */) &&
          (result = this.regexp_eatUnicodePropertyValueExpression(state)) &&
          state.eat(0x7D /* } */)
        ) {
          if (negate && result === CharSetString) { state.raise("Invalid property name"); }
          return result
        }
        state.raise("Invalid property name");
      }

      return CharSetNone
    };

    function isCharacterClassEscape(ch) {
      return (
        ch === 0x64 /* d */ ||
        ch === 0x44 /* D */ ||
        ch === 0x73 /* s */ ||
        ch === 0x53 /* S */ ||
        ch === 0x77 /* w */ ||
        ch === 0x57 /* W */
      )
    }

    // UnicodePropertyValueExpression ::
    //   UnicodePropertyName `=` UnicodePropertyValue
    //   LoneUnicodePropertyNameOrValue
    pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
      var start = state.pos;

      // UnicodePropertyName `=` UnicodePropertyValue
      if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
        var name = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
          var value = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
          return CharSetOk
        }
      }
      state.pos = start;

      // LoneUnicodePropertyNameOrValue
      if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue)
      }
      return CharSetNone
    };

    pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
      if (!hasOwn(state.unicodeProperties.nonBinary, name))
        { state.raise("Invalid property name"); }
      if (!state.unicodeProperties.nonBinary[name].test(value))
        { state.raise("Invalid property value"); }
    };

    pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
      if (state.unicodeProperties.binary.test(nameOrValue)) { return CharSetOk }
      if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) { return CharSetString }
      state.raise("Invalid property name");
    };

    // UnicodePropertyName ::
    //   UnicodePropertyNameCharacters
    pp$1.regexp_eatUnicodePropertyName = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyNameCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== ""
    };

    function isUnicodePropertyNameCharacter(ch) {
      return isControlLetter(ch) || ch === 0x5F /* _ */
    }

    // UnicodePropertyValue ::
    //   UnicodePropertyValueCharacters
    pp$1.regexp_eatUnicodePropertyValue = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyValueCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== ""
    };
    function isUnicodePropertyValueCharacter(ch) {
      return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
    }

    // LoneUnicodePropertyNameOrValue ::
    //   UnicodePropertyValueCharacters
    pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
      return this.regexp_eatUnicodePropertyValue(state)
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
    pp$1.regexp_eatCharacterClass = function(state) {
      if (state.eat(0x5B /* [ */)) {
        var negate = state.eat(0x5E /* ^ */);
        var result = this.regexp_classContents(state);
        if (!state.eat(0x5D /* ] */))
          { state.raise("Unterminated character class"); }
        if (negate && result === CharSetString)
          { state.raise("Negated character class may contain strings"); }
        return true
      }
      return false
    };

    // https://tc39.es/ecma262/#prod-ClassContents
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
    pp$1.regexp_classContents = function(state) {
      if (state.current() === 0x5D /* ] */) { return CharSetOk }
      if (state.switchV) { return this.regexp_classSetExpression(state) }
      this.regexp_nonEmptyClassRanges(state);
      return CharSetOk
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
    pp$1.regexp_nonEmptyClassRanges = function(state) {
      while (this.regexp_eatClassAtom(state)) {
        var left = state.lastIntValue;
        if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
          var right = state.lastIntValue;
          if (state.switchU && (left === -1 || right === -1)) {
            state.raise("Invalid character class");
          }
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
        }
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
    pp$1.regexp_eatClassAtom = function(state) {
      var start = state.pos;

      if (state.eat(0x5C /* \ */)) {
        if (this.regexp_eatClassEscape(state)) {
          return true
        }
        if (state.switchU) {
          // Make the same message as V8.
          var ch$1 = state.current();
          if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
            state.raise("Invalid class escape");
          }
          state.raise("Invalid escape");
        }
        state.pos = start;
      }

      var ch = state.current();
      if (ch !== 0x5D /* ] */) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }

      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
    pp$1.regexp_eatClassEscape = function(state) {
      var start = state.pos;

      if (state.eat(0x62 /* b */)) {
        state.lastIntValue = 0x08; /* <BS> */
        return true
      }

      if (state.switchU && state.eat(0x2D /* - */)) {
        state.lastIntValue = 0x2D; /* - */
        return true
      }

      if (!state.switchU && state.eat(0x63 /* c */)) {
        if (this.regexp_eatClassControlLetter(state)) {
          return true
        }
        state.pos = start;
      }

      return (
        this.regexp_eatCharacterClassEscape(state) ||
        this.regexp_eatCharacterEscape(state)
      )
    };

    // https://tc39.es/ecma262/#prod-ClassSetExpression
    // https://tc39.es/ecma262/#prod-ClassUnion
    // https://tc39.es/ecma262/#prod-ClassIntersection
    // https://tc39.es/ecma262/#prod-ClassSubtraction
    pp$1.regexp_classSetExpression = function(state) {
      var result = CharSetOk, subResult;
      if (this.regexp_eatClassSetRange(state)) ; else if (subResult = this.regexp_eatClassSetOperand(state)) {
        if (subResult === CharSetString) { result = CharSetString; }
        // https://tc39.es/ecma262/#prod-ClassIntersection
        var start = state.pos;
        while (state.eatChars([0x26, 0x26] /* && */)) {
          if (
            state.current() !== 0x26 /* & */ &&
            (subResult = this.regexp_eatClassSetOperand(state))
          ) {
            if (subResult !== CharSetString) { result = CharSetOk; }
            continue
          }
          state.raise("Invalid character in character class");
        }
        if (start !== state.pos) { return result }
        // https://tc39.es/ecma262/#prod-ClassSubtraction
        while (state.eatChars([0x2D, 0x2D] /* -- */)) {
          if (this.regexp_eatClassSetOperand(state)) { continue }
          state.raise("Invalid character in character class");
        }
        if (start !== state.pos) { return result }
      } else {
        state.raise("Invalid character in character class");
      }
      // https://tc39.es/ecma262/#prod-ClassUnion
      for (;;) {
        if (this.regexp_eatClassSetRange(state)) { continue }
        subResult = this.regexp_eatClassSetOperand(state);
        if (!subResult) { return result }
        if (subResult === CharSetString) { result = CharSetString; }
      }
    };

    // https://tc39.es/ecma262/#prod-ClassSetRange
    pp$1.regexp_eatClassSetRange = function(state) {
      var start = state.pos;
      if (this.regexp_eatClassSetCharacter(state)) {
        var left = state.lastIntValue;
        if (state.eat(0x2D /* - */) && this.regexp_eatClassSetCharacter(state)) {
          var right = state.lastIntValue;
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
          return true
        }
        state.pos = start;
      }
      return false
    };

    // https://tc39.es/ecma262/#prod-ClassSetOperand
    pp$1.regexp_eatClassSetOperand = function(state) {
      if (this.regexp_eatClassSetCharacter(state)) { return CharSetOk }
      return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state)
    };

    // https://tc39.es/ecma262/#prod-NestedClass
    pp$1.regexp_eatNestedClass = function(state) {
      var start = state.pos;
      if (state.eat(0x5B /* [ */)) {
        var negate = state.eat(0x5E /* ^ */);
        var result = this.regexp_classContents(state);
        if (state.eat(0x5D /* ] */)) {
          if (negate && result === CharSetString) {
            state.raise("Negated character class may contain strings");
          }
          return result
        }
        state.pos = start;
      }
      if (state.eat(0x5C /* \ */)) {
        var result$1 = this.regexp_eatCharacterClassEscape(state);
        if (result$1) {
          return result$1
        }
        state.pos = start;
      }
      return null
    };

    // https://tc39.es/ecma262/#prod-ClassStringDisjunction
    pp$1.regexp_eatClassStringDisjunction = function(state) {
      var start = state.pos;
      if (state.eatChars([0x5C, 0x71] /* \q */)) {
        if (state.eat(0x7B /* { */)) {
          var result = this.regexp_classStringDisjunctionContents(state);
          if (state.eat(0x7D /* } */)) {
            return result
          }
        } else {
          // Make the same message as V8.
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return null
    };

    // https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents
    pp$1.regexp_classStringDisjunctionContents = function(state) {
      var result = this.regexp_classString(state);
      while (state.eat(0x7C /* | */)) {
        if (this.regexp_classString(state) === CharSetString) { result = CharSetString; }
      }
      return result
    };

    // https://tc39.es/ecma262/#prod-ClassString
    // https://tc39.es/ecma262/#prod-NonEmptyClassString
    pp$1.regexp_classString = function(state) {
      var count = 0;
      while (this.regexp_eatClassSetCharacter(state)) { count++; }
      return count === 1 ? CharSetOk : CharSetString
    };

    // https://tc39.es/ecma262/#prod-ClassSetCharacter
    pp$1.regexp_eatClassSetCharacter = function(state) {
      var start = state.pos;
      if (state.eat(0x5C /* \ */)) {
        if (
          this.regexp_eatCharacterEscape(state) ||
          this.regexp_eatClassSetReservedPunctuator(state)
        ) {
          return true
        }
        if (state.eat(0x62 /* b */)) {
          state.lastIntValue = 0x08; /* <BS> */
          return true
        }
        state.pos = start;
        return false
      }
      var ch = state.current();
      if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) { return false }
      if (isClassSetSyntaxCharacter(ch)) { return false }
      state.advance();
      state.lastIntValue = ch;
      return true
    };

    // https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator
    function isClassSetReservedDoublePunctuatorCharacter(ch) {
      return (
        ch === 0x21 /* ! */ ||
        ch >= 0x23 /* # */ && ch <= 0x26 /* & */ ||
        ch >= 0x2A /* * */ && ch <= 0x2C /* , */ ||
        ch === 0x2E /* . */ ||
        ch >= 0x3A /* : */ && ch <= 0x40 /* @ */ ||
        ch === 0x5E /* ^ */ ||
        ch === 0x60 /* ` */ ||
        ch === 0x7E /* ~ */
      )
    }

    // https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter
    function isClassSetSyntaxCharacter(ch) {
      return (
        ch === 0x28 /* ( */ ||
        ch === 0x29 /* ) */ ||
        ch === 0x2D /* - */ ||
        ch === 0x2F /* / */ ||
        ch >= 0x5B /* [ */ && ch <= 0x5D /* ] */ ||
        ch >= 0x7B /* { */ && ch <= 0x7D /* } */
      )
    }

    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
    pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
      var ch = state.current();
      if (isClassSetReservedPunctuator(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }
      return false
    };

    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
    function isClassSetReservedPunctuator(ch) {
      return (
        ch === 0x21 /* ! */ ||
        ch === 0x23 /* # */ ||
        ch === 0x25 /* % */ ||
        ch === 0x26 /* & */ ||
        ch === 0x2C /* , */ ||
        ch === 0x2D /* - */ ||
        ch >= 0x3A /* : */ && ch <= 0x3E /* > */ ||
        ch === 0x40 /* @ */ ||
        ch === 0x60 /* ` */ ||
        ch === 0x7E /* ~ */
      )
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
    pp$1.regexp_eatClassControlLetter = function(state) {
      var ch = state.current();
      if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
        state.lastIntValue = ch % 0x20;
        state.advance();
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$1.regexp_eatHexEscapeSequence = function(state) {
      var start = state.pos;
      if (state.eat(0x78 /* x */)) {
        if (this.regexp_eatFixedHexDigits(state, 2)) {
          return true
        }
        if (state.switchU) {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
    pp$1.regexp_eatDecimalDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isDecimalDigit(ch = state.current())) {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
        state.advance();
      }
      return state.pos !== start
    };
    function isDecimalDigit(ch) {
      return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
    pp$1.regexp_eatHexDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isHexDigit(ch = state.current())) {
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return state.pos !== start
    };
    function isHexDigit(ch) {
      return (
        (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
        (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
        (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
      )
    }
    function hexToInt(ch) {
      if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
        return 10 + (ch - 0x41 /* A */)
      }
      if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
        return 10 + (ch - 0x61 /* a */)
      }
      return ch - 0x30 /* 0 */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
    // Allows only 0-377(octal) i.e. 0-255(decimal).
    pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
      if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
          var n2 = state.lastIntValue;
          if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
            state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
          } else {
            state.lastIntValue = n1 * 8 + n2;
          }
        } else {
          state.lastIntValue = n1;
        }
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
    pp$1.regexp_eatOctalDigit = function(state) {
      var ch = state.current();
      if (isOctalDigit(ch)) {
        state.lastIntValue = ch - 0x30; /* 0 */
        state.advance();
        return true
      }
      state.lastIntValue = 0;
      return false
    };
    function isOctalDigit(ch) {
      return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
    // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$1.regexp_eatFixedHexDigits = function(state, length) {
      var start = state.pos;
      state.lastIntValue = 0;
      for (var i = 0; i < length; ++i) {
        var ch = state.current();
        if (!isHexDigit(ch)) {
          state.pos = start;
          return false
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return true
    };

    // Object type used to represent tokens. Note that normally, tokens
    // simply exist as properties on the parser object. This is only
    // used for the onToken callback and the external tokenizer.

    var Token = function Token(p) {
      this.type = p.type;
      this.value = p.value;
      this.start = p.start;
      this.end = p.end;
      if (p.options.locations)
        { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
      if (p.options.ranges)
        { this.range = [p.start, p.end]; }
    };

    // ## Tokenizer

    var pp = Parser.prototype;

    // Move to the next token

    pp.next = function(ignoreEscapeSequenceInKeyword) {
      if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
        { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
      if (this.options.onToken)
        { this.options.onToken(new Token(this)); }

      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };

    pp.getToken = function() {
      this.next();
      return new Token(this)
    };

    // If we're in an ES6 environment, make parsers iterable
    if (typeof Symbol !== "undefined")
      { pp[Symbol.iterator] = function() {
        var this$1$1 = this;

        return {
          next: function () {
            var token = this$1$1.getToken();
            return {
              done: token.type === types$1.eof,
              value: token
            }
          }
        }
      }; }

    // Toggle strict mode. Re-reads the next number or string to please
    // pedantic tests (`"use strict"; 010;` should fail).

    // Read a single token, updating the parser object's token-related
    // properties.

    pp.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

      this.start = this.pos;
      if (this.options.locations) { this.startLoc = this.curPosition(); }
      if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }

      if (curContext.override) { return curContext.override(this) }
      else { this.readToken(this.fullCharCodeAtPos()); }
    };

    pp.readToken = function(code) {
      // Identifier or keyword. '\uXXXX' sequences are allowed in
      // identifiers, so '\' also dispatches to that.
      if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
        { return this.readWord() }

      return this.getTokenFromCode(code)
    };

    pp.fullCharCodeAtPos = function() {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 0xd7ff || code >= 0xdc00) { return code }
      var next = this.input.charCodeAt(this.pos + 1);
      return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00
    };

    pp.skipBlockComment = function() {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
      this.pos = end + 2;
      if (this.options.locations) {
        for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
          ++this.curLine;
          pos = this.lineStart = nextBreak;
        }
      }
      if (this.options.onComment)
        { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                               startLoc, this.curPosition()); }
    };

    pp.skipLineComment = function(startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine(ch)) {
        ch = this.input.charCodeAt(++this.pos);
      }
      if (this.options.onComment)
        { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                               startLoc, this.curPosition()); }
    };

    // Called at the start of the parse and after every token. Skips
    // whitespace and comments, and.

    pp.skipSpace = function() {
      loop: while (this.pos < this.input.length) {
        var ch = this.input.charCodeAt(this.pos);
        switch (ch) {
        case 32: case 160: // ' '
          ++this.pos;
          break
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10: case 8232: case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break
        case 47: // '/'
          switch (this.input.charCodeAt(this.pos + 1)) {
          case 42: // '*'
            this.skipBlockComment();
            break
          case 47:
            this.skipLineComment(2);
            break
          default:
            break loop
          }
          break
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop
          }
        }
      }
    };

    // Called at the end of every token. Sets `end`, `val`, and
    // maintains `context` and `exprAllowed`, and skips the space after
    // the token, so that the next one's `start` will point at the
    // right position.

    pp.finishToken = function(type, val) {
      this.end = this.pos;
      if (this.options.locations) { this.endLoc = this.curPosition(); }
      var prevType = this.type;
      this.type = type;
      this.value = val;

      this.updateContext(prevType);
    };

    // ### Token reading

    // This is the function that is called to fetch the next token. It
    // is somewhat obscure, because it works in character codes rather
    // than characters, and because operator parsing has been inlined
    // into it.
    //
    // All in the name of speed.
    //
    pp.readToken_dot = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) { return this.readNumber(true) }
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
        this.pos += 3;
        return this.finishToken(types$1.ellipsis)
      } else {
        ++this.pos;
        return this.finishToken(types$1.dot)
      }
    };

    pp.readToken_slash = function() { // '/'
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
      if (next === 61) { return this.finishOp(types$1.assign, 2) }
      return this.finishOp(types$1.slash, 1)
    };

    pp.readToken_mult_modulo_exp = function(code) { // '%*'
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code === 42 ? types$1.star : types$1.modulo;

      // exponentiation operator ** and **=
      if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types$1.starstar;
        next = this.input.charCodeAt(this.pos + 2);
      }

      if (next === 61) { return this.finishOp(types$1.assign, size + 1) }
      return this.finishOp(tokentype, size)
    };

    pp.readToken_pipe_amp = function(code) { // '|&'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (this.options.ecmaVersion >= 12) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 === 61) { return this.finishOp(types$1.assign, 3) }
        }
        return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)
      }
      if (next === 61) { return this.finishOp(types$1.assign, 2) }
      return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)
    };

    pp.readToken_caret = function() { // '^'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) { return this.finishOp(types$1.assign, 2) }
      return this.finishOp(types$1.bitwiseXOR, 1)
    };

    pp.readToken_plus_min = function(code) { // '+-'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
            (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          // A `-->` line comment
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken()
        }
        return this.finishOp(types$1.incDec, 2)
      }
      if (next === 61) { return this.finishOp(types$1.assign, 2) }
      return this.finishOp(types$1.plusMin, 1)
    };

    pp.readToken_lt_gt = function(code) { // '<>'
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }
        return this.finishOp(types$1.bitShift, size)
      }
      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
          this.input.charCodeAt(this.pos + 3) === 45) {
        // `<!--`, an XML-style comment that should be interpreted as a line comment
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken()
      }
      if (next === 61) { size = 2; }
      return this.finishOp(types$1.relational, size)
    };

    pp.readToken_eq_excl = function(code) { // '=!'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
        this.pos += 2;
        return this.finishToken(types$1.arrow)
      }
      return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)
    };

    pp.readToken_question = function() { // '?'
      var ecmaVersion = this.options.ecmaVersion;
      if (ecmaVersion >= 11) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 46) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }
        }
        if (next === 63) {
          if (ecmaVersion >= 12) {
            var next2$1 = this.input.charCodeAt(this.pos + 2);
            if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }
          }
          return this.finishOp(types$1.coalesce, 2)
        }
      }
      return this.finishOp(types$1.question, 1)
    };

    pp.readToken_numberSign = function() { // '#'
      var ecmaVersion = this.options.ecmaVersion;
      var code = 35; // '#'
      if (ecmaVersion >= 13) {
        ++this.pos;
        code = this.fullCharCodeAtPos();
        if (isIdentifierStart(code, true) || code === 92 /* '\' */) {
          return this.finishToken(types$1.privateId, this.readWord1())
        }
      }

      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };

    pp.getTokenFromCode = function(code) {
      switch (code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
      case 46: // '.'
        return this.readToken_dot()

      // Punctuation tokens.
      case 40: ++this.pos; return this.finishToken(types$1.parenL)
      case 41: ++this.pos; return this.finishToken(types$1.parenR)
      case 59: ++this.pos; return this.finishToken(types$1.semi)
      case 44: ++this.pos; return this.finishToken(types$1.comma)
      case 91: ++this.pos; return this.finishToken(types$1.bracketL)
      case 93: ++this.pos; return this.finishToken(types$1.bracketR)
      case 123: ++this.pos; return this.finishToken(types$1.braceL)
      case 125: ++this.pos; return this.finishToken(types$1.braceR)
      case 58: ++this.pos; return this.finishToken(types$1.colon)

      case 96: // '`'
        if (this.options.ecmaVersion < 6) { break }
        ++this.pos;
        return this.finishToken(types$1.backQuote)

      case 48: // '0'
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
        if (this.options.ecmaVersion >= 6) {
          if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
          if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
        }

      // Anything else beginning with a digit is an integer, octal
      // number, or float.
      case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
        return this.readNumber(false)

      // Quotes produce strings.
      case 34: case 39: // '"', "'"
        return this.readString(code)

      // Operators are parsed inline in tiny state machines. '=' (61) is
      // often referred to. `finishOp` simply skips the amount of
      // characters it is given as second argument, and returns a token
      // of the type given by its first argument.
      case 47: // '/'
        return this.readToken_slash()

      case 37: case 42: // '%*'
        return this.readToken_mult_modulo_exp(code)

      case 124: case 38: // '|&'
        return this.readToken_pipe_amp(code)

      case 94: // '^'
        return this.readToken_caret()

      case 43: case 45: // '+-'
        return this.readToken_plus_min(code)

      case 60: case 62: // '<>'
        return this.readToken_lt_gt(code)

      case 61: case 33: // '=!'
        return this.readToken_eq_excl(code)

      case 63: // '?'
        return this.readToken_question()

      case 126: // '~'
        return this.finishOp(types$1.prefix, 1)

      case 35: // '#'
        return this.readToken_numberSign()
      }

      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };

    pp.finishOp = function(type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str)
    };

    pp.readRegexp = function() {
      var escaped, inClass, start = this.pos;
      for (;;) {
        if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
        var ch = this.input.charAt(this.pos);
        if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
        if (!escaped) {
          if (ch === "[") { inClass = true; }
          else if (ch === "]" && inClass) { inClass = false; }
          else if (ch === "/" && !inClass) { break }
          escaped = ch === "\\";
        } else { escaped = false; }
        ++this.pos;
      }
      var pattern = this.input.slice(start, this.pos);
      ++this.pos;
      var flagsStart = this.pos;
      var flags = this.readWord1();
      if (this.containsEsc) { this.unexpected(flagsStart); }

      // Validate pattern
      var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
      state.reset(start, pattern, flags);
      this.validateRegExpFlags(state);
      this.validateRegExpPattern(state);

      // Create Literal#value property value.
      var value = null;
      try {
        value = new RegExp(pattern, flags);
      } catch (e) {
        // ESTree requires null if it failed to instantiate RegExp object.
        // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
      }

      return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})
    };

    // Read an integer in the given radix. Return null if zero digits
    // were read, the integer value otherwise. When `len` is given, this
    // will return `null` unless the integer has exactly `len` digits.

    pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
      // `len` is used for character escape sequences. In that case, disallow separators.
      var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

      // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
      // and isn't fraction part nor exponent part. In that case, if the first digit
      // is zero then disallow separators.
      var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

      var start = this.pos, total = 0, lastCode = 0;
      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
        var code = this.input.charCodeAt(this.pos), val = (void 0);

        if (allowSeparators && code === 95) {
          if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
          if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
          if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
          lastCode = code;
          continue
        }

        if (code >= 97) { val = code - 97 + 10; } // a
        else if (code >= 65) { val = code - 65 + 10; } // A
        else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
        else { val = Infinity; }
        if (val >= radix) { break }
        lastCode = code;
        total = total * radix + val;
      }

      if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
      if (this.pos === start || len != null && this.pos - start !== len) { return null }

      return total
    };

    function stringToNumber(str, isLegacyOctalNumericLiteral) {
      if (isLegacyOctalNumericLiteral) {
        return parseInt(str, 8)
      }

      // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
      return parseFloat(str.replace(/_/g, ""))
    }

    function stringToBigInt(str) {
      if (typeof BigInt !== "function") {
        return null
      }

      // `BigInt(value)` throws syntax error if the string contains numeric separators.
      return BigInt(str.replace(/_/g, ""))
    }

    pp.readRadixNumber = function(radix) {
      var start = this.pos;
      this.pos += 2; // 0x
      var val = this.readInt(radix);
      if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
      } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types$1.num, val)
    };

    // Read an integer, octal integer, or floating-point number.

    pp.readNumber = function(startsWithDot) {
      var start = this.pos;
      if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
      var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (octal && this.strict) { this.raise(start, "Invalid number"); }
      var next = this.input.charCodeAt(this.pos);
      if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var val$1 = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
        if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
        return this.finishToken(types$1.num, val$1)
      }
      if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
      if (next === 46 && !octal) { // '.'
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
      }
      if ((next === 69 || next === 101) && !octal) { // 'eE'
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) { ++this.pos; } // '+-'
        if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
      }
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

      var val = stringToNumber(this.input.slice(start, this.pos), octal);
      return this.finishToken(types$1.num, val)
    };

    // Read a string value, interpreting backslash-escapes.

    pp.readCodePoint = function() {
      var ch = this.input.charCodeAt(this.pos), code;

      if (ch === 123) { // '{'
        if (this.options.ecmaVersion < 6) { this.unexpected(); }
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
      } else {
        code = this.readHexChar(4);
      }
      return code
    };

    pp.readString = function(quote) {
      var out = "", chunkStart = ++this.pos;
      for (;;) {
        if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) { break }
        if (ch === 92) { // '\'
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else if (ch === 0x2028 || ch === 0x2029) {
          if (this.options.ecmaVersion < 10) { this.raise(this.start, "Unterminated string constant"); }
          ++this.pos;
          if (this.options.locations) {
            this.curLine++;
            this.lineStart = this.pos;
          }
        } else {
          if (isNewLine(ch)) { this.raise(this.start, "Unterminated string constant"); }
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types$1.string, out)
    };

    // Reads template string tokens.

    var INVALID_TEMPLATE_ESCAPE_ERROR = {};

    pp.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
          this.readInvalidTemplateToken();
        } else {
          throw err
        }
      }

      this.inTemplateElement = false;
    };

    pp.invalidStringToken = function(position, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR
      } else {
        this.raise(position, message);
      }
    };

    pp.readTmplToken = function() {
      var out = "", chunkStart = this.pos;
      for (;;) {
        if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
          if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
            if (ch === 36) {
              this.pos += 2;
              return this.finishToken(types$1.dollarBraceL)
            } else {
              ++this.pos;
              return this.finishToken(types$1.backQuote)
            }
          }
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(types$1.template, out)
        }
        if (ch === 92) { // '\'
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
          case 10:
            out += "\n";
            break
          default:
            out += String.fromCharCode(ch);
            break
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };

    // Reads a template token to search for the end, without validating any escape sequences
    pp.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++) {
        switch (this.input[this.pos]) {
        case "\\":
          ++this.pos;
          break

        case "$":
          if (this.input[this.pos + 1] !== "{") { break }
          // fall through
        case "`":
          return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))

        case "\r":
          if (this.input[this.pos + 1] === "\n") { ++this.pos; }
          // fall through
        case "\n": case "\u2028": case "\u2029":
          ++this.curLine;
          this.lineStart = this.pos + 1;
          break
        }
      }
      this.raise(this.start, "Unterminated template");
    };

    // Used to read escaped characters

    pp.readEscapedChar = function(inTemplate) {
      var ch = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch) {
      case 110: return "\n" // 'n' -> '\n'
      case 114: return "\r" // 'r' -> '\r'
      case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
      case 117: return codePointToString(this.readCodePoint()) // 'u'
      case 116: return "\t" // 't' -> '\t'
      case 98: return "\b" // 'b' -> '\b'
      case 118: return "\u000b" // 'v' -> '\u000b'
      case 102: return "\f" // 'f' -> '\f'
      case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
      case 10: // ' \n'
        if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
        return ""
      case 56:
      case 57:
        if (this.strict) {
          this.invalidStringToken(
            this.pos - 1,
            "Invalid escape sequence"
          );
        }
        if (inTemplate) {
          var codePos = this.pos - 1;

          this.invalidStringToken(
            codePos,
            "Invalid escape sequence in template string"
          );
        }
      default:
        if (ch >= 48 && ch <= 55) {
          var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          this.pos += octalStr.length - 1;
          ch = this.input.charCodeAt(this.pos);
          if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
            this.invalidStringToken(
              this.pos - 1 - octalStr.length,
              inTemplate
                ? "Octal literal in template string"
                : "Octal literal in strict mode"
            );
          }
          return String.fromCharCode(octal)
        }
        if (isNewLine(ch)) {
          // Unicode new line characters after \ get removed from output in both
          // template literals and strings
          if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
          return ""
        }
        return String.fromCharCode(ch)
      }
    };

    // Used to read character escape sequences ('\x', '\u', '\U').

    pp.readHexChar = function(len) {
      var codePos = this.pos;
      var n = this.readInt(16, len);
      if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
      return n
    };

    // Read an identifier, and return it as a string. Sets `this.containsEsc`
    // to whether the word contained a '\u' escape.
    //
    // Incrementally adds only escaped chars, adding other chunks as-is
    // as a micro-optimization.

    pp.readWord1 = function() {
      this.containsEsc = false;
      var word = "", first = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch, astral)) {
          this.pos += ch <= 0xffff ? 1 : 2;
        } else if (ch === 92) { // "\"
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117) // "u"
            { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
            { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
          word += codePointToString(esc);
          chunkStart = this.pos;
        } else {
          break
        }
        first = false;
      }
      return word + this.input.slice(chunkStart, this.pos)
    };

    // Read an identifier or keyword token. Will check for reserved
    // words when necessary.

    pp.readWord = function() {
      var word = this.readWord1();
      var type = types$1.name;
      if (this.keywords.test(word)) {
        type = keywords[word];
      }
      return this.finishToken(type, word)
    };

    // Acorn is a tiny, fast JavaScript parser written in JavaScript.
    //
    // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
    // various contributors and released under an MIT license.
    //
    // Git repositories for Acorn are available at
    //
    //     http://marijnhaverbeke.nl/git/acorn
    //     https://github.com/acornjs/acorn.git
    //
    // Please use the [github bug tracker][ghbt] to report issues.
    //
    // [ghbt]: https://github.com/acornjs/acorn/issues
    //
    // [walk]: util/walk.js


    var version = "8.14.0";

    Parser.acorn = {
      Parser: Parser,
      version: version,
      defaultOptions: defaultOptions$2,
      Position: Position,
      SourceLocation: SourceLocation,
      getLineInfo: getLineInfo,
      Node: Node,
      TokenType: TokenType,
      tokTypes: types$1,
      keywordTypes: keywords,
      TokContext: TokContext,
      tokContexts: types,
      isIdentifierChar: isIdentifierChar,
      isIdentifierStart: isIdentifierStart,
      Token: Token,
      isNewLine: isNewLine,
      lineBreak: lineBreak,
      lineBreakG: lineBreakG,
      nonASCIIwhitespace: nonASCIIwhitespace
    };

    // The main exported interface (under `self.acorn` when in the
    // browser) is a `parse` function that takes a code string and returns
    // an abstract syntax tree as specified by the [ESTree spec][estree].
    //
    // [estree]: https://github.com/estree/estree

    function parse(input, options) {
      return Parser.parse(input, options)
    }

    // AST walker module for ESTree compatible trees

    // A simple walk is one where you simply specify callbacks to be
    // called on specific nodes. The last two arguments are optional. A
    // simple use would be
    //
    //     walk.simple(myTree, {
    //         Expression: function(node) { ... }
    //     });
    //
    // to do something with all expressions. All ESTree node types
    // can be used to identify node types, as well as Expression and
    // Statement, which denote categories of nodes.
    //
    // The base argument can be used to pass a custom (recursive)
    // walker, and state can be used to give this walked an initial
    // state.

    function simple(node, visitors, baseVisitor, state, override) {
      if (!baseVisitor) { baseVisitor = base
      ; }(function c(node, st, override) {
        var type = override || node.type;
        baseVisitor[type](node, st, c);
        if (visitors[type]) { visitors[type](node, st); }
      })(node, state, override);
    }

    // A recursive walk is one where your functions override the default
    // walkers. They can modify and replace the state parameter that's
    // threaded through the walk, and can opt how and whether to walk
    // their child nodes (by calling their third argument on these
    // nodes).
    function recursive(node, state, funcs, baseVisitor, override) {
      var visitor = funcs ? make(funcs) : baseVisitor
      ;(function c(node, st, override) {
        visitor[override || node.type](node, st, c);
      })(node, state, override);
    }

    // Used to create a custom walker. Will fill in all missing node
    // type properties with the defaults.
    function make(funcs, baseVisitor) {
      var visitor = Object.create(base);
      for (var type in funcs) { visitor[type] = funcs[type]; }
      return visitor
    }

    function skipThrough(node, st, c) { c(node, st); }
    function ignore(_node, _st, _c) {}

    // Node walkers.

    var base = {};

    base.Program = base.BlockStatement = base.StaticBlock = function (node, st, c) {
      for (var i = 0, list = node.body; i < list.length; i += 1)
        {
        var stmt = list[i];

        c(stmt, st, "Statement");
      }
    };
    base.Statement = skipThrough;
    base.EmptyStatement = ignore;
    base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression =
      function (node, st, c) { return c(node.expression, st, "Expression"); };
    base.IfStatement = function (node, st, c) {
      c(node.test, st, "Expression");
      c(node.consequent, st, "Statement");
      if (node.alternate) { c(node.alternate, st, "Statement"); }
    };
    base.LabeledStatement = function (node, st, c) { return c(node.body, st, "Statement"); };
    base.BreakStatement = base.ContinueStatement = ignore;
    base.WithStatement = function (node, st, c) {
      c(node.object, st, "Expression");
      c(node.body, st, "Statement");
    };
    base.SwitchStatement = function (node, st, c) {
      c(node.discriminant, st, "Expression");
      for (var i = 0, list = node.cases; i < list.length; i += 1) {
        var cs = list[i];

        c(cs, st);
      }
    };
    base.SwitchCase = function (node, st, c) {
      if (node.test) { c(node.test, st, "Expression"); }
      for (var i = 0, list = node.consequent; i < list.length; i += 1)
        {
        var cons = list[i];

        c(cons, st, "Statement");
      }
    };
    base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {
      if (node.argument) { c(node.argument, st, "Expression"); }
    };
    base.ThrowStatement = base.SpreadElement =
      function (node, st, c) { return c(node.argument, st, "Expression"); };
    base.TryStatement = function (node, st, c) {
      c(node.block, st, "Statement");
      if (node.handler) { c(node.handler, st); }
      if (node.finalizer) { c(node.finalizer, st, "Statement"); }
    };
    base.CatchClause = function (node, st, c) {
      if (node.param) { c(node.param, st, "Pattern"); }
      c(node.body, st, "Statement");
    };
    base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
      c(node.test, st, "Expression");
      c(node.body, st, "Statement");
    };
    base.ForStatement = function (node, st, c) {
      if (node.init) { c(node.init, st, "ForInit"); }
      if (node.test) { c(node.test, st, "Expression"); }
      if (node.update) { c(node.update, st, "Expression"); }
      c(node.body, st, "Statement");
    };
    base.ForInStatement = base.ForOfStatement = function (node, st, c) {
      c(node.left, st, "ForInit");
      c(node.right, st, "Expression");
      c(node.body, st, "Statement");
    };
    base.ForInit = function (node, st, c) {
      if (node.type === "VariableDeclaration") { c(node, st); }
      else { c(node, st, "Expression"); }
    };
    base.DebuggerStatement = ignore;

    base.FunctionDeclaration = function (node, st, c) { return c(node, st, "Function"); };
    base.VariableDeclaration = function (node, st, c) {
      for (var i = 0, list = node.declarations; i < list.length; i += 1)
        {
        var decl = list[i];

        c(decl, st);
      }
    };
    base.VariableDeclarator = function (node, st, c) {
      c(node.id, st, "Pattern");
      if (node.init) { c(node.init, st, "Expression"); }
    };

    base.Function = function (node, st, c) {
      if (node.id) { c(node.id, st, "Pattern"); }
      for (var i = 0, list = node.params; i < list.length; i += 1)
        {
        var param = list[i];

        c(param, st, "Pattern");
      }
      c(node.body, st, node.expression ? "Expression" : "Statement");
    };

    base.Pattern = function (node, st, c) {
      if (node.type === "Identifier")
        { c(node, st, "VariablePattern"); }
      else if (node.type === "MemberExpression")
        { c(node, st, "MemberPattern"); }
      else
        { c(node, st); }
    };
    base.VariablePattern = ignore;
    base.MemberPattern = skipThrough;
    base.RestElement = function (node, st, c) { return c(node.argument, st, "Pattern"); };
    base.ArrayPattern = function (node, st, c) {
      for (var i = 0, list = node.elements; i < list.length; i += 1) {
        var elt = list[i];

        if (elt) { c(elt, st, "Pattern"); }
      }
    };
    base.ObjectPattern = function (node, st, c) {
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

        if (prop.type === "Property") {
          if (prop.computed) { c(prop.key, st, "Expression"); }
          c(prop.value, st, "Pattern");
        } else if (prop.type === "RestElement") {
          c(prop.argument, st, "Pattern");
        }
      }
    };

    base.Expression = skipThrough;
    base.ThisExpression = base.Super = base.MetaProperty = ignore;
    base.ArrayExpression = function (node, st, c) {
      for (var i = 0, list = node.elements; i < list.length; i += 1) {
        var elt = list[i];

        if (elt) { c(elt, st, "Expression"); }
      }
    };
    base.ObjectExpression = function (node, st, c) {
      for (var i = 0, list = node.properties; i < list.length; i += 1)
        {
        var prop = list[i];

        c(prop, st);
      }
    };
    base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
    base.SequenceExpression = function (node, st, c) {
      for (var i = 0, list = node.expressions; i < list.length; i += 1)
        {
        var expr = list[i];

        c(expr, st, "Expression");
      }
    };
    base.TemplateLiteral = function (node, st, c) {
      for (var i = 0, list = node.quasis; i < list.length; i += 1)
        {
        var quasi = list[i];

        c(quasi, st);
      }

      for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)
        {
        var expr = list$1[i$1];

        c(expr, st, "Expression");
      }
    };
    base.TemplateElement = ignore;
    base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
      c(node.argument, st, "Expression");
    };
    base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
      c(node.left, st, "Expression");
      c(node.right, st, "Expression");
    };
    base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
      c(node.left, st, "Pattern");
      c(node.right, st, "Expression");
    };
    base.ConditionalExpression = function (node, st, c) {
      c(node.test, st, "Expression");
      c(node.consequent, st, "Expression");
      c(node.alternate, st, "Expression");
    };
    base.NewExpression = base.CallExpression = function (node, st, c) {
      c(node.callee, st, "Expression");
      if (node.arguments)
        { for (var i = 0, list = node.arguments; i < list.length; i += 1)
          {
            var arg = list[i];

            c(arg, st, "Expression");
          } }
    };
    base.MemberExpression = function (node, st, c) {
      c(node.object, st, "Expression");
      if (node.computed) { c(node.property, st, "Expression"); }
    };
    base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
      if (node.declaration)
        { c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression"); }
      if (node.source) { c(node.source, st, "Expression"); }
    };
    base.ExportAllDeclaration = function (node, st, c) {
      if (node.exported)
        { c(node.exported, st); }
      c(node.source, st, "Expression");
    };
    base.ImportDeclaration = function (node, st, c) {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1)
        {
        var spec = list[i];

        c(spec, st);
      }
      c(node.source, st, "Expression");
    };
    base.ImportExpression = function (node, st, c) {
      c(node.source, st, "Expression");
    };
    base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;

    base.TaggedTemplateExpression = function (node, st, c) {
      c(node.tag, st, "Expression");
      c(node.quasi, st, "Expression");
    };
    base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, "Class"); };
    base.Class = function (node, st, c) {
      if (node.id) { c(node.id, st, "Pattern"); }
      if (node.superClass) { c(node.superClass, st, "Expression"); }
      c(node.body, st);
    };
    base.ClassBody = function (node, st, c) {
      for (var i = 0, list = node.body; i < list.length; i += 1)
        {
        var elt = list[i];

        c(elt, st);
      }
    };
    base.MethodDefinition = base.PropertyDefinition = base.Property = function (node, st, c) {
      if (node.computed) { c(node.key, st, "Expression"); }
      if (node.value) { c(node.value, st, "Expression"); }
    };

    // Astring is a tiny and fast JavaScript code generator from an ESTree-compliant AST.
    //
    // Astring was written by David Bonnet and released under an MIT license.
    //
    // The Git repository for Astring is available at:
    // https://github.com/davidbonnet/astring.git
    //
    // Please use the GitHub bug tracker to report issues:
    // https://github.com/davidbonnet/astring/issues

    const { stringify } = JSON;

    /* c8 ignore if */
    if (!String.prototype.repeat) {
      /* c8 ignore next */
      throw new Error(
        'String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation',
      )
    }

    /* c8 ignore if */
    if (!String.prototype.endsWith) {
      /* c8 ignore next */
      throw new Error(
        'String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation',
      )
    }

    const OPERATOR_PRECEDENCE = {
      '||': 2,
      '??': 3,
      '&&': 4,
      '|': 5,
      '^': 6,
      '&': 7,
      '==': 8,
      '!=': 8,
      '===': 8,
      '!==': 8,
      '<': 9,
      '>': 9,
      '<=': 9,
      '>=': 9,
      in: 9,
      instanceof: 9,
      '<<': 10,
      '>>': 10,
      '>>>': 10,
      '+': 11,
      '-': 11,
      '*': 12,
      '%': 12,
      '/': 12,
      '**': 13,
    };

    // Enables parenthesis regardless of precedence
    const NEEDS_PARENTHESES = 17;

    const EXPRESSIONS_PRECEDENCE = {
      // Definitions
      ArrayExpression: 20,
      TaggedTemplateExpression: 20,
      ThisExpression: 20,
      Identifier: 20,
      PrivateIdentifier: 20,
      Literal: 18,
      TemplateLiteral: 20,
      Super: 20,
      SequenceExpression: 20,
      // Operations
      MemberExpression: 19,
      ChainExpression: 19,
      CallExpression: 19,
      NewExpression: 19,
      // Other definitions
      ArrowFunctionExpression: NEEDS_PARENTHESES,
      ClassExpression: NEEDS_PARENTHESES,
      FunctionExpression: NEEDS_PARENTHESES,
      ObjectExpression: NEEDS_PARENTHESES,
      // Other operations
      UpdateExpression: 16,
      UnaryExpression: 15,
      AwaitExpression: 15,
      BinaryExpression: 14,
      LogicalExpression: 13,
      ConditionalExpression: 4,
      AssignmentExpression: 3,
      YieldExpression: 2,
      RestElement: 1,
    };

    function formatSequence(state, nodes) {
      /*
      Writes into `state` a sequence of `nodes`.
      */
      const { generator } = state;
      state.write('(');
      if (nodes != null && nodes.length > 0) {
        generator[nodes[0].type](nodes[0], state);
        const { length } = nodes;
        for (let i = 1; i < length; i++) {
          const param = nodes[i];
          state.write(', ');
          generator[param.type](param, state);
        }
      }
      state.write(')');
    }

    function expressionNeedsParenthesis(state, node, parentNode, isRightHand) {
      const nodePrecedence = state.expressionsPrecedence[node.type];
      if (nodePrecedence === NEEDS_PARENTHESES) {
        return true
      }
      const parentNodePrecedence = state.expressionsPrecedence[parentNode.type];
      if (nodePrecedence !== parentNodePrecedence) {
        // Different node types
        return (
          (!isRightHand &&
            nodePrecedence === 15 &&
            parentNodePrecedence === 14 &&
            parentNode.operator === '**') ||
          nodePrecedence < parentNodePrecedence
        )
      }
      if (nodePrecedence !== 13 && nodePrecedence !== 14) {
        // Not a `LogicalExpression` or `BinaryExpression`
        return false
      }
      if (node.operator === '**' && parentNode.operator === '**') {
        // Exponentiation operator has right-to-left associativity
        return !isRightHand
      }
      if (
        nodePrecedence === 13 &&
        parentNodePrecedence === 13 &&
        (node.operator === '??' || parentNode.operator === '??')
      ) {
        // Nullish coalescing and boolean operators cannot be combined
        return true
      }
      if (isRightHand) {
        // Parenthesis are used if both operators have the same precedence
        return (
          OPERATOR_PRECEDENCE[node.operator] <=
          OPERATOR_PRECEDENCE[parentNode.operator]
        )
      }
      return (
        OPERATOR_PRECEDENCE[node.operator] <
        OPERATOR_PRECEDENCE[parentNode.operator]
      )
    }

    function formatExpression(state, node, parentNode, isRightHand) {
      /*
      Writes into `state` the provided `node`, adding parenthesis around if the provided `parentNode` needs it. If `node` is a right-hand argument, the provided `isRightHand` parameter should be `true`.
      */
      const { generator } = state;
      if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {
        state.write('(');
        generator[node.type](node, state);
        state.write(')');
      } else {
        generator[node.type](node, state);
      }
    }

    function reindent(state, text, indent, lineEnd) {
      /*
      Writes into `state` the `text` string reindented with the provided `indent`.
      */
      const lines = text.split('\n');
      const end = lines.length - 1;
      state.write(lines[0].trim());
      if (end > 0) {
        state.write(lineEnd);
        for (let i = 1; i < end; i++) {
          state.write(indent + lines[i].trim() + lineEnd);
        }
        state.write(indent + lines[end].trim());
      }
    }

    function formatComments(state, comments, indent, lineEnd) {
      /*
      Writes into `state` the provided list of `comments`, with the given `indent` and `lineEnd` strings.
      Line comments will end with `"\n"` regardless of the value of `lineEnd`.
      Expects to start on a new unindented line.
      */
      const { length } = comments;
      for (let i = 0; i < length; i++) {
        const comment = comments[i];
        state.write(indent);
        if (comment.type[0] === 'L') {
          // Line comment
          state.write('// ' + comment.value.trim() + '\n', comment);
        } else {
          // Block comment
          state.write('/*');
          reindent(state, comment.value, indent, lineEnd);
          state.write('*/' + lineEnd);
        }
      }
    }

    function hasCallExpression(node) {
      /*
      Returns `true` if the provided `node` contains a call expression and `false` otherwise.
      */
      let currentNode = node;
      while (currentNode != null) {
        const { type } = currentNode;
        if (type[0] === 'C' && type[1] === 'a') {
          // Is CallExpression
          return true
        } else if (type[0] === 'M' && type[1] === 'e' && type[2] === 'm') {
          // Is MemberExpression
          currentNode = currentNode.object;
        } else {
          return false
        }
      }
    }

    function formatVariableDeclaration(state, node) {
      /*
      Writes into `state` a variable declaration.
      */
      const { generator } = state;
      const { declarations } = node;
      state.write(node.kind + ' ');
      const { length } = declarations;
      if (length > 0) {
        generator.VariableDeclarator(declarations[0], state);
        for (let i = 1; i < length; i++) {
          state.write(', ');
          generator.VariableDeclarator(declarations[i], state);
        }
      }
    }

    let ForInStatement,
      FunctionDeclaration,
      RestElement,
      BinaryExpression,
      ArrayExpression,
      BlockStatement;

    const GENERATOR = {
      /*
      Default generator.
      */
      Program(node, state) {
        const indent = state.indent.repeat(state.indentLevel);
        const { lineEnd, writeComments } = state;
        if (writeComments && node.comments != null) {
          formatComments(state, node.comments, indent, lineEnd);
        }
        const statements = node.body;
        const { length } = statements;
        for (let i = 0; i < length; i++) {
          const statement = statements[i];
          if (writeComments && statement.comments != null) {
            formatComments(state, statement.comments, indent, lineEnd);
          }
          state.write(indent);
          this[statement.type](statement, state);
          state.write(lineEnd);
        }
        if (writeComments && node.trailingComments != null) {
          formatComments(state, node.trailingComments, indent, lineEnd);
        }
      },
      BlockStatement: (BlockStatement = function (node, state) {
        const indent = state.indent.repeat(state.indentLevel++);
        const { lineEnd, writeComments } = state;
        const statementIndent = indent + state.indent;
        state.write('{');
        const statements = node.body;
        if (statements != null && statements.length > 0) {
          state.write(lineEnd);
          if (writeComments && node.comments != null) {
            formatComments(state, node.comments, statementIndent, lineEnd);
          }
          const { length } = statements;
          for (let i = 0; i < length; i++) {
            const statement = statements[i];
            if (writeComments && statement.comments != null) {
              formatComments(state, statement.comments, statementIndent, lineEnd);
            }
            state.write(statementIndent);
            this[statement.type](statement, state);
            state.write(lineEnd);
          }
          state.write(indent);
        } else {
          if (writeComments && node.comments != null) {
            state.write(lineEnd);
            formatComments(state, node.comments, statementIndent, lineEnd);
            state.write(indent);
          }
        }
        if (writeComments && node.trailingComments != null) {
          formatComments(state, node.trailingComments, statementIndent, lineEnd);
        }
        state.write('}');
        state.indentLevel--;
      }),
      ClassBody: BlockStatement,
      StaticBlock(node, state) {
        state.write('static ');
        this.BlockStatement(node, state);
      },
      EmptyStatement(node, state) {
        state.write(';');
      },
      ExpressionStatement(node, state) {
        const precedence = state.expressionsPrecedence[node.expression.type];
        if (
          precedence === NEEDS_PARENTHESES ||
          (precedence === 3 && node.expression.left.type[0] === 'O')
        ) {
          // Should always have parentheses or is an AssignmentExpression to an ObjectPattern
          state.write('(');
          this[node.expression.type](node.expression, state);
          state.write(')');
        } else {
          this[node.expression.type](node.expression, state);
        }
        state.write(';');
      },
      IfStatement(node, state) {
        state.write('if (');
        this[node.test.type](node.test, state);
        state.write(') ');
        this[node.consequent.type](node.consequent, state);
        if (node.alternate != null) {
          state.write(' else ');
          this[node.alternate.type](node.alternate, state);
        }
      },
      LabeledStatement(node, state) {
        this[node.label.type](node.label, state);
        state.write(': ');
        this[node.body.type](node.body, state);
      },
      BreakStatement(node, state) {
        state.write('break');
        if (node.label != null) {
          state.write(' ');
          this[node.label.type](node.label, state);
        }
        state.write(';');
      },
      ContinueStatement(node, state) {
        state.write('continue');
        if (node.label != null) {
          state.write(' ');
          this[node.label.type](node.label, state);
        }
        state.write(';');
      },
      WithStatement(node, state) {
        state.write('with (');
        this[node.object.type](node.object, state);
        state.write(') ');
        this[node.body.type](node.body, state);
      },
      SwitchStatement(node, state) {
        const indent = state.indent.repeat(state.indentLevel++);
        const { lineEnd, writeComments } = state;
        state.indentLevel++;
        const caseIndent = indent + state.indent;
        const statementIndent = caseIndent + state.indent;
        state.write('switch (');
        this[node.discriminant.type](node.discriminant, state);
        state.write(') {' + lineEnd);
        const { cases: occurences } = node;
        const { length: occurencesCount } = occurences;
        for (let i = 0; i < occurencesCount; i++) {
          const occurence = occurences[i];
          if (writeComments && occurence.comments != null) {
            formatComments(state, occurence.comments, caseIndent, lineEnd);
          }
          if (occurence.test) {
            state.write(caseIndent + 'case ');
            this[occurence.test.type](occurence.test, state);
            state.write(':' + lineEnd);
          } else {
            state.write(caseIndent + 'default:' + lineEnd);
          }
          const { consequent } = occurence;
          const { length: consequentCount } = consequent;
          for (let i = 0; i < consequentCount; i++) {
            const statement = consequent[i];
            if (writeComments && statement.comments != null) {
              formatComments(state, statement.comments, statementIndent, lineEnd);
            }
            state.write(statementIndent);
            this[statement.type](statement, state);
            state.write(lineEnd);
          }
        }
        state.indentLevel -= 2;
        state.write(indent + '}');
      },
      ReturnStatement(node, state) {
        state.write('return');
        if (node.argument) {
          state.write(' ');
          this[node.argument.type](node.argument, state);
        }
        state.write(';');
      },
      ThrowStatement(node, state) {
        state.write('throw ');
        this[node.argument.type](node.argument, state);
        state.write(';');
      },
      TryStatement(node, state) {
        state.write('try ');
        this[node.block.type](node.block, state);
        if (node.handler) {
          const { handler } = node;
          if (handler.param == null) {
            state.write(' catch ');
          } else {
            state.write(' catch (');
            this[handler.param.type](handler.param, state);
            state.write(') ');
          }
          this[handler.body.type](handler.body, state);
        }
        if (node.finalizer) {
          state.write(' finally ');
          this[node.finalizer.type](node.finalizer, state);
        }
      },
      WhileStatement(node, state) {
        state.write('while (');
        this[node.test.type](node.test, state);
        state.write(') ');
        this[node.body.type](node.body, state);
      },
      DoWhileStatement(node, state) {
        state.write('do ');
        this[node.body.type](node.body, state);
        state.write(' while (');
        this[node.test.type](node.test, state);
        state.write(');');
      },
      ForStatement(node, state) {
        state.write('for (');
        if (node.init != null) {
          const { init } = node;
          if (init.type[0] === 'V') {
            formatVariableDeclaration(state, init);
          } else {
            this[init.type](init, state);
          }
        }
        state.write('; ');
        if (node.test) {
          this[node.test.type](node.test, state);
        }
        state.write('; ');
        if (node.update) {
          this[node.update.type](node.update, state);
        }
        state.write(') ');
        this[node.body.type](node.body, state);
      },
      ForInStatement: (ForInStatement = function (node, state) {
        state.write(`for ${node.await ? 'await ' : ''}(`);
        const { left } = node;
        if (left.type[0] === 'V') {
          formatVariableDeclaration(state, left);
        } else {
          this[left.type](left, state);
        }
        // Identifying whether node.type is `ForInStatement` or `ForOfStatement`
        state.write(node.type[3] === 'I' ? ' in ' : ' of ');
        this[node.right.type](node.right, state);
        state.write(') ');
        this[node.body.type](node.body, state);
      }),
      ForOfStatement: ForInStatement,
      DebuggerStatement(node, state) {
        state.write('debugger;', node);
      },
      FunctionDeclaration: (FunctionDeclaration = function (node, state) {
        state.write(
          (node.async ? 'async ' : '') +
            (node.generator ? 'function* ' : 'function ') +
            (node.id ? node.id.name : ''),
          node,
        );
        formatSequence(state, node.params);
        state.write(' ');
        this[node.body.type](node.body, state);
      }),
      FunctionExpression: FunctionDeclaration,
      VariableDeclaration(node, state) {
        formatVariableDeclaration(state, node);
        state.write(';');
      },
      VariableDeclarator(node, state) {
        this[node.id.type](node.id, state);
        if (node.init != null) {
          state.write(' = ');
          this[node.init.type](node.init, state);
        }
      },
      ClassDeclaration(node, state) {
        state.write('class ' + (node.id ? `${node.id.name} ` : ''), node);
        if (node.superClass) {
          state.write('extends ');
          const { superClass } = node;
          const { type } = superClass;
          const precedence = state.expressionsPrecedence[type];
          if (
            (type[0] !== 'C' || type[1] !== 'l' || type[5] !== 'E') &&
            (precedence === NEEDS_PARENTHESES ||
              precedence < state.expressionsPrecedence.ClassExpression)
          ) {
            // Not a ClassExpression that needs parentheses
            state.write('(');
            this[node.superClass.type](superClass, state);
            state.write(')');
          } else {
            this[superClass.type](superClass, state);
          }
          state.write(' ');
        }
        this.ClassBody(node.body, state);
      },
      ImportDeclaration(node, state) {
        state.write('import ');
        const { specifiers, attributes } = node;
        const { length } = specifiers;
        // TODO: Once babili is fixed, put this after condition
        // https://github.com/babel/babili/issues/430
        let i = 0;
        if (length > 0) {
          for (; i < length; ) {
            if (i > 0) {
              state.write(', ');
            }
            const specifier = specifiers[i];
            const type = specifier.type[6];
            if (type === 'D') {
              // ImportDefaultSpecifier
              state.write(specifier.local.name, specifier);
              i++;
            } else if (type === 'N') {
              // ImportNamespaceSpecifier
              state.write('* as ' + specifier.local.name, specifier);
              i++;
            } else {
              // ImportSpecifier
              break
            }
          }
          if (i < length) {
            state.write('{');
            for (;;) {
              const specifier = specifiers[i];
              const { name } = specifier.imported;
              state.write(name, specifier);
              if (name !== specifier.local.name) {
                state.write(' as ' + specifier.local.name);
              }
              if (++i < length) {
                state.write(', ');
              } else {
                break
              }
            }
            state.write('}');
          }
          state.write(' from ');
        }
        this.Literal(node.source, state);

        if (attributes && attributes.length > 0) {
          state.write(' with { ');
          for (let i = 0; i < attributes.length; i++) {
            this.ImportAttribute(attributes[i], state);
            if (i < attributes.length - 1) state.write(', ');
          }

          state.write(' }');
        }
        state.write(';');
      },
      ImportAttribute(node, state) {
        this.Identifier(node.key, state);
        state.write(': ');
        this.Literal(node.value, state);
      },
      ImportExpression(node, state) {
        state.write('import(');
        this[node.source.type](node.source, state);
        state.write(')');
      },
      ExportDefaultDeclaration(node, state) {
        state.write('export default ');
        this[node.declaration.type](node.declaration, state);
        if (
          state.expressionsPrecedence[node.declaration.type] != null &&
          node.declaration.type[0] !== 'F'
        ) {
          // All expression nodes except `FunctionExpression`
          state.write(';');
        }
      },
      ExportNamedDeclaration(node, state) {
        state.write('export ');
        if (node.declaration) {
          this[node.declaration.type](node.declaration, state);
        } else {
          state.write('{');
          const { specifiers } = node,
            { length } = specifiers;
          if (length > 0) {
            for (let i = 0; ; ) {
              const specifier = specifiers[i];
              const { name } = specifier.local;
              state.write(name, specifier);
              if (name !== specifier.exported.name) {
                state.write(' as ' + specifier.exported.name);
              }
              if (++i < length) {
                state.write(', ');
              } else {
                break
              }
            }
          }
          state.write('}');
          if (node.source) {
            state.write(' from ');
            this.Literal(node.source, state);
          }

          if (node.attributes && node.attributes.length > 0) {
            state.write(' with { ');
            for (let i = 0; i < node.attributes.length; i++) {
              this.ImportAttribute(node.attributes[i], state);
              if (i < node.attributes.length - 1) state.write(', ');
            }

            state.write(' }');
          }

          state.write(';');
        }
      },
      ExportAllDeclaration(node, state) {
        if (node.exported != null) {
          state.write('export * as ' + node.exported.name + ' from ');
        } else {
          state.write('export * from ');
        }
        this.Literal(node.source, state);

        if (node.attributes && node.attributes.length > 0) {
          state.write(' with { ');
          for (let i = 0; i < node.attributes.length; i++) {
            this.ImportAttribute(node.attributes[i], state);
            if (i < node.attributes.length - 1) state.write(', ');
          }

          state.write(' }');
        }

        state.write(';');
      },
      MethodDefinition(node, state) {
        if (node.static) {
          state.write('static ');
        }
        const kind = node.kind[0];
        if (kind === 'g' || kind === 's') {
          // Getter or setter
          state.write(node.kind + ' ');
        }
        if (node.value.async) {
          state.write('async ');
        }
        if (node.value.generator) {
          state.write('*');
        }
        if (node.computed) {
          state.write('[');
          this[node.key.type](node.key, state);
          state.write(']');
        } else {
          this[node.key.type](node.key, state);
        }
        formatSequence(state, node.value.params);
        state.write(' ');
        this[node.value.body.type](node.value.body, state);
      },
      ClassExpression(node, state) {
        this.ClassDeclaration(node, state);
      },
      ArrowFunctionExpression(node, state) {
        state.write(node.async ? 'async ' : '', node);
        const { params } = node;
        if (params != null) {
          // Omit parenthesis if only one named parameter
          if (params.length === 1 && params[0].type[0] === 'I') {
            // If params[0].type[0] starts with 'I', it can't be `ImportDeclaration` nor `IfStatement` and thus is `Identifier`
            state.write(params[0].name, params[0]);
          } else {
            formatSequence(state, node.params);
          }
        }
        state.write(' => ');
        if (node.body.type[0] === 'O') {
          // Body is an object expression
          state.write('(');
          this.ObjectExpression(node.body, state);
          state.write(')');
        } else {
          this[node.body.type](node.body, state);
        }
      },
      ThisExpression(node, state) {
        state.write('this', node);
      },
      Super(node, state) {
        state.write('super', node);
      },
      RestElement: (RestElement = function (node, state) {
        state.write('...');
        this[node.argument.type](node.argument, state);
      }),
      SpreadElement: RestElement,
      YieldExpression(node, state) {
        state.write(node.delegate ? 'yield*' : 'yield');
        if (node.argument) {
          state.write(' ');
          this[node.argument.type](node.argument, state);
        }
      },
      AwaitExpression(node, state) {
        state.write('await ', node);
        formatExpression(state, node.argument, node);
      },
      TemplateLiteral(node, state) {
        const { quasis, expressions } = node;
        state.write('`');
        const { length } = expressions;
        for (let i = 0; i < length; i++) {
          const expression = expressions[i];
          const quasi = quasis[i];
          state.write(quasi.value.raw, quasi);
          state.write('${');
          this[expression.type](expression, state);
          state.write('}');
        }
        const quasi = quasis[quasis.length - 1];
        state.write(quasi.value.raw, quasi);
        state.write('`');
      },
      TemplateElement(node, state) {
        state.write(node.value.raw, node);
      },
      TaggedTemplateExpression(node, state) {
        formatExpression(state, node.tag, node);
        this[node.quasi.type](node.quasi, state);
      },
      ArrayExpression: (ArrayExpression = function (node, state) {
        state.write('[');
        if (node.elements.length > 0) {
          const { elements } = node,
            { length } = elements;
          for (let i = 0; ; ) {
            const element = elements[i];
            if (element != null) {
              this[element.type](element, state);
            }
            if (++i < length) {
              state.write(', ');
            } else {
              if (element == null) {
                state.write(', ');
              }
              break
            }
          }
        }
        state.write(']');
      }),
      ArrayPattern: ArrayExpression,
      ObjectExpression(node, state) {
        const indent = state.indent.repeat(state.indentLevel++);
        const { lineEnd, writeComments } = state;
        const propertyIndent = indent + state.indent;
        state.write('{');
        if (node.properties.length > 0) {
          state.write(lineEnd);
          if (writeComments && node.comments != null) {
            formatComments(state, node.comments, propertyIndent, lineEnd);
          }
          const comma = ',' + lineEnd;
          const { properties } = node,
            { length } = properties;
          for (let i = 0; ; ) {
            const property = properties[i];
            if (writeComments && property.comments != null) {
              formatComments(state, property.comments, propertyIndent, lineEnd);
            }
            state.write(propertyIndent);
            this[property.type](property, state);
            if (++i < length) {
              state.write(comma);
            } else {
              break
            }
          }
          state.write(lineEnd);
          if (writeComments && node.trailingComments != null) {
            formatComments(state, node.trailingComments, propertyIndent, lineEnd);
          }
          state.write(indent + '}');
        } else if (writeComments) {
          if (node.comments != null) {
            state.write(lineEnd);
            formatComments(state, node.comments, propertyIndent, lineEnd);
            if (node.trailingComments != null) {
              formatComments(state, node.trailingComments, propertyIndent, lineEnd);
            }
            state.write(indent + '}');
          } else if (node.trailingComments != null) {
            state.write(lineEnd);
            formatComments(state, node.trailingComments, propertyIndent, lineEnd);
            state.write(indent + '}');
          } else {
            state.write('}');
          }
        } else {
          state.write('}');
        }
        state.indentLevel--;
      },
      Property(node, state) {
        if (node.method || node.kind[0] !== 'i') {
          // Either a method or of kind `set` or `get` (not `init`)
          this.MethodDefinition(node, state);
        } else {
          if (!node.shorthand) {
            if (node.computed) {
              state.write('[');
              this[node.key.type](node.key, state);
              state.write(']');
            } else {
              this[node.key.type](node.key, state);
            }
            state.write(': ');
          }
          this[node.value.type](node.value, state);
        }
      },
      PropertyDefinition(node, state) {
        if (node.static) {
          state.write('static ');
        }
        if (node.computed) {
          state.write('[');
        }
        this[node.key.type](node.key, state);
        if (node.computed) {
          state.write(']');
        }
        if (node.value == null) {
          if (node.key.type[0] !== 'F') {
            state.write(';');
          }
          return
        }
        state.write(' = ');
        this[node.value.type](node.value, state);
        state.write(';');
      },
      ObjectPattern(node, state) {
        state.write('{');
        if (node.properties.length > 0) {
          const { properties } = node,
            { length } = properties;
          for (let i = 0; ; ) {
            this[properties[i].type](properties[i], state);
            if (++i < length) {
              state.write(', ');
            } else {
              break
            }
          }
        }
        state.write('}');
      },
      SequenceExpression(node, state) {
        formatSequence(state, node.expressions);
      },
      UnaryExpression(node, state) {
        if (node.prefix) {
          const {
            operator,
            argument,
            argument: { type },
          } = node;
          state.write(operator);
          const needsParentheses = expressionNeedsParenthesis(state, argument, node);
          if (
            !needsParentheses &&
            (operator.length > 1 ||
              (type[0] === 'U' &&
                (type[1] === 'n' || type[1] === 'p') &&
                argument.prefix &&
                argument.operator[0] === operator &&
                (operator === '+' || operator === '-')))
          ) {
            // Large operator or argument is UnaryExpression or UpdateExpression node
            state.write(' ');
          }
          if (needsParentheses) {
            state.write(operator.length > 1 ? ' (' : '(');
            this[type](argument, state);
            state.write(')');
          } else {
            this[type](argument, state);
          }
        } else {
          // FIXME: This case never occurs
          this[node.argument.type](node.argument, state);
          state.write(node.operator);
        }
      },
      UpdateExpression(node, state) {
        // Always applied to identifiers or members, no parenthesis check needed
        if (node.prefix) {
          state.write(node.operator);
          this[node.argument.type](node.argument, state);
        } else {
          this[node.argument.type](node.argument, state);
          state.write(node.operator);
        }
      },
      AssignmentExpression(node, state) {
        this[node.left.type](node.left, state);
        state.write(' ' + node.operator + ' ');
        this[node.right.type](node.right, state);
      },
      AssignmentPattern(node, state) {
        this[node.left.type](node.left, state);
        state.write(' = ');
        this[node.right.type](node.right, state);
      },
      BinaryExpression: (BinaryExpression = function (node, state) {
        const isIn = node.operator === 'in';
        if (isIn) {
          // Avoids confusion in `for` loops initializers
          state.write('(');
        }
        formatExpression(state, node.left, node, false);
        state.write(' ' + node.operator + ' ');
        formatExpression(state, node.right, node, true);
        if (isIn) {
          state.write(')');
        }
      }),
      LogicalExpression: BinaryExpression,
      ConditionalExpression(node, state) {
        const { test } = node;
        const precedence = state.expressionsPrecedence[test.type];
        if (
          precedence === NEEDS_PARENTHESES ||
          precedence <= state.expressionsPrecedence.ConditionalExpression
        ) {
          state.write('(');
          this[test.type](test, state);
          state.write(')');
        } else {
          this[test.type](test, state);
        }
        state.write(' ? ');
        this[node.consequent.type](node.consequent, state);
        state.write(' : ');
        this[node.alternate.type](node.alternate, state);
      },
      NewExpression(node, state) {
        state.write('new ');
        const precedence = state.expressionsPrecedence[node.callee.type];
        if (
          precedence === NEEDS_PARENTHESES ||
          precedence < state.expressionsPrecedence.CallExpression ||
          hasCallExpression(node.callee)
        ) {
          state.write('(');
          this[node.callee.type](node.callee, state);
          state.write(')');
        } else {
          this[node.callee.type](node.callee, state);
        }
        formatSequence(state, node['arguments']);
      },
      CallExpression(node, state) {
        const precedence = state.expressionsPrecedence[node.callee.type];
        if (
          precedence === NEEDS_PARENTHESES ||
          precedence < state.expressionsPrecedence.CallExpression
        ) {
          state.write('(');
          this[node.callee.type](node.callee, state);
          state.write(')');
        } else {
          this[node.callee.type](node.callee, state);
        }
        if (node.optional) {
          state.write('?.');
        }
        formatSequence(state, node['arguments']);
      },
      ChainExpression(node, state) {
        this[node.expression.type](node.expression, state);
      },
      MemberExpression(node, state) {
        const precedence = state.expressionsPrecedence[node.object.type];
        if (
          precedence === NEEDS_PARENTHESES ||
          precedence < state.expressionsPrecedence.MemberExpression
        ) {
          state.write('(');
          this[node.object.type](node.object, state);
          state.write(')');
        } else {
          this[node.object.type](node.object, state);
        }
        if (node.computed) {
          if (node.optional) {
            state.write('?.');
          }
          state.write('[');
          this[node.property.type](node.property, state);
          state.write(']');
        } else {
          if (node.optional) {
            state.write('?.');
          } else {
            state.write('.');
          }
          this[node.property.type](node.property, state);
        }
      },
      MetaProperty(node, state) {
        state.write(node.meta.name + '.' + node.property.name, node);
      },
      Identifier(node, state) {
        state.write(node.name, node);
      },
      PrivateIdentifier(node, state) {
        state.write(`#${node.name}`, node);
      },
      Literal(node, state) {
        if (node.raw != null) {
          // Non-standard property
          state.write(node.raw, node);
        } else if (node.regex != null) {
          this.RegExpLiteral(node, state);
        } else if (node.bigint != null) {
          state.write(node.bigint + 'n', node);
        } else {
          state.write(stringify(node.value), node);
        }
      },
      RegExpLiteral(node, state) {
        const { regex } = node;
        state.write(`/${regex.pattern}/${regex.flags}`, node);
      },
    };

    const EMPTY_OBJECT = {};

    class State {
      constructor(options) {
        const setup = options == null ? EMPTY_OBJECT : options;
        this.output = '';
        // Functional options
        if (setup.output != null) {
          this.output = setup.output;
          this.write = this.writeToStream;
        } else {
          this.output = '';
        }
        this.generator = setup.generator != null ? setup.generator : GENERATOR;
        this.expressionsPrecedence =
          setup.expressionsPrecedence != null
            ? setup.expressionsPrecedence
            : EXPRESSIONS_PRECEDENCE;
        // Formating setup
        this.indent = setup.indent != null ? setup.indent : '  ';
        this.lineEnd = setup.lineEnd != null ? setup.lineEnd : '\n';
        this.indentLevel =
          setup.startingIndentLevel != null ? setup.startingIndentLevel : 0;
        this.writeComments = setup.comments ? setup.comments : false;
        // Source map
        if (setup.sourceMap != null) {
          this.write =
            setup.output == null ? this.writeAndMap : this.writeToStreamAndMap;
          this.sourceMap = setup.sourceMap;
          this.line = 1;
          this.column = 0;
          this.lineEndSize = this.lineEnd.split('\n').length - 1;
          this.mapping = {
            original: null,
            // Uses the entire state to avoid generating ephemeral objects
            generated: this,
            name: undefined,
            source: setup.sourceMap.file || setup.sourceMap._file,
          };
        }
      }

      write(code) {
        this.output += code;
      }

      writeToStream(code) {
        this.output.write(code);
      }

      writeAndMap(code, node) {
        this.output += code;
        this.map(code, node);
      }

      writeToStreamAndMap(code, node) {
        this.output.write(code);
        this.map(code, node);
      }

      map(code, node) {
        if (node != null) {
          const { type } = node;
          if (type[0] === 'L' && type[2] === 'n') {
            // LineComment
            this.column = 0;
            this.line++;
            return
          }
          if (node.loc != null) {
            const { mapping } = this;
            mapping.original = node.loc.start;
            mapping.name = node.name;
            this.sourceMap.addMapping(mapping);
          }
          if (
            (type[0] === 'T' && type[8] === 'E') ||
            (type[0] === 'L' && type[1] === 'i' && typeof node.value === 'string')
          ) {
            // TemplateElement or Literal string node
            const { length } = code;
            let { column, line } = this;
            for (let i = 0; i < length; i++) {
              if (code[i] === '\n') {
                column = 0;
                line++;
              } else {
                column++;
              }
            }
            this.column = column;
            this.line = line;
            return
          }
        }
        const { length } = code;
        const { lineEnd } = this;
        if (length > 0) {
          if (
            this.lineEndSize > 0 &&
            (lineEnd.length === 1
              ? code[length - 1] === lineEnd
              : code.endsWith(lineEnd))
          ) {
            this.line += this.lineEndSize;
            this.column = 0;
          } else {
            this.column += length;
          }
        }
      }

      toString() {
        return this.output
      }
    }

    function generate(node, options) {
      /*
      Returns a string representing the rendered code of the provided AST `node`.
      The `options` are:

      - `indent`: string to use for indentation (defaults to `␣␣`)
      - `lineEnd`: string to use for line endings (defaults to `\n`)
      - `startingIndentLevel`: indent level to start from (defaults to `0`)
      - `comments`: generate comments if `true` (defaults to `false`)
      - `output`: output stream to write the rendered code to (defaults to `null`)
      - `generator`: custom code generator (defaults to `GENERATOR`)
      - `expressionsPrecedence`: custom map of node types and their precedence level (defaults to `EXPRESSIONS_PRECEDENCE`)
      */
      const state = new State(options);
      // Travel through the AST node and generate the code
      state.generator[node.type](node, state);
      return state.output
    }

    var __defProp$7 = Object.defineProperty;
    var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$7 = (obj, key, value) => __defNormalProp$7(obj, typeof key !== "symbol" ? key + "" : key, value);
    class ScopeManager {
      constructor() {
        __publicField$7(this, "scopes", []);
        __publicField$7(this, "scopeTypes", []);
        __publicField$7(this, "scopeCounts", /* @__PURE__ */ new Map());
        __publicField$7(this, "contextBoundVars", /* @__PURE__ */ new Set());
        __publicField$7(this, "arrayPatternElements", /* @__PURE__ */ new Set());
        __publicField$7(this, "rootParams", /* @__PURE__ */ new Set());
        __publicField$7(this, "varKinds", /* @__PURE__ */ new Map());
        __publicField$7(this, "loopVars", /* @__PURE__ */ new Set());
        __publicField$7(this, "loopVarNames", /* @__PURE__ */ new Map());
        // Map original names to transformed names
        __publicField$7(this, "paramIdCounter", 0);
        __publicField$7(this, "cacheIdCounter", 0);
        __publicField$7(this, "tempVarCounter", 0);
        this.pushScope("glb");
      }
      get nextParamIdArg() {
        return {
          type: "Identifier",
          name: `'p${this.paramIdCounter++}'`
        };
      }
      get nextCacheIdArg() {
        return {
          type: "Identifier",
          name: `'cache_${this.cacheIdCounter++}'`
        };
      }
      pushScope(type) {
        this.scopes.push(/* @__PURE__ */ new Map());
        this.scopeTypes.push(type);
        this.scopeCounts.set(type, (this.scopeCounts.get(type) || 0) + 1);
      }
      popScope() {
        this.scopes.pop();
        this.scopeTypes.pop();
      }
      getCurrentScopeType() {
        return this.scopeTypes[this.scopeTypes.length - 1];
      }
      getCurrentScopeCount() {
        return this.scopeCounts.get(this.getCurrentScopeType()) || 1;
      }
      addContextBoundVar(name, isRootParam = false) {
        this.contextBoundVars.add(name);
        if (isRootParam) {
          this.rootParams.add(name);
        }
      }
      addArrayPatternElement(name) {
        this.arrayPatternElements.add(name);
      }
      isContextBound(name) {
        return this.contextBoundVars.has(name);
      }
      isArrayPatternElement(name) {
        return this.arrayPatternElements.has(name);
      }
      isRootParam(name) {
        return this.rootParams.has(name);
      }
      addLoopVariable(originalName, transformedName) {
        this.loopVars.add(originalName);
        this.loopVarNames.set(originalName, transformedName);
      }
      getLoopVariableName(name) {
        return this.loopVarNames.get(name);
      }
      isLoopVariable(name) {
        return this.loopVars.has(name);
      }
      addVariable(name, kind) {
        if (this.isContextBound(name)) {
          return name;
        }
        const currentScope = this.scopes[this.scopes.length - 1];
        const scopeType = this.scopeTypes[this.scopeTypes.length - 1];
        const scopeCount = this.scopeCounts.get(scopeType) || 1;
        const newName = `${scopeType}${scopeCount}_${name}`;
        currentScope.set(name, newName);
        this.varKinds.set(newName, kind);
        return newName;
      }
      getVariable(name) {
        if (this.loopVars.has(name)) {
          const transformedName = this.loopVarNames.get(name);
          if (transformedName) {
            return [transformedName, "let"];
          }
        }
        if (this.isContextBound(name)) {
          return [name, "let"];
        }
        for (let i = this.scopes.length - 1; i >= 0; i--) {
          const scope = this.scopes[i];
          if (scope.has(name)) {
            const scopedName = scope.get(name);
            const kind = this.varKinds.get(scopedName) || "let";
            return [scopedName, kind];
          }
        }
        return [name, "let"];
      }
      generateTempVar() {
        return `temp_${++this.tempVarCounter}`;
      }
    }

    //!!!Warning!!! this code is not clean, it was initially written as a PoC then used as transpiler for PineTS
    const CONTEXT_NAME = "$";
    const UNDEFINED_ARG = {
      type: "Identifier",
      name: "undefined"
    };
    function transformArrayIndex(node, scopeManager) {
      if (node.computed && node.property.type === "Identifier") {
        if (scopeManager.isLoopVariable(node.property.name)) {
          return;
        }
        if (!scopeManager.isContextBound(node.property.name)) {
          const [scopedName, kind] = scopeManager.getVariable(node.property.name);
          node.property = {
            type: "MemberExpression",
            object: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: CONTEXT_NAME
              },
              property: {
                type: "Identifier",
                name: kind
              },
              computed: false
            },
            property: {
              type: "Identifier",
              name: scopedName
            },
            computed: false
          };
          node.property = {
            type: "MemberExpression",
            object: node.property,
            property: {
              type: "Literal",
              value: 0
            },
            computed: true
          };
        }
      }
      if (node.computed && node.object.type === "Identifier") {
        if (scopeManager.isLoopVariable(node.object.name)) {
          return;
        }
        if (!scopeManager.isContextBound(node.object.name)) {
          const [scopedName, kind] = scopeManager.getVariable(node.object.name);
          node.object = {
            type: "MemberExpression",
            object: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: CONTEXT_NAME
              },
              property: {
                type: "Identifier",
                name: kind
              },
              computed: false
            },
            property: {
              type: "Identifier",
              name: scopedName
            },
            computed: false
          };
        }
        if (node.property.type === "MemberExpression") {
          const memberNode = node.property;
          if (!memberNode._indexTransformed) {
            transformArrayIndex(memberNode, scopeManager);
            memberNode._indexTransformed = true;
          }
        }
      }
    }
    function transformMemberExpression(memberNode, originalParamName, scopeManager) {
      if (memberNode.object && memberNode.object.type === "Identifier" && memberNode.object.name === "Math") {
        return;
      }
      const isIfStatement = scopeManager.getCurrentScopeType() == "if";
      const isElseStatement = scopeManager.getCurrentScopeType() == "els";
      const isForStatement = scopeManager.getCurrentScopeType() == "for";
      if (!isIfStatement && !isElseStatement && !isForStatement && memberNode.object && memberNode.object.type === "Identifier" && scopeManager.isContextBound(memberNode.object.name) && !scopeManager.isRootParam(memberNode.object.name)) {
        return;
      }
      if (!memberNode._indexTransformed) {
        transformArrayIndex(memberNode, scopeManager);
        memberNode._indexTransformed = true;
      }
    }
    function transformVariableDeclaration(varNode, scopeManager) {
      varNode.declarations.forEach((decl) => {
        if (decl.init.name == "na") {
          decl.init.name = "NaN";
        }
        const isContextProperty = decl.init && decl.init.type === "MemberExpression" && decl.init.object && (decl.init.object.name === "context" || decl.init.object.name === CONTEXT_NAME || decl.init.object.name === "context2");
        const isSubContextProperty = decl.init && decl.init.type === "MemberExpression" && decl.init.object?.object && (decl.init.object.object.name === "context" || decl.init.object.object.name === CONTEXT_NAME || decl.init.object.object.name === "context2");
        const isArrowFunction = decl.init && decl.init.type === "ArrowFunctionExpression";
        if (isContextProperty) {
          if (decl.id.name) {
            scopeManager.addContextBoundVar(decl.id.name);
          }
          if (decl.id.properties) {
            decl.id.properties.forEach((property) => {
              if (property.key.name) {
                scopeManager.addContextBoundVar(property.key.name);
              }
            });
          }
          decl.init.object.name = CONTEXT_NAME;
          return;
        }
        if (isSubContextProperty) {
          if (decl.id.name) {
            scopeManager.addContextBoundVar(decl.id.name);
          }
          if (decl.id.properties) {
            decl.id.properties.forEach((property) => {
              if (property.key.name) {
                scopeManager.addContextBoundVar(property.key.name);
              }
            });
          }
          decl.init.object.object.name = CONTEXT_NAME;
          return;
        }
        if (isArrowFunction) {
          decl.init.params.forEach((param) => {
            if (param.type === "Identifier") {
              scopeManager.addContextBoundVar(param.name);
            }
          });
        }
        const newName = scopeManager.addVariable(decl.id.name, varNode.kind);
        const kind = varNode.kind;
        if (decl.init && !isArrowFunction) {
          if (decl.init.type === "CallExpression" && decl.init.callee.type === "MemberExpression" && decl.init.callee.object && decl.init.callee.object.type === "Identifier" && scopeManager.isContextBound(decl.init.callee.object.name)) {
            transformCallExpression(decl.init, scopeManager);
          } else {
            recursive(
              decl.init,
              { parent: decl.init },
              {
                Identifier(node, state) {
                  node.parent = state.parent;
                  transformIdentifier(node, scopeManager);
                  const isBinaryOperation = node.parent && node.parent.type === "BinaryExpression";
                  const isConditional = node.parent && node.parent.type === "ConditionalExpression";
                  if (node.type === "Identifier" && (isBinaryOperation || isConditional)) {
                    Object.assign(node, {
                      type: "MemberExpression",
                      object: {
                        type: "Identifier",
                        name: node.name
                      },
                      property: {
                        type: "Literal",
                        value: 0
                      },
                      computed: true
                    });
                  }
                },
                CallExpression(node, state, c) {
                  if (node.callee.type === "Identifier") {
                    node.callee.parent = node;
                  }
                  node.arguments.forEach((arg) => {
                    if (arg.type === "Identifier") {
                      arg.parent = node;
                    }
                  });
                  transformCallExpression(node, scopeManager);
                  node.arguments.forEach((arg) => c(arg, { parent: node }));
                },
                BinaryExpression(node, state, c) {
                  if (node.left.type === "Identifier") {
                    node.left.parent = node;
                  }
                  if (node.right.type === "Identifier") {
                    node.right.parent = node;
                  }
                  c(node.left, { parent: node });
                  c(node.right, { parent: node });
                },
                MemberExpression(node, state, c) {
                  if (node.object.type === "Identifier") {
                    node.object.parent = node;
                  }
                  if (node.property.type === "Identifier") {
                    node.property.parent = node;
                  }
                  transformArrayIndex(node, scopeManager);
                  if (node.object) {
                    c(node.object, { parent: node });
                  }
                }
              }
            );
          }
        }
        const targetVarRef = {
          type: "MemberExpression",
          object: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: CONTEXT_NAME
            },
            property: {
              type: "Identifier",
              name: kind
            },
            computed: false
          },
          property: {
            type: "Identifier",
            name: newName
          },
          computed: false
        };
        const isArrayPatternVar = scopeManager.isArrayPatternElement(decl.id.name);
        const isArrayInit = !isArrayPatternVar && decl.init && decl.init.type === "MemberExpression" && decl.init.computed && decl.init.property && (decl.init.property.type === "Literal" || decl.init.property.type === "MemberExpression");
        if (decl.init?.property?.type === "MemberExpression") {
          if (!decl.init.property._indexTransformed) {
            transformArrayIndex(decl.init.property, scopeManager);
            decl.init.property._indexTransformed = true;
          }
        }
        const assignmentExpr = {
          type: "ExpressionStatement",
          expression: {
            type: "AssignmentExpression",
            operator: "=",
            left: targetVarRef,
            right: decl.init ? isArrowFunction || isArrayPatternVar ? decl.init : {
              type: "CallExpression",
              callee: {
                type: "MemberExpression",
                object: {
                  type: "Identifier",
                  name: CONTEXT_NAME
                },
                property: {
                  type: "Identifier",
                  name: "init"
                },
                computed: false
              },
              arguments: isArrayInit ? [targetVarRef, decl.init.object, decl.init.property] : [targetVarRef, decl.init]
            } : {
              type: "Identifier",
              name: "undefined"
            }
          }
        };
        if (isArrayPatternVar) {
          assignmentExpr.expression.right.object.property.name += `?.[0][${decl.init.property.value}]`;
          const obj = assignmentExpr.expression.right.object;
          assignmentExpr.expression.right = {
            type: "CallExpression",
            callee: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: CONTEXT_NAME
              },
              property: {
                type: "Identifier",
                name: "init"
              },
              computed: false
            },
            arguments: [
              targetVarRef,
              obj
              /*, decl.init.property.value*/
            ]
          };
        }
        if (isArrowFunction) {
          scopeManager.pushScope("fn");
          recursive(decl.init.body, scopeManager, {
            BlockStatement(node, state, c) {
              node.body.forEach((stmt) => c(stmt, state));
            },
            IfStatement(node, state, c) {
              state.pushScope("if");
              c(node.consequent, state);
              if (node.alternate) {
                state.pushScope("els");
                c(node.alternate, state);
                state.popScope();
              }
              state.popScope();
            },
            VariableDeclaration(node, state) {
              transformVariableDeclaration(node, state);
            },
            Identifier(node, state) {
              transformIdentifier(node, state);
            },
            AssignmentExpression(node, state) {
              transformAssignmentExpression(node, state);
            }
          });
          scopeManager.popScope();
        }
        Object.assign(varNode, assignmentExpr);
      });
    }
    function transformIdentifier(node, scopeManager) {
      if (node.name !== CONTEXT_NAME) {
        if (node.name === "Math" || node.name === "NaN" || node.name === "undefined" || node.name === "Infinity" || node.name === "null" || node.name.startsWith("'") && node.name.endsWith("'") || node.name.startsWith('"') && node.name.endsWith('"') || node.name.startsWith("`") && node.name.endsWith("`")) {
          return;
        }
        if (scopeManager.isLoopVariable(node.name)) {
          return;
        }
        if (scopeManager.isContextBound(node.name) && !scopeManager.isRootParam(node.name)) {
          return;
        }
        const isNamespaceMember = node.parent && node.parent.type === "MemberExpression" && node.parent.object === node && scopeManager.isContextBound(node.name);
        const isParamCall = node.parent && node.parent.type === "CallExpression" && node.parent.callee && node.parent.callee.type === "MemberExpression" && node.parent.callee.property.name === "param";
        node.parent && node.parent.type === "AssignmentExpression" && node.parent.left === node;
        const isNamespaceFunctionArg = node.parent && node.parent.type === "CallExpression" && node.parent.callee && node.parent.callee.type === "MemberExpression" && scopeManager.isContextBound(node.parent.callee.object.name);
        const isArrayAccess = node.parent && node.parent.type === "MemberExpression" && node.parent.computed;
        const isArrayIndexInNamespaceCall = node.parent && node.parent.type === "MemberExpression" && node.parent.computed && node.parent.property === node && node.parent.parent && node.parent.parent.type === "CallExpression" && node.parent.parent.callee && node.parent.parent.callee.type === "MemberExpression" && scopeManager.isContextBound(node.parent.parent.callee.object.name);
        const isFunctionCall = node.parent && node.parent.type === "CallExpression" && node.parent.callee === node;
        if (isNamespaceMember || isParamCall || isNamespaceFunctionArg || isArrayIndexInNamespaceCall || isFunctionCall) {
          if (isFunctionCall) {
            return;
          }
          const [scopedName2, kind2] = scopeManager.getVariable(node.name);
          Object.assign(node, {
            type: "MemberExpression",
            object: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: CONTEXT_NAME
              },
              property: {
                type: "Identifier",
                name: kind2
              },
              computed: false
            },
            property: {
              type: "Identifier",
              name: scopedName2
            },
            computed: false
          });
          return;
        }
        const [scopedName, kind] = scopeManager.getVariable(node.name);
        const memberExpr = {
          type: "MemberExpression",
          object: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: CONTEXT_NAME
            },
            property: {
              type: "Identifier",
              name: kind
            },
            computed: false
          },
          property: {
            type: "Identifier",
            name: scopedName
          },
          computed: false
        };
        const hasArrayAccess = node.parent && node.parent.type === "MemberExpression" && node.parent.computed && node.parent.object === node;
        if (!hasArrayAccess && !isArrayAccess) {
          Object.assign(node, {
            type: "MemberExpression",
            object: memberExpr,
            property: {
              type: "Literal",
              value: 0
            },
            computed: true
          });
        } else {
          Object.assign(node, memberExpr);
        }
      }
    }
    function transformAssignmentExpression(node, scopeManager) {
      if (node.left.type === "Identifier") {
        const [varName, kind] = scopeManager.getVariable(node.left.name);
        const memberExpr = {
          type: "MemberExpression",
          object: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: CONTEXT_NAME
            },
            property: {
              type: "Identifier",
              name: kind
            },
            computed: false
          },
          property: {
            type: "Identifier",
            name: varName
          },
          computed: false
        };
        node.left = {
          type: "MemberExpression",
          object: memberExpr,
          property: {
            type: "Literal",
            value: 0
          },
          computed: true
        };
      }
      recursive(
        node.right,
        { parent: node.right, inNamespaceCall: false },
        {
          Identifier(node2, state, c) {
            if (node2.name == "na") {
              node2.name = "NaN";
            }
            node2.parent = state.parent;
            transformIdentifier(node2, scopeManager);
            const isBinaryOperation = node2.parent && node2.parent.type === "BinaryExpression";
            const isConditional = node2.parent && node2.parent.type === "ConditionalExpression";
            const isContextBound = scopeManager.isContextBound(node2.name) && !scopeManager.isRootParam(node2.name);
            const hasArrayAccess = node2.parent && node2.parent.type === "MemberExpression" && node2.parent.computed && node2.parent.object === node2;
            const isParamCall = node2.parent && node2.parent._isParamCall;
            const isMemberExpression = node2.parent && node2.parent.type === "MemberExpression";
            const isReserved = node2.name === "NaN";
            if (isContextBound || isConditional || isBinaryOperation) {
              if (node2.type === "MemberExpression") {
                transformArrayIndex(node2, scopeManager);
              } else if (node2.type === "Identifier" && !isMemberExpression && !hasArrayAccess && !isParamCall && !isReserved) {
                addArrayAccess(node2);
              }
            }
          },
          MemberExpression(node2, state, c) {
            transformArrayIndex(node2, scopeManager);
            if (node2.object) {
              c(node2.object, { parent: node2, inNamespaceCall: state.inNamespaceCall });
            }
          },
          CallExpression(node2, state, c) {
            const isNamespaceCall = node2.callee && node2.callee.type === "MemberExpression" && node2.callee.object && node2.callee.object.type === "Identifier" && scopeManager.isContextBound(node2.callee.object.name);
            transformCallExpression(node2, scopeManager);
            node2.arguments.forEach((arg) => c(arg, { parent: node2, inNamespaceCall: isNamespaceCall || state.inNamespaceCall }));
          }
        }
      );
    }
    function transformArrowFunctionParams(node, scopeManager, isRootFunction = false) {
      node.params.forEach((param) => {
        if (param.type === "Identifier") {
          scopeManager.addContextBoundVar(param.name, isRootFunction);
        }
      });
    }
    function transformReturnStatement(node, scopeManager) {
      const curScope = scopeManager.getCurrentScopeType();
      if (node.argument) {
        if (node.argument.type === "ArrayExpression") {
          node.argument.elements = node.argument.elements.map((element) => {
            if (element.type === "Identifier") {
              if (scopeManager.isContextBound(element.name) && !scopeManager.isRootParam(element.name)) {
                return {
                  type: "MemberExpression",
                  object: element,
                  property: {
                    type: "Literal",
                    value: 0
                  },
                  computed: true
                };
              }
              const [scopedName, kind] = scopeManager.getVariable(element.name);
              return {
                type: "MemberExpression",
                object: {
                  type: "MemberExpression",
                  object: {
                    type: "MemberExpression",
                    object: {
                      type: "Identifier",
                      name: CONTEXT_NAME
                    },
                    property: {
                      type: "Identifier",
                      name: kind
                    },
                    computed: false
                  },
                  property: {
                    type: "Identifier",
                    name: scopedName
                  },
                  computed: false
                },
                property: {
                  type: "Literal",
                  value: 0
                },
                computed: true
              };
            } else if (element.type === "MemberExpression") {
              if (element.computed && element.object.type === "Identifier" && scopeManager.isContextBound(element.object.name) && !scopeManager.isRootParam(element.object.name)) {
                return element;
              }
              transformMemberExpression(element, "", scopeManager);
              return element;
            }
            return element;
          });
          node.argument = {
            type: "ArrayExpression",
            elements: [node.argument]
          };
        } else if (node.argument.type === "BinaryExpression") {
          recursive(node.argument, scopeManager, {
            Identifier(node2, state) {
              transformIdentifier(node2, state);
              if (node2.type === "Identifier") {
                addArrayAccess(node2);
              }
            },
            MemberExpression(node2) {
              transformMemberExpression(node2, "", scopeManager);
            }
          });
        } else if (node.argument.type === "ObjectExpression") {
          node.argument.properties = node.argument.properties.map((prop) => {
            if (prop.shorthand) {
              const [scopedName, kind] = scopeManager.getVariable(prop.value.name);
              return {
                type: "Property",
                key: {
                  type: "Identifier",
                  name: prop.key.name
                },
                value: {
                  type: "MemberExpression",
                  object: {
                    type: "MemberExpression",
                    object: {
                      type: "Identifier",
                      name: CONTEXT_NAME
                    },
                    property: {
                      type: "Identifier",
                      name: kind
                    },
                    computed: false
                  },
                  property: {
                    type: "Identifier",
                    name: scopedName
                  },
                  computed: false
                },
                kind: "init",
                method: false,
                shorthand: false,
                computed: false
              };
            }
            return prop;
          });
        } else if (node.argument.type === "Identifier") {
          const [scopedName, kind] = scopeManager.getVariable(node.argument.name);
          node.argument = {
            type: "MemberExpression",
            object: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: CONTEXT_NAME
              },
              property: {
                type: "Identifier",
                name: kind
              },
              computed: false
            },
            property: {
              type: "Identifier",
              name: scopedName
            },
            computed: false
          };
          node.argument = {
            type: "MemberExpression",
            object: node.argument,
            property: {
              type: "Literal",
              value: 0
            },
            computed: true
          };
        }
        if (curScope === "fn") {
          node.argument = {
            type: "CallExpression",
            callee: {
              type: "MemberExpression",
              object: { type: "Identifier", name: CONTEXT_NAME },
              property: { type: "Identifier", name: "precision" }
            },
            arguments: [node.argument]
          };
        }
      }
    }
    function transformIdentifierForParam(node, scopeManager) {
      if (node.type === "Identifier") {
        if (node.name === "na") {
          node.name = "NaN";
          return node;
        }
        if (scopeManager.isLoopVariable(node.name)) {
          return node;
        }
        if (scopeManager.isRootParam(node.name)) {
          const [scopedName2, kind2] = scopeManager.getVariable(node.name);
          return {
            type: "MemberExpression",
            object: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: CONTEXT_NAME
              },
              property: {
                type: "Identifier",
                name: kind2
              },
              computed: false
            },
            property: {
              type: "Identifier",
              name: scopedName2
            },
            computed: false
          };
        }
        if (scopeManager.isContextBound(node.name)) {
          return node;
        }
        const [scopedName, kind] = scopeManager.getVariable(node.name);
        return {
          type: "MemberExpression",
          object: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: CONTEXT_NAME
            },
            property: {
              type: "Identifier",
              name: kind
            },
            computed: false
          },
          property: {
            type: "Identifier",
            name: scopedName
          },
          computed: false
        };
      }
      return node;
    }
    function getParamFromUnaryExpression(node, scopeManager, namespace) {
      const transformedArgument = transformOperand(node.argument, scopeManager, namespace);
      const unaryExpr = {
        type: "UnaryExpression",
        operator: node.operator,
        prefix: node.prefix,
        argument: transformedArgument,
        start: node.start,
        end: node.end
      };
      return unaryExpr;
    }
    function transformOperand(node, scopeManager, namespace = "") {
      switch (node.type) {
        case "BinaryExpression": {
          return getParamFromBinaryExpression(node, scopeManager, namespace);
        }
        case "MemberExpression": {
          const transformedObject = node.object.type === "Identifier" ? transformIdentifierForParam(node.object, scopeManager) : node.object;
          return {
            type: "MemberExpression",
            object: transformedObject,
            property: node.property,
            computed: node.computed
          };
        }
        case "Identifier": {
          if (scopeManager.isLoopVariable(node.name)) {
            return node;
          }
          const isMemberExprProperty = node.parent && node.parent.type === "MemberExpression" && node.parent.property === node;
          if (isMemberExprProperty) {
            return node;
          }
          const transformedObject = transformIdentifierForParam(node, scopeManager);
          return {
            type: "MemberExpression",
            object: transformedObject,
            property: {
              type: "Literal",
              value: 0
            },
            computed: true
          };
        }
        case "UnaryExpression": {
          return getParamFromUnaryExpression(node, scopeManager, namespace);
        }
      }
      return node;
    }
    function getParamFromBinaryExpression(node, scopeManager, namespace) {
      const transformedLeft = transformOperand(node.left, scopeManager, namespace);
      const transformedRight = transformOperand(node.right, scopeManager, namespace);
      const binaryExpr = {
        type: "BinaryExpression",
        operator: node.operator,
        left: transformedLeft,
        right: transformedRight,
        start: node.start,
        end: node.end
      };
      recursive(binaryExpr, scopeManager, {
        CallExpression(node2, scopeManager2) {
          if (!node2._transformed) {
            transformCallExpression(node2, scopeManager2);
          }
        },
        MemberExpression(node2) {
          transformMemberExpression(node2, "", scopeManager);
        }
      });
      return binaryExpr;
    }
    function getParamFromLogicalExpression(node, scopeManager, namespace) {
      const transformedLeft = transformOperand(node.left, scopeManager, namespace);
      const transformedRight = transformOperand(node.right, scopeManager, namespace);
      const logicalExpr = {
        type: "LogicalExpression",
        operator: node.operator,
        left: transformedLeft,
        right: transformedRight,
        start: node.start,
        end: node.end
      };
      recursive(logicalExpr, scopeManager, {
        CallExpression(node2, scopeManager2) {
          if (!node2._transformed) {
            transformCallExpression(node2, scopeManager2);
          }
        }
      });
      return logicalExpr;
    }
    function getParamFromConditionalExpression(node, scopeManager, namespace) {
      recursive(
        node,
        { parent: node, inNamespaceCall: false },
        {
          Identifier(node2, state, c) {
            if (node2.name == "NaN") return;
            if (node2.name == "na") {
              node2.name = "NaN";
              return;
            }
            node2.parent = state.parent;
            transformIdentifier(node2, scopeManager);
            const isBinaryOperation = node2.parent && node2.parent.type === "BinaryExpression";
            const isConditional = node2.parent && node2.parent.type === "ConditionalExpression";
            if (isConditional || isBinaryOperation) {
              if (node2.type === "MemberExpression") {
                transformArrayIndex(node2, scopeManager);
              } else if (node2.type === "Identifier") {
                addArrayAccess(node2);
              }
            }
          },
          MemberExpression(node2, state, c) {
            transformArrayIndex(node2, scopeManager);
            if (node2.object) {
              c(node2.object, { parent: node2, inNamespaceCall: state.inNamespaceCall });
            }
          },
          CallExpression(node2, state, c) {
            const isNamespaceCall = node2.callee && node2.callee.type === "MemberExpression" && node2.callee.object && node2.callee.object.type === "Identifier" && scopeManager.isContextBound(node2.callee.object.name);
            transformCallExpression(node2, scopeManager);
            node2.arguments.forEach((arg) => c(arg, { parent: node2, inNamespaceCall: isNamespaceCall || state.inNamespaceCall }));
          }
        }
      );
      return {
        type: "CallExpression",
        callee: {
          type: "MemberExpression",
          object: { type: "Identifier", name: namespace },
          property: { type: "Identifier", name: "param" }
        },
        arguments: [node, UNDEFINED_ARG, scopeManager.nextParamIdArg],
        _transformed: true,
        _isParamCall: true
      };
    }
    function transformFunctionArgument(arg, namespace, scopeManager) {
      switch (arg?.type) {
        case "BinaryExpression":
          arg = getParamFromBinaryExpression(arg, scopeManager, namespace);
          break;
        case "LogicalExpression":
          arg = getParamFromLogicalExpression(arg, scopeManager, namespace);
          break;
        case "ConditionalExpression":
          return getParamFromConditionalExpression(arg, scopeManager, namespace);
        case "UnaryExpression":
          arg = getParamFromUnaryExpression(arg, scopeManager, namespace);
          break;
      }
      const isArrayAccess = arg.type === "MemberExpression" && arg.computed && arg.property;
      if (isArrayAccess) {
        const transformedObject = arg.object.type === "Identifier" && scopeManager.isContextBound(arg.object.name) && !scopeManager.isRootParam(arg.object.name) ? arg.object : transformIdentifierForParam(arg.object, scopeManager);
        const transformedProperty = arg.property.type === "Identifier" && !scopeManager.isContextBound(arg.property.name) && !scopeManager.isLoopVariable(arg.property.name) ? transformIdentifierForParam(arg.property, scopeManager) : arg.property;
        return {
          type: "CallExpression",
          callee: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: namespace
            },
            property: {
              type: "Identifier",
              name: "param"
            },
            computed: false
          },
          arguments: [transformedObject, transformedProperty, scopeManager.nextParamIdArg],
          _transformed: true,
          _isParamCall: true
        };
      }
      if (arg.type === "ObjectExpression") {
        arg.properties = arg.properties.map((prop) => {
          if (prop.value.name) {
            const [scopedName, kind] = scopeManager.getVariable(prop.value.name);
            return {
              type: "Property",
              key: {
                type: "Identifier",
                name: prop.key.name
              },
              value: {
                type: "MemberExpression",
                object: {
                  type: "MemberExpression",
                  object: {
                    type: "Identifier",
                    name: CONTEXT_NAME
                  },
                  property: {
                    type: "Identifier",
                    name: kind
                  },
                  computed: false
                },
                property: {
                  type: "Identifier",
                  name: scopedName
                },
                computed: false
              },
              kind: "init",
              method: false,
              shorthand: false,
              computed: false
            };
          }
          return prop;
        });
      }
      if (arg.type === "Identifier") {
        if (arg.name === "na") {
          arg.name = "NaN";
          return arg;
        }
        if (scopeManager.isContextBound(arg.name) && !scopeManager.isRootParam(arg.name)) {
          return {
            type: "CallExpression",
            callee: {
              type: "MemberExpression",
              object: {
                type: "Identifier",
                name: namespace
              },
              property: {
                type: "Identifier",
                name: "param"
              },
              computed: false
            },
            arguments: [arg, UNDEFINED_ARG, scopeManager.nextParamIdArg],
            _transformed: true,
            _isParamCall: true
          };
        }
      }
      if (arg?.type === "CallExpression") {
        transformCallExpression(arg, scopeManager);
      }
      return {
        type: "CallExpression",
        callee: {
          type: "MemberExpression",
          object: {
            type: "Identifier",
            name: namespace
          },
          property: {
            type: "Identifier",
            name: "param"
          },
          computed: false
        },
        arguments: [arg.type === "Identifier" ? transformIdentifierForParam(arg, scopeManager) : arg, UNDEFINED_ARG, scopeManager.nextParamIdArg],
        _transformed: true,
        _isParamCall: true
      };
    }
    function transformCallExpression(node, scopeManager, namespace) {
      if (node._transformed) {
        return;
      }
      const isNamespaceCall = node.callee && node.callee.type === "MemberExpression" && node.callee.object && node.callee.object.type === "Identifier" && (scopeManager.isContextBound(node.callee.object.name) || node.callee.object.name === "math" || node.callee.object.name === "ta");
      if (isNamespaceCall) {
        const namespace2 = node.callee.object.name;
        node.arguments = node.arguments.map((arg) => {
          if (arg._isParamCall) {
            return arg;
          }
          return transformFunctionArgument(arg, namespace2, scopeManager);
        });
        node._transformed = true;
      } else if (node.callee && node.callee.type === "Identifier") {
        node.arguments = node.arguments.map((arg) => {
          if (arg._isParamCall) {
            return arg;
          }
          return transformFunctionArgument(arg, CONTEXT_NAME, scopeManager);
        });
        node._transformed = true;
      }
      node.arguments.forEach((arg) => {
        recursive(arg, scopeManager, {
          Identifier(node2, state, c) {
            node2.parent = state.parent;
            transformIdentifier(node2, scopeManager);
            const isBinaryOperation = node2.parent && node2.parent.type === "BinaryExpression";
            const isConditional = node2.parent && node2.parent.type === "ConditionalExpression";
            if (isConditional || isBinaryOperation) {
              if (node2.type === "MemberExpression") {
                transformArrayIndex(node2, scopeManager);
              } else if (node2.type === "Identifier") {
                addArrayAccess(node2);
              }
            }
          },
          CallExpression(node2, state, c) {
            if (!node2._transformed) {
              transformCallExpression(node2, state);
            }
          },
          MemberExpression(node2, state, c) {
            transformMemberExpression(node2, "", scopeManager);
            if (node2.object) {
              c(node2.object, { parent: node2, inNamespaceCall: state.inNamespaceCall });
            }
          }
        });
      });
    }
    function transformFunctionDeclaration(node, scopeManager) {
      node.params.forEach((param) => {
        if (param.type === "Identifier") {
          scopeManager.addContextBoundVar(param.name, false);
        }
      });
      if (node.body && node.body.type === "BlockStatement") {
        scopeManager.pushScope("fn");
        recursive(node.body, scopeManager, {
          BlockStatement(node2, state, c) {
            node2.body.forEach((stmt) => c(stmt, state));
          },
          ReturnStatement(node2, state) {
            transformReturnStatement(node2, state);
          },
          VariableDeclaration(node2, state) {
            transformVariableDeclaration(node2, state);
          },
          Identifier(node2, state) {
            transformIdentifier(node2, state);
          },
          CallExpression(node2, state) {
            transformCallExpression(node2, state);
            node2.arguments.forEach((arg) => {
              if (arg.type === "BinaryExpression") {
                recursive(arg, state, {
                  CallExpression(node3, state2) {
                    transformCallExpression(node3, state2);
                  },
                  MemberExpression(node3) {
                    transformMemberExpression(node3, "", state);
                  }
                });
              }
            });
          },
          MemberExpression(node2) {
            transformMemberExpression(node2, "", scopeManager);
          },
          AssignmentExpression(node2, state) {
            transformAssignmentExpression(node2, state);
          },
          ForStatement(node2, state, c) {
            transformForStatement(node2, state, c);
          },
          IfStatement(node2, state, c) {
            transformIfStatement(node2, state, c);
          },
          BinaryExpression(node2, state, c) {
            recursive(node2, state, {
              CallExpression(node3, state2) {
                transformCallExpression(node3, state2);
              },
              MemberExpression(node3) {
                transformMemberExpression(node3, "", state);
              }
            });
          }
        });
        scopeManager.popScope();
      }
    }
    function addArrayAccess(node, scopeManager) {
      Object.assign(node, {
        type: "MemberExpression",
        object: {
          type: "Identifier",
          name: node.name,
          start: node.start,
          end: node.end
        },
        property: {
          type: "Literal",
          value: 0
        },
        computed: true,
        _indexTransformed: true
      });
    }
    function transformForStatement(node, scopeManager, c) {
      if (node.init && node.init.type === "VariableDeclaration") {
        const decl = node.init.declarations[0];
        const originalName = decl.id.name;
        scopeManager.addLoopVariable(originalName, originalName);
        node.init = {
          type: "VariableDeclaration",
          kind: node.init.kind,
          declarations: [
            {
              type: "VariableDeclarator",
              id: {
                type: "Identifier",
                name: originalName
              },
              init: decl.init
            }
          ]
        };
        if (decl.init) {
          recursive(decl.init, scopeManager, {
            Identifier(node2, state) {
              if (!scopeManager.isLoopVariable(node2.name)) {
                scopeManager.pushScope("for");
                transformIdentifier(node2, state);
                scopeManager.popScope();
              }
            },
            MemberExpression(node2) {
              scopeManager.pushScope("for");
              transformMemberExpression(node2, "", scopeManager);
              scopeManager.popScope();
            }
          });
        }
      }
      if (node.test) {
        recursive(node.test, scopeManager, {
          Identifier(node2, state) {
            if (!scopeManager.isLoopVariable(node2.name) && !node2.computed) {
              scopeManager.pushScope("for");
              transformIdentifier(node2, state);
              if (node2.type === "Identifier") {
                node2.computed = true;
                addArrayAccess(node2);
              }
              scopeManager.popScope();
            }
          },
          MemberExpression(node2) {
            scopeManager.pushScope("for");
            transformMemberExpression(node2, "", scopeManager);
            scopeManager.popScope();
          }
        });
      }
      if (node.update) {
        recursive(node.update, scopeManager, {
          Identifier(node2, state) {
            if (!scopeManager.isLoopVariable(node2.name)) {
              scopeManager.pushScope("for");
              transformIdentifier(node2, state);
              scopeManager.popScope();
            }
          }
        });
      }
      scopeManager.pushScope("for");
      c(node.body, scopeManager);
      scopeManager.popScope();
    }
    function transformExpression(node, scopeManager) {
      recursive(node, scopeManager, {
        MemberExpression(node2) {
          transformMemberExpression(node2, "", scopeManager);
        },
        CallExpression(node2, state) {
          transformCallExpression(node2, state);
        },
        Identifier(node2, state) {
          transformIdentifier(node2, state);
          const isIfStatement = scopeManager.getCurrentScopeType() === "if";
          const isContextBound = scopeManager.isContextBound(node2.name) && !scopeManager.isRootParam(node2.name);
          if (isContextBound && isIfStatement) {
            addArrayAccess(node2);
          }
        }
      });
    }
    function transformIfStatement(node, scopeManager, c) {
      if (node.test) {
        scopeManager.pushScope("if");
        transformExpression(node.test, scopeManager);
        scopeManager.popScope();
      }
      scopeManager.pushScope("if");
      c(node.consequent, scopeManager);
      scopeManager.popScope();
      if (node.alternate) {
        scopeManager.pushScope("els");
        c(node.alternate, scopeManager);
        scopeManager.popScope();
      }
    }
    function transformNestedArrowFunctions(ast) {
      recursive(ast, null, {
        VariableDeclaration(node, state, c) {
          if (node.declarations && node.declarations.length > 0) {
            const declarations = node.declarations;
            declarations.forEach((decl) => {
              if (decl.init && decl.init.type === "ArrowFunctionExpression") {
                const isRootFunction = decl.init.start === 0;
                if (!isRootFunction) {
                  const functionDeclaration = {
                    type: "FunctionDeclaration",
                    id: decl.id,
                    // Use the variable name as function name
                    params: decl.init.params,
                    body: decl.init.body.type === "BlockStatement" ? decl.init.body : {
                      type: "BlockStatement",
                      body: [
                        {
                          type: "ReturnStatement",
                          argument: decl.init.body
                        }
                      ]
                    },
                    async: decl.init.async,
                    generator: false
                  };
                  Object.assign(node, functionDeclaration);
                }
              }
            });
          }
          if (node.body && node.body.body) {
            node.body.body.forEach((stmt) => c(stmt, state));
          }
        }
      });
    }
    function preProcessContextBoundVars(ast, scopeManager) {
      simple(ast, {
        VariableDeclaration(node) {
          node.declarations.forEach((decl) => {
            const isContextProperty = decl.init && decl.init.type === "MemberExpression" && decl.init.object && (decl.init.object.name === "context" || decl.init.object.name === CONTEXT_NAME || decl.init.object.name === "context2");
            const isSubContextProperty = decl.init && decl.init.type === "MemberExpression" && decl.init.object?.object && (decl.init.object.object.name === "context" || decl.init.object.object.name === CONTEXT_NAME || decl.init.object.object.name === "context2");
            if (isContextProperty || isSubContextProperty) {
              if (decl.id.name) {
                scopeManager.addContextBoundVar(decl.id.name);
              }
              if (decl.id.properties) {
                decl.id.properties.forEach((property) => {
                  if (property.key.name) {
                    scopeManager.addContextBoundVar(property.key.name);
                  }
                });
              }
            }
          });
        }
      });
    }
    function transpile(fn) {
      let code = typeof fn === "function" ? fn.toString() : fn;
      const ast = parse(code.trim(), {
        ecmaVersion: "latest",
        sourceType: "module"
      });
      transformNestedArrowFunctions(ast);
      const scopeManager = new ScopeManager();
      let originalParamName;
      preProcessContextBoundVars(ast, scopeManager);
      simple(ast, {
        FunctionDeclaration(node) {
          transformFunctionDeclaration(node, scopeManager);
        },
        ArrowFunctionExpression(node) {
          const isRootFunction = node.start === 0;
          if (isRootFunction && node.params && node.params.length > 0) {
            originalParamName = node.params[0].name;
            node.params[0].name = CONTEXT_NAME;
          }
          transformArrowFunctionParams(node, scopeManager, isRootFunction);
        },
        VariableDeclaration(node) {
          node.declarations.forEach((decl) => {
            if (decl.id.type === "ArrayPattern") {
              const tempVarName = scopeManager.generateTempVar();
              const tempVarDecl = {
                type: "VariableDeclaration",
                kind: node.kind,
                declarations: [
                  {
                    type: "VariableDeclarator",
                    id: {
                      type: "Identifier",
                      name: tempVarName
                    },
                    init: decl.init
                  }
                ]
              };
              decl.id.elements?.forEach((element) => {
                if (element.type === "Identifier") {
                  scopeManager.addArrayPatternElement(element.name);
                }
              });
              const individualDecls = decl.id.elements.map((element, index) => ({
                type: "VariableDeclaration",
                kind: node.kind,
                declarations: [
                  {
                    type: "VariableDeclarator",
                    id: element,
                    init: {
                      type: "MemberExpression",
                      object: {
                        type: "Identifier",
                        name: tempVarName
                      },
                      property: {
                        type: "Literal",
                        value: index
                      },
                      computed: true
                    }
                  }
                ]
              }));
              Object.assign(node, {
                type: "BlockStatement",
                body: [tempVarDecl, ...individualDecls]
              });
            }
          });
        },
        ForStatement(node) {
        }
      });
      recursive(ast, scopeManager, {
        BlockStatement(node, state, c) {
          node.body.forEach((stmt) => c(stmt, state));
        },
        ReturnStatement(node, state) {
          transformReturnStatement(node, state);
        },
        VariableDeclaration(node, state) {
          transformVariableDeclaration(node, state);
        },
        Identifier(node, state) {
          transformIdentifier(node, state);
        },
        CallExpression(node, state) {
          transformCallExpression(node, state);
        },
        MemberExpression(node) {
          transformMemberExpression(node, originalParamName, scopeManager);
        },
        AssignmentExpression(node, state) {
          transformAssignmentExpression(node, state);
        },
        FunctionDeclaration(node, state) {
          return;
        },
        ForStatement(node, state, c) {
          transformForStatement(node, state, c);
        },
        IfStatement(node, state, c) {
          transformIfStatement(node, state, c);
        }
      });
      const transformedCode = generate(ast);
      const _wraperFunction = new Function("", `return ${transformedCode}`);
      return _wraperFunction(this);
    }

    var __defProp$6 = Object.defineProperty;
    var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$6 = (obj, key, value) => __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
    class PineTS {
      constructor(source, tickerId, timeframe, limit, sDate, eDate) {
        this.source = source;
        this.tickerId = tickerId;
        this.timeframe = timeframe;
        this.limit = limit;
        this.sDate = sDate;
        this.eDate = eDate;
        __publicField$6(this, "data", []);
        //#region [Pine Script built-in variables]
        __publicField$6(this, "open", []);
        __publicField$6(this, "high", []);
        __publicField$6(this, "low", []);
        __publicField$6(this, "close", []);
        __publicField$6(this, "volume", []);
        __publicField$6(this, "hl2", []);
        __publicField$6(this, "hlc3", []);
        __publicField$6(this, "ohlc4", []);
        __publicField$6(this, "openTime", []);
        __publicField$6(this, "closeTime", []);
        //#endregion
        //#region run context
        __publicField$6(this, "_periods");
        //#endregion
        //public fn: Function;
        __publicField$6(this, "_readyPromise", null);
        __publicField$6(this, "_ready", false);
        this._readyPromise = new Promise((resolve) => {
          this.loadMarketData(source, tickerId, timeframe, limit, sDate, eDate).then((data) => {
            const marketData = data.reverse();
            this._periods = marketData.length;
            this.data = marketData;
            const _open = marketData.map((d) => d.open);
            const _close = marketData.map((d) => d.close);
            const _high = marketData.map((d) => d.high);
            const _low = marketData.map((d) => d.low);
            const _volume = marketData.map((d) => d.volume);
            const _hlc3 = marketData.map((d) => (d.high + d.low + d.close) / 3);
            const _hl2 = marketData.map((d) => (d.high + d.low) / 2);
            const _ohlc4 = marketData.map((d) => (d.high + d.low + d.open + d.close) / 4);
            const _openTime = marketData.map((d) => d.openTime);
            const _closeTime = marketData.map((d) => d.closeTime);
            this.open = _open;
            this.close = _close;
            this.high = _high;
            this.low = _low;
            this.volume = _volume;
            this.hl2 = _hl2;
            this.hlc3 = _hlc3;
            this.ohlc4 = _ohlc4;
            this.openTime = _openTime;
            this.closeTime = _closeTime;
            this._ready = true;
            resolve(true);
          });
        });
      }
      get periods() {
        return this._periods;
      }
      async loadMarketData(source, tickerId, timeframe, limit, sDate, eDate) {
        if (Array.isArray(source)) {
          return source;
        } else {
          return source.getMarketData(tickerId, timeframe, limit, sDate, eDate);
        }
      }
      async ready() {
        if (this._ready) return true;
        if (!this._readyPromise) throw new Error("PineTS is not ready");
        return this._readyPromise;
      }
      async run(pineTSCode, n, useTACache) {
        await this.ready();
        if (!n) n = this._periods;
        const context = new Context({
          marketData: this.data,
          source: this.source,
          tickerId: this.tickerId,
          timeframe: this.timeframe,
          limit: this.limit,
          sDate: this.sDate,
          eDate: this.eDate
        });
        context.pineTSCode = pineTSCode;
        context.useTACache = useTACache;
        const transformer = transpile.bind(this);
        let transpiledFn = transformer(pineTSCode);
        const contextVarNames = ["const", "var", "let", "params"];
        for (let i = this._periods - n, idx = n - 1; i < this._periods; i++, idx--) {
          context.idx = i;
          context.data.close = this.close.slice(idx);
          context.data.open = this.open.slice(idx);
          context.data.high = this.high.slice(idx);
          context.data.low = this.low.slice(idx);
          context.data.volume = this.volume.slice(idx);
          context.data.hl2 = this.hl2.slice(idx);
          context.data.hlc3 = this.hlc3.slice(idx);
          context.data.ohlc4 = this.ohlc4.slice(idx);
          context.data.openTime = this.openTime.slice(idx);
          context.data.closeTime = this.closeTime.slice(idx);
          const result = await transpiledFn(context);
          if (typeof result === "object") {
            if (typeof context.result !== "object") {
              context.result = {};
            }
            for (let key in result) {
              if (context.result[key] === void 0) {
                context.result[key] = [];
              }
              const val = Array.isArray(result[key]) ? result[key][0] : result[key];
              context.result[key].push(val);
            }
          } else {
            if (!Array.isArray(context.result)) {
              context.result = [];
            }
            context.result.push(result);
          }
          for (let ctxVarName of contextVarNames) {
            for (let key in context[ctxVarName]) {
              if (Array.isArray(context[ctxVarName][key])) {
                const val = context[ctxVarName][key][0];
                context[ctxVarName][key].unshift(val);
              }
            }
          }
        }
        return context;
      }
    }

    var __defProp$5 = Object.defineProperty;
    var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$5 = (obj, key, value) => __defNormalProp$5(obj, key + "" , value);
    class Core {
      constructor(context) {
        this.context = context;
        __publicField$5(this, "color", {
          param: (source, index = 0) => {
            if (Array.isArray(source)) {
              return source[index];
            }
            return source;
          },
          rgb: (r, g, b, a) => a ? `rgba(${r}, ${g}, ${b}, ${a})` : `rgb(${r}, ${g}, ${b})`,
          new: (color, a) => {
            if (color && color.startsWith("#")) {
              const hex = color.slice(1);
              const r = parseInt(hex.slice(0, 2), 16);
              const g = parseInt(hex.slice(2, 4), 16);
              const b = parseInt(hex.slice(4, 6), 16);
              return a ? `rgba(${r}, ${g}, ${b}, ${a})` : `rgb(${r}, ${g}, ${b})`;
            }
            return a ? `rgba(${color}, ${a})` : color;
          },
          white: "white",
          lime: "lime",
          green: "green",
          red: "red",
          maroon: "maroon",
          black: "black",
          gray: "gray",
          blue: "blue"
        });
      }
      extractPlotOptions(options) {
        const _options = {};
        for (let key in options) {
          if (Array.isArray(options[key])) {
            _options[key] = options[key][0];
          } else {
            _options[key] = options[key];
          }
        }
        return _options;
      }
      indicator(title, shorttitle, options) {
      }
      //in the current implementation, plot functions are only used to collect data for the plots array and map it to the market data
      plotchar(series, title, options) {
        if (!this.context.plots[title]) {
          this.context.plots[title] = { data: [], options: this.extractPlotOptions(options), title };
        }
        this.context.plots[title].data.push({
          time: this.context.marketData[this.context.marketData.length - this.context.idx - 1].openTime,
          value: series[0],
          options: { ...this.extractPlotOptions(options), style: "char" }
        });
      }
      plot(series, title, options) {
        if (!this.context.plots[title]) {
          this.context.plots[title] = { data: [], options: this.extractPlotOptions(options), title };
        }
        this.context.plots[title].data.push({
          time: this.context.marketData[this.context.marketData.length - this.context.idx - 1].openTime,
          value: series[0],
          options: this.extractPlotOptions(options)
        });
      }
      na(series) {
        return Array.isArray(series) ? isNaN(series[0]) : isNaN(series);
      }
      nz(series, replacement = 0) {
        const val = Array.isArray(series) ? series[0] : series;
        const rep = Array.isArray(series) ? replacement[0] : replacement;
        return isNaN(val) ? rep : val;
      }
    }

    class Input {
      constructor(context) {
        this.context = context;
      }
      param(source, index = 0) {
        if (Array.isArray(source)) {
          return [source[index]];
        }
        return [source];
      }
      any(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      int(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      float(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      bool(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      string(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      timeframe(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      time(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      price(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      session(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      source(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      symbol(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      text_area(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      enum(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
      color(value, { title, group } = {}) {
        return Array.isArray(value) ? value[0] : value;
      }
    }

    var __defProp$4 = Object.defineProperty;
    var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$4 = (obj, key, value) => __defNormalProp$4(obj, key + "" , value);
    class PineMath {
      constructor(context) {
        this.context = context;
        __publicField$4(this, "_cache", {});
      }
      param(source, index, name) {
        if (!this.context.params[name]) this.context.params[name] = [];
        if (Array.isArray(source)) {
          if (index) {
            this.context.params[name] = source.slice(index);
            this.context.params[name].length = source.length;
            return this.context.params[name];
          }
          this.context.params[name] = source.slice(0);
          return this.context.params[name];
        } else {
          this.context.params[name][0] = source;
          return this.context.params[name];
        }
      }
      abs(source) {
        return Math.abs(source[0]);
      }
      pow(source, power) {
        return Math.pow(source[0], power[0]);
      }
      sqrt(source) {
        return Math.sqrt(source[0]);
      }
      log(source) {
        return Math.log(source[0]);
      }
      ln(source) {
        return Math.log(source[0]);
      }
      exp(source) {
        return Math.exp(source[0]);
      }
      floor(source) {
        return Math.floor(source[0]);
      }
      ceil(source) {
        return Math.ceil(source[0]);
      }
      round(source) {
        return Math.round(source[0]);
      }
      random() {
        return Math.random();
      }
      max(...source) {
        const arg = source.map((e) => Array.isArray(e) ? e[0] : e);
        return Math.max(...arg);
      }
      min(...source) {
        const arg = source.map((e) => Array.isArray(e) ? e[0] : e);
        return Math.min(...arg);
      }
      //sum of last n values
      sum(source, length) {
        const len = Array.isArray(length) ? length[0] : length;
        if (Array.isArray(source)) {
          return source.slice(0, len).reduce((a, b) => a + b, 0);
        }
        return source;
      }
      sin(source) {
        return Math.sin(source[0]);
      }
      cos(source) {
        return Math.cos(source[0]);
      }
      tan(source) {
        return Math.tan(source[0]);
      }
      acos(source) {
        return Math.acos(source[0]);
      }
      asin(source) {
        return Math.asin(source[0]);
      }
      atan(source) {
        return Math.atan(source[0]);
      }
      avg(...sources) {
        const args = sources.map((e) => Array.isArray(e) ? e[0] : e);
        return args.reduce((a, b) => {
          const aVal = Array.isArray(a) ? a[0] : a;
          const bVal = Array.isArray(b) ? b[0] : b;
          return aVal + bVal;
        }, 0) / args.length;
      }
    }

    var __defProp$3 = Object.defineProperty;
    var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$3 = (obj, key, value) => __defNormalProp$3(obj, key + "" , value);
    const TIMEFRAMES = ["1", "3", "5", "15", "30", "45", "60", "120", "180", "240", "D", "W", "M"];
    class PineRequest {
      constructor(context) {
        this.context = context;
        __publicField$3(this, "_cache", {});
      }
      param(source, index, name) {
        if (!this.context.params[name]) this.context.params[name] = [];
        if (Array.isArray(source)) {
          if (index) {
            this.context.params[name] = source.slice(index);
          } else {
            this.context.params[name] = source.slice(0);
          }
          return [source[index], name];
        } else {
          this.context.params[name][0] = source;
          return [source, name];
        }
      }
      async security(symbol, timeframe, expression, gaps = false, lookahead = false, ignore_invalid_symbol = false, currency = null, calc_bars_count = null) {
        const _symbol = symbol[0];
        const _timeframe = timeframe[0];
        const _expression = expression[0];
        const _expression_name = expression[1];
        const ctxTimeframeIdx = TIMEFRAMES.indexOf(this.context.timeframe);
        const reqTimeframeIdx = TIMEFRAMES.indexOf(_timeframe);
        if (ctxTimeframeIdx == -1 || reqTimeframeIdx == -1) {
          throw new Error("Invalid timeframe");
        }
        if (ctxTimeframeIdx > reqTimeframeIdx) {
          throw new Error("Only higher timeframes are supported for now");
        }
        if (ctxTimeframeIdx === reqTimeframeIdx) {
          return _expression;
        }
        const myOpenTime = this.context.data.openTime[0];
        const myCloseTime = this.context.data.closeTime[0];
        if (this.context.cache[_expression_name]) {
          const secContext2 = this.context.cache[_expression_name];
          const secContextIdx2 = this._findSecContextIdx(myOpenTime, myCloseTime, secContext2.data.openTime, secContext2.data.closeTime, lookahead);
          return secContextIdx2 == -1 ? NaN : secContext2.params[_expression_name][secContextIdx2];
        }
        const pineTS = new PineTS(this.context.source, _symbol, _timeframe, this.context.limit || 1e3, this.context.sDate, this.context.eDate);
        const secContext = await pineTS.run(this.context.pineTSCode);
        this.context.cache[_expression_name] = secContext;
        const secContextIdx = this._findSecContextIdx(myOpenTime, myCloseTime, secContext.data.openTime, secContext.data.closeTime, lookahead);
        return secContextIdx == -1 ? NaN : secContext.params[_expression_name][secContextIdx];
      }
      _findSecContextIdx(myOpenTime, myCloseTime, openTime, closeTime, lookahead = false) {
        for (let i = 0; i < openTime.length; i++) {
          if (openTime[i] <= myOpenTime && myCloseTime <= closeTime[i]) {
            return i + (lookahead ? 1 : 2);
          }
        }
        return -1;
      }
    }

    class TechnicalAnalysis {
      constructor(context) {
        this.context = context;
      }
      get tr() {
        const val = this.context.math.max(
          this.context.data.high[0] - this.context.data.low[0],
          this.context.math.abs(this.context.data.high[0] - this.context.data.close[1]),
          this.context.math.abs(this.context.data.low[0] - this.context.data.close[1])
        );
        return val;
      }
      param(source, index, name) {
        if (!this.context.params[name]) this.context.params[name] = [];
        if (Array.isArray(source)) {
          if (index) {
            this.context.params[name] = source.slice(index);
            this.context.params[name].length = source.length;
            return this.context.params[name];
          }
          this.context.params[name] = source.slice(0);
          return this.context.params[name];
        } else {
          this.context.params[name][0] = source;
          return this.context.params[name];
        }
      }
      ema(source, _period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const result = ema(source.slice(0).reverse(), period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      sma(source, _period, _cacheId) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const reversedSource = source.slice(0).reverse();
        if (this.context.useTACache && _cacheId) {
          if (!this.context.cache[_cacheId]) {
            this.context.cache[_cacheId] = {};
          }
          const cacheObj = this.context.cache[_cacheId];
          if (cacheObj) {
            const result2 = sma_cache(reversedSource, period, cacheObj);
            const idx2 = this.context.idx;
            return this.context.precision(result2[idx2]);
          }
        }
        const result = sma(reversedSource, period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      vwma(source, _period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const volume = this.context.data.volume;
        const result = vwma(source.slice(0).reverse(), volume.slice(0).reverse(), period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      wma(source, _period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const result = wma(source.slice(0).reverse(), period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      hma(source, _period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const result = hma(source.slice(0).reverse(), period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      rma(source, _period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const result = rma(source.slice(0).reverse(), period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      change(source, _length = 1) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = change$1(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      rsi(source, _period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const result = rsi(source.slice(0).reverse(), period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      atr(_period) {
        const period = Array.isArray(_period) ? _period[0] : _period;
        const high = this.context.data.high.slice().reverse();
        const low = this.context.data.low.slice().reverse();
        const close = this.context.data.close.slice().reverse();
        const result = atr(high, low, close, period);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      mom(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = mom(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      roc(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = roc(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      dev(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = dev(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      variance(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = variance$1(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      highest(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = highest(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      lowest(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = lowest(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      median(source, _length) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const result = median$1(source.slice(0).reverse(), length);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      stdev(source, _length, _bias = true) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const bias = Array.isArray(_bias) ? _bias[0] : _bias;
        const result = stdev(source.slice(0).reverse(), length, bias);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      linreg(source, _length, _offset) {
        const length = Array.isArray(_length) ? _length[0] : _length;
        const offset = Array.isArray(_offset) ? _offset[0] : _offset;
        const result = linreg(source.slice(0).reverse(), length, offset);
        const idx = this.context.idx;
        return this.context.precision(result[idx]);
      }
      supertrend(_factor, _atrPeriod) {
        const factor = Array.isArray(_factor) ? _factor[0] : _factor;
        const atrPeriod = Array.isArray(_atrPeriod) ? _atrPeriod[0] : _atrPeriod;
        const high = this.context.data.high.slice().reverse();
        const low = this.context.data.low.slice().reverse();
        const close = this.context.data.close.slice().reverse();
        const [supertrend, direction] = calculateSupertrend(high, low, close, factor, atrPeriod);
        const idx = this.context.idx;
        return [[this.context.precision(supertrend[idx]), direction[idx]]];
      }
    }
    function atr(high, low, close, period) {
      const tr = new Array(high.length);
      tr[0] = high[0] - low[0];
      for (let i = 1; i < high.length; i++) {
        const hl = high[i] - low[i];
        const hc = Math.abs(high[i] - close[i - 1]);
        const lc = Math.abs(low[i] - close[i - 1]);
        tr[i] = Math.max(hl, hc, lc);
      }
      const atr2 = new Array(high.length).fill(NaN);
      let sum = 0;
      for (let i = 0; i < period; i++) {
        sum += tr[i];
      }
      atr2[period - 1] = sum / period;
      for (let i = period; i < tr.length; i++) {
        atr2[i] = (atr2[i - 1] * (period - 1) + tr[i]) / period;
      }
      return atr2;
    }
    function ema(source, period) {
      const result = new Array(source.length).fill(NaN);
      const alpha = 2 / (period + 1);
      let sum = 0;
      for (let i = 0; i < period; i++) {
        sum += source[i] || 0;
      }
      result[period - 1] = sum / period;
      for (let i = period; i < source.length; i++) {
        result[i] = source[i] * alpha + result[i - 1] * (1 - alpha);
      }
      return result;
    }
    function rsi(source, period) {
      const result = new Array(source.length).fill(NaN);
      const gains = new Array(source.length).fill(0);
      const losses = new Array(source.length).fill(0);
      for (let i = 1; i < source.length; i++) {
        const diff = source[i] - source[i - 1];
        gains[i] = diff > 0 ? diff : 0;
        losses[i] = diff < 0 ? -diff : 0;
      }
      let avgGain = 0;
      let avgLoss = 0;
      for (let i = 1; i <= period; i++) {
        avgGain += gains[i];
        avgLoss += losses[i];
      }
      avgGain /= period;
      avgLoss /= period;
      result[period] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);
      for (let i = period + 1; i < source.length; i++) {
        avgGain = (avgGain * (period - 1) + gains[i]) / period;
        avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
        result[i] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);
      }
      return result;
    }
    function rma(source, period) {
      const result = new Array(source.length).fill(NaN);
      const alpha = 1 / period;
      let sum = 0;
      for (let i = 0; i < period; i++) {
        sum += source[i] || 0;
      }
      result[period - 1] = sum / period;
      for (let i = period; i < source.length; i++) {
        const currentValue = source[i] || 0;
        result[i] = currentValue * alpha + result[i - 1] * (1 - alpha);
      }
      return result;
    }
    function sma_cache(source, period, cacheObj) {
      const result = cacheObj.previousResult || new Array(source.length).fill(NaN);
      const lastProcessedIndex = cacheObj.lastProcessedIndex || -1;
      let previousSum = cacheObj.previousSum || 0;
      if (lastProcessedIndex === -1 || source.length !== lastProcessedIndex + 1) {
        previousSum = 0;
        for (let i = 0; i < period; i++) {
          previousSum += source[i] || 0;
        }
        result[period - 1] = previousSum / period;
        for (let i = 0; i < period - 1; i++) {
          result[i] = NaN;
        }
        for (let i = period; i < source.length; i++) {
          previousSum = previousSum - (source[i - period] || 0) + (source[i] || 0);
          result[i] = previousSum / period;
        }
      } else if (source.length === lastProcessedIndex + 2) {
        const newIndex = source.length - 1;
        previousSum = previousSum - (source[newIndex - period] || 0) + (source[newIndex] || 0);
        result[newIndex] = previousSum / period;
      } else {
        return sma(source, period);
      }
      cacheObj.previousSum = previousSum;
      cacheObj.lastProcessedIndex = source.length - 1;
      cacheObj.previousResult = result;
      return result;
    }
    function sma(source, period) {
      const result = new Array(source.length).fill(NaN);
      for (let i = period - 1; i < source.length; i++) {
        let sum = 0;
        for (let j = 0; j < period; j++) {
          sum += source[i - j] || 0;
        }
        result[i] = sum / period;
      }
      return result;
    }
    function vwma(source, volume, period) {
      const result = new Array(source.length).fill(NaN);
      for (let i = period - 1; i < source.length; i++) {
        let sumVol = 0;
        let sumVolPrice = 0;
        for (let j = 0; j < period; j++) {
          sumVol += volume[i - j];
          sumVolPrice += source[i - j] * volume[i - j];
        }
        result[i] = sumVolPrice / sumVol;
      }
      return result;
    }
    function hma(source, period) {
      const halfPeriod = Math.floor(period / 2);
      const wma1 = wma(source, halfPeriod);
      const wma2 = wma(source, period);
      const rawHma = wma1.map((value, index) => 2 * value - wma2[index]);
      const sqrtPeriod = Math.floor(Math.sqrt(period));
      const result = wma(rawHma, sqrtPeriod);
      return result;
    }
    function wma(source, period) {
      const result = new Array(source.length);
      for (let i = period - 1; i < source.length; i++) {
        let numerator = 0;
        let denominator = 0;
        for (let j = 0; j < period; j++) {
          numerator += source[i - j] * (period - j);
          denominator += period - j;
        }
        result[i] = numerator / denominator;
      }
      for (let i = 0; i < period - 1; i++) {
        result[i] = NaN;
      }
      return result;
    }
    function change$1(source, length = 1) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length; i < source.length; i++) {
        result[i] = source[i] - source[i - length];
      }
      return result;
    }
    function mom(source, length) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length; i < source.length; i++) {
        result[i] = source[i] - source[i - length];
      }
      return result;
    }
    function roc(source, length) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length; i < source.length; i++) {
        result[i] = (source[i] - source[i - length]) / source[i - length] * 100;
      }
      return result;
    }
    function dev(source, length) {
      const result = new Array(source.length).fill(NaN);
      const smaValues = sma(source, length);
      for (let i = length - 1; i < source.length; i++) {
        let sumDeviation = 0;
        for (let j = 0; j < length; j++) {
          sumDeviation += Math.abs(source[i - j] - smaValues[i]);
        }
        result[i] = sumDeviation / length;
      }
      return result;
    }
    function variance$1(source, length) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length - 1; i < source.length; i++) {
        let sum = 0;
        let sumSquares = 0;
        for (let j = 0; j < length; j++) {
          sum += source[i - j];
          sumSquares += source[i - j] * source[i - j];
        }
        const mean = sum / length;
        result[i] = sumSquares / length - mean * mean;
      }
      return result;
    }
    function highest(source, length) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length - 1; i < source.length; i++) {
        let max = -Infinity;
        for (let j = 0; j < length; j++) {
          const value = source[i - j];
          if (isNaN(value)) {
            max = max === -Infinity ? NaN : max;
          } else {
            max = Math.max(max, value);
          }
        }
        result[i] = max;
      }
      return result;
    }
    function lowest(source, length) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length - 1; i < source.length; i++) {
        let min = Infinity;
        for (let j = 0; j < length; j++) {
          const value = source[i - j];
          if (isNaN(value) || value === void 0) {
            min = min === Infinity ? NaN : min;
          } else {
            min = Math.min(min, value);
          }
        }
        result[i] = min;
      }
      return result;
    }
    function median$1(source, length) {
      const result = new Array(source.length).fill(NaN);
      for (let i = length - 1; i < source.length; i++) {
        const window = source.slice(i - length + 1, i + 1);
        const sorted = window.slice().sort((a, b) => a - b);
        const mid = Math.floor(length / 2);
        result[i] = length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
      }
      return result;
    }
    function stdev(source, length, biased = true) {
      const result = new Array(source.length).fill(NaN);
      const smaValues = sma(source, length);
      for (let i = length - 1; i < source.length; i++) {
        let sum = 0;
        for (let j = 0; j < length; j++) {
          sum += Math.pow(source[i - j] - smaValues[i], 2);
        }
        const divisor = biased ? length : length - 1;
        result[i] = Math.sqrt(sum / divisor);
      }
      return result;
    }
    function linreg(source, length, offset) {
      const size = source.length;
      const output = new Array(size).fill(NaN);
      for (let i = length - 1; i < size; i++) {
        let sumX = 0;
        let sumY = 0;
        let sumXY = 0;
        let sumXX = 0;
        const n = length;
        for (let j = 0; j < length; j++) {
          const x = j;
          const y = source[i - length + 1 + j];
          sumX += x;
          sumY += y;
          sumXY += x * y;
          sumXX += x * x;
        }
        const denominator = n * sumXX - sumX * sumX;
        if (denominator === 0) {
          output[i] = NaN;
          continue;
        }
        const slope = (n * sumXY - sumX * sumY) / denominator;
        const intercept = (sumY - slope * sumX) / n;
        const linRegValue = intercept + slope * (length - 1 - offset);
        output[i] = linRegValue;
      }
      return output;
    }
    function calculateSupertrend(high, low, close, factor, atrPeriod) {
      const length = high.length;
      const supertrend = new Array(length).fill(NaN);
      const direction = new Array(length).fill(0);
      const atrValues = atr(high, low, close, atrPeriod);
      const upperBand = new Array(length).fill(NaN);
      const lowerBand = new Array(length).fill(NaN);
      for (let i = 0; i < length; i++) {
        const hl2 = (high[i] + low[i]) / 2;
        const atrValue = atrValues[i];
        if (!isNaN(atrValue)) {
          upperBand[i] = hl2 + factor * atrValue;
          lowerBand[i] = hl2 - factor * atrValue;
        }
      }
      let prevUpperBand = upperBand[atrPeriod];
      let prevLowerBand = lowerBand[atrPeriod];
      let prevSupertrend = close[atrPeriod] <= prevUpperBand ? prevUpperBand : prevLowerBand;
      let prevDirection = close[atrPeriod] <= prevUpperBand ? -1 : 1;
      supertrend[atrPeriod] = prevSupertrend;
      direction[atrPeriod] = prevDirection;
      for (let i = atrPeriod + 1; i < length; i++) {
        let currentUpperBand = upperBand[i];
        if (currentUpperBand < prevUpperBand || close[i - 1] > prevUpperBand) {
          upperBand[i] = currentUpperBand;
        } else {
          upperBand[i] = prevUpperBand;
        }
        let currentLowerBand = lowerBand[i];
        if (currentLowerBand > prevLowerBand || close[i - 1] < prevLowerBand) {
          lowerBand[i] = currentLowerBand;
        } else {
          lowerBand[i] = prevLowerBand;
        }
        if (prevSupertrend === prevUpperBand) {
          if (close[i] > upperBand[i]) {
            direction[i] = 1;
            supertrend[i] = lowerBand[i];
          } else {
            direction[i] = -1;
            supertrend[i] = upperBand[i];
          }
        } else {
          if (close[i] < lowerBand[i]) {
            direction[i] = -1;
            supertrend[i] = upperBand[i];
          } else {
            direction[i] = 1;
            supertrend[i] = lowerBand[i];
          }
        }
        prevUpperBand = upperBand[i];
        prevLowerBand = lowerBand[i];
        prevSupertrend = supertrend[i];
      }
      return [supertrend, direction];
    }

    var __defProp$2 = Object.defineProperty;
    var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, key + "" , value);
    class PineArrayObject {
      constructor(array) {
        this.array = array;
      }
    }
    class PineArray {
      constructor(context) {
        this.context = context;
        __publicField$2(this, "_cache", {});
      }
      param(source, index = 0) {
        if (Array.isArray(source)) {
          return source[index];
        }
        return source;
      }
      /**
       * This function simulates PineScript's array.get() function
       * @param id - the array object to get the value from
       * @param index - the index of the value to get
       * @returns the value at the given index
       */
      get(id, index) {
        return id.array[index];
      }
      set(id, index, value) {
        id.array[index] = value;
      }
      push(id, value) {
        id.array.push(value);
      }
      // Basic statistics
      sum(id) {
        return id.array.reduce((a, b) => a + (isNaN(b) ? 0 : b), 0);
      }
      avg(id) {
        return this.sum(id) / id.array.length;
      }
      min(id, nth = 0) {
        const sorted = [...id.array].sort((a, b) => a - b);
        return sorted[nth] ?? this.context.NA;
      }
      max(id, nth = 0) {
        const sorted = [...id.array].sort((a, b) => b - a);
        return sorted[nth] ?? this.context.NA;
      }
      size(id) {
        return id.array.length;
      }
      // Array creation
      new_bool(size, initial_value = false) {
        return new PineArrayObject(Array(size).fill(initial_value));
      }
      new_float(size, initial_value = NaN) {
        return new PineArrayObject(Array(size).fill(initial_value));
      }
      new_int(size, initial_value = 0) {
        return new PineArrayObject(Array(size).fill(Math.round(initial_value)));
      }
      new_string(size, initial_value = "") {
        return new PineArrayObject(Array(size).fill(initial_value));
      }
      new(size, initial_value) {
        return new PineArrayObject(Array(size).fill(initial_value));
      }
      // Array operations
      slice(id, start, end) {
        const adjustedEnd = end !== void 0 ? end + 1 : void 0;
        return new PineArrayObject(id.array.slice(start, adjustedEnd));
      }
      reverse(id) {
        id.array.reverse();
      }
      includes(id, value) {
        return id.array.includes(value);
      }
      indexof(id, value) {
        return id.array.indexOf(value);
      }
      lastindexof(id, value) {
        return id.array.lastIndexOf(value);
      }
      // More complex functions
      stdev(id, biased = true) {
        const mean = this.avg(id);
        const deviations = id.array.map((x) => Math.pow(x - mean, 2));
        const divisor = biased ? id.array.length : id.array.length - 1;
        return Math.sqrt(this.sum(new PineArrayObject(deviations)) / divisor);
      }
      variance(id, biased = true) {
        const mean = this.avg(id);
        const deviations = id.array.map((x) => Math.pow(x - mean, 2));
        const divisor = biased ? id.array.length : id.array.length - 1;
        return this.sum(new PineArrayObject(deviations)) / divisor;
      }
      covariance(arr1, arr2, biased = true) {
        if (arr1.array.length !== arr2.array.length || arr1.array.length < 2) return NaN;
        const divisor = biased ? arr1.array.length : arr1.array.length - 1;
        const mean1 = this.avg(arr1);
        const mean2 = this.avg(arr2);
        let sum = 0;
        for (let i = 0; i < arr1.array.length; i++) {
          sum += (arr1.array[i] - mean1) * (arr2.array[i] - mean2);
        }
        return sum / divisor;
      }
      // Additional utility methods
      first(id) {
        return id.array.length > 0 ? id.array[0] : this.context.NA;
      }
      last(id) {
        return id.array.length > 0 ? id.array[id.array.length - 1] : this.context.NA;
      }
      clear(id) {
        id.array.length = 0;
      }
      join(id, separator = ",") {
        return id.array.join(separator);
      }
      /** Array Manipulation Functions */
      abs(id) {
        return new PineArrayObject(id.array.map((val) => Math.abs(val)));
      }
      concat(id, other) {
        id.array.push(...other.array);
        return id;
      }
      copy(id) {
        return new PineArrayObject([...id.array]);
      }
      every(id, callback) {
        return id.array.every(callback);
      }
      fill(id, value, start = 0, end) {
        const length = id.array.length;
        const adjustedEnd = end !== void 0 ? Math.min(end, length) : length;
        for (let i = start; i < adjustedEnd; i++) {
          id.array[i] = value;
        }
      }
      from(source) {
        return new PineArrayObject([...source]);
      }
      insert(id, index, value) {
        id.array.splice(index, 0, value);
      }
      pop(id) {
        return id.array.pop();
      }
      range(id) {
        return this.max(id) - this.min(id);
      }
      remove(id, index) {
        if (index >= 0 && index < id.array.length) {
          return id.array.splice(index, 1)[0];
        }
        return this.context.NA;
      }
      shift(id) {
        return id.array.shift();
      }
      sort(id, order = "asc") {
        id.array.sort((a, b) => order === "asc" ? a - b : b - a);
      }
      sort_indices(id, comparator) {
        const indices = id.array.map((_, index) => index);
        indices.sort((a, b) => {
          const valA = id.array[a];
          const valB = id.array[b];
          return comparator ? comparator(valA, valB) : valA - valB;
        });
        return new PineArrayObject(indices);
      }
      standardize(id) {
        const mean = this.avg(id);
        const stdev = this.stdev(id);
        if (stdev === 0) {
          return new PineArrayObject(id.array.map(() => 0));
        }
        return new PineArrayObject(id.array.map((x) => (x - mean) / stdev));
      }
      unshift(id, value) {
        id.array.unshift(value);
      }
      some(id, callback) {
        return id.array.some(callback);
      }
    }

    var __defProp$1 = Object.defineProperty;
    var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
    class Context {
      constructor({
        marketData,
        source,
        tickerId,
        timeframe,
        limit,
        sDate,
        eDate
      }) {
        __publicField$1(this, "data", {
          open: [],
          high: [],
          low: [],
          close: [],
          volume: [],
          hl2: [],
          hlc3: [],
          ohlc4: []
        });
        __publicField$1(this, "cache", {});
        __publicField$1(this, "useTACache", false);
        __publicField$1(this, "NA", NaN);
        __publicField$1(this, "math");
        __publicField$1(this, "ta");
        __publicField$1(this, "input");
        __publicField$1(this, "request");
        __publicField$1(this, "array");
        __publicField$1(this, "core");
        __publicField$1(this, "lang");
        __publicField$1(this, "idx", 0);
        __publicField$1(this, "params", {});
        __publicField$1(this, "const", {});
        __publicField$1(this, "var", {});
        __publicField$1(this, "let", {});
        __publicField$1(this, "result");
        __publicField$1(this, "plots", {});
        __publicField$1(this, "marketData");
        __publicField$1(this, "source");
        __publicField$1(this, "tickerId");
        __publicField$1(this, "timeframe", "");
        __publicField$1(this, "limit");
        __publicField$1(this, "sDate");
        __publicField$1(this, "eDate");
        __publicField$1(this, "pineTSCode");
        this.marketData = marketData;
        this.source = source;
        this.tickerId = tickerId;
        this.timeframe = timeframe;
        this.limit = limit;
        this.sDate = sDate;
        this.eDate = eDate;
        this.math = new PineMath(this);
        this.ta = new TechnicalAnalysis(this);
        this.input = new Input(this);
        this.request = new PineRequest(this);
        this.array = new PineArray(this);
        const core = new Core(this);
        this.core = {
          plotchar: core.plotchar.bind(core),
          na: core.na.bind(core),
          color: core.color,
          plot: core.plot.bind(core),
          nz: core.nz.bind(core)
        };
      }
      //#region [Runtime functions] ===========================
      /**
       * this function is used to initialize the target variable with the source array
       * this array will represent a time series and its values will be shifted at runtime in order to mimic Pine script behavior
       * @param trg - the target variable name : used internally to maintain the series in the execution context
       * @param src - the source data, can be an array or a single value
       * @param idx - the index of the source array, used to get a sub-series of the source data
       * @returns the target array
       */
      init(trg, src, idx = 0) {
        if (!trg) {
          if (Array.isArray(src)) {
            trg = [this.precision(src[src.length - this.idx - 1 + idx])];
          } else {
            trg = [this.precision(src)];
          }
        } else {
          if (!Array.isArray(src) || Array.isArray(src[0])) {
            trg[0] = Array.isArray(src?.[0]) ? src[0] : this.precision(src);
          } else {
            trg[0] = this.precision(src[src.length - this.idx - 1 + idx]);
          }
        }
        return trg;
      }
      /**
           * this function is used to set the floating point precision of a number
           * by default it is set to 10 decimals which is the same as pine script
           * @param n - the number to be precision
           * @param decimals - the number of decimals to precision to
      
           * @returns the precision number
           */
      precision(n, decimals = 10) {
        if (typeof n !== "number" || isNaN(n)) return n;
        return Number(n.toFixed(decimals));
      }
      /**
       * This function is used to apply special transformation to internal PineTS parameters and handle them as time-series
       * @param source - the source data, can be an array or a single value
       * @param index - the index of the source array, used to get a sub-series of the source data
       * @param name - the name of the parameter, used as a unique identifier in the current execution context, this allows us to properly handle the param as a series
       * @returns the current value of the param
       */
      param(source, index, name) {
        if (typeof source === "string") return source;
        if (!Array.isArray(source) && typeof source === "object") return source;
        if (!this.params[name]) this.params[name] = [];
        if (Array.isArray(source)) {
          if (index) {
            this.params[name] = source.slice(index);
            this.params[name].length = source.length;
            return this.params[name];
          }
          this.params[name] = source.slice(0);
          return this.params[name];
        } else {
          this.params[name][0] = source;
          return this.params[name];
        }
      }
      //#endregion
    }

    var __defProp = Object.defineProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    const BINANCE_API_URL = "https://api.binance.com/api/v3";
    const timeframe_to_binance = {
      "1": "1m",
      // 1 minute
      "3": "3m",
      // 3 minutes
      "5": "5m",
      // 5 minutes
      "15": "15m",
      // 15 minutes
      "30": "30m",
      // 30 minutes
      "45": null,
      // 45 minutes (not directly supported by Binance, needs custom handling)
      "60": "1h",
      // 1 hour
      "120": "2h",
      // 2 hours
      "180": null,
      // 3 hours (not directly supported by Binance, needs custom handling)
      "240": "4h",
      // 4 hours
      "4H": "4h",
      // 4 hours
      "1D": "1d",
      // 1 day
      D: "1d",
      // 1 day
      "1W": "1w",
      // 1 week
      W: "1w",
      // 1 week
      "1M": "1M",
      // 1 month
      M: "1M"
      // 1 month
    };
    class CacheManager {
      constructor(cacheDuration = 5 * 60 * 1e3) {
        __publicField(this, "cache");
        __publicField(this, "cacheDuration");
        this.cache = /* @__PURE__ */ new Map();
        this.cacheDuration = cacheDuration;
      }
      generateKey(params) {
        return Object.entries(params).filter(([_, value]) => value !== void 0).map(([key, value]) => `${key}:${value}`).join("|");
      }
      get(params) {
        const key = this.generateKey(params);
        const cached = this.cache.get(key);
        if (!cached) return null;
        if (Date.now() - cached.timestamp > this.cacheDuration) {
          this.cache.delete(key);
          return null;
        }
        return cached.data;
      }
      set(params, data) {
        const key = this.generateKey(params);
        this.cache.set(key, {
          data,
          timestamp: Date.now()
        });
      }
      clear() {
        this.cache.clear();
      }
      // Optional: method to remove expired entries
      cleanup() {
        const now = Date.now();
        for (const [key, entry] of this.cache.entries()) {
          if (now - entry.timestamp > this.cacheDuration) {
            this.cache.delete(key);
          }
        }
      }
    }
    class BinanceProvider {
      constructor() {
        __publicField(this, "cacheManager");
        this.cacheManager = new CacheManager(5 * 60 * 1e3);
      }
      async getMarketDataInterval(tickerId, timeframe, sDate, eDate) {
        try {
          const interval = timeframe_to_binance[timeframe.toUpperCase()];
          if (!interval) {
            console.error(`Unsupported timeframe: ${timeframe}`);
            return [];
          }
          const timeframeDurations = {
            "1m": 60 * 1e3,
            "3m": 3 * 60 * 1e3,
            "5m": 5 * 60 * 1e3,
            "15m": 15 * 60 * 1e3,
            "30m": 30 * 60 * 1e3,
            "1h": 60 * 60 * 1e3,
            "2h": 2 * 60 * 60 * 1e3,
            "4h": 4 * 60 * 60 * 1e3,
            "1d": 24 * 60 * 60 * 1e3,
            "1w": 7 * 24 * 60 * 60 * 1e3,
            "1M": 30 * 24 * 60 * 60 * 1e3
          };
          let allData = [];
          let currentStart = sDate;
          const endTime = eDate;
          const intervalDuration = timeframeDurations[interval];
          if (!intervalDuration) {
            console.error(`Duration not defined for interval: ${interval}`);
            return [];
          }
          while (currentStart < endTime) {
            const chunkEnd = Math.min(currentStart + 1e3 * intervalDuration, endTime);
            const data = await this.getMarketData(
              tickerId,
              timeframe,
              1e3,
              // Max allowed by Binance
              currentStart,
              chunkEnd
            );
            if (data.length === 0) break;
            allData = allData.concat(data);
            currentStart = data[data.length - 1].closeTime + 1;
            if (data.length < 1e3) break;
          }
          return allData;
        } catch (error) {
          console.error("Error in getMarketDataInterval:", error);
          return [];
        }
      }
      //TODO : allow querying more than 1000 klines
      //TODO : immplement cache
      async getMarketData(tickerId, timeframe, limit, sDate, eDate) {
        try {
          const cacheParams = { tickerId, timeframe, limit, sDate, eDate };
          const cachedData = this.cacheManager.get(cacheParams);
          if (cachedData) {
            console.log("cache hit", tickerId, timeframe, limit, sDate, eDate);
            return cachedData;
          }
          const interval = timeframe_to_binance[timeframe.toUpperCase()];
          if (!interval) {
            console.error(`Unsupported timeframe: ${timeframe}`);
            return [];
          }
          let url = `${BINANCE_API_URL}/klines?symbol=${tickerId}&interval=${interval}`;
          if (!limit && sDate && eDate) {
            return this.getMarketDataInterval(tickerId, timeframe, sDate, eDate);
          }
          if (limit) {
            url += `&limit=${limit}`;
          }
          if (sDate) {
            url += `&startTime=${sDate}`;
          }
          if (eDate) {
            url += `&endTime=${eDate}`;
          }
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const result = await response.json();
          const data = result.map((item) => {
            return {
              openTime: parseInt(item[0]),
              open: parseFloat(item[1]),
              high: parseFloat(item[2]),
              low: parseFloat(item[3]),
              close: parseFloat(item[4]),
              volume: parseFloat(item[5]),
              closeTime: parseInt(item[6]),
              quoteAssetVolume: parseFloat(item[7]),
              numberOfTrades: parseInt(item[8]),
              takerBuyBaseAssetVolume: parseFloat(item[9]),
              takerBuyQuoteAssetVolume: parseFloat(item[10]),
              ignore: item[11]
            };
          });
          this.cacheManager.set(cacheParams, data);
          return data;
        } catch (error) {
          console.error("Error in binance.klines:", error);
          return [];
        }
      }
    }

    ({
      Binance: new BinanceProvider()
      //TODO : add other providers (polygon, etc.)
    });

    function convertTime(t) {
        if (lightweightCharts.isUTCTimestamp(t))
            return t * 1000;
        if (lightweightCharts.isBusinessDay(t))
            return new Date(t.year, t.month, t.day).valueOf();
        const [year, month, day] = t.split('-').map(parseInt);
        return new Date(year, month, day).valueOf();
    }
    function formattedDateAndTime(timestamp) {
        if (!timestamp)
            return ['', ''];
        const dateObj = new Date(timestamp);
        // Format date string
        const year = dateObj.getFullYear();
        const month = dateObj.toLocaleString('default', { month: 'short' });
        const date = dateObj.getDate().toString().padStart(2, '0');
        const formattedDate = `${date} ${month} ${year}`;
        // Format time string
        const hours = dateObj.getHours().toString().padStart(2, '0');
        const minutes = dateObj.getMinutes().toString().padStart(2, '0');
        const formattedTime = `${hours}:${minutes}`;
        return [formattedDate, formattedTime];
    }

    /*
     * Copyright (C) 2025 EsIstJosh
     *
     * This file is part of [lightweight-charts-python] and is licensed under the GNU AGPL v3.0.
     *
     * Note: This file imports modules that remain under the MIT license (e.g., from the original project).
     * The original MIT license text is included in the MIT_LICENSE file in the repository.
     *
     * For the full text of the GNU AGPL v3.0, see <https://www.gnu.org/licenses/agpl-3.0.html>.
     */
    /**
     * CodeEditor creates a bottom-docked pane-style Monaco Editor.
     * The pane spans the full width and can have its height adjusted via a drag handle.
     *
     * New methods executePineTS and addPineTSToChart are added so that
     * the code from the editor is compiled, run via PineTS, and the resulting plots
     * are added to the chart using a provided Handler instance.
     */
    class CodeEditor {
        container;
        header;
        editorDiv;
        resizer;
        editorInstance = null;
        closeButton;
        isResizing = false;
        startY = 0;
        startHeight = 0;
        MIN_HEIGHT = 100; // Minimum pane height in pixels
        MAX_HEIGHT = window.innerHeight - 50; // Maximum pane height
        // Store the Handler instance passed in the constructor.
        handler;
        /**
         * @param handler - The chart handler that manages the Lightweight Charts instance.
         */
        constructor(handler) {
            this.handler = handler;
            // Create the container pane with bottom docking.
            this.container = document.createElement("div");
            Object.assign(this.container.style, {
                position: "fixed",
                bottom: "0",
                left: "0",
                width: "100%",
                height: "300px", // default height
                backgroundColor: "#1e1e1e",
                borderTop: "2px solid #444",
                zIndex: "10000",
                display: "none",
                flexDirection: "column",
            });
            // Create the resizer handle.
            this.resizer = document.createElement("div");
            Object.assign(this.resizer.style, {
                height: "5px",
                width: "100%",
                backgroundColor: "#666",
                cursor: "ns-resize",
                userSelect: "none",
            });
            // Attach mouse events for resizing.
            this.resizer.addEventListener("mousedown", this.onDragStart.bind(this));
            document.addEventListener("mousemove", this.onDrag.bind(this));
            document.addEventListener("mouseup", this.onDragEnd.bind(this));
            this.container.appendChild(this.resizer);
            // Create the header.
            this.header = document.createElement("div");
            Object.assign(this.header.style, {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                padding: "10px",
                backgroundColor: "#333",
            });
            // Left container holds title and action buttons.
            const leftContainer = document.createElement("div");
            leftContainer.style.display = "flex";
            leftContainer.style.alignItems = "center";
            leftContainer.style.gap = "10px";
            const title = document.createElement("span");
            title.innerText = "Code Editor";
            title.style.color = "white";
            leftContainer.appendChild(title);
            // Actions container holds the new buttons.
            const actionsContainer = document.createElement("div");
            actionsContainer.style.display = "flex";
            actionsContainer.style.gap = "10px";
            // Execute button.
            const executeButton = document.createElement("button");
            executeButton.innerText = "Execute";
            Object.assign(executeButton.style, {
                backgroundColor: "#4caf50",
                color: "white",
                border: "none",
                padding: "5px 10px",
                cursor: "pointer",
            });
            executeButton.onclick = () => {
                // Call the integrated execute method.
                this.executePineTS();
            };
            actionsContainer.appendChild(executeButton);
            // Append left container (title + actions) and then the close button.
            leftContainer.appendChild(actionsContainer);
            // Create the close button.
            this.closeButton = document.createElement("button");
            this.closeButton.innerText = "Close";
            Object.assign(this.closeButton.style, {
                backgroundColor: "#ff5555",
                color: "white",
                border: "none",
                padding: "5px 10px",
                cursor: "pointer",
            });
            this.closeButton.onclick = () => this.close();
            // Append left container and close button to header.
            this.header.appendChild(leftContainer);
            this.header.appendChild(this.closeButton);
            this.container.appendChild(this.header);
            // Create the editor container.
            this.editorDiv = document.createElement("div");
            Object.assign(this.editorDiv.style, {
                flex: "1",
                height: "calc(100% - 45px)", // Subtract resizer (5px) and header (40px approx)
            });
            this.container.appendChild(this.editorDiv);
            // Append the container pane to the document body.
            document.body.appendChild(this.container);
            // Initialize Monaco Editor in the editor container.
            this.initializeMonaco();
        }
        /**
         * Initializes the Monaco Editor in the editor pane.
         */
        initializeMonaco() {
            this.editorInstance = monaco__namespace.editor.create(this.editorDiv, {
                value: `
/*
 * @EsIstJosh
 * This feature implements a variation of PineTS, source : <https://github.com/alaa-eddine/PineTS> and is 
 * licensed under the GNU AGPL v3.0. V
 * 
 * Note: This file imports modules that remain under the MIT license (e.g., from the original project).
 * The original MIT license text is included in the MIT_LICENSE file in the repository.
 *
 * For the full text of the GNU AGPL v3.0, see <https://www.gnu.org/licenses/agpl-3.0.html>.
 */
//-----------------Work in Progress, Not Functional Yet-------------------//

      `,
                language: "typescript",
                theme: "vs-dark",
                automaticLayout: true,
            });
            console.log("Monaco Editor initialized in pane.");
        }
        /**
         * Opens (displays) the pane.
         */
        open() {
            this.container.style.display = "flex";
            // Refresh the layout after showing.
            this.editorInstance?.layout();
        }
        /**
         * Closes (hides) the pane.
         */
        close() {
            this.container.style.display = "none";
        }
        /**
         * Sets the code value in the editor.
         * @param code - The code to set in the editor.
         */
        setValue(code) {
            this.editorInstance?.setValue(code);
        }
        /**
         * Gets the current code from the editor.
         * @returns The code in the editor.
         */
        getValue() {
            return this.editorInstance?.getValue() || "";
        }
        async executePineTS() {
            try {
                const code = this.getValue(); // Code as a string from the editor.
                // If you need to create a dynamic userCallback, you can uncomment and adapt the following lines:
                /*
                const userCallback = new Function(
                    'context',
                    `return (async () => {
                        console.log("Received context:", context);
                        const { close, high, low } = context.data; // import OHLCV data
                        const { plot, plotchar, nz, color } = context.core; // import core functions
                        const ta = context.ta; // import technical analysis namespace
                        const math = context.math; // import math namespace
                        const input = context.input; // import input namespace
                        ${code}
                    })();`
                ) as (context: any) => Promise<any>;
                */
                // Prepare data
                const data = [...this.handler.series.data()];
                const sDate = data[0].time;
                const eDate = data[data.length - 1].time;
                // Instantiate PineTS
                const pineTS = new PineTS([...transformDataToArray([...this.handler.series.data()], [...this.handler.volumeSeries.data()])], this.handler.series.options().title, '1D', 400, convertTime(sDate), convertTime(eDate));
                // Run your indicator exactly once
                const { plots } = await pineTS.run((context) => {
                    try {
                        const { close, high, low } = context.data;
                        const ta = context.ta;
                        const math = context.math;
                        const input = context.input;
                        const { plot, plotchar, nz, color } = context.core;
                        //-------------------------------------------------//
                        const ema = ta.ema(close, 21);
                        plot(ema, { color: '#ff0000', style: "line", linewidth: 2 });
                    }
                    catch (error) {
                        console.error('Error inside Squeeze Momentum logic:', error);
                    }
                });
                console.log(plots);
                // Update the chart with the resulting plots
                for (const plotName in plots) {
                    if (plots.hasOwnProperty(plotName)) {
                        addPlotToHandler(this.handler, plotName, plots[plotName]);
                    }
                }
            }
            catch (error) {
                console.error('Error executing PineTS code:', error);
            }
        }
        /**
         * Handler for the start of a drag event on the resizer.
         * @param event - The mouse down event.
         */
        onDragStart(event) {
            this.isResizing = true;
            this.startY = event.clientY;
            this.startHeight = parseInt(window.getComputedStyle(this.container).height, 10);
            event.preventDefault();
        }
        /**
         * Handler for the dragging event to resize the pane.
         * @param event - The mouse move event.
         */
        onDrag(event) {
            if (!this.isResizing)
                return;
            // Calculate the new height as the distance from the bottom.
            const newHeight = this.startHeight + (this.startY - event.clientY);
            // Clamp the new height between MIN_HEIGHT and MAX_HEIGHT.
            const clampedHeight = Math.min(Math.max(newHeight, this.MIN_HEIGHT), this.MAX_HEIGHT);
            this.container.style.height = `${clampedHeight}px`;
            // Notify Monaco that the container size has changed.
            this.editorInstance?.layout();
        }
        /**
         * Handler for the end of a drag event.
         * @param event - The mouse up event.
         */
        onDragEnd(event) {
            if (this.isResizing) {
                this.isResizing = false;
            }
        }
    }
    /**
     * Convert a single PineTS plot object into a Lightweight Charts series using Handler.
     * @param handler   Your existing Handler instance (manages the chart).
     * @param plotName  The name of the plot (e.g. "Momentum", "Cross", etc.).
     * @param plotObj   The object returned by PineTS for this plot.
     */
    function addPlotToHandler(handler, plotName, plotObj) {
        const { data, options } = plotObj;
        const style = options?.style || 'line'; // default to 'line' if not specified
        // 1) Prepare a config object for Handler's createXSeries methods
        //    (color, linewidth, lineStyle, etc.)
        const baseOptions = {
            color: options?.color,
            lineWidth: options?.linewidth,
            // You can add more fields if needed, e.g. lineStyle, upColor, downColor, etc.
        };
        // 2) Create the appropriate series based on style
        let createdSeries;
        switch (style) {
            case 'line':
                createdSeries = handler.createLineSeries(plotName, baseOptions);
                break;
            case 'histogram':
                createdSeries = handler.createHistogramSeries(plotName, baseOptions);
                break;
            case 'area':
                createdSeries = handler.createAreaSeries(plotName, baseOptions);
                break;
            case 'bar':
                createdSeries = handler.createBarSeries(plotName, baseOptions);
                break;
            case 'cross':
                // "cross" isn't a native style in Lightweight Charts.
                // Often, we approximate with a line series having a thick or special style:
                baseOptions.lineWidth = baseOptions.lineWidth ?? 6; // e.g. big line
                createdSeries = handler.createLineSeries(plotName, baseOptions);
                break;
            default:
                console.warn(`Unsupported plot style: ${style}. Using line instead.`);
                createdSeries = handler.createLineSeries(plotName, baseOptions);
                break;
        }
        const baseData = [...handler.series.data()];
        // 3) Convert PineTS data into a format Lightweight Charts expects: { time, value, color? }
        //    PineTS often uses milliseconds. Lightweight Charts expects 'time' in seconds or a Date-like object.
        const seriesData = data.map((pt, idx) => ({
            time: baseData[idx].time, // convert ms -> seconds
            value: pt.value,
            // If you want per-point color, pass 'color' here. The series must support it (e.g. histogram).
            color: pt.color ?? options?.color,
        }));
        // 4) Set data on the newly created series
        createdSeries.series.setData(seriesData);
    }
    /**
     * Transforms an array of data objects (each containing at least a "time" field and OHLCV values)
     * into an array of objects with added "openTime" and "closeTime" fields.
     * If volume is missing on an item, it attempts to use a corresponding value from volumeData.
     *
     * @param data Array of data objects.
     * @param volumeData Array of volume data objects (optional).
     * @returns An array of transformed data objects.
     */
    function transformDataToArray(data, volumeData = []) {
        return data.map((item, idx) => {
            // Parse the "time" field into a timestamp.
            let parsedTime;
            if (typeof item.time === "number") {
                parsedTime = item.time;
            }
            else {
                parsedTime = new Date(item.time).getTime();
            }
            if (isNaN(parsedTime)) {
                console.warn(`Invalid time format: ${item.time}`);
                return null; // Skip this item if time is invalid.
            }
            return {
                ...item,
                openTime: parsedTime,
                closeTime: parsedTime + 86400, // 1 second (1000ms) before openTime.
                // Parse volume; if missing, try to use volumeData.
                volume: item.volume !== undefined
                    ? Number(item.volume)
                    : (volumeData[idx] !== undefined ? Number(volumeData[idx].value) : 0)
            };
        }).filter(item => item !== null);
    }

    class Menu {
        makeButton;
        callbackName;
        div;
        isOpen = false;
        widget;
        constructor(makeButton, items, activeItem, separator, align, callbackName) {
            this.makeButton = makeButton;
            this.callbackName = callbackName;
            this.div = document.createElement('div');
            this.div.classList.add('topbar-menu');
            this.widget = this.makeButton(activeItem + ' ↓', null, separator, true, align);
            this.updateMenuItems(items);
            this.widget.elem.addEventListener('click', () => {
                this.isOpen = !this.isOpen;
                if (!this.isOpen) {
                    this.div.style.display = 'none';
                    return;
                }
                let rect = this.widget.elem.getBoundingClientRect();
                this.div.style.display = 'flex';
                this.div.style.flexDirection = 'column';
                let center = rect.x + (rect.width / 2);
                this.div.style.left = center - (this.div.clientWidth / 2) + 'px';
                this.div.style.top = rect.y + rect.height + 'px';
            });
            document.body.appendChild(this.div);
        }
        updateMenuItems(items) {
            this.div.innerHTML = '';
            items.forEach(text => {
                let button = this.makeButton(text, null, false, false);
                button.elem.addEventListener('click', () => {
                    this._clickHandler(button.elem.innerText);
                });
                button.elem.style.margin = '4px 4px';
                button.elem.style.padding = '2px 2px';
                this.div.appendChild(button.elem);
            });
            this.widget.elem.innerText = items[0] + ' ↓';
        }
        _clickHandler(name) {
            this.widget.elem.innerText = name + ' ↓';
            window.callbackFunction(`${this.callbackName ?? 'undefined'}_~_${name}`);
            this.div.style.display = 'none';
            this.isOpen = false;
        }
    }
    class ChartMenu {
        makeButton;
        div;
        isOpen = false;
        widget;
        globalCallback;
        constructor(makeButton, items, activeItem, separator, align, callbackName, globalCallback) {
            this.makeButton = makeButton;
            this.globalCallback = globalCallback;
            this.div = document.createElement("div");
            this.div.classList.add("topbar-menu");
            // Create the main widget button with the active item.
            this.widget = this.makeButton(activeItem + " ↓", null, separator, true, align);
            // Initialize the menu items.
            this.updateMenuItems(items);
            // Toggle the dropdown on widget click.
            this.widget.elem.addEventListener("click", () => {
                this.isOpen = !this.isOpen;
                if (!this.isOpen) {
                    this.div.style.display = "none";
                    return;
                }
                const rect = this.widget.elem.getBoundingClientRect();
                this.div.style.display = "flex";
                this.div.style.flexDirection = "column";
                const center = rect.x + rect.width / 2;
                this.div.style.left = center - this.div.clientWidth / 2 + "px";
                this.div.style.top = rect.y + rect.height + "px";
            });
            document.body.appendChild(this.div);
        }
        updateMenuItems(items) {
            this.div.innerHTML = "";
            items.forEach(item => {
                const button = this.makeButton(item.label, null, false, false);
                button.elem.addEventListener("click", () => {
                    this._clickHandler(item);
                });
                button.elem.style.margin = "4px 4px";
                button.elem.style.padding = "2px 2px";
                this.div.appendChild(button.elem);
            });
            // Update the main widget to show the first item's label.
            if (items.length > 0) {
                this.widget.elem.innerText = items[0].label + " ↓";
            }
        }
        _clickHandler(item) {
            // Update the widget text.
            this.widget.elem.innerText = item.label + " ↓";
            // If the item has its own callback, invoke it.
            if (item.callback) {
                item.callback();
            }
            else if (this.globalCallback) {
                // Otherwise, fallback to the global callback if provided.
                this.globalCallback(item.label);
            }
            else {
                // Alternatively, you might call a global function:
                window.callbackFunction(`${item.label}`);
            }
            // Hide the menu.
            this.div.style.display = "none";
            this.isOpen = false;
        }
    }

    /*
     * Portions of this file are derived from [lightweight-charts-python] and are
     * licensed under the MIT License. The original copyright notice and license
     * can be found in the LICENSE file.
     *
     * Modifications by [EsIstJosh] are licensed under the GNU AGPL v3.0.
     * See <https://www.gnu.org/licenses/agpl-3.0.html> for the full license text.
     */
    class TopBar {
        _handler;
        _div;
        left;
        right;
        codeEditor;
        constructor(handler) {
            this._handler = handler;
            this._div = document.createElement('div');
            this._div.classList.add('topbar');
            const createTopBarContainer = (justification) => {
                const div = document.createElement('div');
                div.classList.add('topbar-container');
                div.style.justifyContent = justification;
                this._div.appendChild(div);
                return div;
            };
            this.left = createTopBarContainer('flex-start');
            this.right = createTopBarContainer('flex-end');
            this.codeEditor = new CodeEditor(this._handler); // ✅ Instantiate the Monaco Editor
            this.makeChartMenu([
                { label: "Add Series", callback: () => this.openCSVFile("add") },
                { label: "Edit Series", callback: () => this.openCSVFile("edit") }
            ], "Add Series", true, "left");
            // ✅ Add a button to open the editor
            this.makeButton("{}=> ƒ", true, true, "right", false, undefined, () => this.codeEditor.open());
        }
        makeSwitcher(items, defaultItem, callbackName, align = 'left') {
            const switcherElement = document.createElement('div');
            switcherElement.style.margin = '4px 12px';
            let activeItemEl;
            const createAndReturnSwitcherButton = (itemName) => {
                const button = document.createElement('button');
                button.classList.add('topbar-button');
                button.classList.add('switcher-button');
                button.style.margin = '0px 2px';
                button.innerText = itemName;
                if (itemName == defaultItem) {
                    activeItemEl = button;
                    button.classList.add('active-switcher-button');
                }
                const buttonWidth = TopBar.getClientWidth(button);
                button.style.minWidth = buttonWidth + 1 + 'px';
                button.addEventListener('click', () => widget.onItemClicked(button));
                switcherElement.appendChild(button);
                return button;
            };
            const widget = {
                elem: switcherElement,
                callbackName: callbackName,
                intervalElements: items.map(createAndReturnSwitcherButton),
                onItemClicked: (item) => {
                    if (item == activeItemEl)
                        return;
                    activeItemEl.classList.remove('active-switcher-button');
                    item.classList.add('active-switcher-button');
                    activeItemEl = item;
                    window.callbackFunction(`${widget.callbackName}_~_${item.innerText}`);
                }
            };
            this.appendWidget(switcherElement, align, true);
            return widget;
        }
        makeTextBoxWidget(text, align = 'left', callbackName = null) {
            if (callbackName) {
                const textBox = document.createElement('input');
                textBox.classList.add('topbar-textbox-input');
                textBox.value = text;
                textBox.style.width = `${(textBox.value.length + 2)}ch`;
                textBox.addEventListener('focus', () => {
                    window.textBoxFocused = true;
                });
                textBox.addEventListener('input', (e) => {
                    e.preventDefault();
                    textBox.style.width = `${(textBox.value.length + 2)}ch`;
                });
                textBox.addEventListener('keydown', (e) => {
                    if (e.key == 'Enter') {
                        e.preventDefault();
                        textBox.blur();
                    }
                });
                textBox.addEventListener('blur', () => {
                    window.callbackFunction(`${callbackName}_~_${textBox.value}`);
                    window.textBoxFocused = false;
                });
                this.appendWidget(textBox, align, true);
                return textBox;
            }
            else {
                const textBox = document.createElement('div');
                textBox.classList.add('topbar-textbox');
                textBox.innerText = text;
                this.appendWidget(textBox, align, true);
                return textBox;
            }
        }
        makeMenu(items, activeItem, separator, align, callbackName) {
            return new Menu(this.makeButton.bind(this), items, activeItem, separator, align, callbackName);
        }
        makeChartMenu(items, activeItem, separator, align, callbackName, globalCallback) {
            return new ChartMenu(this.makeButton.bind(this), items, activeItem, separator, align, callbackName, globalCallback);
        }
        makeButton(defaultText, separator, append = true, align = 'left', toggle = false, callbackName, callable) {
            let button = document.createElement('button');
            button.classList.add('topbar-button');
            button.innerText = defaultText;
            // Temporarily append to measure width
            document.body.appendChild(button);
            button.style.minWidth = `${button.clientWidth + 1}px`;
            document.body.removeChild(button);
            let state = false;
            const onItemClicked = () => {
                if (toggle) {
                    state = !state;
                    button.style.backgroundColor = state ? 'var(--active-bg-color)' : '';
                    button.style.color = state ? 'var(--active-color)' : '';
                    if (callbackName) {
                        window.callbackFunction(`${callbackName}_~_${state}`);
                    }
                }
                else {
                    if (callbackName) {
                        window.callbackFunction(`${callbackName}_~_${button.innerText}`);
                    }
                }
                if (callable)
                    callable();
            };
            button.addEventListener('click', onItemClicked);
            if (append)
                this.appendWidget(button, align, separator);
            return { elem: button, callbackName };
        }
        makeSliderWidget(min, max, step, defaultValue, callbackName, align = 'left') {
            // Create container for the slider
            const sliderContainer = document.createElement('div');
            sliderContainer.classList.add('topbar-slider-container');
            sliderContainer.style.display = 'flex';
            sliderContainer.style.alignItems = 'center';
            sliderContainer.style.margin = '4px 12px';
            // Create label for displaying the value
            const valueLabel = document.createElement('span');
            valueLabel.classList.add('topbar-slider-label');
            valueLabel.style.marginRight = '8px';
            valueLabel.innerText = defaultValue.toString();
            // Create the slider input
            const slider = document.createElement('input');
            slider.classList.add('topbar-slider');
            slider.type = 'range';
            slider.min = min.toString();
            slider.max = max.toString();
            slider.step = step.toString();
            slider.value = defaultValue.toString();
            slider.style.cursor = 'pointer';
            // Update label and trigger callback on change
            slider.addEventListener('input', () => {
                valueLabel.innerText = slider.value;
                window.callbackFunction(`${callbackName}_~_${slider.value}`);
            });
            // Append elements to the slider container
            sliderContainer.appendChild(valueLabel);
            sliderContainer.appendChild(slider);
            // Append the slider widget to the top bar
            this.appendWidget(sliderContainer, align, true);
            return sliderContainer;
        }
        makeSeparator(align = 'left') {
            const separator = document.createElement('div');
            separator.classList.add('topbar-seperator');
            const div = align == 'left' ? this.left : this.right;
            div.appendChild(separator);
        }
        appendWidget(widget, align, separator) {
            const div = align == 'left' ? this.left : this.right;
            if (separator) {
                if (align == 'left')
                    div.appendChild(widget);
                this.makeSeparator(align);
                if (align == 'right')
                    div.appendChild(widget);
            }
            else
                div.appendChild(widget);
            this._handler.reSize();
        }
        /**
         * Opens a file explorer dialog to select a CSV file, parses it as JSON,
         * verifies that it contains the required OHLCV columns, and if so, updates the chart.
         *
         * If mode is "edit", it updates the current series.
         * If mode is "add", it creates a new series using createCustomOHLCSeries.
         *
         * @param mode "edit" or "add"
         */
        openCSVFile(mode) {
            // Create an invisible file input element for CSV files.
            const input = document.createElement("input");
            input.type = "file";
            input.accept = ".csv";
            input.style.display = "none";
            input.addEventListener("change", (event) => {
                const target = event.target;
                if (target.files && target.files.length > 0) {
                    const file = target.files[0];
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const csvText = e.target?.result;
                        // Parse CSV text using our simple parser.
                        const data = this.parseCSV(csvText);
                        if (data.length === 0) {
                            alert("The CSV file is empty.");
                            return;
                        }
                        // Validate required OHLCV columns.
                        const requiredColumns = ["time", "open", "high", "low", "close"];
                        const headers = Object.keys(data[0]);
                        const valid = requiredColumns.every((col) => headers.includes(col));
                        if (!valid) {
                            alert("The selected CSV does not contain all required OHLCV columns: " +
                                requiredColumns.join(", "));
                            return;
                        }
                        try {
                            if (mode === "edit") {
                                // Update existing series.
                                this._handler.series.setData(data);
                                console.log("Series data updated successfully.");
                            }
                            else if (mode === "add") {
                                // Use the file's name (without extension) as the new series title.
                                const name = file.name.replace(/\.[^/.]+$/, "");
                                // Create a new custom OHLC series.
                                const newSeries = this._handler.createCustomOHLCSeries(name, {});
                                newSeries.series.setData(data);
                                console.log("New series added successfully.");
                            }
                        }
                        catch (error) {
                            console.error("Error updating chart data:", error);
                        }
                    };
                    reader.readAsText(file);
                }
            });
            document.body.appendChild(input);
            input.click();
            document.body.removeChild(input);
        }
        /**
         * A minimal CSV parser that converts CSV text into an array of objects.
         * - Assumes the first line contains headers.
         * - If a header named "time" exists (case-insensitive), it is used as is.
         * - Otherwise, if a header named "date" exists, it is renamed to "time".
         * - If neither exists, the first column is assumed to be the datetime index and renamed to "time".
         *
         * This parser does NOT handle quoted values or embedded commas.
         *
         * @param csvText The CSV text to parse.
         * @returns An array of objects representing the CSV rows.
         */
        parseCSV(csvText) {
            // Split into lines, filtering out any blank lines.
            const lines = csvText.split(/\r?\n/).filter(line => line.trim().length > 0);
            if (lines.length === 0)
                return [];
            // Extract header row.
            let headers = lines[0].split(",").map(header => header.trim());
            // Convert headers to lowercase for comparison.
            const lowerHeaders = headers.map(h => h.toLowerCase());
            if (!lowerHeaders.includes("time")) {
                if (lowerHeaders.includes("date")) {
                    // Replace the header "date" with "time"
                    const dateIndex = lowerHeaders.indexOf("date");
                    headers[dateIndex] = "time";
                }
                else {
                    // If neither "time" nor "date" exists, assume the first column is the datetime index.
                    headers[0] = "time";
                }
            }
            // Map each remaining line to an object.
            const data = lines.slice(1).map(line => {
                const values = line.split(",").map(value => value.trim());
                const obj = {};
                headers.forEach((header, index) => {
                    // Attempt to convert numeric values.
                    const num = Number(values[index]);
                    obj[header] = isNaN(num) ? values[index] : num;
                });
                return obj;
            });
            return data;
        }
        static getClientWidth(element) {
            document.body.appendChild(element);
            const width = element.clientWidth;
            document.body.removeChild(element);
            return width;
        }
    }

    const defaultOptions$1 = {
        title: '',
        followMode: 'tracking',
        horizontalDeadzoneWidth: 45,
        verticalDeadzoneHeight: 100,
        verticalSpacing: 20,
        topOffset: 20,
    };
    class TooltipElement {
        _chart;
        _element;
        _titleElement;
        _priceElement;
        _dateElement;
        _timeElement;
        _options;
        _lastTooltipWidth = null;
        constructor(chart, options) {
            this._options = {
                ...defaultOptions$1,
                ...options,
            };
            this._chart = chart;
            const element = document.createElement('div');
            applyStyle(element, {
                display: 'flex',
                'flex-direction': 'column',
                'align-items': 'center',
                position: 'absolute',
                transform: 'translate(calc(0px - 50%), 0px)',
                opacity: '0',
                left: '0%',
                top: '0',
                'z-index': '100',
                'background-color': 'white',
                'border-radius': '4px',
                padding: '5px 10px',
                'font-family': "-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif",
                'font-size': '12px',
                'font-weight': '400',
                'box-shadow': '0px 2px 4px rgba(0, 0, 0, 0.2)',
                'line-height': '16px',
                'pointer-events': 'none',
                color: '#131722',
            });
            const titleElement = document.createElement('div');
            applyStyle(titleElement, {
                'font-size': '12px',
                'line-height': '24px',
                'font-weight': '590',
            });
            setElementText(titleElement, this._options.title);
            element.appendChild(titleElement);
            const priceElement = document.createElement('div');
            applyStyle(priceElement, {
                'font-size': '12px',
                'line-height': '18px',
                'font-weight': '590',
            });
            setElementText(priceElement, '');
            element.appendChild(priceElement);
            const dateElement = document.createElement('div');
            applyStyle(dateElement, {
                color: '#787B86',
            });
            setElementText(dateElement, '');
            element.appendChild(dateElement);
            const timeElement = document.createElement('div');
            applyStyle(timeElement, {
                color: '#787B86',
            });
            setElementText(timeElement, '');
            element.appendChild(timeElement);
            this._element = element;
            this._titleElement = titleElement;
            this._priceElement = priceElement;
            this._dateElement = dateElement;
            this._timeElement = timeElement;
            const chartElement = this._chart.chartElement();
            chartElement.appendChild(this._element);
            const chartElementParent = chartElement.parentElement;
            if (!chartElementParent) {
                console.error('Chart Element is not attached to the page.');
                return;
            }
            const position = getComputedStyle(chartElementParent).position;
            if (position !== 'relative' && position !== 'absolute') {
                console.error('Chart Element position is expected be `relative` or `absolute`.');
            }
        }
        destroy() {
            if (this._chart && this._element)
                this._chart.chartElement().removeChild(this._element);
        }
        applyOptions(options) {
            this._options = {
                ...this._options,
                ...options,
            };
        }
        options() {
            return this._options;
        }
        updateTooltipContent(tooltipContentData) {
            if (!this._element) {
                console.warn('Tooltip element not found.');
                return;
            }
            const tooltipMeasurement = this._element.getBoundingClientRect();
            this._lastTooltipWidth = tooltipMeasurement.width;
            if (tooltipContentData.title !== undefined && this._titleElement) {
                console.log(`Setting title: ${tooltipContentData.title}`); // Debug log
                setElementText(this._titleElement, tooltipContentData.title);
            }
            else {
                console.warn('Title element is missing or title data is undefined.');
            }
            setElementText(this._priceElement, tooltipContentData.price);
            setElementText(this._dateElement, tooltipContentData.date);
            setElementText(this._timeElement, tooltipContentData.time);
        }
        updatePosition(positionData) {
            if (!this._chart || !this._element)
                return;
            this._element.style.opacity = positionData.visible ? '1' : '0';
            if (!positionData.visible) {
                return;
            }
            const x = this._calculateXPosition(positionData, this._chart);
            const y = this._calculateYPosition(positionData);
            this._element.style.transform = `translate(${x}, ${y})`;
        }
        _calculateXPosition(positionData, chart) {
            const x = positionData.paneX + chart.priceScale('left').width();
            const deadzoneWidth = this._lastTooltipWidth
                ? Math.ceil(this._lastTooltipWidth / 2)
                : this._options.horizontalDeadzoneWidth;
            const xAdjusted = Math.min(Math.max(deadzoneWidth, x), chart.timeScale().width() - deadzoneWidth);
            return `calc(${xAdjusted}px - 50%)`;
        }
        _calculateYPosition(positionData) {
            if (this._options.followMode == 'top') {
                return `${this._options.topOffset}px`;
            }
            const y = positionData.paneY;
            const flip = y <= this._options.verticalSpacing + this._options.verticalDeadzoneHeight;
            const yPx = y + (flip ? 1 : -1) * this._options.verticalSpacing;
            const yPct = flip ? '' : ' - 100%';
            return `calc(${yPx}px${yPct})`;
        }
    }
    function setElementText(element, text) {
        if (!element || text === element.innerText)
            return;
        element.innerText = text;
        element.style.display = text ? 'block' : 'none';
    }
    function applyStyle(element, styles) {
        for (const [key, value] of Object.entries(styles)) {
            element.style.setProperty(key, value);
        }
    }

    function centreOffset(lineBitmapWidth) {
        return Math.floor(lineBitmapWidth * 0.5);
    }
    /**
     * Calculates the bitmap position for an item with a desired length (height or width), and centred according to
     * an position coordinate defined in media sizing.
     * @param positionMedia - position coordinate for the bar (in media coordinates)
     * @param pixelRatio - pixel ratio. Either horizontal for x positions, or vertical for y positions
     * @param desiredWidthMedia - desired width (in media coordinates)
     * @returns Position of of the start point and length dimension.
     */
    function positionsLine(positionMedia, pixelRatio, desiredWidthMedia = 1, widthIsBitmap) {
        const scaledPosition = Math.round(pixelRatio * positionMedia);
        const lineBitmapWidth = Math.round(desiredWidthMedia * pixelRatio);
        const offset = centreOffset(lineBitmapWidth);
        const position = scaledPosition - offset;
        return { position, length: lineBitmapWidth };
    }

    class TooltipCrosshairLinePaneRenderer {
        _data;
        constructor(data) {
            this._data = data;
        }
        draw(target) {
            if (!this._data.visible)
                return;
            target.useBitmapCoordinateSpace((scope) => {
                const ctx = scope.context;
                const crosshairPos = positionsLine(this._data.x, scope.horizontalPixelRatio, 1);
                ctx.fillStyle = this._data.color; // Use the color directly from _data
                ctx.fillRect(crosshairPos.position, this._data.topMargin * scope.verticalPixelRatio, crosshairPos.length, scope.bitmapSize.height);
            });
        }
    }
    class MultiTouchCrosshairPaneView {
        _data;
        constructor(data) {
            this._data = data;
        }
        update(data) {
            this._data = data;
        }
        renderer() {
            return new TooltipCrosshairLinePaneRenderer(this._data);
        }
        zOrder() {
            return 'bottom';
        }
    }
    const defaultOptions = {
        lineColor: 'rgba(0, 0, 0, 0.2)',
        priceExtractor: (data) => {
            if (data.value !== undefined) {
                return data.value.toFixed(2);
            }
            if (data.close !== undefined) {
                return data.close.toFixed(2);
            }
            return '';
        }
    };
    class TooltipPrimitive {
        _options;
        _tooltip = undefined;
        _paneViews;
        _data = {
            x: 0,
            visible: false,
            color: 'rgba(0, 0, 0, 0.2)',
            topMargin: 0,
        };
        _attachedParams;
        constructor(options) {
            this._options = {
                ...defaultOptions,
                ...options,
            };
            this._data.color = this._options.lineColor; // Set the initial color
            this._paneViews = [new MultiTouchCrosshairPaneView(this._data)];
        }
        attached(param) {
            this._attachedParams = param;
            const series = this.series();
            if (series) {
                const seriesOptions = series.options();
                const lineColor = seriesOptions.lineColor || seriesOptions.color || 'rgba(0,0,0,0.2)';
                if (this._options.autoColor) { // Apply the extracted lineColor to the primitive
                    this.applyOptions({
                        lineColor,
                    });
                }
            }
            this._setCrosshairMode();
            param.chart.subscribeCrosshairMove(this._moveHandler);
            this._createTooltipElement();
        }
        detached() {
            const chart = this.chart();
            if (chart) {
                chart.unsubscribeCrosshairMove(this._moveHandler);
            }
            this._hideCrosshair();
            this._hideTooltip();
        }
        paneViews() {
            return this._paneViews;
        }
        updateAllViews() {
            this._paneViews.forEach((pw) => pw.update(this._data));
        }
        setData(data) {
            this._data = data;
            this.updateAllViews();
            this._attachedParams?.requestUpdate();
        }
        currentColor() {
            return this._options.lineColor;
        }
        chart() {
            return this._attachedParams?.chart;
        }
        series() {
            return this._attachedParams?.series;
        }
        applyOptions(options) {
            this._options = {
                ...this._options,
                ...options,
            };
            // Update the data color to match the lineColor if provided
            if (options.lineColor) {
                this.setData({
                    ...this._data,
                    color: options.lineColor,
                });
            }
            // Update the tooltip if it exists
            if (this._tooltip) {
                this._tooltip.applyOptions({
                    ...this._options.tooltip,
                });
            }
            this._attachedParams?.requestUpdate();
        }
        _setCrosshairMode() {
            const chart = this.chart();
            if (!chart) {
                throw new Error('Unable to change crosshair mode because the chart instance is undefined');
            }
            chart.applyOptions({
                crosshair: {
                    mode: lightweightCharts.CrosshairMode.Magnet,
                    vertLine: {
                        visible: false,
                        labelVisible: false,
                    },
                    horzLine: {
                        visible: false,
                        labelVisible: false,
                    },
                },
            });
        }
        _moveHandler = (param) => this._onMouseMove(param);
        switch(series) {
            if (this.series() === series) {
                console.log('Tooltip is already attached to this series.');
                return;
            }
            this._hideCrosshair();
            series.attachPrimitive(this, 'Tooltip', true, false);
            const seriesOptions = series.options();
            const lineColor = seriesOptions.lineColor || seriesOptions.color || 'rgba(0,0,0,0.2)';
            if (this._options.autoColor) { // Apply the extracted lineColor to the primitive
                this.applyOptions({
                    lineColor,
                });
            }
            console.log('Switched tooltip to the new series.');
        }
        _hideCrosshair() {
            this._hideTooltip();
            this.setData({
                x: 0,
                visible: false,
                color: this._options.lineColor,
                topMargin: 0,
            });
        }
        _hideTooltip() {
            if (!this._tooltip)
                return;
            this._tooltip.updateTooltipContent({
                title: '',
                price: '',
                date: '',
                time: '',
            });
            this._tooltip.updatePosition({
                paneX: 0,
                paneY: 0,
                visible: false,
            });
        }
        _onMouseMove(param) {
            const chart = this.chart();
            const series = this.series();
            const logical = param.logical;
            if (!logical || !chart || !series) {
                this._hideCrosshair();
                return;
            }
            const data = param.seriesData.get(series);
            if (!data) {
                this._hideCrosshair();
                return;
            }
            const price = this._options.priceExtractor(data);
            const coordinate = chart.timeScale().logicalToCoordinate(logical);
            const [date, time] = formattedDateAndTime(param.time ? convertTime(param.time) : undefined);
            if (this._tooltip) {
                const title = series.options()?.title || 'Unknown Series';
                const tooltipOptions = this._tooltip.options();
                const topMargin = tooltipOptions.followMode === 'top' ? tooltipOptions.topOffset + 10 : 0;
                this.setData({
                    x: coordinate ?? 0,
                    visible: coordinate !== null,
                    color: this._options.lineColor,
                    topMargin,
                });
                this._tooltip.updateTooltipContent({
                    title, // Display the series title here
                    price,
                    date,
                    time,
                });
                this._tooltip.updatePosition({
                    paneX: param.point?.x ?? 0,
                    paneY: param.point?.y ?? 0,
                    visible: true,
                });
            }
        }
        _createTooltipElement() {
            const chart = this.chart();
            if (!chart)
                throw new Error('Unable to create Tooltip element. Chart not attached');
            this._tooltip = new TooltipElement(chart, {
                ...this._options.tooltip,
            });
        }
    }

    let ColorPicker$1 = class ColorPicker {
        colorOption;
        static colors = [
            '#EBB0B0', '#E9CEA1', '#E5DF80', '#ADEB97', '#A3C3EA', '#D8BDED',
            '#E15F5D', '#E1B45F', '#E2D947', '#4BE940', '#639AE1', '#D7A0E8',
            '#E42C2A', '#E49D30', '#E7D827', '#3CFF0A', '#3275E4', '#B06CE3',
            '#F3000D', '#EE9A14', '#F1DA13', '#2DFC0F', '#1562EE', '#BB00EF',
            '#B50911', '#E3860E', '#D2BD11', '#48DE0E', '#1455B4', '#6E009F',
            '#7C1713', '#B76B12', '#8D7A13', '#479C12', '#165579', '#51007E',
        ];
        _div;
        saveDrawings;
        opacity = 0;
        _opacitySlider;
        _opacityLabel;
        rgba;
        constructor(saveDrawings, colorOption) {
            this.colorOption = colorOption;
            this.saveDrawings = saveDrawings;
            this._div = document.createElement('div');
            this._div.classList.add('color-picker');
            let colorPicker = document.createElement('div');
            colorPicker.style.margin = '10px';
            colorPicker.style.display = 'flex';
            colorPicker.style.flexWrap = 'wrap';
            ColorPicker.colors.forEach((color) => colorPicker.appendChild(this.makeColorBox(color)));
            let separator = document.createElement('div');
            separator.style.backgroundColor = window.pane.borderColor;
            separator.style.height = '1px';
            separator.style.width = '130px';
            let opacity = document.createElement('div');
            opacity.style.margin = '10px';
            let opacityText = document.createElement('div');
            opacityText.style.color = 'lightgray';
            opacityText.style.fontSize = '12px';
            opacityText.innerText = 'Opacity';
            this._opacityLabel = document.createElement('div');
            this._opacityLabel.style.color = 'lightgray';
            this._opacityLabel.style.fontSize = '12px';
            this._opacitySlider = document.createElement('input');
            this._opacitySlider.type = 'range';
            this._opacitySlider.value = (this.opacity * 100).toString();
            this._opacityLabel.innerText = this._opacitySlider.value + '%';
            this._opacitySlider.oninput = () => {
                this._opacityLabel.innerText = this._opacitySlider.value + '%';
                this.opacity = parseInt(this._opacitySlider.value) / 100;
                this.updateColor();
            };
            opacity.appendChild(opacityText);
            opacity.appendChild(this._opacitySlider);
            opacity.appendChild(this._opacityLabel);
            this._div.appendChild(colorPicker);
            this._div.appendChild(separator);
            this._div.appendChild(opacity);
            window.containerDiv.appendChild(this._div);
        }
        _updateOpacitySlider() {
            this._opacitySlider.value = (this.opacity * 100).toString();
            this._opacityLabel.innerText = this._opacitySlider.value + '%';
        }
        makeColorBox(color) {
            const box = document.createElement('div');
            box.style.width = '18px';
            box.style.height = '18px';
            box.style.borderRadius = '3px';
            box.style.margin = '3px';
            box.style.boxSizing = 'border-box';
            box.style.backgroundColor = color;
            box.addEventListener('mouseover', () => box.style.border = '2px solid lightgray');
            box.addEventListener('mouseout', () => box.style.border = 'none');
            const rgba = ColorPicker.extractRGBA(color);
            box.addEventListener('click', () => {
                this.rgba = rgba;
                this.updateColor();
            });
            return box;
        }
        static extractRGBA(anyColor) {
            const dummyElem = document.createElement('div');
            dummyElem.style.color = anyColor;
            document.body.appendChild(dummyElem);
            const computedColor = getComputedStyle(dummyElem).color;
            document.body.removeChild(dummyElem);
            const rgb = computedColor.match(/\d+/g)?.map(Number);
            if (!rgb)
                return [];
            let isRgba = computedColor.includes('rgba');
            let opacity = isRgba ? parseFloat(computedColor.split(',')[3]) : 1;
            return [rgb[0], rgb[1], rgb[2], opacity];
        }
        updateColor() {
            if (!Drawing.lastHoveredObject || !this.rgba)
                return;
            const oColor = `rgba(${this.rgba[0]}, ${this.rgba[1]}, ${this.rgba[2]}, ${this.opacity})`;
            Drawing.lastHoveredObject.applyOptions({ [this.colorOption]: oColor });
            this.saveDrawings();
        }
        openMenu(rect) {
            if (!Drawing.lastHoveredObject)
                return;
            this.rgba = ColorPicker.extractRGBA(Drawing.lastHoveredObject._options[this.colorOption]);
            this.opacity = this.rgba[3];
            this._updateOpacitySlider();
            this._div.style.top = (rect.top - 30) + 'px';
            this._div.style.left = rect.right + 'px';
            this._div.style.display = 'flex';
            setTimeout(() => document.addEventListener('mousedown', (event) => {
                if (!this._div.contains(event.target)) {
                    this.closeMenu();
                }
            }), 10);
        }
        closeMenu() {
            document.body.removeEventListener('click', this.closeMenu);
            this._div.style.display = 'none';
        }
    };

    class ColorPicker {
        container;
        _opacitySlider;
        _opacity_label;
        exitButton;
        color = "#ff0000";
        rgba; // [R, G, B, A]
        opacity;
        applySelection;
        customColors;
        constructor(initialValue, applySelection, customColors) {
            this.applySelection = applySelection;
            this.rgba = ColorPicker.extractRGBA(initialValue);
            this.opacity = this.rgba[3];
            this.container = document.createElement("div");
            this.container.classList.add("color-picker");
            this.container.style.display = "flex";
            this.container.style.flexDirection = "column";
            this.container.style.width = "200px";
            this.container.style.height = "350px";
            this.container.style.position = "relative"; // Ensure proper positioning for the exit button.
            // Build UI elements
            const colorGrid = this.createColorGrid();
            const opacityUI = this.createOpacityUI();
            this.exitButton = this.createExitButton(); // Create the exit button.
            this.customColors = customColors ?? undefined;
            // Append elements to the container
            this.container.appendChild(colorGrid);
            this.container.appendChild(this.createSeparator());
            if (this.customColors && this.customColors.length !== 0) {
                this.createCustomColorSection();
            }
            this.container.appendChild(this.createSeparator());
            this.container.appendChild(opacityUI);
            this.container.appendChild(this.exitButton); // Append the exit button last
        }
        createCustomColorSection() {
            // Only build the custom colors section if a custom colors list is provided.
            if (!this.customColors || this.customColors.length === 0) {
                return null;
            }
            const customContainer = document.createElement("div");
            customContainer.style.display = "flex";
            customContainer.style.flexDirection = "column";
            customContainer.style.alignItems = "center";
            customContainer.style.margin = "8px 0";
            const title = document.createElement("div");
            title.innerText = "Custom Colors";
            title.style.fontSize = "14px";
            title.style.color = "white";
            customContainer.appendChild(title);
            // Create a container row for custom color swatches.
            const swatchContainer = document.createElement("div");
            swatchContainer.style.display = "flex";
            swatchContainer.style.flexWrap = "wrap";
            swatchContainer.style.justifyContent = "center";
            swatchContainer.style.gap = "5px";
            // Function to create a swatch element.
            const createSwatch = (color) => {
                const swatch = document.createElement("div");
                swatch.style.width = "20px";
                swatch.style.height = "20px";
                swatch.style.borderRadius = "4px";
                swatch.style.cursor = "pointer";
                swatch.style.border = "1px solid #999";
                swatch.style.backgroundColor = color;
                swatch.title = color;
                // When clicked, update the target color using this custom color.
                swatch.addEventListener("click", () => {
                    this.updateTargetColor();
                });
                return swatch;
            };
            // Append existing custom color swatches.
            this.customColors.forEach((color) => {
                swatchContainer.appendChild(createSwatch(color));
            });
            // Create an additional swatch for adding a new custom color.
            const addSwatch = document.createElement("div");
            addSwatch.style.width = "20px";
            addSwatch.style.height = "20px";
            addSwatch.style.borderRadius = "4px";
            addSwatch.style.cursor = "pointer";
            addSwatch.style.border = "1px solid #999";
            addSwatch.style.backgroundColor = "rgba(0,0,0,0)"; // Transparent background
            addSwatch.style.display = "flex";
            addSwatch.style.justifyContent = "center";
            addSwatch.style.alignItems = "center";
            addSwatch.style.color = "#999";
            addSwatch.style.fontSize = "16px";
            addSwatch.innerText = "+";
            addSwatch.title = "Add custom color";
            addSwatch.addEventListener("click", (evt) => {
                // Create a hidden input of type color (native color picker, often displayed as a gradient wheel)
                const colorInput = document.createElement("input");
                colorInput.type = "color";
                // Optionally, set a default value (using current color)
                colorInput.value = this.color;
                // Hide the input element.
                colorInput.style.position = "absolute";
                colorInput.style.left = "-9999px";
                document.body.appendChild(colorInput);
                // When a color is picked:
                colorInput.addEventListener("input", () => {
                    this.color = colorInput.value;
                    this.updateTargetColor();
                    if (!this.customColors.includes(this.color)) {
                        this.customColors.push(this.color);
                        swatchContainer.appendChild(createSwatch(this.color));
                        this.saveColors();
                    }
                    document.body.removeChild(colorInput);
                }, { once: true });
                // Programmatically open the native color picker.
                colorInput.click();
            });
            swatchContainer.appendChild(addSwatch);
            customContainer.appendChild(swatchContainer);
            return customContainer;
        }
        saveColors() {
            // Ensure customColors exists.
            // Convert the updated customColors array to a pretty-printed JSON string.
            const dataString = JSON.stringify(this.customColors, null, 2);
            // Define the key for the saved defaults. You can use a default key such as "customColors".
            const key = "colors";
            // Build the message using your standard format.
            const message = `save_defaults_${key}_~_${dataString}`;
            // Call the global callback function to save the defaults.
            window.callbackFunction(message);
        }
        createExitButton() {
            const button = document.createElement('div');
            button.innerText = '✕'; // Close icon
            button.title = 'Close';
            button.style.position = 'absolute';
            button.style.bottom = '5px'; // Move to the bottom
            button.style.right = '5px'; // Default bottom-right corner
            button.style.width = '20px';
            button.style.height = '20px';
            button.style.cursor = 'pointer';
            button.style.display = 'flex';
            button.style.justifyContent = 'center';
            button.style.alignItems = 'center';
            button.style.fontSize = '16px';
            button.style.backgroundColor = '#ccc';
            button.style.borderRadius = '50%';
            button.style.color = '#000';
            button.style.boxShadow = '0 1px 3px rgba(0,0,0,0.3)';
            // Add hover effect
            button.addEventListener('mouseover', () => {
                button.style.backgroundColor = '#e74c3c'; // Red hover color
                button.style.color = '#fff'; // White text on hover
            });
            button.addEventListener('mouseout', () => {
                button.style.backgroundColor = '#ccc';
                button.style.color = '#000';
            });
            // Close the menu when clicked
            button.addEventListener('click', () => {
                this.closeMenu();
            });
            return button;
        }
        createColorGrid() {
            const colorGrid = document.createElement('div');
            colorGrid.style.display = 'grid';
            colorGrid.style.gridTemplateColumns = 'repeat(7, 1fr)'; // 5 columns
            colorGrid.style.gap = '5px';
            colorGrid.style.overflowY = 'auto';
            colorGrid.style.flex = '1';
            const colors = ColorPicker.generateFullSpectrumColors(9); // Generate vibrant colors
            colors.forEach((color) => {
                const box = this.createColorBox(color);
                colorGrid.appendChild(box);
            });
            return colorGrid;
        }
        createColorBox(color) {
            const box = document.createElement("div");
            box.style.aspectRatio = "1"; // Maintain square shape
            box.style.borderRadius = "6px";
            box.style.backgroundColor = color;
            box.style.cursor = "pointer";
            box.addEventListener("click", () => {
                this.rgba = ColorPicker.extractRGBA(color);
                this.updateTargetColor();
            });
            return box;
        }
        static generateFullSpectrumColors(stepsPerTransition) {
            const colors = [];
            // Red to Green (255, 0, 0 → 255, 255, 0)
            for (let g = 0; g <= 255; g += Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(255, ${g}, 0, 1)`);
            }
            // Green to Yellow-Green to Green-Blue (255, 255, 0 → 0, 255, 0)
            for (let r = 255; r >= 0; r -= Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(${r}, 255, 0, 1)`);
            }
            // Green to Cyan (0, 255, 0 → 0, 255, 255)
            for (let b = 0; b <= 255; b += Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(0, 255, ${b}, 1)`);
            }
            // Cyan to Blue (0, 255, 255 → 0, 0, 255)
            for (let g = 255; g >= 0; g -= Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(0, ${g}, 255, 1)`);
            }
            // Blue to Magenta (0, 0, 255 → 255, 0, 255)
            for (let r = 0; r <= 255; r += Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(${r}, 0, 255, 1)`);
            }
            // Magenta to Red (255, 0, 255 → 255, 0, 0)
            for (let b = 255; b >= 0; b -= Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(255, 0, ${b}, 1)`);
            }
            // White to Black (255, 255, 255 → 0, 0, 0)
            for (let i = 255; i >= 0; i -= Math.floor(255 / stepsPerTransition)) {
                colors.push(`rgba(${i}, ${i}, ${i}, 1)`);
            }
            return colors;
        }
        createOpacityUI() {
            const opacityContainer = document.createElement("div");
            opacityContainer.style.margin = "10px";
            opacityContainer.style.display = "flex";
            opacityContainer.style.flexDirection = "column";
            opacityContainer.style.alignItems = "center";
            const opacityText = document.createElement("div");
            opacityText.style.color = "lightgray";
            opacityText.style.fontSize = "12px";
            opacityText.innerText = "Opacity";
            this._opacitySlider = document.createElement("input");
            this._opacitySlider.type = "range";
            this._opacitySlider.min = "0";
            this._opacitySlider.max = "100";
            this._opacitySlider.value = (this.opacity * 100).toString();
            this._opacitySlider.style.width = "80%";
            this._opacity_label = document.createElement("div");
            this._opacity_label.style.color = "lightgray";
            this._opacity_label.style.fontSize = "12px";
            this._opacity_label.innerText = `${this._opacitySlider.value}%`;
            this._opacitySlider.oninput = () => {
                this._opacity_label.innerText = `${this._opacitySlider.value}%`;
                this.opacity = parseInt(this._opacitySlider.value) / 100;
                this.updateTargetColor();
            };
            opacityContainer.appendChild(opacityText);
            opacityContainer.appendChild(this._opacitySlider);
            opacityContainer.appendChild(this._opacity_label);
            return opacityContainer;
        }
        createSeparator() {
            const separator = document.createElement("div");
            separator.style.height = "1px";
            separator.style.width = "100%";
            separator.style.backgroundColor = "#ccc";
            separator.style.margin = "5px 0";
            return separator;
        }
        openMenu(event, parentMenuWidth, // Width of the parent menu
        applySelection) {
            this.applySelection = applySelection;
            // Attach menu to DOM temporarily to calculate dimensions.
            this.container.style.display = 'block';
            document.body.appendChild(this.container);
            // Calculate submenu dimensions.
            const submenuWidth = this.container.offsetWidth || 150;
            const submenuHeight = this.container.offsetHeight || 250;
            // Get mouse position.
            const cursorX = event.clientX;
            const cursorY = event.clientY;
            // Get viewport dimensions.
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            // Calculate position relative to the parent menu.
            let left = cursorX + parentMenuWidth;
            let top = cursorY;
            // Adjust position to avoid overflowing viewport.
            const adjustedLeft = left + submenuWidth > viewportWidth ? cursorX - submenuWidth : left;
            const adjustedTop = top + submenuHeight > viewportHeight ? viewportHeight - submenuHeight - 10 : top;
            this.container.style.left = `${adjustedLeft}px`;
            this.container.style.top = `${adjustedTop}px`;
            this.container.style.display = 'flex';
            this.container.style.position = 'absolute';
            // Ensure the exit button stays within bounds.
            this.exitButton.style.bottom = '5px';
            this.exitButton.style.right = '5px';
            // Define the auto-close handler.
            const onMouseMove = (e) => {
                const rect = this.container.getBoundingClientRect();
                // Extend the container bounds.
                const extendedRect = {
                    left: rect.left - submenuWidth,
                    right: rect.right + submenuWidth,
                    top: rect.top - submenuHeight,
                    bottom: rect.bottom + submenuHeight,
                };
                if (e.clientX < extendedRect.left ||
                    e.clientX > extendedRect.right ||
                    e.clientY < extendedRect.top ||
                    e.clientY > extendedRect.bottom) {
                    this.closeMenu();
                    document.removeEventListener('mousemove', onMouseMove);
                }
            };
            // Only start auto-close tracking when the mouse is over the container.
            this.container.addEventListener('mouseenter', () => {
                document.addEventListener('mousemove', onMouseMove);
            });
            this.container.addEventListener('mouseleave', () => {
                document.removeEventListener('mousemove', onMouseMove);
                this.closeMenu();
            });
            // Also close the menu when clicking outside.
            document.addEventListener('mousedown', this._handleOutsideClick.bind(this), { once: true });
        }
        closeMenu() {
            this.container.style.display = 'none';
            document.removeEventListener('mousedown', this._handleOutsideClick);
        }
        _handleOutsideClick(event) {
            if (!this.container.contains(event.target)) {
                this.closeMenu();
            }
        }
        static extractRGBA(color) {
            const dummyElem = document.createElement('div');
            dummyElem.style.color = color;
            document.body.appendChild(dummyElem);
            const computedColor = getComputedStyle(dummyElem).color;
            document.body.removeChild(dummyElem);
            const rgb = computedColor.match(/\d+/g)?.map(Number) || [0, 0, 0];
            const opacity = computedColor.includes("rgba")
                ? parseFloat(computedColor.split(",")[3])
                : 1;
            return [rgb[0], rgb[1], rgb[2], opacity];
        }
        getElement() {
            return this.container;
        }
        // Dynamically updates the label and selection function
        update(initialValue, applySelection) {
            this.rgba = ColorPicker.extractRGBA(initialValue);
            this.opacity = this.rgba[3];
            this.applySelection = applySelection;
            this.updateTargetColor();
        }
        updateTargetColor() {
            this.color = `rgba(${this.rgba[0]}, ${this.rgba[1]}, ${this.rgba[2]}, ${this.opacity})`;
            this.applySelection(this.color); // Apply color selection immediately
        }
    }

    class StylePicker {
        static _styles = [
            { name: 'Solid', var: lightweightCharts.LineStyle.Solid },
            { name: 'Dotted', var: lightweightCharts.LineStyle.Dotted },
            { name: 'Dashed', var: lightweightCharts.LineStyle.Dashed },
            { name: 'Large Dashed', var: lightweightCharts.LineStyle.LargeDashed },
            { name: 'Sparse Dotted', var: lightweightCharts.LineStyle.SparseDotted },
        ];
        _div;
        _saveDrawings;
        constructor(saveDrawings) {
            this._saveDrawings = saveDrawings;
            this._div = document.createElement('div');
            this._div.classList.add('context-menu');
            StylePicker._styles.forEach((style) => {
                this._div.appendChild(this._makeTextBox(style.name, style.var));
            });
            window.containerDiv.appendChild(this._div);
        }
        _makeTextBox(text, style) {
            const item = document.createElement('span');
            item.classList.add('context-menu-item');
            item.innerText = text;
            item.addEventListener('click', () => {
                Drawing.lastHoveredObject?.applyOptions({ lineStyle: style });
                this._saveDrawings();
            });
            return item;
        }
        openMenu(rect) {
            this._div.style.top = (rect.top - 30) + 'px';
            this._div.style.left = rect.right + 'px';
            this._div.style.display = 'block';
            setTimeout(() => document.addEventListener('mousedown', (event) => {
                if (!this._div.contains(event.target)) {
                    this.closeMenu();
                }
            }), 10);
        }
        closeMenu() {
            document.removeEventListener('click', this.closeMenu);
            this._div.style.display = 'none';
        }
    }

    // volumeProfile.ts
    const defaultVolumeProfileOptions = {
        visible: true,
        sections: 0,
        upColor: undefined, //"rgba(255, 255, 255, 0.25)",
        downColor: undefined, //"rgba(50, 50, 50, 0.25)",
        borderUpColor: undefined, //"rgba(255, 255, 255, 0.33)",
        borderDownColor: undefined, //"rgba(50, 50, 50, 0.33)",
        rightSide: true,
        width: 0,
        lineColor: "#ffffff",
        lineStyle: lightweightCharts.LineStyle.Solid,
        drawGrid: true,
        gridWidth: 1,
        gridColor: "rgba(255, 255, 255, 0.125)",
        gridLineStyle: lightweightCharts.LineStyle.SparseDotted,
        // Possibly xScaleLock, yScaleLock, etc.
    };
    /**
     * The VolumeProfile class implementing ISeriesPrimitive
     * with full dragging/hover logic for p1/p2, akin to TrendTrace.
     */
    class VolumeProfile extends PluginBase {
        p1;
        p2;
        _listeners = [];
        visibleRange = null;
        // Provided by constructor
        // The merged data (OHLC + volume)
        _originalData;
        // The data slice for p1..p2
        _currentSlice = null;
        // Aggregated bins => stored here
        _vpData;
        // The single or multiple pane views we use
        _paneViews;
        // Options from the user + defaults
        _options;
        // Throttle re-renders
        _pendingUpdate = false;
        // For drag/hover logic
        _state = InteractionState.NONE;
        _latestHoverPoint = null;
        _startDragPoint = null;
        static _mouseIsDown = false;
        _hovered = false; // if you want a hovered style
        chart_;
        series_;
        constructor(handler, options = defaultVolumeProfileOptions, p1, p2) {
            super(); // call base plugin constructor if needed
            this.chart_ = handler.chart;
            this.series_ = handler.series;
            const priceData = this.series_.data();
            const volumeData = handler.volumeSeries.data();
            const timeScale = this.chart_.timeScale();
            this.visibleRange = timeScale.getVisibleLogicalRange();
            if (p1 && p2) {
                // Use provided p1 and p2
                this.p1 = p1;
                this.p2 = p2;
            }
            else {
                // Use visible range or default values
                this.p1 = {
                    time: null,
                    logical: this.visibleRange?.from ?? 0,
                    price: 0,
                };
                this.p2 = {
                    time: null,
                    logical: this.visibleRange?.to ?? (this.series.data().length - 1),
                    price: 0,
                };
            }
            // Merge user-specified options with defaults
            this._options = {
                ...defaultVolumeProfileOptions,
                ...options,
            };
            if (volumeData.length > 0 && volumeData.every((v) => "value" in v)) {
                // Merge priceData & volumeData
                this._originalData = priceData.map((dp, idx) => ({
                    ...dp,
                    x1: idx,
                    x2: idx,
                    volume: volumeData[idx]?.value || 0,
                }));
            }
            else {
                console.warn('[ProfileProcessor] volumeData is empty or missing "value" property.');
                // Handle the case where volumeData is invalid
                this._originalData = priceData.map((dp, idx) => ({
                    ...dp,
                    x1: idx,
                    x2: idx,
                    volume: 0, // Default volume
                }));
            }
            // Slice & compute initial bins
            this.sliceData();
            this._vpData = this.calculateVolumeProfile();
            // Create the single pane view
            this._paneViews = [new VolumeProfilePaneView(this)];
            this._subscribeEvents();
            // Trigger initial update
            this.update();
        }
        // The DOM event callbacks
        _handleDomMouseDown = () => {
            // If you want to track raw DOM mousedown
            // (optionally do nothing, or set internal state).
        };
        _handleDomMouseUp = () => {
            // If user physically let go anywhere, we finalize the drag
            // ...
            this._onMouseUp();
        };
        // 8) The subscribe/unsubscribe utilities
        _subscribe(name, listener) {
            document.addEventListener(name, listener);
            this._listeners.push({ name, listener });
        }
        _unsubscribe(name, listener) {
            document.removeEventListener(name, listener);
            const idx = this._listeners.findIndex((x) => x.name === name && x.listener === listener);
            if (idx !== -1)
                this._listeners.splice(idx, 1);
        }
        /**
         * Subscribe to relevant events, e.g., crosshair move, chart click.
         */
        _subscribeEvents() {
            if (this.p1 && this.p2 && this.p1.time && this.p2.time) {
                this.chart_.subscribeCrosshairMove(this._handleMouseMove);
                this.chart_.subscribeClick(this._handleMouseDownOrUp);
                // Store subscriptions for later unsubscription
                this._listeners.push({ name: "crosshairMove", listener: this._handleMouseMove }, { name: "click", listener: this._handleMouseDownOrUp });
            }
            else {
                // Subscribe to visible logical range changes with a handler
                this.chart_
                    .timeScale()
                    .subscribeVisibleLogicalRangeChange(this._handleVisibleLogicalRangeChange);
                // Store the subscription for later unsubscription
                this._listeners.push({
                    name: "visibleLogicalRangeChange",
                    listener: this._handleVisibleLogicalRangeChange,
                });
            }
        }
        /**
         * Handle changes to the visible logical range.
         * Reprocesses the volume profile data and updates the view.
         */
        _handleVisibleLogicalRangeChange = () => {
            const timeScale = this.chart_.timeScale();
            this.visibleRange = timeScale.getVisibleLogicalRange();
            if (!this.visibleRange || !this.series_) {
                console.warn("[VolumeProfile] Visible range or source series is undefined.");
                return;
            }
            // Update p1 and p2 based on the new visible range
            this.p1 = {
                time: null,
                logical: this.visibleRange.from ?? 0,
                price: 0,
            };
            this.p2 = {
                time: null,
                logical: this.visibleRange.to ?? (this.series_.data().length - 1),
                price: 0,
            };
            this.sliceData();
            // Reprocess the volume profile data based on the new visible range
            const vpData = this.calculateVolumeProfile();
            if (vpData) {
                this._vpData = vpData;
                this.updateAllViews();
                this.requestUpdate(); // Trigger re-rendering
            }
            else {
                console.warn("[VolumeProfile] Failed to process Volume Profile data on visible range change.");
            }
        };
        _handleMouseMove = (param) => {
            const mousePoint = this._eventToPoint(param);
            this._latestHoverPoint = mousePoint;
            if (VolumeProfile._mouseIsDown) {
                this._handleDragInteraction(param);
            }
            else {
                // If near p1/p2 => HOVERING, else NONE
                if (this._mouseIsOverPointCanvas(param, 1) ||
                    this._mouseIsOverPointCanvas(param, 2)) {
                    if (this._state === InteractionState.NONE) {
                        this._moveToState(InteractionState.HOVERING);
                    }
                }
                else {
                    if (this._state !== InteractionState.NONE) {
                        this._moveToState(InteractionState.NONE);
                    }
                }
            }
        };
        /**
         * Click => toggle mouseDown
         */
        _handleMouseDownOrUp = () => {
            VolumeProfile._mouseIsDown = !VolumeProfile._mouseIsDown;
            if (VolumeProfile._mouseIsDown) {
                this._onMouseDown();
            }
            else {
                this._onMouseUp();
            }
            this.sliceData();
            this._vpData = this.calculateVolumeProfile();
            // Force re-render
            this.update();
        };
        _onMouseDown() {
            this._startDragPoint = this._latestHoverPoint;
            if (!this._startDragPoint || !this.p1 || !this.p2)
                return;
            // Are we near p1 or p2 in 'raw' logic?
            const nearP1 = this._mouseIsOverPointRaw(this._startDragPoint, this.p1);
            const nearP2 = this._mouseIsOverPointRaw(this._startDragPoint, this.p2);
            if (nearP1) {
                this._moveToState(InteractionState.DRAGGINGP1);
            }
            else if (nearP2) {
                this._moveToState(InteractionState.DRAGGINGP2);
            }
            else {
                this._moveToState(InteractionState.DRAGGING);
            }
        }
        _onMouseUp() {
            VolumeProfile._mouseIsDown = false;
            this._startDragPoint = null;
            this._moveToState(InteractionState.HOVERING);
            // Re-slice the data based on the updated p1 and p2 points.
            this.sliceData();
            // Recompute the volume profile bins with the updated options.
            this._vpData = this.calculateVolumeProfile();
            // Trigger an update to re-render the pane views.
            this.update();
        }
        _handleDragInteraction(param) {
            if (this._state !== InteractionState.DRAGGING &&
                this._state !== InteractionState.DRAGGINGP1 &&
                this._state !== InteractionState.DRAGGINGP2) {
                return;
            }
            const newPoint = this._eventToPoint(param);
            if (!newPoint || !this._startDragPoint)
                return;
            const diff = {
                logical: newPoint.logical - this._startDragPoint.logical,
                price: newPoint.price - this._startDragPoint.price,
            };
            this._onDrag(diff);
            // Now re-slice the data & recalc bins
            this.sliceData();
            this._vpData = this.calculateVolumeProfile();
            // Force re-render
            this.update();
            // Update anchor
            this._startDragPoint = newPoint;
        }
        _onDrag(diff) {
            if (!this.p1 || !this.p2)
                return;
            // If the user is dragging entire shape, do both
            if (this._state === InteractionState.DRAGGING) {
                this._addDiffToPoint(this.p1, diff.logical, diff.price);
                this._addDiffToPoint(this.p2, diff.logical, diff.price);
            }
            else if (this._state === InteractionState.DRAGGINGP1) {
                this._addDiffToPoint(this.p1, diff.logical, diff.price);
            }
            else if (this._state === InteractionState.DRAGGINGP2) {
                this._addDiffToPoint(this.p2, diff.logical, diff.price);
            }
            // Re-slice the data based on the updated p1 and p2 points.
            this.sliceData();
            // Recompute the volume profile bins with the updated options.
            this._vpData = this.calculateVolumeProfile();
            // Trigger an update to re-render the pane views.
            this.update();
        }
        _addDiffToPoint(point, ldiff, pdiff) {
            point.logical = (point.logical + ldiff);
            point.price = point.price + pdiff;
            // If you want to recalc time, do so here
        }
        /**
         * Minimal "raw" logic check
         */
        _mouseIsOverPointRaw(mousePt, pt) {
            if (!mousePt)
                return false;
            const tol = 1; // 1 bar index + 1 price unit tolerance, or whichever
            if (Math.abs(mousePt.logical - pt.logical) < tol) {
                if (Math.abs(mousePt.price - pt.price) < tol)
                    return true;
            }
            return false;
        }
        /**
         * "Canvas" check if user is near p1/p2
         */
        _mouseIsOverPointCanvas(param, which) {
            if (!param.point || !this.p1 || !this.p2)
                return false;
            const tolerancePx = 10;
            const cpt = which === 1
                ? convertPoint(this.p1, this.chart_, this.series_)
                : convertPoint(this.p2, this.chart_, this.series_);
            const dx = param.point.x - cpt.x;
            const dy = param.point.y - cpt.y;
            return dx * dx + dy * dy < tolerancePx * tolerancePx;
        }
        _moveToState(state) {
            switch (state) {
                case InteractionState.NONE:
                    document.body.style.cursor = "default";
                    this._hovered = false;
                    // Unsubscribe from DOM events
                    this._unsubscribe("mousedown", this._handleDomMouseDown);
                    this._unsubscribe("mouseup", this._handleDomMouseUp);
                    break;
                case InteractionState.HOVERING:
                    document.body.style.cursor = "pointer";
                    this._hovered = true;
                    // Sub to mousedown, unsub from mouseup
                    this._subscribe("mousedown", this._handleDomMouseDown);
                    this._unsubscribe("mouseup", this._handleDomMouseUp);
                    break;
                case InteractionState.DRAGGING:
                case InteractionState.DRAGGINGP1:
                case InteractionState.DRAGGINGP2:
                    document.body.style.cursor = "grabbing";
                    this._hovered = false;
                    // unsub from mousedown, sub to mouseup
                    this._unsubscribe("mousedown", this._handleDomMouseDown);
                    this._subscribe("mouseup", this._handleDomMouseUp);
                    break;
            }
            this._state = state;
            // Re-slice the data based on the updated p1 and p2 points.
            this.sliceData();
            // Recompute the volume profile bins with the updated options.
            this._vpData = this.calculateVolumeProfile();
            // Trigger an update to re-render the pane views.
            this.update();
        }
        /**
         * Convert the mouse event => LogicalPoint
         */
        _eventToPoint(param) {
            if (!param.point || param.logical == null)
                return null;
            const barPrice = this.series_.coordinateToPrice(param.point.y);
            if (barPrice == null)
                return null;
            return {
                time: param.time ?? null,
                logical: param.logical,
                price: barPrice.valueOf(),
            };
        }
        /** Slices the original data in [p1..p2] range */
        sliceData() {
            if (!this.p1 || !this.p2)
                return;
            const start = Math.min(this.p1.logical, this.p2.logical);
            const end = Math.max(this.p1.logical, this.p2.logical);
            this._currentSlice = this._originalData.slice(Math.max(0, start), Math.min(end + 1, this._originalData.length - 1));
        }
        calculateDynamicSections(visibleBars, priceMin, priceMax) {
            const K1 = 20; // Adjust for sensitivity to number of bars
            const K2 = 5; // Adjust for sensitivity to price range
            if (visibleBars <= 0 || priceMax <= priceMin) {
                return 10; // Default fallback value if inputs are invalid
            }
            // Dynamic calculation of section count
            const sectionsFromBars = visibleBars / K1;
            const sectionsFromPrice = (priceMax - priceMin) / K2;
            // Take the maximum of the two calculations
            const dynamicSections = 2 *
                Math.max(1, Math.floor(Math.max(sectionsFromBars, sectionsFromPrice)));
            return Math.max(5, dynamicSections);
        }
        calculateVolumeProfile() {
            const visibleBars = Math.min(this.visibleRange.to, this._originalData.length - 1) -
                Math.max(this.visibleRange.from, 0);
            let priceMin = Number.POSITIVE_INFINITY;
            let priceMax = Number.NEGATIVE_INFINITY;
            const profile = [];
            let refTime;
            if (this._currentSlice && this._currentSlice.length > 0) {
                for (const pt of this._currentSlice) {
                    const repPrice = pt.close ?? pt.open;
                    if (repPrice !== undefined) {
                        priceMin = Math.min(priceMin, repPrice);
                        priceMax = Math.max(priceMax, repPrice);
                    }
                }
                // Handle cases where priceMin or priceMax were not updated
                if (priceMin === Number.POSITIVE_INFINITY ||
                    priceMax === Number.NEGATIVE_INFINITY) {
                    priceMin = 0;
                    priceMax = 1;
                }
                // Determine the number of sections dynamically if not explicitly set
                let binCount = this._options.sections !== undefined && this._options.sections > 0
                    ? this._options.sections
                    : this.calculateDynamicSections(visibleBars, priceMin, priceMax);
                // Calculate price range and bin size
                const priceRange = priceMax === priceMin ? 1 : priceMax - priceMin;
                const binSize = priceRange / binCount;
                for (let i = 0; i < binCount; i++) {
                    const binMin = priceMin + i * binSize;
                    const binMax = priceMin + (i + 1) * binSize;
                    let upData = 0;
                    let downData = 0;
                    for (const pt of this._currentSlice) {
                        const repPrice = pt.close ?? pt.open;
                        if (repPrice !== undefined &&
                            repPrice >= binMin &&
                            repPrice < binMax) {
                            const isUp = (pt.close ?? 0) >= (pt.open ?? 0);
                            const volume = pt.volume || 0;
                            if (isUp)
                                upData += volume;
                            else
                                downData += volume;
                        }
                    }
                    // Decide color/border
                    const isUp = upData >= downData;
                    const color = isUp
                        ? this._options.upColor ?? setOpacity(this.series_.options().upColor, .1) ?? "rgba(0,128,0,0.1)"
                        : this._options.downColor ?? setOpacity(this.series_.options().downColor, .1) ?? "rgba(128,0,0,0.1)";
                    const borderColor = isUp
                        ? this._options.borderUpColor ?? setOpacity(this.series_.options().upColor, .5) ?? "rgba(0,128,0,0.66)"
                        : this._options.borderDownColor ?? setOpacity(this.series_.options().downColor, .5) ?? "rgba(128,0,0,0.66)";
                    profile.push({
                        price: binMin,
                        upData,
                        downData,
                        color: this._options.visible ? color : "rgba(0,0,0,0)",
                        borderColor: this._options.visible ? borderColor : "rgba(0,0,0,0)",
                        minPrice: binMin,
                        maxPrice: binMax,
                    });
                }
                refTime = this._options.rightSide
                    ? this._currentSlice[this._currentSlice.length - 1].time
                    : this._currentSlice[0].time;
            }
            else {
                // fallback
                refTime = Date.now().toString();
            }
            this.update();
            return {
                time: refTime,
                profile,
                width: this._options.width ?? 20,
                visibleRange: this.visibleRange,
            };
        }
        /**
         * Schedules an update with requestAnimationFrame
         */
        update() {
            if (!this._pendingUpdate) {
                this._pendingUpdate = true;
                requestAnimationFrame(() => {
                    super.requestUpdate();
                    this.updateAllViews();
                    // or if you just have "this.updateAllViews();"
                    console.log("VolumeProfile updated p1=", this.p1, "p2=", this.p2);
                    this._pendingUpdate = false;
                });
            }
        }
        updateAllViews() {
            // If you want a direct forced re-render
            this._paneViews.forEach((pv) => pv.update());
        }
        /**
         * ISeriesPrimitive: returns your pane views
         */
        paneViews() {
            return this._paneViews;
        }
        /**
         * If you want autoscaling, define it
         */
        autoscaleInfo() {
            if (!this._vpData.profile.length)
                return null;
            return {
                priceRange: {
                    minValue: this._vpData.profile[0].minPrice,
                    maxValue: this._vpData.profile[this._vpData.profile.length - 1].maxPrice,
                },
            };
        }
        /**
         * Applies updated VolumeProfile options, re-slices data, recalculates the profile, and updates the view.
         *
         * @param updatedOptions - A partial object containing one or more VolumeProfileOptions to update.
         */
        applyOptions(updatedOptions) {
            // Merge the new options into the existing options object.
            this._options = {
                ...this._options,
                ...updatedOptions,
            };
            // Re-slice the data based on the updated p1 and p2 points.
            this.sliceData();
            // Recompute the volume profile bins with the updated options.
            this._vpData = this.calculateVolumeProfile();
            // Trigger an update to re-render the pane views.
            this.update();
        }
    }
    /**
     * The VolumeProfilePaneView => transforms bins => screen coords, returns a renderer
     */
    class VolumeProfilePaneView {
        _source;
        _x = null;
        _width = 0;
        _items = [];
        _maxVolume;
        visibleRange = null;
        _p1 = { x: null, y: null };
        _p2 = { x: null, y: null };
        constructor(source) {
            this._source = source;
            // compute maxVolume from the profile
            this._maxVolume = this._source._vpData.profile.reduce((acc, bin) => {
                return Math.max(acc, bin.upData + bin.downData);
            }, 0);
        }
        update() {
            if (!this._source.p1 || !this._source.p2)
                return;
            const data = this._source._vpData;
            const chart = this._source.chart_;
            const series = this._source.series_;
            const timeScale = chart.timeScale();
            // Convert data.time => x
            this._x = timeScale.timeToCoordinate(data.time) ?? null;
            const barSpacing = timeScale.options().barSpacing ?? 1;
            const start = Math.max(0, Math.min(this._source.p1.logical, this._source.p2.logical));
            const end = Math.min(Math.max(this._source.p1.logical, this._source.p2.logical), this._source._originalData.length - 1);
            this._width =
                (data.width && data.width !== 0 ? data.width : (end - start) / 3) *
                    barSpacing;
            // Convert p1/p2 => canvas coords
            this._p1 = convertPoint(this._source.p1, chart, series);
            this._p2 = convertPoint(this._source.p2, chart, series);
            // Rebuild items from bins
            this._items = [];
            if (!data.profile.length)
                return;
            // Possibly re-check maxVolume if slice changed
            this._maxVolume = data.profile.reduce((acc, bin) => {
                return Math.max(acc, bin.upData + bin.downData);
            }, 0);
            for (const bin of data.profile) {
                const y1 = series.priceToCoordinate(bin.maxPrice);
                const y2 = series.priceToCoordinate(bin.minPrice);
                if (y1 == null || y2 == null) {
                    this._items.push({
                        y1: null,
                        y2: null,
                        combinedWidth: 0,
                        upWidth: 0,
                        downWidth: 0,
                        color: bin.color,
                        borderColor: bin.borderColor,
                    });
                    continue;
                }
                const rawVolume = bin.upData + bin.downData;
                const combinedWidth = this._maxVolume > 0 ? this._width * (rawVolume / this._maxVolume) : 0;
                let upWidth = 0, downWidth = 0;
                if (rawVolume > 0) {
                    upWidth = (bin.upData / rawVolume) * combinedWidth;
                    downWidth = (bin.downData / rawVolume) * combinedWidth;
                }
                this._items.push({
                    y1,
                    y2,
                    combinedWidth,
                    upWidth,
                    downWidth,
                    color: bin.color,
                    borderColor: bin.borderColor,
                });
            }
        }
        renderer() {
            return new VolumeProfileRenderer({
                x: this._x,
                width: this._width,
                items: this._items,
                visibleRange: {
                    from: this._source.chart
                        .timeScale()
                        .logicalToCoordinate(Math.max(0, this._source.visibleRange.from)),
                    to: this._source.chart
                        .timeScale()
                        .logicalToCoordinate(Math.min(this._source.series.data().length - 1, this._source.visibleRange.to))
                },
                maxVolume: this._maxVolume,
                maxBars: this._source.series.data().length
            }, this._p1, this._p2, this._source._options, false);
        }
        zOrder() {
            return 'bottom';
        }
    }
    /**
     * The VolumeProfileRenderer => draws bins, extends TwoPointDrawingPaneRenderer
     */
    class VolumeProfileRenderer extends TwoPointDrawingPaneRenderer {
        _data;
        options;
        p1;
        p2;
        constructor(data, p1, p2, options, hovered) {
            super(p1, p2, options, hovered);
            this._data = data;
            this.options = options;
            this.p1 = p1;
            this.p2 = p2;
        }
        draw() { }
        drawBackground(target) {
            console.log(`[VolumeProfileRenderer] draw() called with rightSide: ${this.options.rightSide}`);
            target.useBitmapCoordinateSpace((scope) => {
                let ctx = scope.context;
                // Draw grid lines
                this._drawGrid(ctx, scope);
                setLineStyle(ctx, this.options.lineStyle);
                // Draw the volume profile bars
                this._data.items.forEach((row) => {
                    if (row.y1 === null || row.y2 === null)
                        return;
                    if (this._data.x === null)
                        return; // Ensure x-coordinate is valid
                    // Calculate rectangle position and dimensions
                    const rectY = Math.min(row.y1, row.y2) * scope.verticalPixelRatio;
                    const rectHeight = Math.abs(row.y2 - row.y1) * scope.verticalPixelRatio;
                    const combinedWidth = row.upWidth + row.downWidth;
                    const rectWidth = combinedWidth * scope.horizontalPixelRatio;
                    // Determine rectX based on rightSide
                    let rectX;
                    if (this.options.rightSide) {
                        // Render on the right side
                        rectX = (this._data.x - combinedWidth) * scope.horizontalPixelRatio;
                    }
                    else {
                        // Render on the left side
                        rectX = this._data.x * scope.horizontalPixelRatio;
                    }
                    // Dynamic radius calculation
                    const minRadius = 2; // Minimum radius in pixels
                    const maxRadius = 25; // Maximum radius in pixels
                    const percentage = 0.25; // 25% of the bar's height
                    const radius = Math.min(Math.max(rectHeight * percentage, minRadius), maxRadius);
                    if (rectHeight > 0) {
                        // Draw the border rectangle
                        ctx.beginPath();
                        this._drawRoundedRect(ctx, rectX, rectY, rectWidth, rectHeight, radius);
                        ctx.strokeStyle = row.borderColor;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        // Calculate fill dimensions
                        const fillWidth = Math.max(row.upWidth, row.downWidth) * scope.horizontalPixelRatio;
                        let fillX;
                        if (!this.options.rightSide) {
                            // Fill starts from the left of the bar
                            fillX = rectX;
                        }
                        else {
                            // Fill starts from the left minus fillWidth (i.e., from the right side)
                            fillX = rectX + (combinedWidth - fillWidth);
                        }
                        // Draw the filled rectangle representing greater volume
                        ctx.beginPath();
                        this._drawRoundedRect(ctx, fillX, rectY, fillWidth, rectHeight, radius);
                        ctx.fillStyle = row.color;
                        ctx.fill();
                    }
                });
            });
        }
        /**
         * Draw a grid within the volume profile region, aligning grid rows with sections.
         */
        _drawGrid(ctx, scope) {
            const { items, x } = this._data;
            if (!items || items.length === 0 || x === null)
                return;
            // Check if grid drawing is enabled
            if (!this.options.drawGrid)
                return;
            // Determine the grid width
            let gridWidth;
            if (this.options.gridWidth !== undefined && this.options.gridWidth !== 1) {
                // Use the specified gridWidth from options
                gridWidth = this.options.gridWidth * scope.horizontalPixelRatio;
            }
            else {
                gridWidth = (this._data.visibleRange.to - this._data.visibleRange.from) * scope.horizontalPixelRatio;
            }
            // Set grid line color
            ctx.strokeStyle = this.options.visible
                ? this.options.gridColor || "rgba(255, 255, 255, 0.2)"
                : "rgba(0,0,0,0)"; // Use gridColor from options or default
            // Use setLineStyle to configure grid line style
            setLineStyle(ctx, this.options.gridLineStyle || lightweightCharts.LineStyle.Solid);
            // Loop through each item to draw the grid lines individually with correct offset
            items.forEach((item) => {
                if (item.y1 === null || item.y2 === null)
                    return;
                // Calculate per-item X shift amount based on its upWidth and downWidth
                const shiftAmount = (item.upWidth + item.downWidth) * scope.horizontalPixelRatio;
                let gridStartX;
                let gridEndX;
                if (this.options.rightSide) {
                    gridStartX = (x - gridWidth);
                    gridEndX = x - shiftAmount;
                }
                else {
                    gridStartX = x + shiftAmount;
                    gridEndX = x + gridWidth;
                }
                // Scale Y-axis positions
                const y1 = item.y1 * scope.verticalPixelRatio;
                const y2 = item.y2 * scope.verticalPixelRatio;
                // Draw horizontal grid lines per item
                ctx.beginPath();
                ctx.moveTo(gridStartX, y1);
                ctx.lineTo(gridEndX, y1);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(gridStartX, y2);
                ctx.lineTo(gridEndX, y2);
                ctx.stroke();
            });
        }
        /**
         * Draws a rounded rectangle on the canvas context.
         * Rounds left corners if rightSide is true, otherwise rounds right corners.
         * @param ctx - Canvas rendering context.
         * @param x - The x-coordinate of the rectangle's starting point.
         * @param y - The y-coordinate of the rectangle's starting point.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param r - The radius for the rounded corners.
         * @param rightSide - Determines which corners to round.
         */
        _drawRoundedRect(ctx, x, y, w, h, r) {
            const rFinal = Math.abs(Math.min(r, w / 2, h / 2)); // Ensure radius doesn't exceed dimensions
            ctx.beginPath();
            if (w > 0 && r > 0) {
                if (this.options.rightSide) {
                    // Round top-left and bottom-left corners
                    ctx.moveTo(x + rFinal, y);
                    ctx.lineTo(x + w, y);
                    ctx.lineTo(x + w, y + h);
                    ctx.lineTo(x + rFinal, y + h);
                    ctx.arcTo(x, y + h, x, y + h - rFinal, rFinal);
                    ctx.lineTo(x, y + rFinal);
                    ctx.arcTo(x, y, x + rFinal, y, rFinal);
                }
                else {
                    // Round top-right and bottom-right corners
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + w - rFinal, y);
                    ctx.arcTo(x + w, y, x + w, y + rFinal, rFinal);
                    ctx.lineTo(x + w, y + h - rFinal);
                    ctx.arcTo(x + w, y + h, x + w - rFinal, y + h, rFinal);
                    ctx.lineTo(x, y + h);
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
            }
            else {
                return;
            }
        }
    }

    // Helper export function to calculate ATR
    /**
     * Compute Simple Moving Average (SMA) iteratively
     * @param data - Array of values
     * @param length - SMA period
     * @returns SMA value at the latest index
     */
    function getSma(data, length) {
        if (data.length < length)
            return NaN;
        let sum = 0;
        // Initialize first SMA window
        for (let i = 0; i < length; i++) {
            sum += data[i];
        }
        let sma = sum / length;
        // Compute SMA iteratively
        for (let i = length; i < data.length; i++) {
            sum = sum - data[i - length] + data[i];
            sma = sum / length;
        }
        return sma;
    }
    /**
     * Computes the Rolling Moving Average (RMA) for a data array.
     * @param data Array of values (gains, losses, or prices).
     * @param period RMA period (e.g., 14 for RSI).
     * @returns Array of RMA values, same length as `data`.
     */
    function getRma(data, period) {
        if (period <= 0) {
            // Defensive check
            return NaN;
        }
        const alpha = 1 / period;
        const rmaArr = new Array(data.length).fill(NaN);
        // We must start the initial average with the first data point (or first "period" average).
        // A common approach for RSI: use the first "period" items' average.
        // But for simplicity, let's start from the first item:
        if (data.length > 0) {
            let avg = data[0]; // Start with the first data point
            rmaArr[0] = avg;
            for (let i = 1; i < data.length; i++) {
                avg = alpha * data[i] + (1 - alpha) * avg;
                rmaArr[i] = avg;
            }
        }
        return rmaArr[rmaArr.length - 1];
    }
    function getLinreg(data, period, offset = 0) {
        if (data.length < period)
            return NaN;
        const subset = data.slice(data.length - period);
        const n = period;
        const sumX = (n * (n - 1)) / 2;
        const sumY = subset.reduce((sum, val) => sum + val, 0);
        const sumXY = subset.reduce((sum, val, idx) => sum + idx * val, 0);
        const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        return intercept + slope * (n - 1);
    }
    /**
     * Computes the Relative Strength Index (RSI).
     * @param data - Array of closing prices.
     * @param length - RSI period.
     * @returns RSI value at the latest index.
     */
    function getRsi(data, length) {
        if (data.length < length)
            return NaN;
        let changeArray = data.map((val, idx) => (idx === 0 ? 0 : val - data[idx - 1]));
        let upMoves = changeArray.map(val => Math.max(val, 0));
        let downMoves = changeArray.map(val => Math.max(-val, 0));
        let avgGain = getRma(upMoves, length); // Use Rolling Moving Average for smoothing
        let avgLoss = getRma(downMoves, length);
        if (avgLoss === 0)
            return 100; // Avoid division by zero
        if (avgGain === 0)
            return 0;
        let rs = avgGain / avgLoss;
        return 100 - 100 / (1 + rs);
    }
    /**
    * Applies color attributes to each data point in a histogram series.
    * For the first point, the upColor is used.
    * For each subsequent point, if the current value is greater than or equal
    * to the previous value, upColor is used; otherwise, downColor is used.
    *
    * @param data - Array of data points with at least { time, value }.
    * @param upColor - Color to use when the value is rising (default: 'green').
    * @param downColor - Color to use when the value is falling (default: 'red').
    */
    function setHistogramColors(data, upColor, downColor) {
        for (let i = 0; i < data.length; i++) {
            if (i === 0) {
                data[i].color = upColor;
            }
            else {
                const currentValue = data[i].value;
                const previousValue = data[i - 1].value;
                if (!isNaN(currentValue) && !isNaN(previousValue)) {
                    data[i].color = currentValue >= previousValue ? upColor : downColor;
                }
                else {
                    data[i].color = upColor;
                }
            }
        }
    }
    /************************************************
     * Helper: getNumericArray
     * Ensures the override for a param is an array of numbers.
     * If the user passes a single number, we wrap it.
     ************************************************/
    function getNumericArray(overrideParams, paramName, defaultArr) {
        const val = overrideParams && paramName in overrideParams
            ? overrideParams[paramName]
            : defaultArr;
        return Array.isArray(val) ? val.map(x => Number(x)) : [Number(val)];
    }
    /************************************************
     * Helper: pickParam
     * For figure index i (0-based), pick arr[i] if exists; otherwise, repeat last.
     ************************************************/
    function pickParam(arr, i) {
        return i < arr.length ? arr[i] : arr[arr.length - 1];
    }
    /**
     * A helper function to retrieve (paramMap + overrideParams) for each param key.
     */
    function getParams(definition, overrideParams) {
        const combined = {};
        for (const [paramName, spec] of Object.entries(definition.paramMap)) {
            const val = overrideParams?.[paramName] ?? spec.defaultValue;
            combined[paramName] = val;
        }
        return combined;
    }

    /************************************************
     * 1) Arnaud Legoux Moving Average (ALMA)
     *    Parameters: length, offset, sigma
     *    Title is set as ALMA{length} (e.g. "ALMA9")
     ************************************************/
    const arnaudLegouxMovingAverage = {
        name: "Arnaud Legoux Moving Average",
        shortName: "ALMA",
        shouldOhlc: false,
        paramMap: {
            length: { defaultValue: [9], type: "numberArray" },
            offset: { defaultValue: [0.85], type: "numberArray" },
            sigma: { defaultValue: [6], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const defLength = this.paramMap.length.defaultValue;
            const defOffset = this.paramMap.offset.defaultValue;
            const defSigma = this.paramMap.sigma.defaultValue;
            const lenArr = getNumericArray(overrideParams, "length", defLength);
            const offArr = getNumericArray(overrideParams, "offset", defOffset);
            const sigArr = getNumericArray(overrideParams, "sigma", defSigma);
            const figureCount = Math.max(lenArr.length, offArr.length, sigArr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const length = pickParam(lenArr, i);
                const offset = pickParam(offArr, i);
                const sigma = pickParam(sigArr, i);
                const almaArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < length - 1) {
                        almaArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    let norm = 0, sum = 0;
                    const m = offset * (length - 1);
                    const s = length / sigma;
                    for (let j = 0; j < length; j++) {
                        const weight = Math.exp(-Math.pow(j - m, 2) / (2 * Math.pow(s, 2)));
                        norm += weight;
                        const index2 = idx - (length - 1) + j;
                        sum += dataList[index2].close * weight;
                    }
                    almaArr.push({ time: bar.time, value: sum / norm });
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                // Title follows the old EMA logic: ALMA + the length value (e.g. "ALMA9")
                const key = "alma" + suffix;
                const title = "ALMA" + length + (figureCount > 1 ? ` #${i + 1}` : "");
                results.push({
                    key,
                    title,
                    type: "line",
                    data: almaArr,
                });
            }
            return results;
        },
    };
    /************************************************
     * 2) Bollinger Bands (BOLL)
     *    Parameters: length, multiplier
     *    For each figure, 3 lines are produced (UP, MID, DN).
     *    Titles are set as BOLL_UP{length} etc.
     ************************************************/
    const getBollMd = (subset, mid) => {
        let sum = 0;
        subset.forEach(bar => {
            const diff = bar.close - mid;
            sum += diff * diff;
        });
        return Math.sqrt(sum / subset.length);
    };
    const bollingerBands = {
        name: "Bollinger Bands",
        shortName: "BOLL",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [20], type: "numberArray" },
            multiplier: { defaultValue: [2], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const pArr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const mArr = getNumericArray(overrideParams, "multiplier", this.paramMap.multiplier.defaultValue);
            const figureCount = Math.max(pArr.length, mArr.length);
            const allFigs = [];
            for (let i = 0; i < figureCount; i++) {
                const length = pickParam(pArr, i);
                const multiplier = pickParam(mArr, i);
                let closeSum = 0;
                const upArr = [];
                const midArr = [];
                const dnArr = [];
                dataList.forEach((bar, idx) => {
                    closeSum += bar.close;
                    if (idx >= length - 1) {
                        const mid = closeSum / length;
                        const windowData = dataList.slice(idx - (length - 1), idx + 1);
                        const md = getBollMd(windowData, mid);
                        upArr.push({ time: bar.time, value: mid + multiplier * md });
                        midArr.push({ time: bar.time, value: mid });
                        dnArr.push({ time: bar.time, value: mid - multiplier * md });
                        closeSum -= dataList[idx - (length - 1)].close;
                    }
                    else {
                        upArr.push({ time: bar.time, value: NaN });
                        midArr.push({ time: bar.time, value: NaN });
                        dnArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                allFigs.push({
                    key: `boll_up${suffix}`,
                    title: `BOLL_UP${length}${suffix}`,
                    type: "line",
                    data: upArr,
                });
                allFigs.push({
                    key: `boll_mid${suffix}`,
                    title: `BOLL_MID${length}${suffix}`,
                    type: "line",
                    data: midArr,
                });
                allFigs.push({
                    key: `boll_dn${suffix}`,
                    title: `BOLL_DN${length}${suffix}`,
                    type: "line",
                    data: dnArr,
                });
            }
            return allFigs;
        },
    };
    /************************************************
     * 3) Exponential Moving Average (EMA)
     *    Parameter: length (array)
     *    Title: "EMA" concatenated with the length value (e.g. "EMA12")
     ************************************************/
    const exponentialMovingAverage = {
        name: "Exponential Moving Average",
        shortName: "EMA",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [6, 12, 20], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                let emaVal = 0, sum = 0;
                const dataOut = [];
                dataList.forEach((bar, idx) => {
                    sum += bar.close;
                    if (idx === val - 1) {
                        emaVal = sum / val;
                    }
                    else if (idx > val - 1) {
                        const multiplier = 2 / (val + 1);
                        emaVal = (bar.close - emaVal) * multiplier + emaVal;
                    }
                    if (idx >= val - 1) {
                        dataOut.push({ time: bar.time, value: emaVal });
                        sum -= dataList[idx - (val - 1)].close;
                    }
                    else {
                        dataOut.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "ema" + suffix;
                // Title is the short name followed immediately by the length value
                const title = "EMA" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: dataOut });
            });
            return figs;
        },
    };
    /************************************************
     * 4) Highest High (HH)
     *    Parameter: length (array)
     *    Title: "HH" concatenated with the length value (e.g. "HH14")
     ************************************************/
    const highestHigh = {
        name: "Highest High",
        shortName: "HH",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const out = [];
            arr.forEach((val, i) => {
                const hhArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < val - 1) {
                        hhArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    let highest = -Infinity;
                    for (let j = idx - (val - 1); j <= idx; j++) {
                        highest = Math.max(highest, dataList[j].high);
                    }
                    hhArr.push({ time: bar.time, value: highest });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "hh" + suffix;
                const title = "HH" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                out.push({ key, title, type: "line", data: hhArr });
            });
            return out;
        },
    };
    /************************************************
     * 5) Linear Regression (LINREG)
     *    Parameter: length (array)
     *    Title: "LINREG" concatenated with the length value (e.g. "LINREG14")
     ************************************************/
    const linRegIndicator = {
        name: "Linear Regression",
        shortName: "LINREG",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const closeArr = dataList.map(b => b.close);
            const figs = [];
            arr.forEach((val, i) => {
                const linRegArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < val - 1) {
                        linRegArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const slice = closeArr.slice(idx - (val - 1), idx + 1);
                    const linVal = getLinreg(slice, val, 0);
                    linRegArr.push({ time: bar.time, value: linVal });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "linreg" + suffix;
                const title = "LINREG" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: linRegArr });
            });
            return figs;
        },
    };
    /************************************************
     * 6) Lowest Low (LL)
     *    Parameter: length (array)
     *    Title: "LL" concatenated with the length value (e.g. "LL14")
     ************************************************/
    const lowestLow = {
        name: "Lowest Low",
        shortName: "LL",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                const llArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < val - 1) {
                        llArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    let lowest = Infinity;
                    for (let j = idx - (val - 1); j <= idx; j++) {
                        lowest = Math.min(lowest, dataList[j].low);
                    }
                    llArr.push({ time: bar.time, value: lowest });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "ll" + suffix;
                const title = "LL" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: llArr });
            });
            return figs;
        },
    };
    /************************************************
     * 7) Median
     *    Parameter: length (array)
     *    Title: "Median" concatenated with the length value (e.g. "Median14")
     ************************************************/
    const median = {
        name: "Median",
        shortName: "Median",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                const medArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < val - 1) {
                        medArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const subset = dataList.slice(idx - (val - 1), idx + 1).map(b => b.close);
                    subset.sort((a, b) => a - b);
                    const mid = Math.floor(subset.length / 2);
                    const medianVal = subset.length % 2 === 0
                        ? (subset[mid - 1] + subset[mid]) / 2
                        : subset[mid];
                    medArr.push({ time: bar.time, value: medianVal });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "median" + suffix;
                const title = "Median" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: medArr });
            });
            return figs;
        },
    };
    /************************************************
     * 8) Moving Average (MA)
     *    Parameter: length (array) (4 values originally)
     *    Title: "MA" concatenated with the length value (e.g. "MA5")
     ************************************************/
    const movingAverage = {
        name: "Moving Average",
        shortName: "MA",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [5, 10, 30, 60], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                const maArr = [];
                let sum = 0;
                dataList.forEach((bar, idx) => {
                    sum += bar.close;
                    if (idx >= val - 1) {
                        const avg = sum / val;
                        maArr.push({ time: bar.time, value: avg });
                        sum -= dataList[idx - (val - 1)].close;
                    }
                    else {
                        maArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "ma" + suffix;
                const title = "MA" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: maArr });
            });
            return figs;
        },
    };
    /************************************************
     * 9) Rolling Moving Average (RMA)
     *    Parameter: length (array)
     *    Title: "RMA" concatenated with the length value (e.g. "RMA14")
     ************************************************/
    const rollingMovingAverage = {
        name: "Rolling Moving Average",
        shortName: "RMA",
        shouldOhlc: false,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                const alpha = 1 / val;
                let sum = 0;
                const rmaArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx === 0) {
                        sum = bar.close;
                    }
                    else {
                        sum = alpha * bar.close + (1 - alpha) * sum;
                    }
                    rmaArr.push({ time: bar.time, value: sum });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                const key = "rma" + suffix;
                const title = "RMA" + val + (arr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: rmaArr });
            });
            return figs;
        },
    };
    /************************************************
     * 10) Simple Moving Average (SMA)
     *    Parameters: n, k (both as arrays)
     *    Title: "SMA" concatenated with n value (e.g. "SMA12,2")
     ************************************************/
    const simpleMovingAverage = {
        name: "Simple Moving Average",
        shortName: "SMA",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [12], type: "numberArray" },
            k: { defaultValue: [2], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", this.paramMap.n.defaultValue);
            const kArr = getNumericArray(overrideParams, "k", this.paramMap.k.defaultValue);
            const figureCount = Math.max(nArr.length, kArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const nVal = pickParam(nArr, i);
                const kVal = pickParam(kArr, i);
                let closeSum = 0;
                let smaVal = 0;
                const smaArr = [];
                dataList.forEach((bar, idx) => {
                    closeSum += bar.close;
                    if (idx >= nVal - 1) {
                        if (idx === nVal - 1) {
                            smaVal = closeSum / nVal;
                        }
                        else {
                            smaVal = (bar.close * kVal + smaVal * (nVal - kVal)) / nVal;
                        }
                        closeSum -= dataList[idx - (nVal - 1)].close;
                        smaArr.push({ time: bar.time, value: smaVal });
                    }
                    else {
                        smaArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                const key = "sma" + suffix;
                const title = "SMA" + nVal + "," + kVal + (figureCount > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: smaArr });
            }
            return figs;
        },
    };
    /************************************************
     * 11) Stop and Reverse (SAR)
     *    Parameters: accStart, accStep, accMax (arrays)
     *    Title: "SAR" concatenated with accStart value (e.g. "SAR0.02,0.02,0.20")
     ************************************************/
    const stopAndReverse = {
        name: "Stop and Reverse",
        shortName: "SAR",
        shouldOhlc: true,
        paramMap: {
            accStart: { defaultValue: [0.02], type: "numberArray" },
            accStep: { defaultValue: [0.02], type: "numberArray" },
            accMax: { defaultValue: [0.20], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const startArr = getNumericArray(overrideParams, "accStart", this.paramMap.accStart.defaultValue);
            const stepArr = getNumericArray(overrideParams, "accStep", this.paramMap.accStep.defaultValue);
            const maxArr = getNumericArray(overrideParams, "accMax", this.paramMap.accMax.defaultValue);
            const figureCount = Math.max(startArr.length, stepArr.length, maxArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const accStart = pickParam(startArr, i);
                const accStep = pickParam(stepArr, i);
                const accMax = pickParam(maxArr, i);
                let af = accStart;
                let ep = 0;
                let sarVal = 0;
                let isUp = false;
                const sarArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx === 0) {
                        sarArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    if (idx === 1) {
                        isUp = bar.close > dataList[0].close;
                        ep = isUp ? bar.high : bar.low;
                        sarVal = isUp ? dataList[0].low : dataList[0].high;
                        sarArr.push({ time: dataList[0].time, value: sarVal });
                    }
                    sarVal = sarVal + af * (ep - sarVal);
                    if (isUp) {
                        if (bar.low < sarVal) {
                            isUp = false;
                            sarVal = ep;
                            af = accStart;
                            ep = bar.low;
                        }
                        else {
                            if (bar.high > ep) {
                                ep = bar.high;
                                af = Math.min(af + accStep, accMax);
                            }
                        }
                    }
                    else {
                        if (bar.high > sarVal) {
                            isUp = true;
                            sarVal = ep;
                            af = accStart;
                            ep = bar.high;
                        }
                        else {
                            if (bar.low < ep) {
                                ep = bar.low;
                                af = Math.min(af + accStep, accMax);
                            }
                        }
                    }
                    sarArr.push({ time: bar.time, value: sarVal });
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                const key = "sar" + suffix;
                const title = "SAR" + accStart + "," + accStep + "," + accMax + (figureCount > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: sarArr });
            }
            return figs;
        },
    };
    /************************************************
     * 12) Super Trend
     *    Parameters: factor, atrPeriod (arrays)
     *    Title: "SuperTrend" concatenated with factor (e.g. "SuperTrend3")
     *    (Note: Two lines are produced per figure: one for the trend and one for the direction.)
     ************************************************/
    const superTrend = {
        name: "Super Trend",
        shortName: "SuperTrend",
        shouldOhlc: true,
        paramMap: {
            factor: { defaultValue: [3], type: "numberArray" },
            atrPeriod: { defaultValue: [10], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const factorArr = getNumericArray(overrideParams, "factor", this.paramMap.factor.defaultValue);
            const atrArr = getNumericArray(overrideParams, "atrPeriod", this.paramMap.atrPeriod.defaultValue);
            const figureCount = Math.max(factorArr.length, atrArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const factor = pickParam(factorArr, i);
                const length = pickParam(atrArr, i); // atrPeriod renamed to length here for unification
                const stArr = [];
                const dirArr = [];
                let prevSuperTrend = NaN;
                let prevUpperBand = NaN;
                let prevLowerBand = NaN;
                let direction = NaN;
                dataList.forEach((bar, idx) => {
                    if (idx < length - 1) {
                        stArr.push({ time: bar.time, value: NaN });
                        dirArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    // Compute ATR over the last 'length' bars
                    let sumTR = 0;
                    for (let k = idx - (length - 1); k <= idx; k++) {
                        const prevClose = dataList[k - 1]?.close ?? dataList[k].close;
                        const cTr = Math.max(dataList[k].high - dataList[k].low, Math.abs(dataList[k].high - prevClose), Math.abs(dataList[k].low - prevClose));
                        sumTR += cTr;
                    }
                    const atr = sumTR / length;
                    const src = (bar.high + bar.low) / 2;
                    let upperBand = src + factor * atr;
                    let lowerBand = src - factor * atr;
                    if (!isNaN(prevLowerBand)) {
                        lowerBand = lowerBand > prevLowerBand || dataList[idx - 1].close < prevLowerBand
                            ? lowerBand
                            : prevLowerBand;
                    }
                    if (!isNaN(prevUpperBand)) {
                        upperBand = upperBand < prevUpperBand || dataList[idx - 1].close > prevUpperBand
                            ? upperBand
                            : prevUpperBand;
                    }
                    if (isNaN(prevSuperTrend)) {
                        direction = 1;
                    }
                    else if (prevSuperTrend === prevUpperBand) {
                        direction = bar.close > upperBand ? -1 : 1;
                    }
                    else {
                        direction = bar.close < lowerBand ? 1 : -1;
                    }
                    const stVal = direction === -1 ? lowerBand : upperBand;
                    stArr.push({ time: bar.time, value: stVal });
                    dirArr.push({ time: bar.time, value: direction });
                    prevSuperTrend = stVal;
                    prevUpperBand = upperBand;
                    prevLowerBand = lowerBand;
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "superTrend" + suffix,
                    title: "SuperTrend" + factor + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: stArr,
                });
                figs.push({
                    key: "direction" + suffix,
                    title: "Direction" + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: dirArr,
                });
            }
            return figs;
        },
    };
    /************************************************
     * 13) Symmetric Weighted Moving Average (SWMA)
     *    Parameter: window (array)
     *    Title: "SWMA" concatenated with the window (e.g. "SWMA4")
     ************************************************/
    const symmetricWeightedMovingAverage = {
        name: "Symmetrically Weighted Moving Average",
        shortName: "SWMA",
        shouldOhlc: false,
        paramMap: {
            window: { defaultValue: [4], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const windowArr = getNumericArray(overrideParams, "window", this.paramMap.window.defaultValue);
            const figs = [];
            windowArr.forEach((win, i) => {
                const swmaArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < win - 1) {
                        swmaArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    let numerator = 0, denominator = 0;
                    for (let j = 0; j < win; j++) {
                        const weight = j + 1;
                        numerator += dataList[idx - (win - 1) + j].close * weight;
                        denominator += weight;
                    }
                    swmaArr.push({ time: bar.time, value: numerator / denominator });
                });
                const suffix = windowArr.length > 1 ? `_${i + 1}` : "";
                const key = "swma" + suffix;
                const title = "SWMA" + win + (windowArr.length > 1 ? ` #${i + 1}` : "");
                figs.push({ key, title, type: "line", data: swmaArr });
            });
            return figs;
        },
    };
    /************************************************
     * 14) Triple Exponentially Smoothed Average (TRIX)
     *    Parameters: n, m (arrays)
     *    Title: "TRIX" concatenated with n value (e.g. "TRIX12")
     *    Produces 2 lines: one for TRIX and one for its moving average ("MATRIX")
     ************************************************/
    const tripleExponentiallySmoothedAverage = {
        name: "TRIX",
        shortName: "TRIX",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [12], type: "numberArray" },
            m: { defaultValue: [9], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", this.paramMap.n.defaultValue);
            const mArr = getNumericArray(overrideParams, "m", this.paramMap.m.defaultValue);
            const figureCount = Math.max(nArr.length, mArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const N = pickParam(nArr, i);
                const M = pickParam(mArr, i);
                let ema1 = 0, ema2 = 0, ema3 = 0;
                let sumClose = 0;
                const trixArr = [];
                const maTrixArr = [];
                let trixSum = 0;
                const buffer = [];
                dataList.forEach((bar, idx) => {
                    sumClose += bar.close;
                    if (idx === N - 1) {
                        ema1 = sumClose / N;
                    }
                    else if (idx > N - 1) {
                        ema1 = (bar.close * 2 + (N - 1) * ema1) / (N + 1);
                    }
                    if (idx >= N - 1) {
                        if (idx === 2 * N - 2) {
                            ema2 = ema1;
                        }
                        else if (idx > 2 * N - 2) {
                            ema2 = (ema1 * 2 + (N - 1) * ema2) / (N + 1);
                        }
                    }
                    let trVal = NaN;
                    if (idx >= 2 * N - 2) {
                        if (idx === 3 * N - 3) {
                            ema3 = ema2;
                        }
                        else if (idx > 3 * N - 3) {
                            const old = ema3;
                            ema3 = (ema2 * 2 + (N - 1) * old) / (N + 1);
                            trVal = ((ema3 - old) / old) * 100;
                        }
                    }
                    trixArr.push({ time: bar.time, value: trVal });
                    buffer.push(trVal);
                    trixSum += isNaN(trVal) ? 0 : trVal;
                    if (buffer.length > M) {
                        const oldest = buffer[buffer.length - 1 - M];
                        trixSum -= isNaN(oldest) ? 0 : oldest;
                    }
                    const maVal = buffer.length >= M && !isNaN(trVal) ? trixSum / M : NaN;
                    maTrixArr.push({ time: bar.time, value: maVal });
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "trix" + suffix,
                    title: "TRIX" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: trixArr,
                });
                figs.push({
                    key: "maTrix" + suffix,
                    title: figureCount > 1 ? `MATRIX #${i + 1}` : "MATRIX",
                    type: "line",
                    data: maTrixArr,
                });
            }
            return figs;
        },
    };
    /************************************************
     * 15) Volume Weighted Average Price (VWAP)
     *    Parameter: anchorInterval (array)
     *    Title: "VWAP" concatenated with anchorInterval (e.g. "VWAP1")
     ************************************************/
    const volumeWeightedAveragePrice = {
        name: "Volume Weighted Average Price",
        shortName: "VWAP",
        shouldOhlc: true,
        paramMap: {
            anchorInterval: { defaultValue: [1], type: "numberArray" },
        },
        calc(dataList, overrideParams, volumeData) {
            if (!volumeData) {
                return [
                    { key: "vwap", title: "VWAP", type: "line", data: [] }
                ];
            }
            const arr = getNumericArray(overrideParams, "anchorInterval", this.paramMap.anchorInterval.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                let cumulativeVolume = 0, cumulativeVWAP = 0;
                const vwapArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx % val === 0) {
                        cumulativeVolume = 0;
                        cumulativeVWAP = 0;
                    }
                    const volume = volumeData[idx]?.value ?? 0;
                    const typicalPrice = (bar.high + bar.low + bar.close) / 3;
                    cumulativeVWAP += typicalPrice * volume;
                    cumulativeVolume += volume;
                    const vwapVal = cumulativeVolume !== 0 ? cumulativeVWAP / cumulativeVolume : NaN;
                    vwapArr.push({ time: bar.time, value: vwapVal });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "vwap" + suffix,
                    title: "VWAP" + val + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: vwapArr,
                });
            });
            return figs;
        },
    };
    /************************************************
     * 16) Volume Weighted Moving Average (VWMA)
     *    Parameter: length (array)
     *    Title: "VWMA" concatenated with the length value (e.g. "VWMA20")
     ************************************************/
    const volumeWeightedMovingAverage = {
        name: "Volume Weighted Moving Average",
        shortName: "VWMA",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [20], type: "numberArray" },
        },
        calc(dataList, overrideParams, volumeData) {
            if (!volumeData) {
                return [
                    { key: "vwma", title: "VWMA", type: "line", data: [] }
                ];
            }
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                let sumVolumePrice = 0, sumVolume = 0;
                const vwmaArr = [];
                dataList.forEach((bar, idx) => {
                    const volume = volumeData[idx]?.value ?? 0;
                    sumVolumePrice += bar.close * volume;
                    sumVolume += volume;
                    if (idx >= val - 1) {
                        const avg = sumVolume !== 0 ? sumVolumePrice / sumVolume : NaN;
                        vwmaArr.push({ time: bar.time, value: avg });
                        const oldVolume = volumeData[idx - (val - 1)].value ?? 0;
                        sumVolumePrice -= dataList[idx - (val - 1)].close * oldVolume;
                        sumVolume -= oldVolume;
                    }
                    else {
                        vwmaArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "vwma" + suffix,
                    title: "VWMA" + val + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: vwmaArr,
                });
            });
            return figs;
        },
    };
    /************************************************
     * 17) Weighted Moving Average (WMA)
     *    Parameter: length (array)
     *    Title: "WMA" concatenated with the length value (e.g. "WMA9")
     ************************************************/
    const weightedMovingAverage = {
        name: "Weighted Moving Average",
        shortName: "WMA",
        shouldOhlc: false,
        paramMap: {
            length: { defaultValue: [9], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                const wmaArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < val - 1) {
                        wmaArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    let norm = 0, sum = 0;
                    for (let j = 0; j < val; j++) {
                        const weight = val - j;
                        norm += weight;
                        sum += dataList[idx - j].close * weight;
                    }
                    wmaArr.push({ time: bar.time, value: sum / norm });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "wma" + suffix,
                    title: "WMA" + val + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: wmaArr,
                });
            });
            return figs;
        },
    };
    const highestHighLowestLow = {
        name: "High & Low",
        shortName: "HHLL",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray" },
        },
        calc(dataList, overrideParams) {
            // Get the length values (as an array of numbers)
            const arr = getNumericArray(overrideParams, "length", this.paramMap.length.defaultValue);
            const figs = [];
            arr.forEach((val, i) => {
                const hhArr = [];
                const llArr = [];
                // Iterate through each data bar to compute both HH and LL
                dataList.forEach((bar, idx) => {
                    if (idx < val - 1) {
                        hhArr.push({ time: bar.time, value: NaN });
                        llArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    let highest = -Infinity;
                    let lowest = Infinity;
                    for (let j = idx - (val - 1); j <= idx; j++) {
                        highest = Math.max(highest, dataList[j].high);
                        lowest = Math.min(lowest, dataList[j].low);
                    }
                    hhArr.push({ time: bar.time, value: highest });
                    llArr.push({ time: bar.time, value: lowest });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "hh" + suffix,
                    title: "HH" + val + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: hhArr,
                });
                figs.push({
                    key: "ll" + suffix,
                    title: "LL" + val + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: llArr,
                });
            });
            return figs;
        },
    };
    const OVERLAYS = [
        // Overlay Indicators
        arnaudLegouxMovingAverage,
        bollingerBands,
        exponentialMovingAverage,
        highestHigh,
        highestHighLowestLow,
        linRegIndicator,
        lowestLow,
        median,
        movingAverage,
        rollingMovingAverage,
        simpleMovingAverage,
        stopAndReverse,
        superTrend,
        symmetricWeightedMovingAverage,
        tripleExponentiallySmoothedAverage,
        volumeWeightedAveragePrice,
        volumeWeightedMovingAverage,
        weightedMovingAverage,
        // Oscillator Indicators (unchanged)
    ];

    /*
      Partial Integration of KLineCharts' Indicators with Lightweight Charts
      ===============================================================

    */
    /************************************************
     * Oscillator Indicators (other than MACD)
     ************************************************/
    /* 1) awesomeOscillator */
    const awesomeOscillator = {
        name: "Awesome Oscillator",
        shortName: "AO",
        shouldOhlc: true,
        paramMap: {
            shortPeriod: { defaultValue: [5], type: "numberArray", min: 1, max: 100 },
            longPeriod: { defaultValue: [34], type: "numberArray", min: 1, max: 200 },
        },
        calc(dataList, overrideParams) {
            const shortArr = getNumericArray(overrideParams, "shortPeriod", [5]);
            const longArr = getNumericArray(overrideParams, "longPeriod", [34]);
            const figureCount = Math.max(shortArr.length, longArr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const shortP = pickParam(shortArr, i);
                const longP = pickParam(longArr, i);
                const maxP = Math.max(shortP, longP);
                let shortSum = 0, longSum = 0;
                const aoArr = [];
                dataList.forEach((bar, idx) => {
                    const mid = (bar.high + bar.low) / 2;
                    shortSum += mid;
                    longSum += mid;
                    let sMa = NaN, lMa = NaN;
                    if (idx >= shortP - 1) {
                        sMa = shortSum / shortP;
                        const removeVal = (dataList[idx - (shortP - 1)].high + dataList[idx - (shortP - 1)].low) / 2;
                        shortSum -= removeVal;
                    }
                    if (idx >= longP - 1) {
                        lMa = longSum / longP;
                        const removeVal = (dataList[idx - (longP - 1)].high + dataList[idx - (longP - 1)].low) / 2;
                        longSum -= removeVal;
                    }
                    let aoVal = NaN;
                    if (idx >= maxP - 1) {
                        aoVal = sMa - lMa;
                    }
                    aoArr.push({ time: bar.time, value: aoVal });
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                const key = "ao" + suffix;
                const title = "AO" + pickParam(shortArr, i) + (figureCount > 1 ? ` #${i + 1}` : "");
                // Optional color parameters remain unchanged.
                const upColor = overrideParams?.upColor ?? "green";
                const downColor = overrideParams?.downColor ?? "red";
                setHistogramColors(aoArr, upColor, downColor);
                results.push({
                    key,
                    title,
                    type: "histogram",
                    data: aoArr,
                    pane: 1
                });
            }
            return results;
        },
    };
    /* 2) Average True Range (ATR) */
    const averageTrueRange = {
        name: "Average True Range",
        shortName: "ATR",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray", min: 1, max: 100 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [14]);
            const results = [];
            arr.forEach((length, i) => {
                const atrArr = [];
                let sumTR = 0;
                const trValues = [];
                dataList.forEach((bar, idx) => {
                    if (idx === 0) {
                        atrArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const prevClose = dataList[idx - 1].close;
                    const tr = Math.max(bar.high - bar.low, Math.abs(bar.high - prevClose), Math.abs(bar.low - prevClose));
                    trValues.push(tr);
                    sumTR += tr;
                    if (trValues.length > length) {
                        sumTR -= trValues.shift();
                    }
                    const atrVal = trValues.length >= length ? sumTR / length : NaN;
                    atrArr.push({ time: bar.time, value: atrVal });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "atr" + suffix,
                    title: "ATR" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: atrArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 3) Bias */
    const bias = {
        name: "Bias",
        shortName: "BIAS",
        shouldOhlc: true,
        paramMap: {
            period1: { defaultValue: [6], type: "numberArray", min: 1, max: 999 },
            period2: { defaultValue: [12], type: "numberArray", min: 1, max: 999 },
            period3: { defaultValue: [24], type: "numberArray", min: 1, max: 999 },
        },
        calc(dataList, overrideParams) {
            const p1Arr = getNumericArray(overrideParams, "period1", [6]);
            const p2Arr = getNumericArray(overrideParams, "period2", [12]);
            const p3Arr = getNumericArray(overrideParams, "period3", [24]);
            const figureCount = Math.max(p1Arr.length, p2Arr.length, p3Arr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const p1 = pickParam(p1Arr, i);
                const p2 = pickParam(p2Arr, i);
                const p3 = pickParam(p3Arr, i);
                const arrP = [p1, p2, p3];
                const sums = arrP.map(() => 0);
                // Produce three lines in one set
                const figs = arrP.map((val, idx) => ({
                    key: `bias${idx + 1}` + (figureCount > 1 ? `_${i + 1}` : ""),
                    title: `BIAS${val}` + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: [],
                    pane: 1
                }));
                dataList.forEach((bar, idx) => {
                    const c = bar.close;
                    arrP.forEach((period, j) => {
                        sums[j] += c;
                        if (idx >= period - 1) {
                            const mean = sums[j] / period;
                            const biasVal = ((c - mean) / mean) * 100;
                            figs[j].data.push({ time: bar.time, value: biasVal });
                            sums[j] -= dataList[idx - (period - 1)].close;
                        }
                        else {
                            figs[j].data.push({ time: bar.time, value: NaN });
                        }
                    });
                });
                results.push(...figs);
            }
            return results;
        },
    };
    /* 4) BRAR (Buy-Ratio Analysis) */
    const brar = {
        name: "Buy-Ratio Analysis",
        shortName: "BRAR",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [26], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [26]);
            const results = [];
            arr.forEach((length, i) => {
                let hcy = 0, cyl = 0, ho = 0, ol = 0;
                const brData = [];
                const arData = [];
                dataList.forEach((bar, idx) => {
                    const prev = idx - 1 >= 0 ? dataList[idx - 1] : bar;
                    ho += bar.high - bar.open;
                    ol += bar.open - bar.low;
                    hcy += bar.high - prev.close;
                    cyl += prev.close - bar.low;
                    if (idx >= length - 1) {
                        const brVal = cyl !== 0 ? (hcy / cyl) * 100 : 0;
                        const arVal = ol !== 0 ? (ho / ol) * 100 : 0;
                        brData.push({ time: bar.time, value: brVal });
                        arData.push({ time: bar.time, value: arVal });
                        const oldBar = dataList[idx - (length - 1)];
                        const oldPrev = idx - length >= 0 ? dataList[idx - length] : oldBar;
                        hcy -= (oldBar.high - oldPrev.close);
                        cyl -= (oldPrev.close - oldBar.low);
                        ho -= (oldBar.high - oldBar.open);
                        ol -= (oldBar.open - oldBar.low);
                    }
                    else {
                        brData.push({ time: bar.time, value: NaN });
                        arData.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "br" + suffix,
                    title: "BR" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: brData,
                    pane: 1
                });
                results.push({
                    key: "ar" + suffix,
                    title: "AR" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: arData,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 5) Bull and Bear Index (BBI) */
    const bullAndBearIndex = {
        name: "Bull and Bear Index",
        shortName: "BBI",
        shouldOhlc: true,
        paramMap: {
            p1: { defaultValue: [3], type: "numberArray", min: 1 },
            p2: { defaultValue: [6], type: "numberArray", min: 1 },
            p3: { defaultValue: [12], type: "numberArray", min: 1 },
            p4: { defaultValue: [24], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const p1Arr = getNumericArray(overrideParams, "p1", [3]);
            const p2Arr = getNumericArray(overrideParams, "p2", [6]);
            const p3Arr = getNumericArray(overrideParams, "p3", [12]);
            const p4Arr = getNumericArray(overrideParams, "p4", [24]);
            const figureCount = Math.max(p1Arr.length, p2Arr.length, p3Arr.length, p4Arr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const p1 = pickParam(p1Arr, i);
                const p2 = pickParam(p2Arr, i);
                const p3 = pickParam(p3Arr, i);
                const p4 = pickParam(p4Arr, i);
                const params = [p1, p2, p3, p4];
                const sums = [0, 0, 0, 0];
                const mas = [0, 0, 0, 0];
                const bbiArr = [];
                dataList.forEach((bar, idx) => {
                    const c = bar.close;
                    params.forEach((pVal, j) => {
                        sums[j] += c;
                        if (idx >= pVal - 1) {
                            mas[j] = sums[j] / pVal;
                            sums[j] -= dataList[idx - (pVal - 1)].close;
                        }
                    });
                    if (idx >= Math.max(...params) - 1) {
                        const val = (mas[0] + mas[1] + mas[2] + mas[3]) / 4;
                        bbiArr.push({ time: bar.time, value: val });
                    }
                    else {
                        bbiArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "bbi" + suffix,
                    title: "BBI" + [p1, p2, p3, p4].join(",") + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: bbiArr,
                    pane: 1
                });
            }
            return results;
        },
    };
    /* 6) Commodity Channel Index (CCI) */
    const commodityChannelIndex = {
        name: "Commodity Channel Index",
        shortName: "CCI",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [20], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [20]);
            const results = [];
            arr.forEach((length, i) => {
                let tpSum = 0;
                const tpList = [];
                const cciArr = [];
                dataList.forEach((bar, idx) => {
                    const tp = (bar.high + bar.low + bar.close) / 3;
                    tpSum += tp;
                    tpList.push(tp);
                    if (idx >= length - 1) {
                        const maTp = tpSum / length;
                        let sumAbs = 0;
                        for (let j = idx - (length - 1); j <= idx; j++) {
                            sumAbs += Math.abs(tpList[j] - maTp);
                        }
                        const md = sumAbs / length;
                        const cciVal = md !== 0 ? ((tp - maTp) / (md * 0.015)) : 0;
                        cciArr.push({ time: bar.time, value: cciVal });
                        const agoTp = (dataList[idx - (length - 1)].high +
                            dataList[idx - (length - 1)].low +
                            dataList[idx - (length - 1)].close) / 3;
                        tpSum -= agoTp;
                    }
                    else {
                        cciArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "cci" + suffix,
                    title: "CCI" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: cciArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 7) Current Ratio (CR) */
    const currentRatio = {
        name: "Current Ratio",
        shortName: "CR",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [26], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [26]);
            const results = [];
            arr.forEach((length, i) => {
                let sumNum = 0, sumDen = 0;
                const queueNum = [];
                const queueDen = [];
                const crArr = [];
                dataList.forEach((bar, idx) => {
                    const prev = idx - 1 >= 0 ? dataList[idx - 1] : bar;
                    const mid = (prev.high + prev.low) / 2;
                    const highSubMid = Math.max(0, bar.high - mid);
                    const midSubLow = Math.max(0, mid - bar.low);
                    sumNum += highSubMid;
                    sumDen += midSubLow;
                    queueNum.push(highSubMid);
                    queueDen.push(midSubLow);
                    let crVal = NaN;
                    if (idx >= length - 1) {
                        crVal = sumDen !== 0 ? (sumNum / sumDen) * 100 : 0;
                        sumNum -= queueNum[idx - (length - 1)];
                        sumDen -= queueDen[idx - (length - 1)];
                    }
                    crArr.push({ time: bar.time, value: crVal });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "cr" + suffix,
                    title: "CR" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: crArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 8) Difference of Moving Average (DMA)
       Parameters: n1, n2, m */
    const differentOfMovingAverage = {
        name: "Difference of Moving Average",
        shortName: "DMA",
        shouldOhlc: true,
        paramMap: {
            n1: { defaultValue: [10], type: "numberArray", min: 1 },
            n2: { defaultValue: [50], type: "numberArray", min: 1 },
            m: { defaultValue: [10], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const n1Arr = getNumericArray(overrideParams, "n1", [10]);
            const n2Arr = getNumericArray(overrideParams, "n2", [50]);
            const mArr = getNumericArray(overrideParams, "m", [10]);
            const figureCount = Math.max(n1Arr.length, n2Arr.length, mArr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const n1 = pickParam(n1Arr, i);
                const n2 = pickParam(n2Arr, i);
                const mVal = pickParam(mArr, i);
                const maxP = Math.max(n1, n2);
                let sum1 = 0, sum2 = 0, dmaSum = 0;
                const dmaArr = [];
                const amaArr = [];
                const resultsDma = [];
                dataList.forEach((bar, idx) => {
                    sum1 += bar.close;
                    sum2 += bar.close;
                    let ma1 = NaN, ma2 = NaN;
                    if (idx >= n1 - 1) {
                        ma1 = sum1 / n1;
                        sum1 -= dataList[idx - (n1 - 1)].close;
                    }
                    if (idx >= n2 - 1) {
                        ma2 = sum2 / n2;
                        sum2 -= dataList[idx - (n2 - 1)].close;
                    }
                    if (idx >= maxP - 1) {
                        const dif = ma1 - ma2;
                        resultsDma.push(dif);
                        dmaArr.push({ time: bar.time, value: dif });
                        dmaSum += dif;
                        if (resultsDma.length > mVal) {
                            dmaSum -= resultsDma[resultsDma.length - 1 - mVal];
                            const amaVal = dmaSum / mVal;
                            amaArr.push({ time: bar.time, value: amaVal });
                        }
                        else {
                            amaArr.push({ time: bar.time, value: NaN });
                        }
                    }
                    else {
                        dmaArr.push({ time: bar.time, value: NaN });
                        amaArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "dma" + suffix,
                    title: "DMA" + n1 + "-" + n2 + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: dmaArr,
                    pane: 1
                });
                results.push({
                    key: "ama" + suffix,
                    title: "AMA" + n1 + "-" + n2 + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: amaArr,
                    pane: 1
                });
            }
            return results;
        },
    };
    /* 9) Directional Movement Index (DMI)
       Parameters: n, mm */
    const directionalMovementIndex = {
        name: "Directional Movement Index",
        shortName: "DMI",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [14], type: "numberArray", min: 1 },
            mm: { defaultValue: [6], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", [14]);
            const mmArr = getNumericArray(overrideParams, "mm", [6]);
            const figureCount = Math.max(nArr.length, mmArr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const N = pickParam(nArr, i);
                const MM = pickParam(mmArr, i);
                let tr = 0, dmp = 0, dmm = 0;
                let adx = 0;
                let outAdxStarted = false;
                const pdiArr = [];
                const mdiArr = [];
                const adxArr = [];
                const adxrArr = [];
                dataList.forEach((bar, idx) => {
                    const prev = idx - 1 >= 0 ? dataList[idx - 1] : bar;
                    const highDiff = bar.high - prev.high;
                    const lowDiff = prev.low - bar.low;
                    const cTr = Math.max(bar.high - bar.low, Math.abs(bar.high - prev.close), Math.abs(prev.close - bar.low));
                    let cDmp = 0, cDmm = 0;
                    if (highDiff > 0 && highDiff > lowDiff)
                        cDmp = highDiff;
                    if (lowDiff > 0 && lowDiff > highDiff)
                        cDmm = lowDiff;
                    if (idx === 0) {
                        tr = cTr;
                        dmp = cDmp;
                        dmm = cDmm;
                    }
                    else {
                        tr = (tr * (N - 1) + cTr) / N;
                        dmp = (dmp * (N - 1) + cDmp) / N;
                        dmm = (dmm * (N - 1) + cDmm) / N;
                    }
                    let pdi = NaN, mdi = NaN;
                    if (tr !== 0) {
                        pdi = (dmp / tr) * 100;
                        mdi = (dmm / tr) * 100;
                    }
                    pdiArr.push({ time: bar.time, value: pdi });
                    mdiArr.push({ time: bar.time, value: mdi });
                    let dx = NaN;
                    if (!isNaN(pdi) && !isNaN(mdi) && (pdi + mdi) !== 0) {
                        dx = (Math.abs(mdi - pdi) / (mdi + pdi)) * 100;
                    }
                    if (idx < N - 1) {
                        adxArr.push({ time: bar.time, value: NaN });
                        adxrArr.push({ time: bar.time, value: NaN });
                    }
                    else {
                        if (!outAdxStarted) {
                            adx = dx;
                            outAdxStarted = true;
                        }
                        else {
                            adx = (adx * (N - 1) + dx) / N;
                        }
                        adxArr.push({ time: bar.time, value: adx });
                        if (idx < N - 1 + MM) {
                            adxrArr.push({ time: bar.time, value: NaN });
                        }
                        else {
                            const olderAdx = adxArr[adxArr.length - 1 - MM];
                            if (olderAdx) {
                                const val = (adx + olderAdx.value) / 2;
                                adxrArr.push({ time: bar.time, value: val });
                            }
                            else {
                                adxrArr.push({ time: bar.time, value: NaN });
                            }
                        }
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "pdi" + suffix,
                    title: "PDI" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: pdiArr,
                    pane: 1
                });
                results.push({
                    key: "mdi" + suffix,
                    title: "MDI" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: mdiArr,
                    pane: 1
                });
                results.push({
                    key: "adx" + suffix,
                    title: "ADX" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: adxArr,
                    pane: 1
                });
                results.push({
                    key: "adxr" + suffix,
                    title: "ADXR" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: adxrArr,
                    pane: 1
                });
            }
            return results;
        },
    };
    /* 10) Momentum (MTM)
       Parameters: n, m
    */
    const momentum = {
        name: "Momentum",
        shortName: "MTM",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [12], type: "numberArray", min: 1 },
            m: { defaultValue: [6], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", [12]);
            const mArr = getNumericArray(overrideParams, "m", [6]);
            const figureCount = Math.max(nArr.length, mArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const N = pickParam(nArr, i);
                const M = pickParam(mArr, i);
                const mtmArr = [];
                const maMtmArr = [];
                let sumMtm = 0;
                const mtmBuffer = [];
                dataList.forEach((bar, idx) => {
                    if (idx >= N) {
                        const oldBar = dataList[idx - N];
                        const val = bar.close - oldBar.close;
                        mtmArr.push({ time: bar.time, value: val });
                        mtmBuffer.push(val);
                        sumMtm += val;
                        if (mtmBuffer.length > M) {
                            sumMtm -= mtmBuffer[mtmBuffer.length - 1 - M];
                        }
                        const maVal = mtmBuffer.length >= M ? sumMtm / M : NaN;
                        maMtmArr.push({ time: bar.time, value: maVal });
                    }
                    else {
                        mtmArr.push({ time: bar.time, value: NaN });
                        maMtmArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "mtm" + suffix,
                    title: "MTM" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: mtmArr,
                    pane: 1
                });
                figs.push({
                    key: "maMtm" + suffix,
                    title: "MAMTM" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: maMtmArr,
                    pane: 1
                });
            }
            return figs;
        },
    };
    /* 11) Psychological Line (PSY)
       Parameters: n, m
    */
    const psychologicalLine = {
        name: "Psychological Line",
        shortName: "PSY",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [12], type: "numberArray", min: 1 },
            m: { defaultValue: [6], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", [12]);
            const mArr = getNumericArray(overrideParams, "m", [6]);
            const figureCount = Math.max(nArr.length, mArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const N = pickParam(nArr, i);
                const M = pickParam(mArr, i);
                let upCount = 0;
                const upQueue = [];
                let psySum = 0;
                const psyArr = [];
                const maPsyArr = [];
                const psyBuffer = [];
                dataList.forEach((bar, idx) => {
                    const prev = idx - 1 >= 0 ? dataList[idx - 1] : bar;
                    const upFlag = bar.close > prev.close ? 1 : 0;
                    upQueue.push(upFlag);
                    upCount += upFlag;
                    if (idx >= N - 1) {
                        const ratio = (upCount / N) * 100;
                        psyArr.push({ time: bar.time, value: ratio });
                        psyBuffer.push(ratio);
                        psySum += ratio;
                        if (psyBuffer.length > M) {
                            psySum -= psyBuffer[psyBuffer.length - 1 - M];
                        }
                        const maVal = psyBuffer.length >= M ? psySum / M : NaN;
                        maPsyArr.push({ time: bar.time, value: maVal });
                        upCount -= upQueue[idx - (N - 1)];
                    }
                    else {
                        psyArr.push({ time: bar.time, value: NaN });
                        maPsyArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "psy" + suffix,
                    title: "PSY" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: psyArr,
                    pane: 1
                });
                figs.push({
                    key: "maPsy" + suffix,
                    title: "MAPSY" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: maPsyArr,
                    pane: 1
                });
            }
            return figs;
        },
    };
    /* 12) Rate of Change (ROC)
       Parameters: n, m
    */
    const rateOfChange = {
        name: "Rate of Change",
        shortName: "ROC",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [12], type: "numberArray", min: 1 },
            m: { defaultValue: [6], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", [12]);
            const mArr = getNumericArray(overrideParams, "m", [6]);
            const figureCount = Math.max(nArr.length, mArr.length);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const N = pickParam(nArr, i);
                const M = pickParam(mArr, i);
                const rocArr = [];
                const maRocArr = [];
                let rocSum = 0;
                const buffer = [];
                dataList.forEach((bar, idx) => {
                    if (idx >= N) {
                        const ago = dataList[idx - N];
                        const prevClose = ago.close;
                        let rocVal = 0;
                        if (prevClose !== 0) {
                            rocVal = ((bar.close - prevClose) / prevClose) * 100;
                        }
                        rocArr.push({ time: bar.time, value: rocVal });
                        buffer.push(rocVal);
                        rocSum += rocVal;
                        if (buffer.length > M) {
                            rocSum -= buffer[buffer.length - 1 - M];
                        }
                        const maVal = buffer.length >= M ? rocSum / M : NaN;
                        maRocArr.push({ time: bar.time, value: maVal });
                    }
                    else {
                        rocArr.push({ time: bar.time, value: NaN });
                        maRocArr.push({ time: bar.time, value: NaN });
                    }
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                figs.push({
                    key: "roc" + suffix,
                    title: "ROC" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: rocArr,
                    pane: 1
                });
                figs.push({
                    key: "maRoc" + suffix,
                    title: "MAROC" + N + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: maRocArr,
                    pane: 1
                });
            }
            return figs;
        },
    };
    /* 13) Relative Strength Index (RSI)
       Parameters: p1, p2, p3
    */
    const relativeStrengthIndex = {
        name: "RSI + SMA",
        shortName: "RSI_SMA",
        shouldOhlc: true,
        paramMap: {
            p1: { defaultValue: [14], type: "numberArray", min: 1 }, // RSI period
            p2: { defaultValue: [21], type: "numberArray", min: 1 }, // SMA-of-RSI period
        },
        calc(dataList, overrideParams) {
            const p1Arr = getNumericArray(overrideParams, "p1", [14]); // RSI length
            const p2Arr = getNumericArray(overrideParams, "p2", [10]); // SMA length
            const figureCount = Math.max(p1Arr.length, p2Arr.length);
            const closeArr = dataList.map(b => b.close);
            const figs = [];
            for (let i = 0; i < figureCount; i++) {
                const p1 = pickParam(p1Arr, i);
                const p2 = pickParam(p2Arr, i);
                let rsiValues = [];
                const rsiData = [];
                const smaData = [];
                // Compute RSI iteratively and feed it into getSma step-by-step
                dataList.forEach((bar, idx) => {
                    const rsiVal = getRsi(closeArr.slice(0, idx + 1), p1); // Get latest RSI value
                    rsiValues.push(rsiVal);
                    const smaVal = getSma(rsiValues, p2); // Get latest SMA of RSI
                    rsiData.push({ time: bar.time, value: rsiVal });
                    smaData.push({ time: bar.time, value: smaVal });
                });
                // Build the indicator lines
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                const lineRsi = {
                    key: `rsi${suffix}`,
                    title: `RSI(${p1})${suffix}`,
                    type: "line",
                    data: rsiData,
                    pane: 1
                };
                const lineSma = {
                    key: `smaOfRsi${suffix}`,
                    title: `SMA(${p2}) of RSI(${p1})${suffix}`,
                    type: "line",
                    data: smaData,
                    pane: 1
                };
                figs.push(lineRsi, lineSma);
            }
            return figs;
        },
    };
    /* 14) Stochastic (KDJ)
       Parameters: n, kPeriod, dPeriod
    */
    const stoch = {
        name: "Stochastic",
        shortName: "KDJ",
        shouldOhlc: true,
        paramMap: {
            n: { defaultValue: [9], type: "numberArray", min: 1 },
            kPeriod: { defaultValue: [3], type: "numberArray", min: 1 },
            dPeriod: { defaultValue: [3], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const nArr = getNumericArray(overrideParams, "n", [9]);
            const kArr = getNumericArray(overrideParams, "kPeriod", [3]);
            const dArr = getNumericArray(overrideParams, "dPeriod", [3]);
            const figureCount = Math.max(nArr.length, kArr.length, dArr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const nVal = pickParam(nArr, i);
                const kPeriod = pickParam(kArr, i);
                const dPeriod = pickParam(dArr, i);
                let prevK = 50, prevD = 50;
                const kArrOut = [];
                const dArrOut = [];
                const jArrOut = [];
                dataList.forEach((bar, idx) => {
                    if (idx < nVal - 1) {
                        kArrOut.push({ time: bar.time, value: NaN });
                        dArrOut.push({ time: bar.time, value: NaN });
                        jArrOut.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const slice = dataList.slice(idx - (nVal - 1), idx + 1);
                    const highN = Math.max(...slice.map(b => b.high));
                    const lowN = Math.min(...slice.map(b => b.low));
                    const rsv = highN === lowN ? 100 : ((bar.close - lowN) / (highN - lowN)) * 100;
                    const kVal = ((kPeriod - 1) * prevK + rsv) / kPeriod;
                    const dVal = ((dPeriod - 1) * prevD + kVal) / dPeriod;
                    const jVal = 3 * kVal - 2 * dVal;
                    kArrOut.push({ time: bar.time, value: kVal });
                    dArrOut.push({ time: bar.time, value: dVal });
                    jArrOut.push({ time: bar.time, value: jVal });
                    prevK = kVal;
                    prevD = dVal;
                });
                const suffix = figureCount > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "k" + suffix,
                    title: "K" + nVal + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: kArrOut,
                    pane: 1
                });
                results.push({
                    key: "d" + suffix,
                    title: "D" + nVal + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: dArrOut,
                    pane: 1
                });
                results.push({
                    key: "j" + suffix,
                    title: "J" + nVal + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: jArrOut,
                    pane: 1
                });
            }
            return results;
        },
    };
    /* 15) Variance
       Parameter: length
    */
    const variance = {
        name: "Variance",
        shortName: "Variance",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray", min: 1, max: 100 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [14]);
            const results = [];
            arr.forEach((length, i) => {
                const varArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < length - 1) {
                        varArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const subset = dataList.slice(idx - (length - 1), idx + 1).map(b => b.close);
                    const mean = subset.reduce((sum, val) => sum + val, 0) / subset.length;
                    const variance = subset.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / subset.length;
                    varArr.push({ time: bar.time, value: variance });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "variance" + suffix,
                    title: "Variance" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: varArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 16) Williams %R (WR)
       Parameters: p1, p2, p3
    */
    const williamsR = {
        name: "Williams %R",
        shortName: "WR",
        shouldOhlc: true,
        paramMap: {
            p1: { defaultValue: [6], type: "numberArray", min: 1 },
            p2: { defaultValue: [10], type: "numberArray", min: 1 },
            p3: { defaultValue: [14], type: "numberArray", min: 1 },
        },
        calc(dataList, overrideParams) {
            const p1Arr = getNumericArray(overrideParams, "p1", [6]);
            const p2Arr = getNumericArray(overrideParams, "p2", [10]);
            const p3Arr = getNumericArray(overrideParams, "p3", [14]);
            const figureCount = Math.max(p1Arr.length, p2Arr.length, p3Arr.length);
            const results = [];
            for (let i = 0; i < figureCount; i++) {
                const p1 = pickParam(p1Arr, i);
                const p2 = pickParam(p2Arr, i);
                const p3 = pickParam(p3Arr, i);
                const arrP = [p1, p2, p3];
                const lines = arrP.map((val, j) => ({
                    key: `wr${j + 1}` + (figureCount > 1 ? `_${i + 1}` : ""),
                    title: `WR${val}` + (figureCount > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: [],
                    pane: 1
                }));
                dataList.forEach((bar, idx) => {
                    arrP.forEach((period, j) => {
                        if (idx >= period - 1) {
                            let highest = -Infinity, lowest = Infinity;
                            for (let k = idx - (period - 1); k <= idx; k++) {
                                highest = Math.max(highest, dataList[k].high);
                                lowest = Math.min(lowest, dataList[k].low);
                            }
                            const wrVal = highest !== lowest ? ((bar.close - highest) / (highest - lowest)) * 100 : 0;
                            lines[j].data.push({ time: bar.time, value: wrVal });
                        }
                        else {
                            lines[j].data.push({ time: bar.time, value: NaN });
                        }
                    });
                });
                results.push(...lines);
            }
            return results;
        },
    };
    /* 17) Change
       Parameter: length
    */
    const change = {
        name: "Change",
        shortName: "Change",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [1], type: "numberArray", min: 1, max: 100 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [1]);
            const results = [];
            arr.forEach((length, i) => {
                const chArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < length) {
                        chArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const prevClose = dataList[idx - length].close;
                    chArr.push({ time: bar.time, value: bar.close - prevClose });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "change" + suffix,
                    title: "Change" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: chArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 18) Range
       Parameter: length
    */
    const range = {
        name: "Range",
        shortName: "Range",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray", min: 1, max: 100 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [14]);
            const results = [];
            arr.forEach((length, i) => {
                const rArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < length - 1) {
                        rArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const subset = dataList.slice(idx - (length - 1), idx + 1);
                    const highest = Math.max(...subset.map(b => b.high));
                    const lowest = Math.min(...subset.map(b => b.low));
                    rArr.push({ time: bar.time, value: highest - lowest });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "range" + suffix,
                    title: "Range" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: rArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    /* 19) Standard Deviation
       Parameter: length
    */
    const standardDeviation = {
        name: "Standard Deviation",
        shortName: "StdDev",
        shouldOhlc: true,
        paramMap: {
            length: { defaultValue: [14], type: "numberArray", min: 1, max: 100 },
        },
        calc(dataList, overrideParams) {
            const arr = getNumericArray(overrideParams, "length", [14]);
            const results = [];
            arr.forEach((length, i) => {
                const sdArr = [];
                dataList.forEach((bar, idx) => {
                    if (idx < length - 1) {
                        sdArr.push({ time: bar.time, value: NaN });
                        return;
                    }
                    const subset = dataList.slice(idx - (length - 1), idx + 1).map(b => b.close);
                    const mean = subset.reduce((sum, val) => sum + val, 0) / subset.length;
                    const variance = subset.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / subset.length;
                    const stdDev = Math.sqrt(variance);
                    sdArr.push({ time: bar.time, value: stdDev });
                });
                const suffix = arr.length > 1 ? `_${i + 1}` : "";
                results.push({
                    key: "stdDev" + suffix,
                    title: "StdDev" + length + (arr.length > 1 ? ` #${i + 1}` : ""),
                    type: "line",
                    data: sdArr,
                    pane: 1
                });
            });
            return results;
        },
    };
    // =====================================================================
    // 15) Moving Average Convergence Divergence (MACD) - MACD Series Modified
    // =====================================================================
    const movingAverageConvergenceDivergence = {
        name: 'Moving Average Convergence Divergence',
        shortName: 'MACD',
        shouldOhlc: true,
        paramMap: {
            shortPeriod: { defaultValue: 12, type: 'number', min: 1 },
            longPeriod: { defaultValue: 26, type: 'number', min: 1 },
            signalPeriod: { defaultValue: 9, type: 'number', min: 1 },
        },
        calc(dataList, overrideParams) {
            const pm = getParams(this, overrideParams);
            const shortP = pm.shortPeriod;
            const longP = pm.longPeriod;
            const signalP = pm.signalPeriod;
            let emaShort = 0, emaLong = 0;
            let dif = 0, dea = 0;
            let difSum = 0;
            const difArr = [];
            const deaArr = [];
            const macdArr = [];
            let sumClose = 0;
            dataList.forEach((bar, i) => {
                sumClose += bar.close;
                // Initialize short EMA
                if (i === shortP - 1) {
                    emaShort = sumClose / shortP;
                }
                else if (i > shortP - 1) {
                    emaShort =
                        (bar.close * 2 + (shortP - 1) * emaShort) / (shortP + 1);
                }
                // Initialize long EMA
                if (i === longP - 1) {
                    emaLong = sumClose / longP;
                }
                else if (i > longP - 1) {
                    emaLong =
                        (bar.close * 2 + (longP - 1) * emaLong) / (longP + 1);
                }
                if (i >= Math.max(shortP, longP) - 1) {
                    dif = emaShort - emaLong;
                    difArr.push({ time: bar.time, value: dif });
                    difSum += dif;
                    if (difArr.length === signalP) {
                        dea = difSum / signalP;
                    }
                    else if (difArr.length > signalP) {
                        dea = (dif * 2 + (signalP - 1) * dea) / (signalP + 1);
                    }
                    if (difArr.length >= signalP) {
                        deaArr.push({ time: bar.time, value: dea });
                        macdArr.push({
                            time: bar.time,
                            value: (dif - dea) * 2,
                        });
                    }
                    else {
                        deaArr.push({ time: bar.time, value: NaN });
                        macdArr.push({ time: bar.time, value: NaN });
                    }
                }
                else {
                    difArr.push({ time: bar.time, value: NaN });
                    deaArr.push({ time: bar.time, value: NaN });
                    macdArr.push({ time: bar.time, value: NaN });
                }
            });
            // Extract optional color parameters with defaults.
            const upColor = overrideParams?.upColor ?? 'green';
            const downColor = overrideParams?.downColor ?? 'red';
            setHistogramColors(macdArr, upColor, downColor);
            return [
                { key: 'dif', title: 'DIF', type: 'line', data: difArr, pane: 1 },
                { key: 'dea', title: 'DEA', type: 'line', data: deaArr, pane: 1 },
                { key: 'macd', title: 'MACD', type: 'histogram', data: macdArr, pane: 1 },
            ];
        },
    };
    // You can continue adding other indicators below as needed.
    // =====================================================================
    //  INDICATORS (collect them in one array)
    // =====================================================================
    const OSCILLATORS = [
        // Oscillator Indicators
        awesomeOscillator,
        averageTrueRange,
        bias,
        brar,
        bullAndBearIndex,
        commodityChannelIndex,
        currentRatio,
        differentOfMovingAverage,
        directionalMovementIndex,
        momentum,
        movingAverageConvergenceDivergence,
        psychologicalLine,
        rateOfChange,
        relativeStrengthIndex,
        stoch,
        variance,
        williamsR,
        change,
        range,
        standardDeviation,
    ];

    // =========================
    //  Basic Data Interfaces
    // =========================
    const INDICATORS = [...OVERLAYS, ...OSCILLATORS];

    class DataMenu {
        contextMenu;
        handler;
        container;
        // Set the default active tab to "options" (primary).
        currentTab = "options";
        constructor(options) {
            this.contextMenu = options.contextMenu;
            this.handler = options.handler;
            // Use the context menu's container as the modal container.
            this.container = this.contextMenu.div;
        }
        /**
         * Opens the export/import dialog modal.
         * The modal has two tabs: one for full serialization and one for options.
         * Each tab has its own set of export/import buttons.
         * A common Save button is provided.
         *
         * @param target - The object to export/import (must implement IJsonSerializable).
         * @param event - An optional MouseEvent used for positioning.
         */
        openMenu(target, event, overrideType) {
            // Determine the type to export using the override if provided.
            const typeStr = overrideType || target._type || target.constructor.name;
            // Compute JSON strings for full serialization.
            const fullData = {
                type: typeStr,
                object: target.toJSON(), // Using "object" instead of "data"
                title: target.title,
            };
            const fullJson = JSON.stringify(fullData, null, 2);
            // Retrieve options. If the target is a Handler, use target.chart.options().
            let opts = {};
            if (target instanceof Handler) {
                opts = target.chart.options();
            }
            else if (target.options !== undefined) {
                opts = typeof target.options === "function" ? target.options() : target.options;
            }
            else if (target._options !== undefined) {
                opts = target._options;
            }
            // Use the key 'options' for the options export.
            const optionsData = {
                ...opts
            };
            const optionsJson = JSON.stringify(optionsData, null, 2);
            const modalOverlay = document.createElement("div");
            modalOverlay.style.position = "fixed";
            modalOverlay.style.top = "0";
            modalOverlay.style.left = "0";
            modalOverlay.style.width = "100%";
            modalOverlay.style.height = "100%";
            modalOverlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
            modalOverlay.style.display = "flex";
            modalOverlay.style.justifyContent = "center";
            modalOverlay.style.alignItems = "center";
            modalOverlay.style.zIndex = "1000";
            // Close the modal when the Esc key is pressed.
            const handleKeyDown = (e) => {
                if (e.key === "Escape") {
                    this.close(modalOverlay, handleKeyDown);
                }
            };
            document.addEventListener("keydown", handleKeyDown);
            // Create the modal content container.
            const modalContent = document.createElement("div");
            // Set dark mode for both tabs.
            modalContent.style.backgroundColor = "#333";
            modalContent.style.color = "#fff";
            modalContent.style.padding = "20px";
            modalContent.style.borderRadius = "8px";
            modalContent.style.width = "80%";
            modalContent.style.maxWidth = "800px";
            modalContent.style.maxHeight = "90%";
            modalContent.style.overflowY = "auto";
            modalContent.style.boxShadow = "0 2px 10px rgba(0,0,0,0.5)";
            modalContent.setAttribute("tabindex", "-1");
            modalContent.focus();
            // Create tab headers. Options tab will be on the left.
            const tabsContainer = document.createElement("div");
            tabsContainer.style.display = "flex";
            tabsContainer.style.borderBottom = "1px solid #555";
            tabsContainer.style.marginBottom = "10px";
            const optionsTab = document.createElement("button");
            optionsTab.textContent = "Options";
            optionsTab.style.flex = "1";
            optionsTab.style.padding = "10px";
            optionsTab.style.cursor = "pointer";
            optionsTab.style.border = "none";
            // Active tab background.
            optionsTab.style.backgroundColor = this.currentTab === "options" ? "#555" : "#333";
            optionsTab.onclick = () => {
                this.currentTab = "options";
                optionsTab.style.backgroundColor = "#555";
                fullTab.style.backgroundColor = "#333";
                textarea.value = optionsJson;
                optionsButtonsContainer.style.display = "flex";
                fullButtonsContainer.style.display = "none";
            };
            const fullTab = document.createElement("button");
            fullTab.textContent = "Full";
            fullTab.style.flex = "1";
            fullTab.style.padding = "10px";
            fullTab.style.cursor = "pointer";
            fullTab.style.border = "none";
            fullTab.style.backgroundColor = this.currentTab === "full" ? "#555" : "#333";
            fullTab.onclick = () => {
                this.currentTab = "full";
                fullTab.style.backgroundColor = "#555";
                optionsTab.style.backgroundColor = "#333";
                textarea.value = fullJson;
                fullButtonsContainer.style.display = "flex";
                optionsButtonsContainer.style.display = "none";
            };
            // Append tabs in the order: Options (left), then Full (right).
            tabsContainer.appendChild(optionsTab);
            tabsContainer.appendChild(fullTab);
            modalContent.appendChild(tabsContainer);
            // Title element.
            const titleElem = document.createElement("h2");
            titleElem.textContent = `Export/Import ${target.title} Data`;
            modalContent.appendChild(titleElem);
            // Create the textarea for JSON editing.
            const textarea = document.createElement("textarea");
            // Since currentTab defaults to "options", display options JSON.
            textarea.value = this.currentTab === "full" ? fullJson : optionsJson;
            textarea.style.width = "100%";
            textarea.style.height = "400px";
            textarea.style.marginTop = "10px";
            textarea.style.marginBottom = "10px";
            textarea.style.resize = "vertical";
            // Dark mode styling.
            textarea.style.backgroundColor = "#444";
            textarea.style.color = "#fff";
            textarea.setAttribute("aria-label", "JSON Data Editor");
            modalContent.appendChild(textarea);
            // Create two separate button containers for each tab.
            const fullButtonsContainer = document.createElement("div");
            fullButtonsContainer.style.display = this.currentTab === "full" ? "flex" : "none";
            fullButtonsContainer.style.flexWrap = "wrap";
            fullButtonsContainer.style.justifyContent = "flex-end";
            fullButtonsContainer.style.gap = "10px";
            const exportFullButton = document.createElement("button");
            exportFullButton.textContent = "Export";
            exportFullButton.style.padding = "8px 12px";
            exportFullButton.style.cursor = "pointer";
            exportFullButton.style.backgroundColor = "#f44336";
            exportFullButton.style.color = "#fff";
            exportFullButton.style.border = "none";
            exportFullButton.style.borderRadius = "4px";
            exportFullButton.onclick = () => {
                this.downloadJson(fullJson, `${target.title}_full.json`);
            };
            fullButtonsContainer.appendChild(exportFullButton);
            const importFullButton = document.createElement("button");
            importFullButton.textContent = "Import";
            importFullButton.style.padding = "8px 12px";
            importFullButton.style.cursor = "pointer";
            importFullButton.style.backgroundColor = "#4CAF50";
            importFullButton.style.color = "#fff";
            importFullButton.style.border = "none";
            importFullButton.style.borderRadius = "4px";
            importFullButton.onclick = () => {
                try {
                    const modifiedData = JSON.parse(textarea.value);
                    if (typeof modifiedData !== "object" || !modifiedData.object) {
                        throw new Error("Invalid structure: missing 'object'.");
                    }
                    target.fromJSON(modifiedData.object);
                    if (typeof target.updateView === "function") {
                        target.updateView();
                    }
                    this.showNotification("Whole data imported successfully.", "success");
                }
                catch (error) {
                    this.showNotification("Failed to import whole data: " + error.message, "error");
                }
            };
            fullButtonsContainer.appendChild(importFullButton);
            const optionsButtonsContainer = document.createElement("div");
            optionsButtonsContainer.style.display = this.currentTab === "options" ? "flex" : "none";
            optionsButtonsContainer.style.flexWrap = "wrap";
            optionsButtonsContainer.style.justifyContent = "flex-end";
            optionsButtonsContainer.style.gap = "10px";
            const exportOptionsButton = document.createElement("button");
            exportOptionsButton.textContent = "Export Options";
            exportOptionsButton.style.padding = "8px 12px";
            exportOptionsButton.style.cursor = "pointer";
            exportOptionsButton.style.backgroundColor = "#f44336";
            exportOptionsButton.style.color = "#fff";
            exportOptionsButton.style.border = "none";
            exportOptionsButton.style.borderRadius = "4px";
            exportOptionsButton.onclick = () => {
                this.downloadJson(optionsJson, `${target.title}_options.json`);
            };
            optionsButtonsContainer.appendChild(exportOptionsButton);
            const importOptionsButton = document.createElement("button");
            importOptionsButton.textContent = "Import Options";
            importOptionsButton.style.padding = "8px 12px";
            importOptionsButton.style.cursor = "pointer";
            importOptionsButton.style.backgroundColor = "#4CAF50";
            importOptionsButton.style.color = "#fff";
            importOptionsButton.style.border = "none";
            importOptionsButton.style.borderRadius = "4px";
            importOptionsButton.onclick = () => {
                // Create a hidden file input element and trigger its click.
                const fileInput = document.createElement("input");
                fileInput.type = "file";
                fileInput.accept = "application/json";
                fileInput.style.display = "none";
                fileInput.addEventListener("change", () => {
                    if (fileInput.files && fileInput.files.length > 0) {
                        const file = fileInput.files[0];
                        const reader = new FileReader();
                        reader.onload = () => {
                            try {
                                // Get the file contents (as text)
                                const fileContents = reader.result;
                                if (typeof fileContents !== "string") {
                                    throw new Error("File content is not a string.");
                                }
                                // Replace the textarea content with the imported JSON
                                textarea.value = fileContents;
                                // Parse the JSON content
                                const modifiedData = JSON.parse(fileContents);
                                // Check that the expected key exists.
                                if (typeof modifiedData !== "object" || !modifiedData.options) {
                                    throw new Error("Invalid structure: missing 'options'.");
                                }
                                target.fromJSON(modifiedData.options);
                                if (typeof target.updateView === "function") {
                                    target.updateView();
                                }
                                this.showNotification("Options imported successfully.", "success");
                            }
                            catch (error) {
                                this.showNotification("Failed to import options: " + error.message, "error");
                            }
                        };
                        reader.readAsText(file);
                    }
                });
                fileInput.click();
            };
            optionsButtonsContainer.appendChild(importOptionsButton);
            const saveButton = document.createElement("button");
            saveButton.textContent = "Save";
            saveButton.style.padding = "8px 12px";
            saveButton.style.cursor = "pointer";
            saveButton.style.backgroundColor = "#008CBA";
            saveButton.style.color = "#fff";
            saveButton.style.border = "none";
            saveButton.style.borderRadius = "4px";
            saveButton.onclick = () => {
                try {
                    const modifiedData = JSON.parse(textarea.value);
                    if (typeof modifiedData !== "object" || !modifiedData.options) {
                        throw new Error("Invalid structure: missing 'options'.");
                    }
                    // 1) Apply to the chart
                    target.fromJSON(modifiedData);
                    if (typeof target.updateView === "function") {
                        target.updateView();
                    }
                    // 2) Then do the file download
                    const dataString = JSON.stringify(modifiedData, null, 2);
                    // ... (same Blob + <a download> logic)
                    this.showNotification("Options applied and exported successfully.", "success");
                }
                catch (error) {
                    this.showNotification("Failed to save options: " + error.message, "error");
                }
            };
            // In your DataMenu's openMenu method (or where you add the Save as Default button)
            const saveDefaultButton = document.createElement("button");
            saveDefaultButton.textContent = "Save as Default";
            saveDefaultButton.style.padding = "8px 12px";
            saveDefaultButton.style.cursor = "pointer";
            saveDefaultButton.style.backgroundColor = "#008CBA";
            saveDefaultButton.style.color = "#fff";
            saveDefaultButton.style.border = "none";
            saveDefaultButton.style.borderRadius = "4px";
            saveDefaultButton.onclick = () => {
                let opts = {};
                // Extract options from the target.
                if (target instanceof Handler) {
                    opts = target.chart.options();
                }
                else if (typeof target.options === "function") {
                    opts = target.options();
                }
                else if (target.options !== undefined) {
                    opts = target.options;
                }
                else if (target._options !== undefined) {
                    opts = target._options;
                }
                // Build a JSON string strictly containing the options.
                const optionsJson = JSON.stringify(opts, null, 2);
                // Determine the key:
                // If target._type is "custom/Custom" (case-insensitive), then prompt the user.
                // Otherwise, use target._type converted to lowercase. If _type is undefined, fallback to target.title.
                let key;
                if (target._type && target._type.toLowerCase() === "custom/custom") {
                    key = prompt("Enter save key (e.g., area, line, candlestick):", target.title.toLowerCase()) || "";
                    if (!key)
                        return; // abort if no key is provided.
                }
                else {
                    key = target._type ? target._type.toLowerCase() : target.title.toLowerCase();
                }
                // Build the callback message using a fixed prefix "save_defaults" and the key and options JSON separated by ";;;"
                const message = `save_defaults_~_${key};;;${optionsJson}`;
                window.callbackFunction(message);
            };
            this.container.appendChild(saveDefaultButton);
            // Create a container for the bottom buttons that holds both sets.
            const bottomButtonsContainer = document.createElement("div");
            bottomButtonsContainer.style.display = "flex";
            bottomButtonsContainer.style.flexDirection = "column";
            bottomButtonsContainer.style.gap = "10px";
            bottomButtonsContainer.appendChild(fullButtonsContainer);
            bottomButtonsContainer.appendChild(optionsButtonsContainer);
            bottomButtonsContainer.appendChild(saveButton);
            bottomButtonsContainer.appendChild(saveDefaultButton);
            modalContent.appendChild(bottomButtonsContainer);
            modalOverlay.appendChild(modalContent);
            this.container.appendChild(modalOverlay);
        }
        downloadJson(jsonData, filename) {
            try {
                const blob = new Blob([jsonData], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }
            catch (error) {
                this.showNotification("Failed to download data: " + error, "error");
            }
        }
        addSaveDefaultButton(target) {
            const saveDefaultButton = document.createElement("button");
            saveDefaultButton.textContent = "Save as Default";
            saveDefaultButton.style.padding = "8px 12px";
            saveDefaultButton.style.cursor = "pointer";
            saveDefaultButton.style.backgroundColor = "#008CBA";
            saveDefaultButton.style.color = "#fff";
            saveDefaultButton.style.border = "none";
            saveDefaultButton.style.borderRadius = "4px";
            saveDefaultButton.onclick = () => {
                let opts = {};
                // Extract options from the target.
                if (target instanceof Handler) {
                    // For a Handler, use its chart options.
                    opts = target.chart.options();
                }
                else if (typeof target.options === "function") {
                    opts = target.options();
                }
                else if (target.options !== undefined) {
                    opts = target.options;
                }
                else if (target._options !== undefined) {
                    opts = target._options;
                }
                // Build a JSON string strictly containing the options.
                const optionsJson = JSON.stringify(opts, null, 2);
                // Use the target's title (lowercase) as the key.
                // Prompt the user for the key, defaulting to target.title.toLowerCase().
                const key = prompt("Enter save key (area, line, trend-trace, candlestick etc):", target.title.toLowerCase());
                if (!key) {
                    // User cancelled or provided an empty key; abort saving.
                    return;
                }
                // Build the callback message.
                const message = `save_defaults_${key}_~_${optionsJson}`;
                // Call the global callback function.
                window.callbackFunction(message);
            };
            this.container.appendChild(saveDefaultButton);
        }
        close(overlay, keyDownHandler) {
            if (overlay.parentElement) {
                overlay.parentElement.removeChild(overlay);
            }
            document.removeEventListener("keydown", keyDownHandler);
        }
        showNotification(message, type) {
            const notification = document.createElement("div");
            notification.textContent = message;
            notification.style.position = "fixed";
            notification.style.bottom = "20px";
            notification.style.right = "20px";
            notification.style.padding = "10px 20px";
            notification.style.borderRadius = "4px";
            notification.style.color = "#fff";
            notification.style.backgroundColor = type === "success" ? "#4CAF50" : "#f44336";
            notification.style.boxShadow = "0 2px 6px rgba(0,0,0,0.2)";
            notification.style.zIndex = "1001";
            notification.style.opacity = "0";
            notification.style.transition = "opacity 0.5s ease-in-out";
            this.container.appendChild(notification);
            setTimeout(() => {
                notification.style.opacity = "1";
            }, 100);
            setTimeout(() => {
                notification.style.opacity = "0";
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.parentElement.removeChild(notification);
                    }
                }, 500);
            }, 3000);
        }
        openDefaultOptions(defaultKey) {
            // 1) Fetch the current defaults for this key from your manager.
            //    e.g., if your Handler has a property like `defaultsManager`.
            const defaultsManager = this.handler.defaultsManager;
            if (!defaultsManager) {
                this.showNotification("No defaults manager found.", "error");
                return;
            }
            const currentDefaults = defaultsManager.get(defaultKey);
            if (!currentDefaults) {
                this.showNotification(`No default config found for key: "${defaultKey}"`, "error");
                return;
            }
            // Convert current defaults to JSON (prettified)
            JSON.stringify(currentDefaults, null, 2);
            // 2) Create the modal overlay
            const modalOverlay = document.createElement("div");
            Object.assign(modalOverlay.style, {
                position: "fixed",
                top: "0",
                left: "0",
                width: "100%",
                height: "100%",
                backgroundColor: "rgba(0,0,0,0.5)",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                zIndex: "1000",
            });
            // ESC key closes the modal
            const handleKeyDown = (e) => {
                if (e.key === "Escape") {
                    this.close(modalOverlay, handleKeyDown);
                }
            };
            document.addEventListener("keydown", handleKeyDown);
            // 3) Modal content container
            const modalContent = document.createElement("div");
            Object.assign(modalContent.style, {
                backgroundColor: "#333",
                color: "#fff",
                padding: "20px",
                borderRadius: "8px",
                width: "80%",
                maxWidth: "800px",
                maxHeight: "90%",
                overflowY: "auto",
                boxShadow: "0 2px 10px rgba(0,0,0,0.5)",
            });
            modalContent.setAttribute("tabindex", "-1");
            modalContent.focus();
            // Title
            const titleElem = document.createElement("h2");
            titleElem.textContent = `Edit Default Options - "${defaultKey}"`;
            modalContent.appendChild(titleElem);
            // 4) Textarea with the current defaults JSON
            const textarea = document.createElement("textarea");
            textarea.value = JSON.stringify(currentDefaults, null, 2);
            Object.assign(textarea.style, {
                width: "100%",
                height: "400px",
                resize: "vertical",
                backgroundColor: "#444",
                color: "#fff",
                border: "none",
                margin: "10px 0",
                padding: "10px",
            });
            modalContent.appendChild(textarea);
            // Buttons row
            const buttonRow = document.createElement("div");
            Object.assign(buttonRow.style, {
                display: "flex",
                flexWrap: "wrap",
                gap: "10px",
                justifyContent: "flex-end",
            });
            // Export button
            const exportButton = document.createElement("button");
            exportButton.textContent = "Export";
            Object.assign(exportButton.style, {
                padding: "8px 12px",
                cursor: "pointer",
                backgroundColor: "#f44336",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
            });
            exportButton.onclick = () => {
                this.downloadJson(textarea.value, `${defaultKey}_defaults.json`);
            };
            buttonRow.appendChild(exportButton);
            // Import button
            const importButton = document.createElement("button");
            importButton.textContent = "Import";
            Object.assign(importButton.style, {
                padding: "8px 12px",
                cursor: "pointer",
                backgroundColor: "#4CAF50",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
            });
            importButton.onclick = () => {
                const fileInput = document.createElement("input");
                fileInput.type = "file";
                fileInput.accept = "application/json";
                fileInput.style.display = "none";
                fileInput.addEventListener("change", () => {
                    if (fileInput.files && fileInput.files.length > 0) {
                        const file = fileInput.files[0];
                        const reader = new FileReader();
                        reader.onload = () => {
                            try {
                                if (typeof reader.result !== "string") {
                                    throw new Error("File content is not a string.");
                                }
                                // Put contents into the textarea
                                textarea.value = reader.result;
                            }
                            catch (err) {
                                this.showNotification("Failed to read defaults file: " + err.message, "error");
                            }
                        };
                        reader.readAsText(file);
                    }
                });
                fileInput.click();
            };
            buttonRow.appendChild(importButton);
            // ─── SAVE BUTTON (Updated) ───────────────────────────────────────────
            // Instead of calling defaultsManager.set(...),
            // we replicate the "save as default" approach: build a 'save_defaults_...' message.
            const saveButton = document.createElement("button");
            saveButton.textContent = "Save";
            Object.assign(saveButton.style, {
                padding: "8px 12px",
                cursor: "pointer",
                backgroundColor: "#008CBA",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
            });
            saveButton.onclick = () => {
                try {
                    // Parse the user-edited JSON
                    const newData = JSON.parse(textarea.value);
                    // Convert to a string for the message
                    const dataString = JSON.stringify(newData, null, 2);
                    // We'll attempt to build a key from defaultKey. If the user wants a different one,
                    // they can specify it here, or we can just rely on defaultKey.
                    let key = defaultKey;
                    // If you want to handle custom logic for "custom/custom" or a user prompt, do so here.
                    // Build the message same as your normal "Save as Default" approach
                    // e.g. "save_defaults_area_~_{...json...}" or if you'd prefer "save_defaults_~_{key};;;{json}"
                    const message = `save_defaults_${key}_~_${dataString}`;
                    // Call the callback
                    window.callbackFunction(message);
                    this.showNotification(`Defaults for "${key}" saved successfully.`, "success");
                }
                catch (error) {
                    this.showNotification("Failed to save defaults: " + error.message, "error");
                }
            };
            buttonRow.appendChild(saveButton);
            // Cancel button
            const cancelButton = document.createElement("button");
            cancelButton.textContent = "Cancel";
            Object.assign(cancelButton.style, {
                padding: "8px 12px",
                cursor: "pointer",
                backgroundColor: "#444",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
            });
            cancelButton.onclick = () => {
                this.close(modalOverlay, handleKeyDown);
            };
            buttonRow.appendChild(cancelButton);
            modalContent.appendChild(buttonRow);
            modalOverlay.appendChild(modalContent);
            this.container.appendChild(modalOverlay);
        }
    }

    /**
     * A multi-panel Settings modal that replicates the layout of TradingView’s “Chart Settings”:
     * - Left-hand navigation with categories
     * - Right-hand content panel for relevant settings
     * - Bottom row with “Template”, “Cancel”, and “Ok” buttons
     */
    class SettingsModal {
        container;
        backdrop;
        isOpen = false;
        // Left-nav categories and the right-hand content area.
        categories = [];
        contentArea;
        activeCategoryId = "";
        // A reference to the chart handler (or chart instance)
        handler;
        // Optionally, a custom color picker component reference.
        colorPicker = null;
        _originalOpacities = {};
        /**
         * Pass in your chart handler so that the modal controls can read and update chart options.
         */
        constructor(handler) {
            this.handler = handler;
            const defaultColors = Array.isArray(this.handler.defaultsManager.get('colors')) ? [...this.handler.defaultsManager.get('colors')] : [];
            this.colorPicker = new ColorPicker("#ff0000", () => null, defaultColors && defaultColors.length !== 0 ? defaultColors : undefined);
            // Create the backdrop
            this.backdrop = document.createElement("div");
            this.backdrop.style.position = "fixed";
            this.backdrop.style.top = "0";
            this.backdrop.style.left = "0";
            this.backdrop.style.width = "100%";
            this.backdrop.style.height = "100%";
            this.backdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
            this.backdrop.style.opacity = "0";
            this.backdrop.style.transition = "opacity 0.3s ease";
            this.backdrop.style.zIndex = "9998"; // behind the modal
            this.backdrop.style.display = "none";
            this.backdrop.addEventListener("click", (e) => {
                // If clicked outside the modal, we can close or ignore
                if (e.target === this.backdrop) {
                    this.close(false);
                }
            });
            document.body.appendChild(this.backdrop);
            // Create the main container (the modal itself)
            this.container = document.createElement("div");
            this.container.style.position = "fixed";
            this.container.style.top = "50%";
            this.container.style.left = "50%";
            this.container.style.transform = "translate(-50%, -50%)";
            this.container.style.width = "700px";
            this.container.style.maxWidth = "90%";
            this.container.style.height = "500px";
            this.container.style.maxHeight = "90%";
            this.container.style.backgroundColor = "#2B2B2B";
            this.container.style.color = "#FFF";
            this.container.style.borderRadius = "6px";
            this.container.style.boxShadow = "0 2px 10px rgba(0,0,0,0.8)";
            this.container.style.zIndex = "9999";
            this.container.style.opacity = "0";
            this.container.style.display = "none";
            this.container.style.transition = "opacity 0.3s ease, transform 0.3s ease";
            document.body.appendChild(this.container);
            // Title bar with "Settings" and a close (×) button
            const titleBar = document.createElement("div");
            titleBar.style.display = "flex";
            titleBar.style.alignItems = "center";
            titleBar.style.justifyContent = "space-between";
            titleBar.style.padding = "12px 16px";
            titleBar.style.borderBottom = "1px solid #3C3C3C";
            const titleText = document.createElement("div");
            titleText.innerText = "Settings";
            titleText.style.fontSize = "16px";
            titleText.style.fontWeight = "bold";
            titleBar.appendChild(titleText);
            // “X” close button
            const closeBtn = document.createElement("div");
            closeBtn.innerText = "×";
            closeBtn.style.fontSize = "20px";
            closeBtn.style.cursor = "pointer";
            closeBtn.onclick = () => this.close(false);
            titleBar.appendChild(closeBtn);
            this.container.appendChild(titleBar);
            // Main content area: left nav and right content panel.
            const mainContent = document.createElement("div");
            mainContent.style.display = "flex";
            mainContent.style.flex = "1 1 auto";
            mainContent.style.height = "calc(100% - 50px)"; // subtract title and bottom bar
            this.container.appendChild(mainContent);
            // Left navigation panel
            const leftNav = document.createElement("div");
            leftNav.style.width = "150px";
            leftNav.style.borderRight = "1px solid #3C3C3C";
            leftNav.style.display = "flex";
            leftNav.style.flexDirection = "column";
            mainContent.appendChild(leftNav);
            // Right content panel
            this.contentArea = document.createElement("div");
            this.contentArea.style.flex = "1";
            this.contentArea.style.padding = "16px";
            this.contentArea.style.overflowY = "auto";
            mainContent.appendChild(this.contentArea);
            // Bottom bar with Template, Cancel, and Ok buttons.
            const bottomBar = document.createElement("div");
            bottomBar.style.borderTop = "1px solid #3C3C3C";
            bottomBar.style.display = "flex";
            bottomBar.style.alignItems = "center";
            bottomBar.style.justifyContent = "space-between";
            bottomBar.style.padding = "8px 12px";
            const templateBtn = document.createElement("button");
            templateBtn.innerText = "Template ▾";
            templateBtn.style.backgroundColor = "#444";
            templateBtn.style.color = "#FFF";
            templateBtn.style.border = "none";
            templateBtn.style.borderRadius = "4px";
            templateBtn.style.padding = "6px 12px";
            bottomBar.appendChild(templateBtn);
            const rightBtnContainer = document.createElement("div");
            rightBtnContainer.style.display = "flex";
            rightBtnContainer.style.gap = "8px";
            const cancelBtn = document.createElement("button");
            cancelBtn.innerText = "Cancel";
            cancelBtn.style.backgroundColor = "#444";
            cancelBtn.style.color = "#FFF";
            cancelBtn.style.border = "none";
            cancelBtn.style.borderRadius = "4px";
            cancelBtn.style.padding = "6px 12px";
            cancelBtn.style.cursor = "pointer";
            cancelBtn.onclick = () => this.close(false);
            rightBtnContainer.appendChild(cancelBtn);
            const okBtn = document.createElement("button");
            okBtn.innerText = "Ok";
            okBtn.style.backgroundColor = "#008CBA";
            okBtn.style.color = "#FFF";
            okBtn.style.border = "none";
            okBtn.style.borderRadius = "4px";
            okBtn.style.padding = "6px 12px";
            okBtn.style.cursor = "pointer";
            okBtn.onclick = () => this.close(true);
            rightBtnContainer.appendChild(okBtn);
            bottomBar.appendChild(rightBtnContainer);
            this.container.appendChild(bottomBar);
            /***************************************
             * Define new left-nav categories (tabs)
             ***************************************/
            this.categories = [
                {
                    id: "series-colors", // The main tab for color editing across *all* series
                    label: "Series Colors",
                    buildContent: () => this.buildSeriesColorsTab(),
                },
                {
                    id: "primitive-colors", // The main tab for color editing across *all* series
                    label: "Primitives Colors",
                    buildContent: () => this.buildPrimitivesTab(),
                },
                // Your other tabs ...
                {
                    id: "layout-options",
                    label: "Layout Options",
                    buildContent: () => this.buildLayoutOptionsTab(),
                },
                {
                    id: "grid-options",
                    label: "Grid Options",
                    buildContent: () => this.buildGridOptionsTab(),
                },
                {
                    id: "crosshair-options",
                    label: "Crosshair Options",
                    buildContent: () => this.buildCrosshairOptionsTab(),
                },
                {
                    id: "time-scale-options",
                    label: "Time Scale",
                    buildContent: () => this.buildTimeScaleOptionsTab(),
                },
                {
                    id: "price-scale-options",
                    label: "Price Scale",
                    buildContent: () => this.buildPriceScaleOptionsTab(),
                },
                {
                    id: "defaults-list",
                    label: "Defaults",
                    buildContent: () => this.buildDefaultsListTab(),
                },
                {
                    id: "source-code",
                    label: "source-code",
                    buildContent: () => this.buildSourceCodeTab(),
                },
            ];
            // Build the left-nav buttons
            this.categories.forEach((cat) => {
                const catBtn = document.createElement("div");
                catBtn.innerText = cat.label;
                Object.assign(catBtn.style, {
                    padding: "8px 16px",
                    cursor: "pointer",
                    borderBottom: "1px solid #3C3C3C",
                });
                this.buildSeriesColorsTab();
                catBtn.addEventListener("click", () => this.switchCategory(cat.id));
                leftNav.appendChild(catBtn);
            });
            // Start with the first category active
            if (this.categories.length > 0) {
                this.switchCategory(this.categories[0].id);
            }
        }
        // ─────────────────────────────────────────────────────────────
        // 1) Show / Hide Modal
        // ─────────────────────────────────────────────────────────────
        open() {
            if (this.isOpen)
                return;
            this.isOpen = true;
            // Show the backdrop
            this.backdrop.style.display = "block";
            setTimeout(() => {
                this.backdrop.style.opacity = "1";
            }, 10);
            // Show the container
            this.container.style.display = "block";
            setTimeout(() => {
                this.container.style.opacity = "1";
                this.container.style.transform = "translate(-50%, -50%) scale(1)";
            }, 10);
            this.buildSeriesColorsTab();
        }
        close(confirmed) {
            // If “Ok” was clicked, do final logic (like saving user changes).
            if (confirmed) {
                console.log("Settings Modal: OK clicked. Save changes here.");
                // Implement real save logic if needed.
            }
            else {
                console.log("Settings Modal: Cancel clicked.");
                // Implement rollback logic if needed.
            }
            this.isOpen = false;
            this.backdrop.style.opacity = "0";
            this.container.style.opacity = "0";
            this.container.style.transform = "translate(-50%, -50%) scale(0.95)";
            setTimeout(() => {
                if (!this.isOpen) {
                    this.backdrop.style.display = "none";
                    this.container.style.display = "none";
                }
            }, 300);
        }
        // ─────────────────────────────────────────────────────────────
        // 2) Navigation / Category Switching
        // ─────────────────────────────────────────────────────────────
        switchCategory(catId) {
            this.activeCategoryId = catId;
            // Clear the content area
            this.contentArea.innerHTML = "";
            // Find the category object
            const categoryObj = this.categories.find((c) => c.id === catId);
            if (categoryObj) {
                categoryObj.buildContent();
            }
        }
        /**************************************
         * New Tab Builders (for each option)
         **************************************/
        /**
         * Layout Options Tab
         * Recreates settings for text and background colors.
         */
        buildLayoutOptionsTab() {
            const title = document.createElement("div");
            title.innerText = "Layout Options";
            title.style.fontSize = "16px";
            title.style.fontWeight = "bold";
            title.style.marginBottom = "8px";
            this.contentArea.appendChild(title);
            // Text Color Option
            const currentTextColor = this.getCurrentOptionValue("layout.textColor") || "#000000";
            this.addColorPicker("Text Color", currentTextColor, (color) => {
                this.handler.chart.applyOptions({ layout: { textColor: color } });
            });
            // Background Options based on current type:
            const currentBackground = this.handler.chart.options().layout?.background;
            if (currentBackground && currentBackground.type === "solid") {
                // Solid background color
                const bgColor = currentBackground.color || "#FFFFFF";
                this.addColorPicker("Background Color", bgColor, (color) => {
                    this.handler.chart.applyOptions({
                        layout: { background: { type: lightweightCharts.ColorType.Solid, color } },
                    });
                });
            }
            else if (currentBackground &&
                currentBackground.type === lightweightCharts.ColorType.VerticalGradient) {
                // Gradient background colors
                let topColor = currentBackground.topColor || "rgba(255,0,0,0.33)";
                let bottomColor = currentBackground.bottomColor || "rgba(0,255,0,0.33)";
                this.addColorPicker("Top Color", topColor, (color) => {
                    bottomColor = currentBackground.bottomColor || "rgba(0,255,0,0.33)";
                    this.handler.chart.applyOptions({
                        layout: {
                            background: {
                                type: lightweightCharts.ColorType.VerticalGradient,
                                topColor: color,
                                bottomColor,
                            },
                        },
                    });
                });
                this.addColorPicker("Bottom Color", bottomColor, (color) => {
                    topColor = currentBackground.topColor || "rgba(255,0,0,0.33)";
                    this.handler.chart.applyOptions({
                        layout: {
                            background: {
                                type: lightweightCharts.ColorType.VerticalGradient,
                                topColor,
                                bottomColor: color,
                            },
                        },
                    });
                });
            }
            else {
                console.warn("Unknown background type.");
            }
            // Button to switch background type
            const switchBtn = document.createElement("button");
            switchBtn.innerText = "Switch Background Type";
            switchBtn.style.marginTop = "12px";
            switchBtn.onclick = () => this.toggleBackgroundType();
            this.contentArea.appendChild(switchBtn);
        }
        /**
         * Grid Options Tab
         * Provides controls for grid line colors, styles, and visibility.
         */
        buildGridOptionsTab() {
            const title = document.createElement("div");
            title.innerText = "Grid Options";
            title.style.fontSize = "16px";
            title.style.fontWeight = "bold";
            title.style.marginBottom = "8px";
            this.contentArea.appendChild(title);
            // Vertical grid line color
            const vertLineColor = this.getCurrentOptionValue("grid.vertLines.color") || "#D6DCDE";
            this.addColorPicker("Vertical Line Color", vertLineColor, (color) => {
                this.handler.chart.applyOptions({ grid: { vertLines: { color } } });
            });
            // Horizontal grid line color
            const horzLineColor = this.getCurrentOptionValue("grid.horzLines.color") || "#D6DCDE";
            this.addColorPicker("Horizontal Line Color", horzLineColor, (color) => {
                this.handler.chart.applyOptions({ grid: { horzLines: { color } } });
            });
            // 1) Build a lookup that maps the user-friendly string to the numeric enum
            const styleMapping = {
                Solid: lightweightCharts.LineStyle.Solid,
                Dotted: lightweightCharts.LineStyle.Dotted,
                Dashed: lightweightCharts.LineStyle.Dashed,
                LargeDashed: lightweightCharts.LineStyle.LargeDashed,
                SparseDotted: lightweightCharts.LineStyle.SparseDotted,
            };
            // 2) When you handle the dropdown selection:
            this.addDropdown("Vertical Line Style", ["Solid", "Dashed", "Dotted", "LargeDashed"], (selected) => {
                // Map the string to the numeric style
                const lineStyle = styleMapping[selected];
                // Apply the chart options
                this.handler.chart.applyOptions({
                    grid: { vertLines: { style: lineStyle } },
                });
            });
            this.addDropdown("Horizontal Line Style", ["Solid", "Dashed", "Dotted", "LargeDashed"], (selected) => {
                // Map the string to the numeric style
                const lineStyle = styleMapping[selected];
                // Apply the chart options
                this.handler.chart.applyOptions({
                    grid: { horzLines: { style: lineStyle } },
                });
            });
            // Checkboxes for line visibility
            const vertVisible = this.getCurrentOptionValue("grid.vertLines.visible") !== false;
            this.addCheckbox("Show Vertical Lines", vertVisible, (visible) => {
                this.handler.chart.applyOptions({ grid: { vertLines: { visible } } });
            });
            const horzVisible = this.getCurrentOptionValue("grid.horzLines.visible") !== false;
            this.addCheckbox("Show Horizontal Lines", horzVisible, (visible) => {
                this.handler.chart.applyOptions({ grid: { horzLines: { visible } } });
            });
        }
        /**
         * Crosshair Options Tab
         * Provides full customization controls for the crosshair:
         * - Mode (Normal, Magnet, Hidden)
         * - Vertical line: width, style, color, label background color
         * - Horizontal line: width, style, color, label background color
         */
        buildCrosshairOptionsTab() {
            // Create and append the title element
            const title = document.createElement("div");
            title.innerText = "Crosshair Options";
            title.style.fontSize = "16px";
            title.style.fontWeight = "bold";
            title.style.marginBottom = "8px";
            this.contentArea.appendChild(title);
            // Build a lookup that maps a user-friendly string to the numeric LineStyle enum.
            const crosshairStyleMapping = {
                Solid: lightweightCharts.LineStyle.Solid,
                Dotted: lightweightCharts.LineStyle.Dotted,
                Dashed: lightweightCharts.LineStyle.Dashed,
                LargeDashed: lightweightCharts.LineStyle.LargeDashed,
                SparseDotted: lightweightCharts.LineStyle.SparseDotted,
            };
            // Retrieve the current default for vertical and horizontal crosshair styles.
            const currentCrosshairVertStyle = (this.getCurrentOptionValue("crosshair.vertLine.style") || "Solid");
            const currentCrosshairHorzStyle = (this.getCurrentOptionValue("crosshair.horzLine.style") || "Solid");
            // -------------------------------
            // Crosshair Mode Dropdown
            // -------------------------------
            const crosshairModes = ["Normal", "Magnet", "Hidden"];
            const currentMode = (this.getCurrentOptionValue("crosshair.mode") ||
                "Normal");
            this.addDropdown("Crosshair Mode", crosshairModes, (selected) => {
                this.handler.chart.applyOptions({
                    crosshair: { mode: selected },
                });
            }, currentMode);
            // -------------------------------
            // Vertical Crosshair Line Options
            // -------------------------------
            // Vertical line width dropdown (values 1–10)
            const widthOptions = Array.from({ length: 10 }, (_, i) => (i + 1).toString());
            const currentVertWidth = (this.getCurrentOptionValue("crosshair.vertLine.width") || "1").toString();
            this.addDropdown("Vertical Line Width", widthOptions, (selected) => {
                const newWidth = parseInt(selected, 10);
                this.handler.chart.applyOptions({
                    crosshair: { vertLine: { width: newWidth } },
                });
            }, currentVertWidth);
            // Vertical Crosshair Line Style Dropdown
            this.addDropdown("Vertical Crosshair Line Style", ["Solid", "Dashed", "Dotted", "LargeDashed"], (selected) => {
                const lineStyle = crosshairStyleMapping[selected];
                this.handler.chart.applyOptions({
                    crosshair: { vertLine: { style: lineStyle } },
                });
            }, currentCrosshairVertStyle);
            // Vertical line color picker.
            const vertLineColor = this.getCurrentOptionValue("crosshair.vertLine.color") || "#C3BCDB44";
            this.addColorPicker("Vertical Line Color", vertLineColor, (newColor) => {
                this.handler.chart.applyOptions({
                    crosshair: { vertLine: { color: newColor } },
                });
            });
            // Vertical line label background color picker.
            const vertLabelBg = this.getCurrentOptionValue("crosshair.vertLine.labelBackgroundColor") ||
                "#9B7DFF";
            this.addColorPicker("Vertical Label Background", vertLabelBg, (newColor) => {
                this.handler.chart.applyOptions({
                    crosshair: { vertLine: { labelBackgroundColor: newColor } },
                });
            });
            // -------------------------------
            // Horizontal Crosshair Line Options
            // -------------------------------
            // Horizontal line width dropdown (values 1–10)
            (this.getCurrentOptionValue("crosshair.horzLine.width") || "1").toString();
            this.addDropdown("Horizontal Line Width", widthOptions, (selected) => {
                const newWidth = parseInt(selected, 10);
                this.handler.chart.applyOptions({
                    crosshair: { horzLine: { width: newWidth } },
                });
            });
            // Horizontal Crosshair Line Style Dropdown
            this.addDropdown("Horizontal Crosshair Line Style", ["Solid", "Dashed", "Dotted", "LargeDashed"], (selected) => {
                const lineStyle = crosshairStyleMapping[selected];
                this.handler.chart.applyOptions({
                    crosshair: { horzLine: { style: lineStyle } },
                });
            }, currentCrosshairHorzStyle);
            // Horizontal line color picker.
            const horzLineColor = this.getCurrentOptionValue("crosshair.horzLine.color") || "#9B7DFF";
            this.addColorPicker("Horizontal Line Color", horzLineColor, (newColor) => {
                this.handler.chart.applyOptions({
                    crosshair: { horzLine: { color: newColor } },
                });
            });
            // Horizontal line label background color picker.
            const horzLabelBg = this.getCurrentOptionValue("crosshair.horzLine.labelBackgroundColor") ||
                "#9B7DFF";
            this.addColorPicker("Horizontal Label Background", horzLabelBg, (newColor) => {
                this.handler.chart.applyOptions({
                    crosshair: { horzLine: { labelBackgroundColor: newColor } },
                });
            });
        }
        /**
         * Time Scale Options Tab
         * Provides numeric and boolean controls for time scale settings.
         */
        buildTimeScaleOptionsTab() {
            const title = document.createElement("div");
            title.innerText = "Time Scale Options";
            title.style.fontSize = "16px";
            title.style.fontWeight = "bold";
            title.style.marginBottom = "8px";
            this.contentArea.appendChild(title);
            // Right Offset
            const rightOffset = this.getCurrentOptionValue("timeScale.rightOffset") || 0;
            this.addNumberField("Right Offset", rightOffset, (val) => {
                this.handler.chart.applyOptions({ timeScale: { rightOffset: val } });
            });
            // Bar Spacing
            const barSpacing = this.getCurrentOptionValue("timeScale.barSpacing") || 10;
            this.addNumberField("Bar Spacing", barSpacing, (val) => {
                this.handler.chart.applyOptions({ timeScale: { barSpacing: val } });
            });
            // Min Bar Spacing
            const minBarSpacing = this.getCurrentOptionValue("timeScale.minBarSpacing") || 0.1;
            this.addNumberField("Min Bar Spacing", minBarSpacing, (val) => {
                this.handler.chart.applyOptions({ timeScale: { minBarSpacing: val } });
            });
            // Additional checkboxes (e.g., Fix Left/Right Edge, Lock Visible Range, etc.)
            const fixLeftEdge = this.getCurrentOptionValue("timeScale.fixLeftEdge") || false;
            this.addCheckbox("Fix Left Edge", fixLeftEdge, (val) => {
                this.handler.chart.applyOptions({ timeScale: { fixLeftEdge: val } });
            });
            const fixRightEdge = this.getCurrentOptionValue("timeScale.fixRightEdge") || false;
            this.addCheckbox("Fix Right Edge", fixRightEdge, (val) => {
                this.handler.chart.applyOptions({ timeScale: { fixRightEdge: val } });
            });
            const lockVisibleRange = this.getCurrentOptionValue("timeScale.lockVisibleTimeRangeOnResize") ||
                false;
            this.addCheckbox("Lock Visible Range on Resize", lockVisibleRange, (val) => {
                this.handler.chart.applyOptions({
                    timeScale: { lockVisibleTimeRangeOnResize: val },
                });
            });
            const visible = this.getCurrentOptionValue("timeScale.visible");
            this.addCheckbox("Time Scale Visible", visible !== false, (val) => {
                this.handler.chart.applyOptions({ timeScale: { visible: val } });
            });
            const borderVisible = this.getCurrentOptionValue("timeScale.borderVisible");
            this.addCheckbox("Border Visible", borderVisible !== false, (val) => {
                this.handler.chart.applyOptions({ timeScale: { borderVisible: val } });
            });
            const borderColor = this.getCurrentOptionValue("timeScale.borderColor") || "#000000";
            this.addColorPicker("Border Color", borderColor, (color) => {
                this.handler.chart.applyOptions({ timeScale: { borderColor: color } });
            });
        }
        /**
         * Price Scale Options Tab
         * Provides a dropdown for mode and checkboxes for additional options.
         */
        buildPriceScaleOptionsTab() {
            const title = document.createElement("div");
            title.innerText = "Price Scale Options";
            title.style.fontSize = "16px";
            title.style.fontWeight = "bold";
            title.style.marginBottom = "8px";
            this.contentArea.appendChild(title);
            // For this example, we use the "right" price scale.
            const priceScale = this.handler.chart.priceScale("right");
            priceScale.options().mode || lightweightCharts.PriceScaleMode.Normal;
            const modeOptions = [
                { label: "Normal", value: lightweightCharts.PriceScaleMode.Normal },
                { label: "Logarithmic", value: lightweightCharts.PriceScaleMode.Logarithmic },
                { label: "Percentage", value: lightweightCharts.PriceScaleMode.Percentage },
                { label: "Indexed To 100", value: lightweightCharts.PriceScaleMode.IndexedTo100 },
            ];
            const modeLabels = modeOptions.map((opt) => opt.label);
            this.addDropdown("Price Scale Mode", modeLabels, (selected) => {
                const selectedOption = modeOptions.find((opt) => opt.label === selected);
                if (selectedOption) {
                    priceScale.applyOptions({ mode: selectedOption.value });
                }
            });
            // Additional toggles for the price scale
            const autoScale = priceScale.options().autoScale !== undefined
                ? priceScale.options().autoScale
                : true;
            this.addCheckbox("Auto Scale", autoScale, (val) => {
                priceScale.applyOptions({ autoScale: val });
            });
            const invertScale = priceScale.options().invertScale || false;
            this.addCheckbox("Invert Scale", invertScale, (val) => {
                priceScale.applyOptions({ invertScale: val });
            });
            const alignLabels = priceScale.options().alignLabels !== undefined
                ? priceScale.options().alignLabels
                : true;
            this.addCheckbox("Align Labels", alignLabels, (val) => {
                priceScale.applyOptions({ alignLabels: val });
            });
            const borderVisible = priceScale.options().borderVisible !== undefined
                ? priceScale.options().borderVisible
                : true;
            this.addCheckbox("Border Visible", borderVisible, (val) => {
                priceScale.applyOptions({ borderVisible: val });
            });
            const ticksVisible = priceScale.options().ticksVisible || false;
            this.addCheckbox("Ticks Visible", ticksVisible, (val) => {
                priceScale.applyOptions({ ticksVisible: val });
            });
        }
        /**
         * Demonstrates how a sub-tab might be built for “Clone Series”.
         */
        buildCloneSeriesTab(series) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `Clone Series - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(title);
            // TODO: Real logic for cloning the series
            // E.g., ask user for a name, create a new series with same config, etc.
            const msg = document.createElement("div");
            msg.innerText = "(Clone Series logic not yet implemented.)";
            msg.style.color = "#ccc";
            msg.style.marginBottom = "12px";
            this.contentArea.appendChild(msg);
            // Back button
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        buildVisibilityOptionsTab(series) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `Visibility Options - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(title);
            // TODO: e.g., checkboxes for “visible”, “markers visible”, etc.
            const msg = document.createElement("div");
            msg.innerText = "(Visibility Options logic not yet implemented.)";
            msg.style.color = "#ccc";
            msg.style.marginBottom = "12px";
            this.contentArea.appendChild(msg);
            // Back button
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        // Same pattern for Style Options
        buildStyleOptionsTab(series) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `Style Options - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(title);
            // TODO: real style config controls
            const msg = document.createElement("div");
            msg.innerText = "(Style Options logic not yet implemented.)";
            msg.style.color = "#ccc";
            msg.style.marginBottom = "12px";
            this.contentArea.appendChild(msg);
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        buildWidthOptionsTab(series) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `Width Options - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(title);
            // TODO: e.g., numeric field for line width, bar width, etc.
            const msg = document.createElement("div");
            msg.innerText = "(Width Options logic not yet implemented.)";
            msg.style.color = "#ccc";
            msg.style.marginBottom = "12px";
            this.contentArea.appendChild(msg);
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        /**
         * Builds the "Primitives" tab.
         * Iterates through each primitive in handler.primitives and, if a primitive
         * exposes an options object (via a function, _options, or direct property),
         * uses buildPrimitiveColorOptions to display its color controls.
         * The changes are applied using primitive.applyOptions(newOpts).
         */
        /**
         * Builds the "Primitives" tab.
         * For each series in handler._seriesList that has a primitives array,
         * creates a container labeled with the series title (from series.options().title)
         * and then iterates through each primitive to build color controls.
         * Changes are applied via primitive.applyOptions(newOpts).
         */
        buildPrimitivesTab() {
            this.contentArea.innerHTML = "";
            // Main title for the tab.
            const title = document.createElement("div");
            title.innerText = "Primitives";
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px"
            });
            this.contentArea.appendChild(title);
            // Iterate over each series in the handler's series list.
            this.handler._seriesList.forEach((series) => {
                // Only process series that have a primitives array with at least one primitive.
                if (series.primitives && Array.isArray(series.primitives) && series.primitives.length > 0) {
                    // Get series title from series.options(). If not defined, default to "Unnamed Series".
                    let seriesTitle = "Unnamed Series";
                    const seriesOpts = series.options();
                    if (seriesOpts && seriesOpts.title) {
                        seriesTitle = seriesOpts.title;
                    }
                    // Create a container for this series.
                    const seriesContainer = document.createElement("div");
                    Object.assign(seriesContainer.style, {
                        border: "2px solid #666",
                        marginBottom: "12px",
                        padding: "8px",
                        borderRadius: "4px"
                    });
                    // Add a header using the series title.
                    const seriesHeader = document.createElement("div");
                    seriesHeader.innerText = `Series: ${seriesTitle}`;
                    Object.assign(seriesHeader.style, {
                        fontSize: "18px",
                        fontWeight: "bold",
                        marginBottom: "8px"
                    });
                    seriesContainer.appendChild(seriesHeader);
                    // Process each primitive in this series.
                    series.primitives.forEach((primitive, primitiveIndex) => {
                        // Attempt to retrieve options from the primitive.
                        let opts;
                        if (typeof primitive.options === "function") {
                            opts = primitive.options();
                        }
                        else if (primitive._options) {
                            opts = primitive._options;
                        }
                        else if (primitive.options) {
                            opts = primitive.options;
                        }
                        if (!opts)
                            return;
                        // Create a container for this primitive.
                        const primitiveContainer = document.createElement("div");
                        Object.assign(primitiveContainer.style, {
                            border: "1px solid #444",
                            marginBottom: "8px",
                            padding: "8px",
                            borderRadius: "4px"
                        });
                        // Header for the primitive.
                        const primitiveHeader = document.createElement("div");
                        primitiveHeader.innerText = `Primitive ${primitiveIndex + 1}: ${primitive.name || "Unnamed"}`;
                        Object.assign(primitiveHeader.style, {
                            fontSize: "16px",
                            fontWeight: "bold",
                            marginBottom: "6px"
                        });
                        primitiveContainer.appendChild(primitiveHeader);
                        // Build color controls for the primitive.
                        this.buildPrimitiveColorOptions(opts, primitiveContainer, (newOpts) => {
                            primitive.applyOptions(newOpts);
                        });
                        seriesContainer.appendChild(primitiveContainer);
                    });
                    this.contentArea.appendChild(seriesContainer);
                }
            });
        }
        buildIndicatorsTab(series) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `Indicators - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(title);
            const msg = document.createElement("div");
            msg.innerText = "(Indicators logic not yet implemented.)";
            msg.style.color = "#ccc";
            msg.style.marginBottom = "12px";
            this.contentArea.appendChild(msg);
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        /**
         * Builds a Source Code tab that displays licensing information and provides
         * links to the repositories used in this build.
         *
         * This project is a derivative work that incorporates components from the following repositories:
         *
         * Base Source Repositories:
         *  - Lightweight Charts: <a href="https://github.com/louisnw01/lightweight-charts-python" target="_blank">louisnw01/lightweight-charts-python (MIT)</a>
         *  - PineTS: <a href="https://github.com/alaa-eddine/PineTS" target="_blank">alaa-eddine/PineTS (AGPL)</a>
         *
         * Modified/Forked Repositories (by EsIstJosh):
         *  - Lightweight Charts: <a href="https://github.com/EsIstJosh/lightweight-charts-python" target="_blank">EsIstJosh/lightweight-charts-python</a>
         *  - PineTS: <a href="https://github.com/EsIstJosh/PineTS" target="_blank">EsIstJosh/PineTS</a>
         */
        buildSourceCodeTab() {
            // Clear the content area
            this.contentArea.innerHTML = "";
            // Title for the Source Code tab
            const title = document.createElement("div");
            title.innerText = "Source Code & Licensing";
            title.style.fontSize = "16px";
            title.style.fontWeight = "bold";
            title.style.marginBottom = "12px";
            this.contentArea.appendChild(title);
            // Informational text explaining the derivative nature of this project.
            const info = document.createElement("div");
            info.style.marginBottom = "12px";
            info.style.fontSize = "16px";
            info.innerHTML = `
    <p>
      This project is a derivative work that incorporates components from the following repositories:
    </p>
    <p>
      <strong>Base Source Repositories:</strong>
    </p>
    <ul>
      <li>
        <a href="https://github.com/louisnw01/lightweight-charts-python" target="_blank" style="color:#008CBA; text-decoration:underline;">
          louisnw01/lightweight-charts-python (MIT)
        </a>
      </li>
      <li>
        <a href="https://github.com/alaa-eddine/PineTS" target="_blank" style="color:#008CBA; text-decoration:underline;">
          alaa-eddine/PineTS (AGPL)
        </a>
      </li>
    </ul>
    <p>
      <strong>Modified/Forked Repositories (by EsIstJosh):</strong>
    </p>
    <ul>
      <li>
        <a href="https://github.com/EsIstJosh/lightweight-charts-python" target="_blank" style="color:#5eb623; text-decoration:underline;">
          EsIstJosh/lightweight-charts-python
        </a>
      </li>
      <li>
        <a href="https://github.com/EsIstJosh/PineTS" target="_blank" style="color:#5eb623; text-decoration:underline;">
          EsIstJosh/PineTS
        </a>
      </li>
    </ul>
  `;
            this.contentArea.appendChild(info);
            // Back button to return to the default category (for example, the first category)
            this.addButton("⤝ Back", () => this.switchCategory(this.categories[0].id), {
                backgroundColor: "#444",
            });
        }
        buildSeriesMenuTab(series) {
            // Clear content area
            this.contentArea.innerHTML = "";
            // Title
            const title = document.createElement("div");
            title.innerText = `Series Settings - ${series.options().title ?? "Untitled"}`;
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(title);
            // Title input
            this.addTextInput("Title", series.options().title || "", (newTitle) => {
                series.applyOptions({ title: newTitle });
                // Optionally update seriesMap
                const oldTitle = series.options().title;
                if (oldTitle && this.handler.seriesMap.has(oldTitle)) {
                    this.handler.seriesMap.delete(oldTitle);
                }
                this.handler.seriesMap.set(newTitle, series);
            });
            // Sub-tabs
            this.addButton("Clone Series ▸", () => this.buildCloneSeriesTab(series));
            this.addButton("Visibility Options ▸", () => this.buildVisibilityOptionsTab(series));
            this.addButton("Style Options ▸", () => this.buildStyleOptionsTab(series));
            this.addButton("Width Options ▸", () => this.buildWidthOptionsTab(series));
            this.addButton("Color Options ▸", () => this.buildSeriesColorsTabSingle(series));
            this.addButton("Price Scale Options ▸", () => this.buildPriceScaleOptionsTab());
            this.addButton("Primitives ▸", () => this.buildPrimitivesTab());
            this.addButton("Indicators ▸", () => this.buildIndicatorsTab(series));
            this.addButton("Export/Import Series Data ▸", () => this.buildDataExportImportTab(series));
        }
        // ─────────────────────────────────────────────────────────────
        // 3) TAB BUILDERS
        // ─────────────────────────────────────────────────────────────
        /**
         * "Series Colors" main tab: displays color pickers for *all* series side-by-side.
         * This is in addition to the per-series color sub-tab accessible in “Series Menu.”
         */
        /**
         * "Series Colors" main tab: displays color pickers for *all* series side-by-side.
         * This is in addition to the per-series color sub-tab accessible in “Series Menu.”
         */
        buildSeriesColorsTab() {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = "Series Colors (All Series)";
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(title);
            // Retrieve all series from your handler.seriesMap
            const seriesEntries = Array.from(this.handler.seriesMap.entries());
            if (seriesEntries.length === 0) {
                const noSeriesMsg = document.createElement("div");
                noSeriesMsg.innerText = "No series found.";
                noSeriesMsg.style.color = "#ccc";
                this.contentArea.appendChild(noSeriesMsg);
                return;
            }
            // For each series, create a mini color section
            seriesEntries.forEach(([seriesName, series]) => {
                this.buildSeriesColorSection(seriesName, series);
            });
            // If a volume series exists, add a separate section for volume colors.
            if (this.handler.volumeSeries) {
                const container = document.createElement("div");
                Object.assign(container.style, {
                    border: "1px solid #444",
                    marginBottom: "8px",
                    padding: "8px",
                    borderRadius: "4px",
                });
                // Create a header for the volume series section.
                const header = document.createElement("div");
                header.innerText = "Series: Volume";
                Object.assign(header.style, {
                    fontSize: "16px",
                    fontWeight: "bold",
                    marginBottom: "6px",
                });
                container.appendChild(header);
                // Explicitly reference the volume series.
                const volumeSeries = this.handler.volumeSeries;
                // Derive fallback colors from the base series options.
                const defaultUpColor = (this.handler.series.options()).borderUpColor || "#00FF00";
                const defaultDownColor = (this.handler.series.options()).borderDownColor || "#FF0000";
                // Copy the current volume series data.
                // Scan the volume data to find initial up/down colors.
                let foundUpColor = this.handler.volumeUpColor;
                let foundDownColor = this.handler.volumeDownColor;
                const currentUpColor = foundUpColor ?? defaultUpColor;
                const currentDownColor = foundDownColor ?? defaultDownColor;
                // Variables to store current colors.
                let volumeUpColor = currentUpColor;
                let volumeDownColor = currentDownColor;
                /**
                 * Updates the volume series colors.
                 * For each data point, if its volume is greater than the previous point, assign newUpColor;
                 * otherwise, assign newDownColor.
                 */
                const updateVolumeColors = (newUpColor, newDownColor) => {
                    const data = [...volumeSeries.data()];
                    if (!data || data.length === 0) {
                        console.warn("No volume data available to update colors.");
                        return;
                    }
                    const newData = data.map((item, index) => {
                        if (index === 0) {
                            return { ...item, color: newUpColor };
                        }
                        const prevVolume = data[index - 1].value;
                        const updatedColor = item.value > prevVolume ? newUpColor : newDownColor;
                        return { ...item, color: updatedColor };
                    });
                    volumeSeries.setData(newData);
                    this.handler.volumeUpColor = newUpColor;
                    this.handler.volumeDownColor = newDownColor;
                };
                // Use addSideBySideColors to create the volume color pickers.
                this.addSideBySideColors("Volume Colors", volumeUpColor, volumeDownColor, (upColor, downColor) => {
                    volumeUpColor = upColor;
                    volumeDownColor = downColor;
                    updateVolumeColors(upColor, downColor);
                }, container);
                // Finally, attach container to content area
                this.contentArea.appendChild(container);
            }
        }
        buildSeriesColorSection(seriesName, series) {
            const container = document.createElement("div");
            Object.assign(container.style, {
                border: "1px solid #444",
                marginBottom: "8px",
                padding: "8px",
                borderRadius: "4px",
            });
            const header = document.createElement("div");
            header.innerText = `Series: ${seriesName}`;
            Object.assign(header.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "6px",
            });
            container.appendChild(header);
            const seriesType = series.seriesType?.();
            // For OHLC or Candlestick-like data
            if (seriesType === "Candlestick" ||
                seriesType === "Bar" ||
                seriesType === "Custom") {
                if ("upColor" in series.options()) {
                    // Body
                    this.addSideBySideColors("Body", series.options().upColor, series.options().downColor, (upColor, downColor) => {
                        series.applyOptions({ upColor, downColor });
                    }, container);
                }
                if ("borderUpColor" in series.options()) {
                    // Borders
                    this.addSideBySideColors("Borders", series.options().borderUpColor, series.options().borderDownColor, (upColor, downColor) => {
                        series.applyOptions({
                            borderUpColor: upColor,
                            borderDownColor: downColor,
                        });
                    }, container);
                    this.addSideBySideColors("Wick", series.options().wickUpColor, series.options().wickDownColor, (upColor, downColor) => {
                        series.applyOptions({
                            wickUpColor: upColor,
                            wickDownColor: downColor,
                        });
                    }, container);
                }
            }
            else if (seriesType === "Line") {
                // Single color
                const currentLineColor = series.options().color || "#ffffff";
                this.addColorPicker("Line Color", currentLineColor, (newCol) => series.applyOptions({ color: newCol }), container);
            }
            else if (seriesType === "Area") {
                const opts = series.options();
                // lineColor, topColor, bottomColor
                this.addColorPicker("Line Color", opts.lineColor || "#EEEEEE", (c) => {
                    series.applyOptions({ lineColor: c });
                }, container);
                this.addColorPicker("Top Fill", opts.topColor || "#008cff44", (c) => {
                    series.applyOptions({ topColor: c });
                }, container);
                this.addColorPicker("Bottom Fill", opts.bottomColor || "#008cff00", (c) => {
                    series.applyOptions({ bottomColor: c });
                }, container);
            }
            else {
                const msg = document.createElement("div");
                msg.innerText = `No color settings for series type: ${seriesType}`;
                msg.style.color = "#bbb";
                container.appendChild(msg);
            }
            // Finally, attach container to content area
            this.contentArea.appendChild(container);
        }
        /**
         * A single-series “Color Options” sub-tab
         */
        buildSeriesColorsTabSingle(series) {
            // Clear the content area
            this.contentArea.innerHTML = "";
            // A container for everything on this tab
            const container = document.createElement("div");
            Object.assign(container.style, {
                border: "1px solid #444",
                marginBottom: "8px",
                padding: "8px",
                borderRadius: "4px",
            });
            this.contentArea.appendChild(container);
            // Title
            const title = document.createElement("div");
            title.innerText = `Color Options - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            container.appendChild(title);
            const seriesType = series.type?.();
            if (seriesType === "Candlestick" ||
                seriesType === "Bar" ||
                seriesType === "Custom") {
                if ("upColor" in series.options()) {
                    // Body
                    this.addSideBySideColors("Body", series.options().upColor, series.options().downColor, (upColor, downColor) => {
                        series.applyOptions({ upColor, downColor });
                    }, container);
                }
                if ("borderUpColor" in series.options()) {
                    this.addSideBySideColors("Borders", series.options().borderUpColor, series.options().borderDownColor, (upColor, downColor) => {
                        series.applyOptions({
                            borderUpColor: upColor,
                            borderDownColor: downColor,
                        });
                    }, container);
                    this.addSideBySideColors("Wick", series.options().wickUpColor, series.options().wickDownColor, (upColor, downColor) => {
                        series.applyOptions({
                            wickUpColor: upColor,
                            wickDownColor: downColor,
                        });
                    }, container);
                }
            }
            else if (seriesType === "Line") {
                const currentLineColor = series.options().color || "#FFFFFF";
                this.addColorPicker("Line Color", currentLineColor, (newColor) => {
                    series.applyOptions({ color: newColor });
                }, container);
                // etc...
            }
            else if (seriesType === "Area") {
                const opts = series.options();
                // ...
                this.addColorPicker("Line Color", opts.lineColor || "#EEEEEE", (c) => {
                    series.applyOptions({ lineColor: c });
                }, container);
                // ...
            }
            else {
                const unknownMsg = document.createElement("div");
                unknownMsg.innerText = `No color settings for series type: ${seriesType}`;
                unknownMsg.style.color = "#bbb";
                container.appendChild(unknownMsg);
            }
            // Back button at the bottom
            const backBtn = document.createElement("button");
            backBtn.innerText = "⤝ Back";
            Object.assign(backBtn.style, {
                backgroundColor: "#444",
                marginTop: "16px",
                padding: "8px 12px",
                color: "#fff",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
            });
            backBtn.onclick = () => this.buildSeriesMenuTab(series);
            container.appendChild(backBtn);
        }
        buildDataExportImportTab(series) {
            this.subTabSkeleton("Export/Import", series, "(Export/Import logic not yet implemented.)");
        }
        /**
         * Helper to quickly build a “placeholder” sub-tab.
         */
        subTabSkeleton(tabName, series, message) {
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = `${tabName} - ${series.options().title || "Untitled"}`;
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(title);
            const msg = document.createElement("div");
            msg.innerText = message;
            Object.assign(msg.style, {
                color: "#ccc",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(msg);
            this.addButton("⤝ Back", () => this.buildSeriesMenuTab(series), {
                backgroundColor: "#444",
            });
        }
        buildDefaultsListTab() {
            // Clear content area
            this.contentArea.innerHTML = "";
            const title = document.createElement("div");
            title.innerText = "Default Configurations";
            Object.assign(title.style, {
                fontSize: "16px",
                fontWeight: "bold",
                marginBottom: "12px",
            });
            this.contentArea.appendChild(title);
            // Suppose your Handler has a property: handler.defaultsManager
            const defaultsManager = this.handler?.defaultsManager;
            if (!defaultsManager) {
                const msg = document.createElement("div");
                msg.innerText = "No defaults manager found.";
                msg.style.color = "#ccc";
                this.contentArea.appendChild(msg);
                return;
            }
            // Retrieve all defaults from the manager
            const allDefaultsMap = defaultsManager.getAll(); // a Map<string, any>
            const allKeys = Array.from(allDefaultsMap.keys());
            if (allKeys.length === 0) {
                const msg = document.createElement("div");
                msg.innerText = "No default configurations found.";
                msg.style.color = "#ccc";
                this.contentArea.appendChild(msg);
                return;
            }
            // Add a new button for Export/Import of the chart config
            this.addButton("Current Chart Config ▸", (evt) => {
                // You can place your logic here; for example:
                // 1. If dataMenu is not instantiated, create it
                if (!this.handler.ContextMenu.dataMenu) {
                    // dataMenu is hypothetical—replace with your own menu or logic
                    this.handler.ContextMenu.dataMenu = new DataMenu({
                        contextMenu: this.handler.ContextMenu,
                        handler: this.handler,
                    });
                }
                // 2. Then open the menu or export logic
                // “Handler” is a label or ID you can pass along, depending on your needs
                this.handler.ContextMenu.dataMenu.openMenu(this.handler, evt, "Handler");
            }, {
                backgroundColor: "#444",
                borderRadius: "8px",
                marginBottom: "8px",
                display: "block",
            });
            // For each key, add a button to open the default options editor
            allKeys.forEach((key) => {
                this.addButton(`Edit "${key}" Defaults`, () => {
                    // We assume there's a dataMenu in your handler with openDefaultOptions(key)
                    if (this.handler.ContextMenu?.dataMenu &&
                        typeof this.handler.ContextMenu.dataMenu.openDefaultOptions ===
                            "function") {
                        this.handler.ContextMenu.dataMenu.openDefaultOptions(key);
                    }
                    else {
                        console.warn("No dataMenu or openDefaultOptions method found on handler.");
                    }
                }, {
                    backgroundColor: "#444",
                    borderRadius: "8px",
                    marginBottom: "8px",
                    display: "block",
                });
            });
        }
        // ─────────────────────────────────────────────────────────────
        // 6) HELPER METHODS
        // ─────────────────────────────────────────────────────────────
        /**
         * Adds a color “swatch” button that, when clicked, opens our *reusable* colorPicker menu.
         */
        addColorPicker(label, defaultColor, onChange, parent = this.contentArea) {
            // Container row
            const container = document.createElement("div");
            Object.assign(container.style, {
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                marginBottom: "8px",
                fontFamily: "sans-serif",
                fontSize: "16px",
            });
            // Label
            const lbl = document.createElement("span");
            lbl.innerText = label;
            container.appendChild(lbl);
            // Swatch (div) that shows the currently selected color
            const swatch = document.createElement("div");
            Object.assign(swatch.style, {
                width: "26px",
                height: "26px",
                borderRadius: "4px",
                cursor: "pointer",
                border: "1px solid #999",
                backgroundColor: defaultColor,
            });
            container.appendChild(swatch);
            // When user clicks the swatch, open the REUSABLE colorPicker
            swatch.addEventListener("click", (ev) => {
                // 1) Update the colorPicker's current color and callback
                this.colorPicker.update(swatch.style.backgroundColor, (newColor) => {
                    // We'll also set the swatch's background to the newly chosen color
                    swatch.style.backgroundColor = newColor;
                    onChange(newColor);
                });
                // 2) Open the colorPicker near the clicked swatch
                this.colorPicker.openMenu(ev, swatch.offsetWidth, (newColor) => {
                    // This "applySelection" callback is also triggered whenever the user picks a color
                    swatch.style.backgroundColor = newColor;
                    onChange(newColor);
                });
            });
            parent.appendChild(container);
        }
        /**
         * Adds a dropdown (select) control.
         * @param label The label to display.
         * @param options An array of option strings.
         * @param onChange Callback function when the selected option changes.
         * @param initial (Optional) The initial value to pre-select.
         */
        addDropdown(label, options, onChange, initial) {
            const container = document.createElement("div");
            container.style.display = "flex";
            container.style.alignItems = "center";
            container.style.justifyContent = "space-between";
            container.style.marginBottom = "8px";
            const lbl = document.createElement("span");
            lbl.innerText = label;
            container.appendChild(lbl);
            const select = document.createElement("select");
            select.style.backgroundColor = "#444";
            select.style.color = "#fff";
            select.style.border = "1px solid #555";
            select.style.borderRadius = "4px";
            select.style.outline = "none";
            options.forEach((opt) => {
                const option = document.createElement("option");
                option.value = opt;
                option.innerText = opt;
                if (initial && opt === initial) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            if (initial) {
                select.value = initial;
            }
            select.onchange = () => onChange(select.value);
            container.appendChild(select);
            this.contentArea.appendChild(container);
        }
        addButton(label, onClick, customStyle) {
            const button = document.createElement("button");
            button.innerText = label;
            Object.assign(button.style, {
                padding: "8px 12px",
                margin: "4px 0",
                backgroundColor: "#008CBA",
                color: "#fff",
                border: "none",
                borderRadius: "8px",
                cursor: "pointer",
                fontFamily: "sans-serif",
                fontSize: "16px",
            });
            if (customStyle) {
                Object.assign(button.style, customStyle);
            }
            button.onclick = onClick;
            this.contentArea.appendChild(button);
        }
        /**
         * Adds a numeric input field.
         */
        addNumberField(label, initial, onChange) {
            const container = document.createElement("div");
            container.style.display = "flex";
            container.style.alignItems = "center";
            container.style.justifyContent = "space-between";
            container.style.marginBottom = "8px";
            const lbl = document.createElement("span");
            lbl.innerText = label;
            container.appendChild(lbl);
            const input = document.createElement("input");
            input.type = "number";
            input.value = initial.toString();
            input.style.width = "60px";
            input.style.backgroundColor = "#444";
            input.style.color = "#fff";
            input.style.border = "1px solid #555";
            input.style.borderRadius = "4px";
            input.oninput = () => {
                const val = parseFloat(input.value);
                onChange(isNaN(val) ? 0 : val);
            };
            container.appendChild(input);
            this.contentArea.appendChild(container);
        }
        /**
         * Adds a checkbox control.
         */
        addCheckbox(label, initial, onChange) {
            const container = document.createElement("label");
            container.style.display = "flex";
            container.style.alignItems = "center";
            container.style.marginBottom = "8px";
            const input = document.createElement("input");
            input.type = "checkbox";
            input.checked = initial;
            input.style.marginRight = "8px";
            input.onchange = () => onChange(input.checked);
            container.appendChild(input);
            const span = document.createElement("span");
            span.innerText = label;
            container.appendChild(span);
            this.contentArea.appendChild(container);
        }
        /**
         * Retrieves the current option value from the chart given a dot‑separated path.
         */
        getCurrentOptionValue(optionPath) {
            const keys = optionPath.split(".");
            let options = this.handler.chart.options();
            for (const key of keys) {
                if (options && key in options) {
                    options = options[key];
                }
                else {
                    console.warn(`Option path "${optionPath}" is invalid.`);
                    return null;
                }
            }
            return options;
        }
        /**
         * Toggles the chart’s background type between solid and vertical-gradient.
         */
        toggleBackgroundType() {
            // Get the current background settings
            const currentBg = this.handler.chart.options().layout?.background;
            // If there's no background at all, define a fallback
            if (!currentBg) {
                // Example: default to solid white
                this.handler.chart.applyOptions({
                    layout: {
                        background: {
                            type: lightweightCharts.ColorType.Solid,
                            color: "#FFFFFF",
                        },
                    },
                });
                this.buildLayoutOptionsTab();
                return;
            }
            // Check what the current background type is
            if (currentBg.type === lightweightCharts.ColorType.Solid) {
                // We are going from SOLID => VERTICAL GRADIENT
                // Use the current solid color as the topColor, or fallback
                const existingSolidColor = currentBg.color || "#FFFFFF";
                // Optionally, if you previously stored a bottom color somewhere,
                // you can retrieve that. Otherwise, pick a fallback:
                const defaultBottom = "rgba(0,255,0,0.33)";
                const updatedBackground = {
                    type: lightweightCharts.ColorType.VerticalGradient,
                    topColor: existingSolidColor,
                    bottomColor: defaultBottom,
                };
                this.handler.chart.applyOptions({
                    layout: { background: updatedBackground },
                });
            }
            else if (currentBg.type === lightweightCharts.ColorType.VerticalGradient) {
                // We are going from VERTICAL GRADIENT => SOLID
                // Choose which gradient color to adopt as your new "solid" color.
                // Often the top color is used, but you could pick bottom if you prefer.
                const currentTop = currentBg.topColor || "#FFFFFF";
                const updatedBackground = {
                    type: lightweightCharts.ColorType.Solid,
                    color: currentTop,
                };
                this.handler.chart.applyOptions({
                    layout: { background: updatedBackground },
                });
            }
            else {
                // If it's some other background type or missing fields,
                // fallback to a default
                console.warn("Unknown background type. Falling back to solid #FFFFFF.");
                this.handler.chart.applyOptions({
                    layout: {
                        background: {
                            type: lightweightCharts.ColorType.Solid,
                            color: "#FFFFFF",
                        },
                    },
                });
            }
            // Finally, refresh the Layout Options tab so the new colors become current.
            this.buildLayoutOptionsTab();
        }
        /***********************************************************
         * 4. Helper Methods for UI Controls
         ***********************************************************/
        /** Simple function to create a text input row. */
        addTextInput(label, defaultValue, onChange) {
            const container = document.createElement("div");
            Object.assign(container.style, {
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                marginBottom: "8px",
                fontFamily: "sans-serif",
                fontSize: "16px",
            });
            const lbl = document.createElement("span");
            lbl.innerText = label;
            container.appendChild(lbl);
            const input = document.createElement("input");
            input.type = "text";
            input.value = defaultValue;
            Object.assign(input.style, {
                width: "150px",
                padding: "4px",
                backgroundColor: "#444",
                color: "#fff",
                border: "1px solid #555",
                borderRadius: "4px",
            });
            input.oninput = () => onChange(input.value);
            container.appendChild(input);
            this.contentArea.appendChild(container);
        }
        // At the top of your class, add a record to store original opacities by label.
        /**
         * Adds two color swatches for “Up” and “Down” colors, plus a checkbox
         * that toggles both to alpha=0 when disabled and restores the original opacity
         * when enabled. Uses the single ColorPicker instance.
         *
         * The original opacity settings are stored in a class-level record, keyed by the label.
         */
        addSideBySideColors(label, defaultUpColor, defaultDownColor, onChange, parent = this.contentArea) {
            // 1) Create row container for checkbox, label, and swatches
            const row = document.createElement("div");
            Object.assign(row.style, {
                display: "flex",
                alignItems: "center",
                marginBottom: "8px",
                gap: "12px",
            });
            // 2) Checkbox to enable/disable alpha=0
            const enabledCheck = document.createElement("input");
            enabledCheck.type = "checkbox";
            enabledCheck.checked = !(getAlphaFromColor(defaultUpColor) === 0 && getAlphaFromColor(defaultDownColor) === 0);
            row.appendChild(enabledCheck);
            // 3) Label
            const lbl = document.createElement("span");
            lbl.innerText = label;
            Object.assign(lbl.style, { minWidth: "60px" });
            row.appendChild(lbl);
            // 4) Container for the up/down swatches
            const pickersContainer = document.createElement("div");
            Object.assign(pickersContainer.style, {
                display: "flex",
                gap: "8px",
            });
            row.appendChild(pickersContainer);
            // Track the “current” colors
            let currentUpColor = defaultUpColor;
            let currentDownColor = defaultDownColor;
            // If not already stored, record the original opacities for this label.
            if (!(label in this._originalOpacities)) {
                this._originalOpacities[label] = {
                    up: getAlphaFromColor(defaultUpColor) ?? 1,
                    down: getAlphaFromColor(defaultDownColor) ?? 1,
                };
            }
            // 5) Create the two swatches (Up and Down)
            const upSwatch = document.createElement("div");
            Object.assign(upSwatch.style, {
                width: "32px",
                height: "32px",
                borderRadius: "4px",
                cursor: "pointer",
                border: "1px solid #999",
                backgroundColor: currentUpColor,
            });
            const downSwatch = document.createElement("div");
            Object.assign(downSwatch.style, {
                width: "32px",
                height: "32px",
                borderRadius: "4px",
                cursor: "pointer",
                border: "1px solid #999",
                backgroundColor: currentDownColor,
            });
            pickersContainer.appendChild(upSwatch);
            pickersContainer.appendChild(downSwatch);
            // Helper: notify the outside world about color changes
            const fireChange = () => {
                onChange(currentUpColor, currentDownColor);
            };
            // 6) Checkbox logic: when toggled, update the colors' opacity and adjust the checkbox state.
            enabledCheck.addEventListener("change", () => {
                if (enabledCheck.checked) {
                    // Re-enabling: restore saved colors with original opacity from our record.
                    currentUpColor = setOpacity(currentUpColor, this._originalOpacities[label].up ?? getAlphaFromColor(defaultUpColor));
                    currentDownColor = setOpacity(currentDownColor, this._originalOpacities[label].down ?? getAlphaFromColor(defaultDownColor));
                    upSwatch.style.border = "1px solid #999";
                    downSwatch.style.border = "1px solid #999";
                }
                else {
                    // Disabling: save current colors, then set opacity to 0.
                    this._originalOpacities[label].up = getAlphaFromColor(currentUpColor);
                    this._originalOpacities[label].down = getAlphaFromColor(currentDownColor);
                    currentUpColor = setOpacity(currentUpColor, 0);
                    currentDownColor = setOpacity(currentDownColor, 0);
                    // Remove borders when disabled.
                    upSwatch.style.border = "0px";
                    downSwatch.style.border = "0px";
                }
                upSwatch.style.backgroundColor = currentUpColor;
                downSwatch.style.backgroundColor = currentDownColor;
                // After the change, adjust the checkbox state based on the new opacity.
                enabledCheck.checked = !(getAlphaFromColor(currentUpColor) === 0 &&
                    getAlphaFromColor(currentDownColor) === 0);
                fireChange();
            });
            // 7) Up swatch event: open color picker for up color.
            upSwatch.addEventListener("click", (evt) => {
                if (!enabledCheck.checked) {
                    enabledCheck.checked = true;
                    enabledCheck.dispatchEvent(new Event("change"));
                }
                this.colorPicker.openMenu(evt, upSwatch.offsetWidth + downSwatch.offsetWidth, (finalColor) => {
                    currentUpColor = finalColor;
                    upSwatch.style.backgroundColor = finalColor;
                    fireChange();
                });
            });
            // 8) Down swatch event: open color picker for down color.
            downSwatch.addEventListener("click", (evt) => {
                if (!enabledCheck.checked) {
                    enabledCheck.checked = true;
                    enabledCheck.dispatchEvent(new Event("change"));
                }
                this.colorPicker.openMenu(evt, downSwatch.offsetWidth, (finalColor) => {
                    currentDownColor = finalColor;
                    downSwatch.style.backgroundColor = finalColor;
                    fireChange();
                });
            });
            // 9) Finally, append the row to the parent element.
            parent.appendChild(row);
        }
        /**
         * Builds color controls for a primitive's options.
         * It groups related color options if both keys (e.g. upColor/downColor) exist;
         * for remaining keys that include "color", it creates a single color picker.
         * After any change, it calls updateFn with the new options so that
         * primitive.applyOptions() can be invoked.
         *
         * @param options The options object to process.
         * @param parent The container element to which the controls are appended.
         * @param updateFn A callback to update the primitive (typically, primitive.applyOptions(newOpts)).
         */
        buildPrimitiveColorOptions(options, parent, updateFn) {
            // Define groups of related color keys.
            const groups = {
                "Body": ["upColor", "downColor"],
                "Borders": ["borderUpColor", "borderDownColor"],
                "Wick": ["wickUpColor", "wickDownColor"]
            };
            // Track which keys have been processed.
            const processedKeys = new Set();
            // Process each defined group.
            for (const groupLabel in groups) {
                const [key1, key2] = groups[groupLabel];
                if (key1 in options && key2 in options) {
                    processedKeys.add(key1);
                    processedKeys.add(key2);
                    this.addSideBySideColors(groupLabel, options[key1], options[key2], (upColor, downColor) => {
                        options[key1] = upColor;
                        options[key2] = downColor;
                        updateFn(options);
                    }, parent);
                }
            }
            // For any remaining keys that include "color" and weren't grouped:
            Object.keys(options).forEach((key) => {
                if (key.toLowerCase().includes("color") && !processedKeys.has(key)) {
                    this.addColorPicker(key, options[key], (newColor) => {
                        options[key] = newColor;
                        updateFn(options);
                    }, parent);
                }
            });
        }
    }
    /*
      Example usage somewhere in your code:
      
      logSeriesColorsFromMap.call(this);

      This will print to the console something like:

        > Color keys for Series: "MyCandles"
          Found color: upColor = "#1565C0"
          Found color: downColor = "#8B4513"
          Found color: borderUpColor = "#00FF00"
          Found color: borderDownColor = "#FF0000"
          ...
    */

    // ----------------------------------
    // External Library Imports
    // ----------------------------------
    // ----------------------------------
    // If you have actual code referencing commented-out or removed imports,
    // reintroduce them accordingly.
    // ----------------------------------
    let activeMenu = null;
    class ContextMenu {
        handler;
        handlerMap;
        getMouseEventParams;
        div;
        hoverItem;
        items = [];
        colorPicker;
        saveDrawings = null;
        drawingTool = null;
        recentSeries = null;
        recentDrawing = null;
        SettingsModal = null;
        volumeProfile = null;
        dataMenu;
        constructor(handler, handlerMap, getMouseEventParams) {
            this.handler = handler;
            this.handlerMap = handlerMap;
            this.getMouseEventParams = getMouseEventParams;
            this.div = document.createElement("div");
            this.div.classList.add("context-menu");
            document.body.appendChild(this.div);
            this.div.style.overflowY = "scroll";
            this.hoverItem = null;
            document.body.addEventListener("contextmenu", this._onRightClick.bind(this));
            document.body.addEventListener("click", this._onClick.bind(this));
            const defaultColors = Array.isArray(this.handler.defaultsManager.get('colors')) ? [...this.handler.defaultsManager.get('colors')] : [];
            this.colorPicker = new ColorPicker("#ff0000", () => null, defaultColors && defaultColors.length !== 0 ? defaultColors : undefined);
            //this.handler.chart.subscribeCrosshairMove((param: MouseEventParams) => {
            //  this.handleCrosshairMove(param);
            //});
            this.dataMenu = new DataMenu({ contextMenu: this, handler: this.handler });
            this.SettingsModal = new SettingsModal(this.handler);
            this.setupMenu();
        }
        constraints = {
            baseline: { skip: true },
            title: { skip: true },
            PriceLineSource: { skip: true },
            tickInterval: { min: 0, max: 100 },
            lastPriceAnimation: { skip: true },
            lineType: { min: 0, max: 2 },
            lineStyle: { min: 0, max: 4 },
            seriesType: { skip: true },
            chandelierSize: { min: 1 }, // skip: true },
            dynamicCandles: { skip: true },
            volumeMALength: { skip: true },
            volumeMultiplier: { skip: true },
            volumeOpacityPeriod: { skip: true }
        };
        setupDrawingTools(saveDrawings, drawingTool) {
            this.saveDrawings = saveDrawings;
            this.drawingTool = drawingTool;
        }
        shouldSkipOption(optionName) {
            const constraints = this.constraints[optionName] || {};
            return !!constraints.skip;
        }
        separator() {
            const separator = document.createElement("div");
            separator.style.width = "90%";
            separator.style.height = "1px";
            separator.style.margin = "3px 0px";
            separator.style.backgroundColor = window.pane.borderColor;
            this.div.appendChild(separator);
            this.items.push(separator);
        }
        menuItem(text, action, hover = null) {
            const item = document.createElement("span");
            item.classList.add("context-menu-item");
            this.div.appendChild(item);
            const elem = document.createElement("span");
            elem.innerText = text;
            elem.style.pointerEvents = "none";
            item.appendChild(elem);
            if (hover) {
                let arrow = document.createElement("span");
                arrow.innerText = `►`;
                arrow.style.fontSize = "8px";
                arrow.style.pointerEvents = "none";
                item.appendChild(arrow);
            }
            item.addEventListener("mouseover", () => {
                if (this.hoverItem && this.hoverItem.closeAction)
                    this.hoverItem.closeAction();
                this.hoverItem = { elem: elem, action: action, closeAction: hover };
            });
            if (!hover)
                item.addEventListener("click", (event) => {
                    action(event);
                    this.div.style.display = "none";
                });
            else {
                let timeout;
                item.addEventListener("mouseover", () => (timeout = setTimeout(() => action(item.getBoundingClientRect()), 100)));
                item.addEventListener("mouseout", () => clearTimeout(timeout));
            }
            this.items.push(item);
        }
        _onClick(ev) {
            const target = ev.target;
            if (this.colorPicker && !this.colorPicker.getElement().contains(target)) {
                this.colorPicker.closeMenu();
            }
        }
        // series-context-menu.ts
        _onRightClick(event) {
            event.preventDefault(); // Prevent the browser's context menu
            const mouseEventParams = this.getMouseEventParams();
            const seriesFromProximity = this.getProximitySeries(this.getMouseEventParams());
            const drawingFromProximity = this.getProximityDrawing(); // Implement this method based on your drawing logic
            const trendFromProximity = this.getProximityTrendTrace();
            console.log("Mouse Event Params:", mouseEventParams);
            console.log("Proximity Series:", seriesFromProximity);
            console.log("Proximity Drawing:", drawingFromProximity);
            this.clearMenu(); // Clear existing menu items
            this.clearAllMenus(); // Clear other menus if necessary
            if (seriesFromProximity) {
                // Right-click on a series
                console.log("Right-click detected on a series (proximity).");
                this.populateSeriesMenu(seriesFromProximity, event);
                this.recentSeries = seriesFromProximity;
            }
            else if (drawingFromProximity) {
                // Right-click on a drawing
                console.log("Right-click detected on a drawing.");
                this.populateDrawingMenu(event, drawingFromProximity);
                this.recentDrawing = drawingFromProximity;
            }
            else if (trendFromProximity) {
                // Right-click on a drawing
                console.log("Right-click detected on a drawing.");
                this.populateTrendTraceMenu(event, trendFromProximity);
            }
            else if (mouseEventParams?.hoveredSeries) {
                // Fallback to hovered series
                console.log("Right-click detected on a series (hovered).");
                this.populateSeriesMenu(mouseEventParams.hoveredSeries, event);
                this.recentSeries = seriesFromProximity;
            }
            else {
                // Right-click on chart background
                console.log("Right-click detected on the chart background.");
                this.populateChartMenu(event);
            }
            // Position the menu at cursor location
            this.showMenu(event);
            event.preventDefault();
            event.stopPropagation(); // Prevent event bubbling
        }
        // series-context-menu.ts
        getProximityDrawing() {
            // Implement your logic to determine if a drawing is under the cursor
            // For example:
            if (Drawing.hoveredObject) {
                return Drawing.hoveredObject;
            }
            return null;
        }
        getProximityTrendTrace() {
            if (TrendTrace.hoveredObject) {
                return TrendTrace.hoveredObject;
            }
            return null;
        }
        getProximitySeries(param) {
            if (!param || !param.seriesData) {
                console.warn("No mouse event parameters or series data available.");
                return null;
            }
            if (!param.point) {
                console.warn("No point data in MouseEventParams.");
                return null;
            }
            const cursorY = param.point.y;
            let sourceSeries = null;
            const referenceSeries = this.handler.chart.panes()[param.paneIndex ?? 0].getSeries()[0];
            if (this.handler.series && this.handler.series.getPane().paneIndex() === param.paneIndex) {
                sourceSeries = this.handler.series;
                console.log(`Using handler.series for coordinate conversion.`);
            }
            else if (referenceSeries) {
                sourceSeries = referenceSeries;
                console.log(`Using referenceSeries for coordinate conversion.`);
            }
            else {
                console.warn("No handler.series or referenceSeries available.");
                return null;
            }
            // If the pane index from the event doesn't match the source series' pane,
            // update sourceSeries based on the pane index from the event.
            if (param.paneIndex !== sourceSeries.getPane().paneIndex()) {
                sourceSeries = this.handler.chart.panes()[param.paneIndex ?? 1].getSeries()[0];
            }
            const cursorPrice = sourceSeries.coordinateToPrice(cursorY);
            console.log(`Converted chart Y (${cursorY}) to Price: ${cursorPrice}`);
            if (cursorPrice === null) {
                console.warn("Cursor price is null. Unable to determine proximity.");
                return null;
            }
            const seriesByDistance = [];
            param.seriesData.forEach((data, series) => {
                let refPrice;
                if (isSingleValueData(data)) {
                    refPrice = data.value;
                }
                else if (isOHLCData(data)) {
                    refPrice = data.close;
                }
                if (refPrice !== undefined && !isNaN(refPrice)) {
                    const distance = Math.abs(refPrice - cursorPrice);
                    const paneSize = this.handler.chart.panes()[param.paneIndex].getHeight();
                    const top = sourceSeries.coordinateToPrice(0);
                    const bottom = sourceSeries.coordinateToPrice(paneSize);
                    if (top === null || bottom === null)
                        return null;
                    const percentageDifference = (distance / (top - bottom)) * 100;
                    if (percentageDifference <= 3 && param.paneIndex === series.getPane().paneIndex()) {
                        seriesByDistance.push({ distance, series: series });
                    }
                }
            });
            // Sort series by proximity (distance)
            seriesByDistance.sort((a, b) => a.distance - b.distance);
            if (seriesByDistance.length > 1 && this.recentSeries === seriesByDistance[0].series) {
                console.log("Multiple series found.");
                return seriesByDistance[1].series;
            }
            else if (seriesByDistance.length > 0) {
                console.log("Closest series found.");
                return seriesByDistance[0].series;
            }
            console.log("No series found within the proximity threshold.");
            return null;
        }
        showMenu(event) {
            const x = event.clientX;
            const y = event.clientY;
            this.div.style.position = "absolute";
            this.div.style.zIndex = "10000";
            this.div.style.left = `${x}px`;
            this.div.style.top = `${y}px`;
            this.div.style.width = "250px";
            this.div.style.maxHeight = `400px`;
            this.div.style.overflowY = "auto";
            this.div.style.display = "block";
            this.div.style.overflowX = "hidden";
            console.log("Displaying Menu at:", x, y);
            activeMenu = this.div;
            console.log("Displaying Menu", x, y);
            document.addEventListener("mousedown", this.hideMenuOnOutsideClick.bind(this), { once: true });
        }
        hideMenuOnOutsideClick(event) {
            if (!this.div.contains(event.target)) {
                this.hideMenu();
            }
        }
        hideMenu() {
            this.div.style.display = "none";
            if (activeMenu === this.div) {
                activeMenu = null;
            }
        }
        clearAllMenus() {
            this.handlerMap.forEach((handler) => {
                if (handler.ContextMenu) {
                    handler.ContextMenu.clearMenu();
                }
            });
        }
        setupMenu() {
            if (!this.div.querySelector(".chart-options-container")) {
                const chartOptionsContainer = document.createElement("div");
                chartOptionsContainer.classList.add("chart-options-container");
                this.div.appendChild(chartOptionsContainer);
            }
            if (!this.div.querySelector(".context-menu-item.close-menu")) {
                this.addMenuItem("Close Menu", () => this.hideMenu());
            }
        }
        addNumberInput(label, defaultValue, onChange, min, max, step) {
            return this.addMenuInput(this.div, {
                type: "number",
                label,
                value: defaultValue,
                onChange,
                min,
                max,
                step,
            });
        }
        addCheckbox(label, value, onChange) {
            return this.addMenuInput(this.div, {
                type: "boolean",
                label,
                value: value,
                onChange,
            });
        }
        addSelectInput(label, currentValue, options, onSelectChange) {
            return this.addMenuInput(this.div, {
                type: "select",
                label,
                value: currentValue,
                onChange: onSelectChange,
                options,
            });
        }
        addMenuInput(parent, config, idPrefix = "") {
            const container = document.createElement("div");
            container.classList.add("context-menu-item");
            container.style.display = "flex";
            container.style.alignItems = "right";
            container.style.justifyContent = "space-around";
            if (config.label) {
                const labelElem = document.createElement("label");
                labelElem.innerText = config.label;
                labelElem.htmlFor = `${idPrefix}${config.label.toLowerCase()}`;
                labelElem.style.flex = "0.8";
                labelElem.style.whiteSpace = "nowrap";
                container.appendChild(labelElem);
            }
            let inputElem;
            switch (config.type) {
                case "hybrid": {
                    if (!config.hybridConfig) {
                        throw new Error("Hybrid type requires hybridConfig.");
                    }
                    // Container for the two side-by-side buttons (plus an optional dropdown).
                    const container = document.createElement("div");
                    container.classList.add("context-menu-item");
                    container.style.position = "relative";
                    container.style.display = "flex";
                    container.style.flexDirection = "row";
                    container.style.justifyContent = "flex-end";
                    container.style.alignItems = "right";
                    // -------------------------------
                    // Shared Styling for Both Buttons
                    // -------------------------------
                    const baseButtonStyle = {
                        backgroundColor: "#2b2b2b",
                        color: "#fff",
                        border: "1px solid #444",
                        padding: "2px 2px", // Minimal padding so text is visible
                        textAlign: "center",
                        cursor: "pointer",
                        boxSizing: "border-box",
                        display: "flex",
                        alignItems: "right",
                        justifyContent: "right",
                        // No fixed height; the button grows to fit text or symbols
                        // If you need a strict height, uncomment below and set as desired:
                        // height: "24px",
                        // lineHeight: "24px",
                    };
                    // Helper function to apply shared styling.
                    function applyStyles(elem, styles) {
                        for (const [key, value] of Object.entries(styles)) {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            elem.style[key] = value;
                        }
                    }
                    // -------------------------------
                    // Main Button (Left) - No Label
                    // -------------------------------
                    const mainButton = document.createElement("div");
                    applyStyles(mainButton, baseButtonStyle);
                    mainButton.style.borderRadius = "4px 0 0 4px"; // Rounded left corners
                    mainButton.innerText = config.sublabel ?? '▵';
                    // No label or text in the main button
                    mainButton.addEventListener("click", (event) => {
                        event.stopPropagation();
                        config.hybridConfig.defaultAction();
                    });
                    // -------------------------------
                    // Dropdown Button (Right) - Displays ∷
                    // -------------------------------
                    const dropdownButton = document.createElement("div");
                    applyStyles(dropdownButton, baseButtonStyle);
                    // Remove left border to join seamlessly with mainButton
                    dropdownButton.style.borderLeft = "none";
                    dropdownButton.style.borderRadius = "0 4px 4px 0"; // Rounded right corners
                    dropdownButton.innerText = "☷";
                    // -------------------------------
                    // Dropdown Container (Shown if multiple options)
                    // -------------------------------
                    const dropdown = document.createElement("div");
                    dropdown.style.position = "absolute";
                    dropdown.style.top = "100%"; // or set to "0" and adjust left/right if needed
                    dropdown.style.right = "0";
                    dropdown.style.backgroundColor = "#2b2b2b";
                    dropdown.style.color = "#fff";
                    dropdown.style.border = "1px solid #444";
                    dropdown.style.borderRadius = "4px";
                    dropdown.style.minWidth = "100px";
                    dropdown.style.boxShadow = "0px 2px 5px rgba(0, 0, 0, 0.5)";
                    dropdown.style.zIndex = "10000";
                    dropdown.style.display = "none";
                    // Decide single vs. multiple option behavior
                    if (config.hybridConfig.options.length === 1) {
                        // If there is exactly one option, clicking the dropdownButton calls that single action
                        const singleOption = config.hybridConfig.options[0];
                        dropdownButton.addEventListener("click", (event) => {
                            event.stopPropagation();
                            singleOption.action();
                        });
                    }
                    else {
                        // Multiple options => build and toggle the dropdown
                        config.hybridConfig.options.forEach((option) => {
                            const optionElem = document.createElement("div");
                            optionElem.innerText = option.name;
                            optionElem.style.cursor = "pointer";
                            optionElem.style.padding = "5px 10px";
                            optionElem.addEventListener("click", (event) => {
                                event.stopPropagation();
                                dropdown.style.display = "none";
                                option.action();
                            });
                            optionElem.addEventListener("mouseenter", () => {
                                optionElem.style.backgroundColor = "#444";
                            });
                            optionElem.addEventListener("mouseleave", () => {
                                optionElem.style.backgroundColor = "#2b2b2b";
                            });
                            dropdown.appendChild(optionElem);
                        });
                        // Toggle dropdown by clicking the dropdownButton
                        dropdownButton.addEventListener("click", (event) => {
                            event.stopPropagation();
                            dropdown.style.display =
                                dropdown.style.display === "none" ? "block" : "none";
                        });
                        // Add the dropdown to the container so it appears below/right
                        container.appendChild(dropdown);
                    }
                    // Add both buttons side by side to the container
                    container.appendChild(mainButton);
                    container.appendChild(dropdownButton);
                    // Assign the final element reference
                    inputElem = container;
                    break;
                }
                case "number": {
                    const input = document.createElement("input");
                    input.type = "number";
                    input.value = config.value !== undefined ? config.value.toString() : "";
                    input.style.backgroundColor = "#2b2b2b"; // Darker gray background
                    input.style.color = "#fff"; // White text
                    input.style.border = "1px solid #444"; // Subtle border
                    input.style.borderRadius = "4px";
                    input.style.textAlign = "center";
                    input.style.marginLeft = "auto"; // Adds margin to the right of the input
                    input.style.marginRight = "8px"; // Adds margin to the right of the input
                    input.style.width = "40px"; // Ensures a consistent width
                    // Set min/max if provided
                    if (config.min !== undefined)
                        input.min = config.min.toString();
                    if (config.max !== undefined)
                        input.max = config.max.toString();
                    // NEW: Set step if provided, default to 1 if not
                    if (config.step !== undefined && !isNaN(config.step)) {
                        input.step = config.step.toString();
                    }
                    else {
                        input.step = "1"; // Or any other default
                    }
                    input.addEventListener("input", (event) => {
                        const target = event.target;
                        let newValue = parseFloat(target.value);
                        if (!isNaN(newValue)) {
                            config.onChange(newValue);
                        }
                    });
                    inputElem = input;
                    break;
                }
                case "boolean": {
                    const input = document.createElement("input");
                    input.type = "checkbox";
                    input.checked = config.value ?? false;
                    input.style.marginLeft = "auto";
                    input.style.marginRight = "8px";
                    input.addEventListener("change", (event) => {
                        const target = event.target;
                        config.onChange(target.checked);
                    });
                    inputElem = input;
                    break;
                }
                case "select": {
                    const select = document.createElement("select");
                    select.id = `${idPrefix}${config.label ? config.label.toLowerCase() : "select"}`;
                    select.style.backgroundColor = "#2b2b2b"; // Darker gray background
                    select.style.color = "#fff"; // White text
                    select.style.border = "1px solid #444"; // Subtle border
                    select.style.borderRadius = "4px";
                    select.style.marginLeft = "auto";
                    select.style.marginRight = "8px"; // Adds margin to the right of the dropdown
                    select.style.width = "80px"; // Ensures consistent width for dropdown
                    config.options?.forEach((optionValue) => {
                        const option = document.createElement("option");
                        option.value = optionValue;
                        option.text = optionValue;
                        option.style.whiteSpace = "normal"; // Allow wrapping within dropdown
                        option.style.textAlign = "right";
                        if (optionValue === config.value)
                            option.selected = true;
                        select.appendChild(option);
                    });
                    select.addEventListener("change", (event) => {
                        const target = event.target;
                        config.onChange(target.value);
                    });
                    inputElem = select;
                    break;
                }
                case "string": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.value = config.value ?? "";
                    input.style.backgroundColor = "#2b2b2b"; // Darker gray background
                    input.style.color = "#fff"; // White text
                    input.style.border = "1px solid #444"; // Subtle border
                    input.style.borderRadius = "4px";
                    input.style.marginLeft = "auto";
                    input.style.textAlign = "center";
                    input.style.marginRight = "8px"; // Adds margin to the right of the text input
                    input.style.width = "60px"; // Ensures consistent width
                    input.addEventListener("input", (event) => {
                        const target = event.target;
                        config.onChange(target.value);
                    });
                    inputElem = input;
                    break;
                }
                case "color": {
                    const input = document.createElement("input");
                    input.type = "color";
                    input.value = config.value ?? "#000000";
                    input.style.marginLeft = "auto";
                    input.style.cursor = "pointer";
                    input.style.marginRight = "8px"; // Adds margin to the right of the input
                    input.style.width = "100px"; // Ensures a consistent width
                    input.addEventListener("input", (event) => {
                        const target = event.target;
                        config.onChange(target.value);
                    });
                    inputElem = input;
                    break;
                }
                default:
                    throw new Error("Unsupported input type");
            }
            //inputElem.style.padding= "2px 10px 2px 10px";
            container.style.padding = "2px 10px 2px 10px";
            container.appendChild(inputElem);
            parent.appendChild(container);
            return container;
        }
        addMenuItem(text, action, shouldHide = true, hasSubmenu = false, submenuLevel = 1) {
            const item = document.createElement("span");
            item.classList.add("context-menu-item");
            item.innerText = text;
            if (hasSubmenu) {
                const defaultArrow = document.createElement("span");
                defaultArrow.classList.add("submenu-arrow");
                defaultArrow.innerText = "ː".repeat(submenuLevel);
                item.appendChild(defaultArrow);
            }
            item.addEventListener("click", (event) => {
                event.stopPropagation();
                action();
                if (shouldHide) {
                    this.hideMenu();
                }
            });
            const arrows = ["➩", "➯", "➱", "➬", "➫"];
            item.addEventListener("mouseenter", () => {
                item.style.backgroundColor = "royalblue";
                item.style.color = "white";
                if (!item.querySelector(".hover-arrow")) {
                    const hoverArrow = document.createElement("span");
                    hoverArrow.classList.add("hover-arrow");
                    const randomIndex = Math.floor(Math.random() * arrows.length);
                    const selectedArrow = arrows[randomIndex];
                    hoverArrow.innerText = selectedArrow;
                    hoverArrow.style.marginLeft = "auto";
                    hoverArrow.style.fontSize = "8px";
                    hoverArrow.style.color = "white";
                    item.appendChild(hoverArrow);
                }
            });
            item.addEventListener("mouseleave", () => {
                item.style.backgroundColor = "";
                item.style.color = "";
                const hoverArrow = item.querySelector(".hover-arrow");
                if (hoverArrow) {
                    item.removeChild(hoverArrow);
                }
            });
            this.div.appendChild(item);
            this.items.push(item);
            return item;
        }
        clearMenu() {
            const dynamicItems = this.div.querySelectorAll(".context-menu-item:not(.close-menu), .context-submenu");
            dynamicItems.forEach((item) => item.remove());
            this.items = [];
            this.div.innerHTML = "";
        }
        /**
         * Unified color picker menu item.
         * @param label Display label for the menu item
         * @param currentColor The current color value
         * @param optionPath The dot-separated path to the option
         * @param optionTarget The chart or series to apply the color to
         */
        addColorPickerMenuItem(label, currentColor, optionPath, optionTarget) {
            const menuItem = document.createElement("span");
            menuItem.classList.add("context-menu-item");
            menuItem.innerText = label;
            this.div.appendChild(menuItem);
            const applyColor = (newColor) => {
                const options = buildOptions(optionPath, newColor);
                optionTarget.applyOptions(options);
                console.log(`Updated ${optionPath} to ${newColor}`);
                // If optionTarget is a series and the option is color-based, update LegendSeries colors
                const isSeries = (target) => {
                    return (typeof target === "object" &&
                        target !== null &&
                        // Some property check to confirm it's ISeriesApiExtended
                        typeof target.applyOptions === "function" &&
                        typeof target.dataByIndex === "function");
                };
                if (isSeries(optionTarget) &&
                    ["color", "lineColor", "upColor", "downColor"].includes(optionPath)) {
                    // Attempt to find the legend item in the legend _lines array
                    const legendItem = this.handler.legend._lines.find((item) => item.series === optionTarget);
                    if (legendItem) {
                        // Map the relevant color to the correct index
                        // color, lineColor, upColor => index 0
                        // downColor => index 1
                        if (optionPath === "downColor") {
                            legendItem.colors[1] = newColor;
                            console.log(`Legend down color updated to: ${newColor}`);
                        }
                        else {
                            legendItem.colors[0] = newColor;
                            console.log(`Legend up/main color updated to: ${newColor}`);
                        }
                    }
                }
            };
            menuItem.addEventListener("click", (event) => {
                event.stopPropagation();
                if (!this.colorPicker) {
                    this.colorPicker = new ColorPicker(currentColor ?? "#000000", applyColor);
                }
                this.colorPicker.openMenu(event, 225, applyColor);
            });
            return menuItem;
        }
        // Class-level arrays to store current options for width and style.
        currentWidthOptions = [];
        currentStyleOptions = [];
        /**
         * Populates the clone series submenu.
         *
         * @param series - The original series to clone.
         * @param event - The mouse event triggering the context menu.
         */
        populateSeriesMenu(series, event) {
            // Type guard to check if series is extended
            const _series = ensureExtendedSeries(series, this.handler.legend);
            // Now `series` is guaranteed to be extended
            const seriesOptions = series.options();
            if (!seriesOptions) {
                console.warn("No options found for the selected series.");
                return;
            }
            this.div.innerHTML = "";
            const colorOptions = [];
            const visibilityOptions = [];
            const otherOptions = [];
            // Temporary arrays before assigning to class-level variables
            const tempWidthOptions = [];
            const tempStyleOptions = [];
            for (const optionName of Object.keys(seriesOptions)) {
                const optionValue = seriesOptions[optionName];
                if (this.shouldSkipOption(optionName))
                    continue;
                if (optionName.toLowerCase().includes("base"))
                    continue;
                const lowerOptionName = camelToTitle(optionName).toLowerCase();
                const isWidthOption = lowerOptionName.includes("width") ||
                    lowerOptionName === "radius" ||
                    lowerOptionName.includes("radius");
                if (lowerOptionName.includes("color")) {
                    // Color options
                    if (typeof optionValue === "string") {
                        colorOptions.push({ label: optionName, value: optionValue });
                    }
                    else {
                        console.warn(`Expected string value for color option "${optionName}".`);
                    }
                }
                else if (isWidthOption) {
                    if (typeof optionValue === "number") {
                        let minVal = 1;
                        let maxVal = 10;
                        let step = 1;
                        // If this property is specifically "radius", make it 0..1
                        if (lowerOptionName.includes("radius")) {
                            minVal = 0;
                            maxVal = 1;
                            step = 0.1;
                        }
                        // Add it to your "width" options array with the specialized range
                        tempWidthOptions.push({
                            name: optionName,
                            label: optionName,
                            value: optionValue,
                            min: minVal,
                            max: maxVal,
                            step: step,
                        });
                    }
                }
                else if (lowerOptionName.includes("visible") ||
                    lowerOptionName.includes("visibility")) {
                    // Visibility options
                    if (typeof optionValue === "boolean") {
                        visibilityOptions.push({ label: optionName, value: optionValue });
                    }
                    else {
                        console.warn(`Expected boolean value for visibility option "${optionName}".`);
                    }
                }
                else if (optionName === "lineType") {
                    // lineType is a style option
                    // LineType: Simple=0, WithSteps=1
                    const possibleLineTypes = this.getPredefinedOptions(camelToTitle(optionName));
                    tempStyleOptions.push({
                        name: optionName,
                        label: optionName,
                        value: optionValue,
                        options: possibleLineTypes,
                    });
                }
                else if (optionName === "crosshairMarkerRadius") {
                    // crosshairMarkerRadius should appear under Width Options
                    if (typeof optionValue === "number") {
                        tempWidthOptions.push({
                            name: optionName,
                            label: optionName,
                            value: optionValue,
                            min: 1,
                            max: 50,
                        });
                    }
                    else {
                        console.warn(`Expected number value for crosshairMarkerRadius option "${optionName}".`);
                    }
                }
                else if (lowerOptionName.includes("style")) {
                    // Style options (e.g. lineStyle)
                    if (typeof optionValue === "string" ||
                        Object.values(lightweightCharts.LineStyle).includes(optionValue) ||
                        typeof optionValue === "number") {
                        const possibleStyles = [
                            "Solid",
                            "Dotted",
                            "Dashed",
                            "Large Dashed",
                            "Sparse Dotted",
                        ];
                        tempStyleOptions.push({
                            name: optionName,
                            label: optionName,
                            value: optionValue,
                            options: possibleStyles,
                        });
                    }
                } // Example: handle shape if "shape" is in the name
                else if (lowerOptionName.includes("shape")) {
                    // If we confirm it's a recognized CandleShape
                    if (isCandleShape(optionValue)) {
                        const predefinedShapes = [
                            "Rectangle",
                            "Rounded",
                            "Ellipse",
                            "Arrow",
                            "3d",
                            "Polygon",
                            "Bar",
                            "Slanted"
                        ];
                        if (predefinedShapes) {
                            tempStyleOptions.push({
                                name: optionName,
                                label: optionName,
                                value: optionValue, // This is guaranteed CandleShape now
                                options: predefinedShapes,
                            });
                        }
                    }
                }
                else {
                    // Other options go directly to otherOptions
                    otherOptions.push({ label: optionName, value: optionValue });
                }
            }
            // Assign the temp arrays to class-level arrays for use in submenus
            this.currentWidthOptions = tempWidthOptions;
            this.currentStyleOptions = tempStyleOptions;
            this.addTextInput("Title", series.options().title || "", // Default to empty string if no title exists
            (newValue) => {
                const options = { title: newValue };
                // Remove old entry and re-add with new title
                if (this.handler.seriesMap.has(series.options().title)) {
                    this.handler.seriesMap.delete(series.options().title);
                }
                this.handler.seriesMap.set(newValue, series);
                console.log(`Updated seriesMap label to: ${newValue}`);
                // Update the legend title
                const legendItem = this.handler.legend._lines.find((item) => item.series === series);
                if (legendItem && legendItem.series === series) {
                    legendItem.name = newValue;
                    console.log(`Updated legend title to: ${newValue}`);
                }
                series.applyOptions(options);
                console.log(`Updated title to: ${newValue}`);
            });
            // Retrieve current pane index of the series and the array of existing panes.
            const currentPaneIndex = series.getPane().paneIndex();
            const panes = this.handler.chart.panes();
            // Determine the current value (label) for the hybrid input.
            const currentValue = `Pane ${currentPaneIndex}`;
            // Define the default action:
            // If the series is in the main pane (pane 0), move it to the next existing pane (if available)
            // or create a new pane if there isn’t one.
            // Otherwise (if the series is on any other pane), move it back to the main pane (pane 0).
            const defaultAction = () => {
                if (currentPaneIndex === 0) {
                    series.moveToPane(panes.length);
                    console.log(`Default: Moved series from pane ${currentPaneIndex} to a new pane at index ${panes.length}.`);
                }
                else {
                    series.moveToPane(0);
                    console.log(`Default: Moved series from pane ${currentPaneIndex} back to main pane (0).`);
                }
            };
            // Build the list of options:
            // For each existing pane, add an option labeled "Pane 0", "Pane 1", etc.
            // Then add an extra option for a "New Pane".
            const options = [];
            for (let i = 0; i < panes.length; i++) {
                if (i === currentPaneIndex) {
                    continue;
                }
                options.push({
                    name: `Pane ${i}`,
                    action: () => {
                        series.moveToPane(i);
                        console.log(`Moved series to existing pane ${i}.`);
                    },
                });
            }
            options.push({
                name: "New Pane",
                action: () => {
                    series.moveToPane(panes.length);
                    console.log(`Moved series to a new pane at index ${panes.length}.`);
                },
            });
            // Create the hybrid input using your addMenuInput helper.
            // This will render a dropdown that shows all options and executes the corresponding action on change.
            this.addMenuInput(this.div, {
                type: "hybrid",
                label: "Move to pane",
                sublabel: currentPaneIndex === 0 ? 'New Pane' : 'Top',
                value: currentValue,
                onChange: (newValue) => {
                    // When the user selects an option, look it up in the options array and execute its action.
                    const selectedOption = options.find((opt) => opt.name === newValue);
                    if (selectedOption) {
                        selectedOption.action();
                    }
                },
                hybridConfig: {
                    defaultAction: defaultAction,
                    options: options.map((opt) => ({
                        name: opt.name,
                        action: opt.action,
                    })),
                },
            });
            // Inside populateSeriesMenu (already in your code above)
            this.addMenuItem("Clone Series ▸", () => {
                this.populateCloneSeriesMenu(series, event);
            }, false, true);
            // Add main menu items only if these arrays have content
            if (visibilityOptions.length > 0) {
                this.addMenuItem("Visibility Options ▸", () => {
                    this.populateVisibilityMenu(event, series);
                }, false, true);
            }
            if (this.currentStyleOptions.length > 0) {
                this.addMenuItem("Style Options ▸", () => {
                    this.populateStyleMenu(event, series);
                }, false, true);
            }
            if (this.currentWidthOptions.length > 0) {
                this.addMenuItem("Width Options ▸", () => {
                    this.populateWidthMenu(event, series);
                }, false, true);
            }
            if (colorOptions.length > 0) {
                this.addMenuItem("Color Options ▸", () => {
                    this.populateColorOptionsMenu(colorOptions, series, event);
                }, false, true);
            }
            // **** New block: add numeric inputs for volume-based or chandelier aggregation ****
            //let aggregatorOptions = series.options();
            //if ( "volumeCandles" in aggregatorOptions && "volumeMALength" in aggregatorOptions &&
            //  "volumeMultiplier" in aggregatorOptions &&
            //  "chandelierSize" in aggregatorOptions &&
            //  aggregatorOptions?.volumeCandles !== undefined) {
            //const aggregatorOptions = series.options() as  OhlcSeriesOptions ;
            // if ('volumeCandles' in aggregatorOptions && "volumeMALength" in aggregatorOptions &&
            //   "volumeMultiplier" in aggregatorOptions) {
            //  // Add a checkbox for toggling volumeCandles.
            //  // When toggled, the series options are updated and the menu is repopulated.
            //  this.addCheckbox("Volume Candles", (aggregatorOptions as OhlcSeriesOptions).volumeCandles ?? false, (newValue: boolean) => {
            //    const options = { volumeCandles: newValue };
            //    series.applyOptions(options as Partial<OhlcSeriesOptions>);
            //    console.log(`Updated volumeCandles to ${newValue}`);
            //    // Repopulate the series menu with the updated options.
            //    this.populateSeriesMenu(series, event);
            //  });
            //  if ((series.options() as ohlcSeriesOptions).volumeCandles) {
            //  // Volume candles are enabled: add number inputs for the volume moving average length and multiplier.
            //  this.addNumberInput(
            //    "Volume MA Length",
            //    (aggregatorOptions as OhlcSeriesOptions).volumeMALength ?? 20,
            //    (newValue: number) => {
            //      const options = { volumeMALength: newValue };
            //      series.applyOptions(options as Partial<OhlcSeriesOptions>);
            //      console.log(`Updated Volume MA Length to ${newValue}`);
            //      // Optionally repopulate the menu dynamically if needed.
            //    },
            //    1,
            //    100,
            //    1
            //  );
            //  this.addNumberInput(
            //    "Volume Multiplier",
            //    (aggregatorOptions as OhlcSeriesOptions).volumeMultiplier ?? 1.0,
            //    (newValue: number) => {
            //      const options = { volumeMultiplier: newValue };
            //      series.applyOptions(options as Partial<OhlcSeriesOptions>);
            //      console.log(`Updated Volume Multiplier to ${newValue}`);
            //      // Optionally repopulate the menu dynamically if needed.
            //    },
            //    0.1,
            //    10,
            //    0.1
            //  );
            //}else {
            //  // Volume candles are disabled: add a number input for chandelier size.
            // if (
            //   series instanceof ohlcSeries &&
            //   (series.options() as OhlcSeriesOptions).chandelierSize
            // ) {
            //   // series is an OhlcSeries and has a defined chandelierSize option.
            //   // Your code here...
            //
            //   this.addNumberInput(
            //     "Chandelier Size",
            //     (series.options() as OhlcSeriesOptions).chandelierSize ?? 1,
            //     (newValue: number) => {
            //       const options = { chandelierSize: newValue };
            //       series.applyOptions(options as Partial<OhlcSeriesOptions>);
            //       console.log(`Updated Chandelier Size to ${newValue}`);
            //       // Optionally repopulate the menu dynamically if needed.
            //     },
            //     1,
            //     100,
            //     1
            //   );
            // }
            //
            //
            // *************************************************************************
            // Add other options dynamically
            // Add a new input for volume opacity period if volume opacity is enabled.
            if (seriesOptions.enableVolumeOpacity) {
                this.addNumberInput("Volume Opacity Period", seriesOptions.volumeOpacityPeriod ?? 21, // Default period if not set
                (newValue) => {
                    const options = { volumeOpacityPeriod: newValue };
                    series.applyOptions(options);
                    console.log(`Updated Volume Opacity Period to ${newValue}`);
                    // Optionally, repopulate the menu if you want to reflect the change immediately.
                }, 1, // Minimum period
                10000, // Maximum period (adjust as needed)
                1 // Step value
                );
            }
            if (seriesOptions.enableVolumeOpacity) {
                // Define the allowed modes for volume opacity.
                const allowedModes = ["/ max", "> previous", "> average"];
                // Ensure the current mode is valid; default to "/ max" if not.
                const currentMode = allowedModes.includes(seriesOptions.volumeOpacityMode)
                    ? seriesOptions.volumeOpacityMode
                    : "/ max";
                // Create a select input for volume opacity mode.
                this.addSelectInput("Volume Opacity Mode", currentMode ?? '> previous', allowedModes, (newValue) => {
                    const options = { volumeOpacityMode: newValue };
                    series.applyOptions(options);
                    console.log(`Updated Volume Opacity Mode to: ${newValue}`);
                });
            }
            otherOptions.forEach((option) => {
                const optionLabel = camelToTitle(option.label); // Human-readable label
                // Skip if explicitly marked as skippable
                if (this.constraints[option.label]?.skip) {
                    return;
                }
                if (typeof option.value === "boolean") {
                    this.addCheckbox(camelToTitle(option.label), Boolean(option.value), (newValue) => {
                        const options = buildOptions(option.label, newValue);
                        series.applyOptions(options);
                        console.log(`Updated ${option.label} to ${newValue}`);
                        // Optionally, repopulate the menu dynamically if needed.
                    });
                }
                else if (typeof option.value === "string") {
                    // Add a submenu or text input for string options
                    const predefinedOptions = this.getPredefinedOptions(option.label);
                    if (predefinedOptions && predefinedOptions.length > 0) {
                        this.addMenuItem(`${optionLabel} ▸`, () => {
                            this.div.innerHTML = ""; // Clear existing menu items
                            this.addSelectInput(optionLabel, option.value, predefinedOptions, (newValue) => {
                                const options = buildOptions(option.label, newValue);
                                series.applyOptions(options);
                                console.log(`Updated ${option.label} to ${newValue}`);
                                // Repopulate the menu dynamically
                            });
                        }, false, true // Mark as a submenu
                        );
                    }
                    else {
                        this.addMenuItem(`${optionLabel} ▸`, () => {
                            this.div.innerHTML = ""; // Clear existing menu items
                            this.addTextInput(optionLabel, option.value, (newValue) => {
                                const options = buildOptions(option.label, newValue);
                                series.applyOptions(options);
                                console.log(`Updated ${option.label} to ${newValue}`);
                                // Repopulate the menu dynamically
                            });
                        }, false, true // Mark as a submenu
                        );
                    }
                }
                else if (typeof option.value === "number") {
                    // Get min and max constraints, if any.
                    const min = this.constraints[option.label]?.min;
                    const max = this.constraints[option.label]?.max;
                    // Directly add the number input for the numeric option.
                    this.addNumberInput(optionLabel, option.value, (newValue) => {
                        const options = buildOptions(option.label, newValue);
                        series.applyOptions(options);
                        console.log(`Updated ${option.label} to ${newValue}`);
                        // Optionally, repopulate the menu dynamically if needed.
                    }, min, max);
                }
                else {
                    return; // Skip unsupported data types.
                }
            }),
                // Add "Price Scale Options" Menu
                this.addMenuItem("Price Scale Options ▸", () => {
                    this.populatePriceScaleMenu(event, (series.options().priceScaleId ?? "right"), series);
                }, false, true);
            // Add the "Primitives" submenu
            this.addMenuItem("Primitives ▸", () => {
                this.populatePrimitivesMenu(_series, event);
            }, false, true);
            // 2) If all items are OHLC, add a submenu item for your “Indicators”
            this.addMenuItem("Indicators ▸", () => {
                this.populateIndicatorMenu(series, event);
            }, false, // do not hide the entire menu automatically
            true // indicates a submenu arrow “▸”
            );
            // Check if this series is part of an indicator
            if (isISeriesIndicator(series)) {
                const indicatorSeries = series;
                this.addMenuItem(`Configure ${indicatorSeries.indicator.name}`, () => {
                    this.configureIndicatorParams(indicatorSeries, event, indicatorSeries.figureCount);
                }, false);
            }
            // NEW: Add a menu item to open the DataMenu for exporting/importing series data.
            this.addMenuItem("Export/Import Series Data ▸", () => {
                if (!this.dataMenu) {
                    this.dataMenu = new DataMenu({ contextMenu: this, handler: this.handler });
                }
                // Open the DataMenu with the series as the target. 
                // Here we pass "Series" as the override type.
                this.dataMenu.openMenu(series, event, "Series");
            }, false);
            // Add remaining existing menu items
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false, false);
            this.showMenu(event);
        }
        populateDrawingMenu(event, drawing) {
            this.div.innerHTML = ""; // Clear existing menu items
            if (!this.drawingTool) {
                this.drawingTool = new DrawingTool(this.handler.chart, this.handler._seriesList[0]);
            }
            // Add drawing-specific menu items
            for (const optionName of Object.keys(drawing._options)) {
                let subMenu;
                if (optionName.toLowerCase().includes("color")) {
                    subMenu = new ColorPicker$1(this.saveDrawings, optionName);
                }
                else if (optionName === "lineStyle") {
                    subMenu = new StylePicker(this.saveDrawings);
                }
                else {
                    continue;
                }
                const onClick = (rect) => subMenu.openMenu(rect);
                this.menuItem(camelToTitle(optionName), onClick, () => {
                    document.removeEventListener("click", subMenu.closeMenu);
                    subMenu._div.style.display = "none";
                });
            }
            // 1) If this drawing is a PitchFork, add a select input for variant.
            if (drawing._type === "PitchFork") {
                // For clarity, cast or check if your PitchFork uses drawing._options.variant
                const currentVariant = drawing._options.variant || "standard";
                const allowedVariants = [
                    "standard",
                    "schiff",
                    "modifiedSchiff",
                    "inside",
                ];
                this.addSelectInput("Pitchfork Variant", currentVariant, allowedVariants, (newValue) => {
                    drawing._options.variant = newValue;
                    if (this.saveDrawings) {
                        this.saveDrawings();
                    }
                });
                // Add a number input for "value".
                this.addNumberInput("Length", drawing._options.length, (newValue) => {
                    drawing._options.length = newValue;
                    if (this.saveDrawings) {
                        this.saveDrawings();
                    }
                }, 0, // minimum value (adjust as needed)
                1000, // maximum value (adjust as needed)
                0.1 // step (adjust as needed)
                );
                // Add a menu item to populate the detailed PitchFork menu.
                this.addMenuItem("Fork Line Options ▸", () => {
                    this.populateForkLineMainMenu(event, drawing);
                }, false, true);
                // NEW: Add a menu item to open the DataMenu for exporting/importing series data.
                this.addMenuItem("Export/Import  PitchFork Data ▸", () => {
                    if (!this.dataMenu) {
                        this.dataMenu = new DataMenu({ contextMenu: this, handler: this.handler });
                    }
                    // Open the DataMenu with the series as the target. 
                    // Here we pass "Series" as the override type.
                    this.dataMenu.openMenu(drawing, event, "PitchFork");
                }, false);
            }
            if (drawing.points?.length >= 2 && drawing.points[0] && drawing.points[1]) {
                let multiPointDrawing;
                if (drawing.points?.length > 2) {
                    multiPointDrawing = drawing;
                }
                else {
                    multiPointDrawing = drawing;
                }
                if (multiPointDrawing.linkedObjects?.length) {
                    multiPointDrawing.linkedObjects.forEach((object) => {
                        if (object instanceof TrendTrace) {
                            this.addMenuItem(`${object.title} Options`, () => {
                                this.populateTrendTraceMenu(event, object);
                            }, false, true);
                        }
                        else if (object instanceof VolumeProfile) {
                            this.addMenuItem(`Volume Profile Options`, () => {
                                this.populateVolumeProfileMenu(event, object);
                            }, false, true);
                        }
                    });
                }
                // Always add the creation menu items for Trend Trace and Volume Profile
                this.addMenuItem("Trend Trace ▸", () => {
                    this._createTrendTrace(event, multiPointDrawing);
                }, false, true);
                this.addMenuItem("Volume Profile ▸", () => {
                    this._createVolumeProfile(multiPointDrawing);
                }, false, true);
            }
            const onClickDelete = () => this.drawingTool.delete(drawing);
            this.separator();
            this.menuItem("Delete Drawing", onClickDelete);
            // Optionally, add a back button or main menu option.
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false, false);
            this.showMenu(event);
        }
        populateChartMenu(event) {
            this.div.innerHTML = "";
            console.log(`Displaying Menu Options: Chart`);
            this.addResetViewOption();
            const params = this.getMouseEventParams();
            // Retrieve current pane index of the series and the array of existing panes.
            const panes = this.handler.chart.panes();
            const paneIndex = params?.paneIndex;
            const pane = this.handler.chart.panes()[paneIndex ?? 0];
            // Determine the current value (label) for the hybrid input.
            // Define the default action:
            // If the series is in the main pane (pane 0), move it to the next existing pane (if available)
            // or create a new pane if there isn’t one.
            // Otherwise (if the series is on any other pane), move it back to the main pane (pane 0).
            const defaultAction = () => {
                (paneIndex ?? 0 > 0 ? pane.moveTo(0) : pane.moveTo(panes.length - 1));
            };
            // Build the list of options:
            // For each existing pane, add an option labeled "Pane 0", "Pane 1", etc.
            // Then add an extra option for a "New Pane".
            const options = [];
            options.push({
                name: `Top`,
                action: () => {
                    pane.moveTo(0);
                    console.log(`Moved pane to top`);
                },
            });
            if (panes.length > 2 && (paneIndex ?? 0) > 1) {
                options.push({
                    name: "Up",
                    action: () => {
                        pane.moveTo((paneIndex ?? 2) - 1);
                        console.log(`Moved pane up`);
                    },
                });
            }
            if (panes.length > 2 && (paneIndex ?? 0) < panes.length - 2) {
                options.push({
                    name: "Down",
                    action: () => {
                        pane.moveTo((paneIndex ?? 0) + 1);
                        console.log(`Moved pane down`);
                    },
                });
            }
            options.push({
                name: `Bottom`,
                action: () => {
                    pane.moveTo(panes.length - 1);
                    console.log(`Moved pane to bottom`);
                },
            });
            if (panes.length > 1) {
                // Create the hybrid input using your addMenuInput helper.
                // This will render a dropdown that shows all options and executes the corresponding action on change.
                this.addMenuInput(this.div, {
                    type: "hybrid",
                    label: "Move pane",
                    sublabel: (paneIndex ?? 0 > 0 ? "Top" : "Bottom"),
                    hybridConfig: {
                        defaultAction: defaultAction,
                        options: options.map((opt) => ({
                            name: opt.name,
                            action: opt.action,
                        })),
                    },
                });
            }
            this.addMenuInput(this.div, {
                type: "hybrid",
                label: "Display Volume Profile",
                sublabel: "≖",
                hybridConfig: {
                    defaultAction: () => {
                        if (!this.volumeProfile) {
                            // Attach VolumeProfile
                            this.volumeProfile = new VolumeProfile(this.handler, defaultVolumeProfileOptions);
                            this.handler.series.attachPrimitive(this.volumeProfile, "Visible Range Volume Profile", false, true);
                            console.log("[ChartMenu] Attached Volume Profile.");
                        }
                        else {
                            // Detach VolumeProfile
                            this.handler.series.detachPrimitive(this.volumeProfile);
                            this.volumeProfile = null;
                            console.log("[ChartMenu] Detached Volume Profile.");
                        }
                    },
                    options: [
                        {
                            name: "Options",
                            action: () => {
                                if (this.volumeProfile) {
                                    this.populateVolumeProfileMenu(event, this.volumeProfile);
                                }
                            },
                        },
                    ],
                },
            });
            this.addMenuItem(" ~ Series List", () => {
                this.populateSeriesListMenu(event, false, (destinationSeries) => {
                    this.populateSeriesMenu(destinationSeries, event);
                });
            }, false, true);
            //// Layout menu
            //this.addMenuItem(
            //  "⌯ Layout Options        ",
            //  () => this.populateLayoutMenu(event),
            //  false,
            //  true
            //);
            //this.addMenuItem(
            //  "⌗ Grid Options          ",
            //  () => this.populateGridMenu(event),
            //  false,
            //  true
            //);
            //this.addMenuItem(
            //  "⊹ Crosshair Options     ",
            //  () => this.populateCrosshairOptionsMenu(event),
            //  false,
            //  true
            //);
            //this.addMenuItem(
            //  "ⴵ Time Scale Options    ",
            //  () => this.populateTimeScaleMenu(event),
            //  false,
            //  true
            //);
            //this.addMenuItem(
            //  "$ Price Scale Options   ",
            //  () => this.populatePriceScaleMenu(event, "right"),
            //  false,
            //  true
            //);
            // ***** NEW: Add a menu item for exporting/importing the handler's state *****
            //this.addMenuItem(
            //  "Export/Import Chart Config ▸",
            //  () => {
            //    if (!this.dataMenu) {
            //      this.dataMenu = new DataMenu({ contextMenu: this, handler: this.handler });
            //    }
            //
            //    this.dataMenu.openMenu(this.handler, event, "Handler");
            //  },
            //  false
            //);
            this.addMenuItem("Settings...", () => {
                this.SettingsModal.open();
            }, true);
            this.showMenu(event);
        }
        populateLayoutMenu(event) {
            // Clear the menu
            this.div.innerHTML = "";
            // Text Color Option
            const textColorOption = {
                name: "Text Color",
                valuePath: "layout.textColor",
            };
            const initialTextColor = this.getCurrentOptionValue(textColorOption.valuePath) ||
                "#000000";
            this.addColorPickerMenuItem(camelToTitle(textColorOption.name), initialTextColor, textColorOption.valuePath, this.handler.chart);
            // Background Color Options Based on Current Background Type
            const currentBackground = this.handler.chart.options().layout?.background;
            if (isSolidColor(currentBackground)) {
                // Solid Background Color
                this.addColorPickerMenuItem("Background Color", currentBackground.color || "#FFFFFF", "layout.background.color", this.handler.chart);
            }
            else if (isVerticalGradientColor(currentBackground)) {
                // Gradient Background Colors
                this.addColorPickerMenuItem("Top Color", currentBackground.topColor || "rgba(255,0,0,0.33)", "layout.background.topColor", this.handler.chart);
                this.addColorPickerMenuItem("Bottom Color", currentBackground.bottomColor || "rgba(0,255,0,0.33)", "layout.background.bottomColor", this.handler.chart);
            }
            else {
                console.warn("Unknown background type; no color options displayed.");
            }
            // Switch Background Type Option
            this.addMenuItem("Switch Background Type", () => {
                this.toggleBackgroundType(event);
            }, false, true);
            // Back to Main Menu Option
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false, false);
            // Display the updated menu
            this.showMenu(event);
        }
        toggleBackgroundType(event) {
            const currentBackground = this.handler.chart.options().layout?.background;
            let updatedBackground;
            // Toggle between Solid and Vertical Gradient
            if (isSolidColor(currentBackground)) {
                updatedBackground = {
                    type: lightweightCharts.ColorType.VerticalGradient,
                    topColor: "rgba(255,0,0,0.2)",
                    bottomColor: "rgba(0,255,0,0.2)",
                };
            }
            else {
                updatedBackground = {
                    type: lightweightCharts.ColorType.Solid,
                    color: "#000000",
                };
            }
            // Apply the updated background type
            this.handler.chart.applyOptions({
                layout: { background: updatedBackground },
            });
            // Repopulate the Layout Menu with the new background type's options
            this.populateLayoutMenu(event);
        }
        populateWidthMenu(event, series) {
            this.div.innerHTML = ""; // Clear current menu
            // Use the stored currentWidthOptions array
            this.currentWidthOptions.forEach((option) => {
                if (typeof option.value === "number") {
                    this.addNumberInput(camelToTitle(option.label), option.value, (newValue) => {
                        const options = buildOptions(option.name, newValue);
                        series.applyOptions(options);
                        console.log(`Updated ${option.label} to ${newValue}`);
                    }, option.min, option.max);
                }
            });
            this.addMenuItem("⤝ Back to Series Options", () => {
                this.populateSeriesMenu(series, event);
            }, false, false);
            this.showMenu(event);
        }
        populatePrimitivesMenu(series, event) {
            this.div.innerHTML = "";
            console.log(`Showing Primitive Menu `);
            const primitives = series.primitives;
            this.addMenuItem("Fill Area Between", () => {
                this.startFillAreaBetween(event, series); // Define the method below
            }, false, false);
            // Access the primitives
            // Debugging output
            console.log("Primitives:", primitives);
            // Add "Customize Fill Area" option if `FillArea` is present
            const hasFillArea = primitives?.FillArea ?? primitives?.pt;
            if (primitives["FillArea"]) {
                this.addMenuItem("Customize Fill Area", () => {
                    this.customizeFillAreaOptions(event, hasFillArea);
                }, false, true);
            }
            this.addMenuItem("Create TrendTrace", () => {
                this._createTrendTrace(event, this.recentDrawing);
            }, false, false);
            // Debugging output
            console.log("Primitives:", primitives);
            // Add "Customize TrendTrace" option if `TrendTrace` is already present
            if (primitives["TrendTrace"]) {
                this.addMenuItem("Customize TrendTrace", () => {
                    this.populateTrendTraceMenu(event, primitives["TrendTrace"]);
                }, false, true);
            }
            //this.addMenuItem(
            //  "Stop Loss / Take Profit ▸",
            //  () => {
            //      // If not attached yet, attach it
            //      if (!primitives["StopLossTakeProfit"]) {
            //          const sltp = new StopLossTakeProfit(
            //              this.handler.chart,
            //              series,
            //              {
            //                  color: '#444',
            //                  hoverColor: '#888',
            //                  backgroundColorStop: 'rgba(255,0,0,0.3)',
            //                  backgroundColorTarget: 'rgba(0,255,0,0.3)',
            //                  extendRightBars: 15,
            //              }
            //          );
            //          primitives["StopLossTakeProfit"] = sltp;
            //          console.log("StopLossTakeProfit attached");
            //      } else {
            //          console.log("StopLossTakeProfit already exists, customizing...");
            //          // If you want to open a submenu to customize,
            //          // e.g., setStopLoss, setTakeProfit, etc.
            //      }
            //  },
            //  false,
            //  true
            //);//
            // Add a Back option
            this.addMenuItem("⤝ Back", () => {
                this.populateSeriesMenu(series, event);
            }, false, false);
            this.showMenu(event);
        }
        populateStyleMenu(event, series) {
            this.div.innerHTML = ""; // Clear the current menu
            this.currentStyleOptions.forEach((option) => {
                const predefinedOptions = this.getPredefinedOptions(option.name);
                if (predefinedOptions) {
                    this.addSelectInput(camelToTitle(option.name), option.value.toString(), predefinedOptions, (newValue) => {
                        let finalValue = newValue;
                        // If the option name indicates it's a line style, map string => numeric
                        if (option.name.toLowerCase().includes("style")) {
                            const lineStyleMap = {
                                Solid: 0,
                                Dotted: 1,
                                Dashed: 2,
                                "Large Dashed": 3,
                                "Sparse Dotted": 4,
                            };
                            finalValue = lineStyleMap[newValue] ?? 0; // fallback to Solid (0)
                        }
                        // If the option name indicates it's a line type, map string => numeric
                        else if (option.name.toLowerCase().includes("linetype")) {
                            const lineTypeMap = {
                                Simple: 0,
                                WithSteps: 1,
                                Curved: 2,
                            };
                            finalValue = lineTypeMap[newValue] ?? 0; // fallback to Simple (0)
                        }
                        // Build the updated options object
                        const updatedOptions = buildOptions(option.name, finalValue);
                        series.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to "${newValue}" =>`, finalValue);
                        // --- Update the Legend Symbol if it's a lineStyle change on a Line series ---
                        if (option.name.toLowerCase().includes("style") &&
                            series.seriesType() === "Line") {
                            // Convert the numeric finalValue into a symbol
                            const lineStyleNumeric = finalValue;
                            const symbol = (() => {
                                switch (lineStyleNumeric) {
                                    case 0:
                                        return "―"; // Solid
                                    case 1:
                                        return "··"; // Dotted
                                    case 2:
                                        return "--"; // Dashed
                                    case 3:
                                        return "- -"; // Large Dashed
                                    case 4:
                                        return "· ·"; // Sparse Dotted
                                    default:
                                        return "~"; // Fallback
                                }
                            })();
                            // Find the corresponding legend item in the legend._lines array
                            const legendItem = this.handler.legend._lines.find((item) => item.series === series);
                            if (legendItem) {
                                legendItem.legendSymbol = [symbol];
                                console.log(`Updated legend symbol for lineStyle(${lineStyleNumeric}) to: ${symbol}`);
                            }
                        }
                    });
                }
                else {
                    console.warn(`No predefined options found for "${option.name}".`);
                }
            });
            // Add a Back option
            this.addMenuItem("⤝ Back", () => {
                this.populateSeriesMenu(series, event);
            }, false, false);
            this.showMenu(event);
        }
        populateCloneSeriesMenu(series, event) {
            this.div.innerHTML = "";
            // Fetch the current data from the series
            const data = series.data();
            // Basic clone targets for any data
            const cloneOptions = ["Line", "Histogram", "Area"];
            if (data && data.length > 0) {
                // Check if any bar is recognized as OHLC
                const hasOHLC = data.some((bar) => isOHLCData(bar));
                // If so, we push "Bar" and "Candlestick" to the menu
                if (hasOHLC) {
                    cloneOptions.push("Bar", "Candlestick", "Ohlc");
                }
            }
            // Generate the menu items for each clone option
            cloneOptions.forEach((type) => {
                this.addMenuItem(`Clone as ${type}`, () => {
                    const clonedSeries = cloneSeriesAsType(series, this.handler, type, this.handler.defaultsManager.defaults.get(type.toLowerCase()) || {});
                    if (clonedSeries) {
                        console.log(`Cloned series as ${type}:`, clonedSeries);
                    }
                    else {
                        console.warn(`Failed to clone as ${type}.`);
                    }
                }, false);
            });
            // Back to Series Options
            this.addMenuItem("⤝ Series Options", () => {
                this.populateSeriesMenu(series, event);
            }, false, false);
            this.showMenu(event);
        }
        addTextInput(label, defaultValue, onChange) {
            const container = document.createElement("div");
            container.classList.add("context-menu-item");
            container.style.display = "flex";
            container.style.alignItems = "center";
            container.style.justifyContent = "space-between";
            const labelElem = document.createElement("label");
            labelElem.innerText = label;
            labelElem.htmlFor = `${label.toLowerCase()}-input`;
            labelElem.style.marginRight = "8px";
            labelElem.style.flex = "1"; // Ensure the label takes up available space
            container.appendChild(labelElem);
            const input = document.createElement("input");
            input.type = "text";
            input.value = defaultValue;
            input.id = `${label.toLowerCase()}-input`;
            input.style.flex = "0 0 100px"; // Fixed width for input
            input.style.marginLeft = "auto"; // Right-align
            input.style.backgroundColor = "#2b2b2b"; // Darker gray background
            input.style.color = "#fff"; // White text color for contrast
            input.style.border = "1px solid #444"; // Subtle border
            input.style.borderRadius = "4px";
            input.style.cursor = "pointer";
            input.addEventListener("input", (event) => {
                const target = event.target;
                onChange(target.value);
            });
            container.appendChild(input);
            this.div.appendChild(container);
            return container;
        }
        populateColorOptionsMenu(colorOptions, series, event) {
            this.div.innerHTML = "";
            colorOptions.forEach((option) => {
                this.addColorPickerMenuItem(camelToTitle(option.label), option.value, option.label, series);
            });
            this.addMenuItem("⤝ Back to Series Options", () => {
                this.populateSeriesMenu(series, event);
            }, false, false);
            this.showMenu(event);
        }
        populateVisibilityMenu(event, series) {
            this.div.innerHTML = "";
            const seriesOptions = series.options();
            const visibilityOptionNames = ["visible", "crosshairMarkerVisible", "priceLineVisible"];
            visibilityOptionNames.forEach((optionName) => {
                const optionValue = seriesOptions[optionName];
                if (typeof optionValue === "boolean") {
                    this.addCheckbox(camelToTitle(optionName), optionValue, (newValue) => {
                        const options = buildOptions(optionName, newValue);
                        series.applyOptions(options);
                        console.log(`Toggled ${optionName} to ${newValue}`);
                    });
                }
            });
            this.addMenuItem("⤝ Back to Series Options", () => {
                this.populateSeriesMenu(series, event);
            }, false, false);
            this.showMenu(event);
        }
        populateBackgroundTypeMenu(event) {
            this.div.innerHTML = "";
            const backgroundOptions = [
                {
                    text: "Solid",
                    action: () => this.setBackgroundType(event, lightweightCharts.ColorType.Solid),
                },
                {
                    text: "Vertical Gradient",
                    action: () => this.setBackgroundType(event, lightweightCharts.ColorType.VerticalGradient),
                },
            ];
            backgroundOptions.forEach((option) => {
                // Use shouldHide = false if you want to move to another menu without closing
                this.addMenuItem(option.text, option.action, false, // don't hide immediately if you want subsequent menus
                false, 1);
            });
            // Back to Chart Menu
            this.addMenuItem("⤝ Chart Menu", () => {
                this.populateChartMenu(event);
            }, false);
            this.showMenu(event);
        }
        populateGradientBackgroundMenuInline(event, gradientBackground) {
            this.div.innerHTML = "";
            this.addColorPickerMenuItem(camelToTitle("Top Color"), gradientBackground.topColor, "layout.background.topColor", this.handler.chart);
            this.addColorPickerMenuItem(camelToTitle("Bottom Color"), gradientBackground.bottomColor, "layout.background.bottomColor", this.handler.chart);
            // Back to Background Type Menu
            this.addMenuItem("⤝ Background Type & Colors", () => {
                this.populateBackgroundTypeMenu(event);
            }, false);
            this.showMenu(event);
        }
        populateGridMenu(event) {
            this.div.innerHTML = ""; // Clear the menu
            // Configuration for grid options
            const gridOptions = [
                {
                    name: "Vertical Line Color",
                    type: "color",
                    valuePath: "grid.vertLines.color",
                    defaultValue: "#D6DCDE",
                },
                {
                    name: "Horizontal Line Color",
                    type: "color",
                    valuePath: "grid.horzLines.color",
                    defaultValue: "#D6DCDE",
                },
                {
                    name: "Vertical Line Style",
                    type: "select",
                    valuePath: "grid.vertLines.style",
                    options: ["Solid", "Dashed", "Dotted", "LargeDashed"],
                    defaultValue: "Solid",
                },
                {
                    name: "Horizontal Line Style",
                    type: "select",
                    valuePath: "grid.horzLines.style",
                    options: ["Solid", "Dashed", "Dotted", "LargeDashed"],
                    defaultValue: "Solid",
                },
                {
                    name: "Show Vertical Lines",
                    type: "boolean",
                    valuePath: "grid.vertLines.visible",
                    defaultValue: true,
                },
                {
                    name: "Show Horizontal Lines",
                    type: "boolean",
                    valuePath: "grid.horzLines.visible",
                    defaultValue: true,
                },
            ];
            // Iterate over the grid options and dynamically add inputs
            gridOptions.forEach((option) => {
                const currentValue = this.getCurrentOptionValue(option.valuePath) ?? option.defaultValue;
                if (option.type === "color") {
                    this.addColorPickerMenuItem(camelToTitle(option.name), currentValue, option.valuePath, this.handler.chart);
                }
                else if (option.type === "select") {
                    this.addSelectInput(camelToTitle(option.name), currentValue, option.options, (newValue) => {
                        const selectedIndex = option.options.indexOf(newValue);
                        const updatedOptions = buildOptions(option.valuePath, selectedIndex);
                        this.handler.chart.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to: ${newValue}`);
                    });
                }
                else if (option.type === "boolean") {
                    this.addCheckbox(camelToTitle(option.name), currentValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        this.handler.chart.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to: ${newValue}`);
                    });
                }
            });
            // Back to Main Menu
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false);
            this.showMenu(event); // Display the updated menu
        }
        populateBackgroundMenu(event) {
            this.div.innerHTML = "";
            this.addMenuItem("Type & Colors", () => {
                this.populateBackgroundTypeMenu(event);
            }, false, true);
            this.addMenuItem("Options", () => {
                this.populateBackgroundOptionsMenu(event);
            }, false, true);
            this.addMenuItem("⤝ Layout Options", () => {
                this.populateLayoutMenu(event);
            }, false);
            this.showMenu(event);
        }
        populateBackgroundOptionsMenu(event) {
            this.div.innerHTML = "";
            const backgroundOptions = [
                { name: "Background Color", valuePath: "layout.background.color" },
                { name: "Background Top Color", valuePath: "layout.background.topColor" },
                {
                    name: "Background Bottom Color",
                    valuePath: "layout.background.bottomColor",
                },
            ];
            backgroundOptions.forEach((option) => {
                const initialColor = this.getCurrentOptionValue(option.valuePath) || "#FFFFFF";
                this.addColorPickerMenuItem(camelToTitle(option.name), initialColor, option.valuePath, this.handler.chart);
            });
            // Back to Background Menu
            this.addMenuItem("⤝ Background", () => {
                this.populateBackgroundMenu(event);
            }, false);
            this.showMenu(event);
        }
        populateSolidBackgroundMenuInline(event, solidBackground) {
            this.div.innerHTML = "";
            this.addColorPickerMenuItem(camelToTitle("Background Color"), solidBackground.color, "layout.background.color", this.handler.chart);
            // Back to Type & Colors
            this.addMenuItem("⤝ Type & Colors", () => {
                this.populateBackgroundTypeMenu(event);
            }, false);
            this.showMenu(event);
        }
        populateCrosshairOptionsMenu(event) {
            this.div.innerHTML = "";
            const crosshairOptions = [
                { name: "Line Color", valuePath: "crosshair.lineColor" },
                { name: "Vertical Line Color", valuePath: "crosshair.vertLine.color" },
                { name: "Horizontal Line Color", valuePath: "crosshair.horzLine.color" },
            ];
            crosshairOptions.forEach((option) => {
                const initialColor = this.getCurrentOptionValue(option.valuePath) || "#000000";
                this.addColorPickerMenuItem(camelToTitle(option.name), initialColor, option.valuePath, this.handler.chart);
            });
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false);
            this.showMenu(event);
        }
        populateTimeScaleMenu(event) {
            this.div.innerHTML = ""; // Clear current menu
            // TimeScaleOptions configuration
            const timeScaleOptions = [
                {
                    name: "Right Offset",
                    type: "number",
                    valuePath: "timeScale.rightOffset",
                    min: 0,
                    max: 100,
                },
                {
                    name: "Bar Spacing",
                    type: "number",
                    valuePath: "timeScale.barSpacing",
                    min: 1,
                    max: 100,
                },
                {
                    name: "Min Bar Spacing",
                    type: "number",
                    valuePath: "timeScale.minBarSpacing",
                    min: 0.1,
                    max: 10,
                    step: 0.1,
                },
                {
                    name: "Fix Left Edge",
                    type: "boolean",
                    valuePath: "timeScale.fixLeftEdge",
                },
                {
                    name: "Fix Right Edge",
                    type: "boolean",
                    valuePath: "timeScale.fixRightEdge",
                },
                {
                    name: "Lock Visible Range on Resize",
                    type: "boolean",
                    valuePath: "timeScale.lockVisibleTimeRangeOnResize",
                },
                {
                    name: "Visible",
                    type: "boolean",
                    valuePath: "timeScale.visible",
                },
                {
                    name: "Border Visible",
                    type: "boolean",
                    valuePath: "timeScale.borderVisible",
                },
                {
                    name: "Border Color",
                    type: "color",
                    valuePath: "timeScale.borderColor",
                },
            ];
            // Iterate over options and dynamically add inputs based on type
            timeScaleOptions.forEach((option) => {
                if (option.type === "number") {
                    const currentValue = this.getCurrentOptionValue(option.valuePath);
                    this.addNumberInput(camelToTitle(option.name), currentValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        this.handler.chart.applyOptions(updatedOptions);
                        console.log(`Updated TimeScale ${option.name} to: ${newValue}`);
                    }, option.min, option.max);
                }
                else if (option.type === "boolean") {
                    const currentValue = this.getCurrentOptionValue(option.valuePath);
                    this.addCheckbox(camelToTitle(option.name), currentValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        this.handler.chart.applyOptions(updatedOptions);
                        console.log(`Updated TimeScale ${option.name} to: ${newValue}`);
                    });
                }
                else if (option.type === "color") {
                    const currentColor = this.getCurrentOptionValue(option.valuePath) ||
                        "#000000";
                    this.addColorPickerMenuItem(camelToTitle(option.name), currentColor, option.valuePath, this.handler.chart);
                }
            });
            // Back to Main Menu
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false);
            this.showMenu(event); // Display the updated menu
        }
        populatePriceScaleMenu(event, priceScaleId = "right", series) {
            this.div.innerHTML = ""; // Clear current menu
            if (series) {
                this.addMenuInput(this.div, {
                    type: "hybrid",
                    label: "Price Scale",
                    value: series.options().priceScaleId || "",
                    onChange: (newValue) => {
                        series.applyOptions({ priceScaleId: newValue });
                        console.log(`Updated price scale to: ${newValue}`);
                    },
                    hybridConfig: {
                        defaultAction: () => {
                            const newPriceScaleId = series.options().priceScaleId === "left" ? "right" : "left";
                            series.applyOptions({ priceScaleId: newPriceScaleId });
                            console.log(`Series price scale switched to: ${newPriceScaleId}`);
                        },
                        options: [
                            {
                                name: "Left",
                                action: () => series.applyOptions({ priceScaleId: "left" }),
                            },
                            {
                                name: "Right",
                                action: () => series.applyOptions({ priceScaleId: "right" }),
                            },
                            {
                                name: "Volume",
                                action: () => series.applyOptions({ priceScaleId: "volume_scale" }),
                            },
                            {
                                name: "Custom",
                                action: () => {
                                    const inputContainer = document.createElement("div");
                                    const inputField = document.createElement("input");
                                    inputField.type = "text";
                                    inputField.placeholder = "Enter custom scale ID";
                                    inputField.value = series.options().priceScaleId || "";
                                    inputField.addEventListener("change", () => {
                                        series.applyOptions({ priceScaleId: inputField.value });
                                        console.log(`Custom scale ID set to: ${inputField.value}`);
                                    });
                                    inputContainer.appendChild(inputField);
                                    this.div.appendChild(inputContainer);
                                },
                            },
                        ],
                    },
                });
            }
            else {
                // Dropdown for Price Scale Mode
                const currentMode = this.handler.chart.priceScale(priceScaleId).options().mode ??
                    lightweightCharts.PriceScaleMode.Normal;
                const modeOptions = [
                    { label: "Normal", value: lightweightCharts.PriceScaleMode.Normal },
                    { label: "Logarithmic", value: lightweightCharts.PriceScaleMode.Logarithmic },
                    { label: "Percentage", value: lightweightCharts.PriceScaleMode.Percentage },
                    { label: "Indexed To 100", value: lightweightCharts.PriceScaleMode.IndexedTo100 },
                ];
                const modeLabels = modeOptions.map((opt) => opt.label);
                this.addSelectInput("Price Scale Mode", modeOptions.find((opt) => opt.value === currentMode)?.label || "Normal", // Current value label
                modeLabels, // Dropdown options (labels)
                (newLabel) => {
                    const selectedOption = modeOptions.find((opt) => opt.label === newLabel);
                    if (selectedOption) {
                        this.applyPriceScaleOptions(priceScaleId, {
                            mode: selectedOption.value,
                        });
                        console.log(`Price scale (${priceScaleId}) mode set to: ${newLabel}`);
                        this.populatePriceScaleMenu(event, priceScaleId, series); // Refresh the menu
                    }
                });
                // Additional Price Scale Options
                const options = this.handler.chart.priceScale(priceScaleId).options();
                const additionalOptions = [
                    {
                        name: "Auto Scale",
                        value: options.autoScale ?? true,
                        action: (newValue) => {
                            this.applyPriceScaleOptions(priceScaleId, { autoScale: newValue });
                            console.log(`Price scale (${priceScaleId}) autoScale set to: ${newValue}`);
                        },
                    },
                    {
                        name: "Invert Scale",
                        value: options.invertScale ?? false,
                        action: (newValue) => {
                            this.applyPriceScaleOptions(priceScaleId, {
                                invertScale: newValue,
                            });
                            console.log(`Price scale (${priceScaleId}) invertScale set to: ${newValue}`);
                        },
                    },
                    {
                        name: "Align Labels",
                        value: options.alignLabels ?? true,
                        action: (newValue) => {
                            this.applyPriceScaleOptions(priceScaleId, {
                                alignLabels: newValue,
                            });
                            console.log(`Price scale (${priceScaleId}) alignLabels set to: ${newValue}`);
                        },
                    },
                    {
                        name: "Border Visible",
                        value: options.borderVisible ?? true,
                        action: (newValue) => {
                            this.applyPriceScaleOptions(priceScaleId, {
                                borderVisible: newValue,
                            });
                            console.log(`Price scale (${priceScaleId}) borderVisible set to: ${newValue}`);
                        },
                    },
                    {
                        name: "Ticks Visible",
                        value: options.ticksVisible ?? false,
                        action: (newValue) => {
                            this.applyPriceScaleOptions(priceScaleId, {
                                ticksVisible: newValue,
                            });
                            console.log(`Price scale (${priceScaleId}) ticksVisible set to: ${newValue}`);
                        },
                    },
                ];
                additionalOptions.forEach((opt) => {
                    this.addMenuItem(`${opt.name}: ${opt.value ? "On" : "Off"}`, () => {
                        const newValue = !opt.value; // Toggle the current value
                        opt.action(newValue);
                        this.populatePriceScaleMenu(event, priceScaleId, series); // Refresh the menu
                    }, false, false);
                });
            }
            // Back to Main Menu
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false);
            this.showMenu(event); // Display the updated menu
        }
        applyPriceScaleOptions(priceScaleId, options) {
            // Access the price scale from the chart using its ID
            const priceScale = this.handler.chart.priceScale(priceScaleId);
            if (!priceScale) {
                console.warn(`Price scale with ID "${priceScaleId}" not found.`);
                return;
            }
            // Apply the provided options to the price scale
            priceScale.applyOptions(options);
            console.log(`Applied options to price scale "${priceScaleId}":`, options);
        }
        getCurrentOptionValue(optionPath) {
            const keys = optionPath.split(".");
            let options = this.handler.chart.options();
            for (const key of keys) {
                if (options && key in options) {
                    options = options[key];
                }
                else {
                    console.warn(`Option path "${optionPath}" is invalid.`);
                    return null;
                }
            }
            return options;
        }
        setBackgroundType(event, type) {
            const currentBackground = this.handler.chart.options().layout?.background;
            let updatedBackground;
            if (type === lightweightCharts.ColorType.Solid) {
                updatedBackground = isSolidColor(currentBackground)
                    ? { type: lightweightCharts.ColorType.Solid, color: currentBackground.color }
                    : { type: lightweightCharts.ColorType.Solid, color: "#000000" };
            }
            else if (type === lightweightCharts.ColorType.VerticalGradient) {
                updatedBackground = isVerticalGradientColor(currentBackground)
                    ? {
                        type: lightweightCharts.ColorType.VerticalGradient,
                        topColor: currentBackground.topColor,
                        bottomColor: currentBackground.bottomColor,
                    }
                    : {
                        type: lightweightCharts.ColorType.VerticalGradient,
                        topColor: "rgba(255,0,0,.2)",
                        bottomColor: "rgba(0,255,0,.2)",
                    };
            }
            else {
                console.error(`Unsupported ColorType: ${type}`);
                return;
            }
            this.handler.chart.applyOptions({
                layout: {
                    background: updatedBackground,
                },
            });
            if (type === lightweightCharts.ColorType.Solid) {
                this.populateSolidBackgroundMenuInline(event, updatedBackground);
            }
            else if (type === lightweightCharts.ColorType.VerticalGradient) {
                this.populateGradientBackgroundMenuInline(event, updatedBackground);
            }
        }
        startFillAreaBetween(event, originSeries) {
            console.log("Fill Area Between started. Origin series set:", originSeries.options().title);
            // Ensure the series is decorated
            // Populate the Series List Menu
            this.populateSeriesListMenu(event, false, (destinationSeries) => {
                if (destinationSeries && destinationSeries !== originSeries) {
                    console.log("Destination series selected:", destinationSeries.options().title);
                    // Ensure the destination series is also decorated
                    // Instantiate and attach the FillArea
                    originSeries.primitives["FillArea"] = new FillArea(originSeries, destinationSeries, {
                        ...defaultFillAreaOptions,
                    });
                    originSeries.attachPrimitive(originSeries.primitives["FillArea"], `Fill Area ⥵ ${destinationSeries.options().title}`, false, true);
                    // Attach the FillArea as a primitive
                    //if (!originSeries.primitives['FillArea']) {
                    //  originSeries.attachPrimitive(originSeries.primitives["FillArea"])
                    //}
                    console.log("Fill Area successfully added between selected series.");
                    alert(`Fill Area added between ${originSeries.options().title} and ${destinationSeries.options().title}`);
                }
                else {
                    alert("Invalid selection. Please choose a different series as the destination.");
                }
            });
        }
        getPredefinedOptions(label) {
            const predefined = {
                "Series Type": ["Line", "Histogram", "Area", "Bar", "Candlestick"],
                "Line Style": [
                    "Solid",
                    "Dotted",
                    "Dashed",
                    "Large Dashed",
                    "Sparse Dotted",
                ],
                "Line Type": ["Simple", "WithSteps", "Curved"],
                seriesType: ["Line", "Histogram", "Area", "Bar", "Candlestick"],
                lineStyle: ["Solid", "Dotted", "Dashed", "Large Dashed", "Sparse Dotted"],
                "Price Line Style": [
                    "Solid",
                    "Dotted",
                    "Dashed",
                    "Large Dashed",
                    "Sparse Dotted",
                ],
                lineType: ["Simple", "WithSteps", "Curved"],
                Shape: ["Rectangle", "Rounded", "Ellipse", "Arrow", "3d", "Polygon", "Bar", "Slanted"],
                "Candle Shape": [
                    "Rectangle",
                    "Rounded",
                    "Ellipse",
                    "Arrow",
                    "3d",
                    "Polygon",
                    "Bar",
                    "Slanted"
                ],
            };
            return predefined[camelToTitle(label)] || null;
        }
        /**
         * Populates the Series List Menu for selecting the destination series.
         * @param onSelect Callback when a series is selected.
         */
        populateSeriesListMenu(event, hideMenu, onSelect) {
            this.div.innerHTML = ""; // Clear the current menu
            // 1) Gather all series from your `handler.seriesMap`.
            const mappedSeries = Array.from(this.handler.seriesMap.entries()).map(([seriesName, series]) => ({
                label: seriesName,
                value: series,
            }));
            let seriesOptions = [...mappedSeries];
            if (this.handler.volumeSeries) {
                const volumeSeries = {
                    label: "Volume",
                    value: this.handler.volumeSeries,
                };
                seriesOptions = [volumeSeries, ...seriesOptions];
            }
            console.log(seriesOptions);
            // 3) Display series in the menu
            seriesOptions.forEach((option) => {
                this.addMenuItem(option.label, () => {
                    onSelect(option.value);
                    if (hideMenu) {
                        this.hideMenu();
                    }
                    else {
                        this.div.innerHTML = ""; // Clear the current menu
                        this.populateSeriesMenu(option.value, event); // Open the series menu
                        this.showMenu(event);
                    }
                }, false, true);
            });
            // Add a "Cancel" option to go back or exit
            this.addMenuItem("Cancel", () => {
                console.log("Operation canceled.");
                this.hideMenu();
            });
            // Back to Main Menu
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false);
            // Show the menu at the current mouse position
            this.showMenu(event);
        }
        customizeFillAreaOptions(event, FillArea) {
            this.div.innerHTML = ""; // Clear current menu
            if (isFillArea(FillArea)) {
                // Add color pickers for each color-related option
                this.addColorPickerMenuItem("Origin > Destination", FillArea.options.originColor, "originColor", FillArea);
                this.addColorPickerMenuItem("Origin < Destination", FillArea.options.destinationColor, "destinationColor", FillArea);
            }
            // Back to main menu
            this.addMenuItem("⤝ Back to Main Menu", () => this.populateChartMenu(event), false);
            this.showMenu(event);
        }
        addResetViewOption() {
            const resetMenuItem = this.addMenuInput(this.div, {
                type: "hybrid",
                label: "∟ Reset",
                sublabel: "View",
                hybridConfig: {
                    defaultAction: () => {
                        this.handler.chart.timeScale().resetTimeScale();
                        this.handler.chart.timeScale().fitContent();
                    },
                    options: [
                        {
                            name: "⥗ Time Scale",
                            action: () => this.handler.chart.timeScale().resetTimeScale(),
                        },
                        {
                            name: "⥘ Price Scale",
                            action: () => this.handler.chart.timeScale().fitContent,
                        },
                    ],
                },
            });
            this.div.appendChild(resetMenuItem);
        }
        /**
         * Creates a TrendTrace for the given series.
         *
         * @param series - The series to which the TrendTrace will be attached.
         */
        _createTrendTrace(event, drawing) {
            // Populate the Series List Menu
            this.populateSeriesListMenu(event, false, (series) => {
                let offset;
                if (drawing._type === "PitchFork" && series && drawing.p1 && drawing.p2) {
                    console.log("Series selected:", series.options().title);
                    const options = drawing._options;
                    offset =
                        (options.length ?? 1) *
                            Math.abs(drawing.p2.logical - drawing.p1.logical);
                }
                if (series && drawing.p1 && drawing.p2) {
                    console.log("Series selected:", series.options().title);
                    series.primitives["TrendTrace"] = new TrendTrace(this.handler, series, drawing.p1, drawing.p2, defaultSequenceOptions, offset);
                    series.attachPrimitive(series.primitives["TrendTrace"], `${drawing.p1?.logical} ⥵ ${drawing.p2?.logical}`, false, true);
                    console.log("Trend Trace successfully created for selected series.");
                    drawing.linkedObjects.push(series.primitives["TrendTrace"]);
                }
            });
        }
        _createVolumeProfile(drawing) {
            const series = this.handler.series ?? this.handler._seriesList[0];
            if (series && drawing.p1 && drawing.p2) {
                console.log("Series selected:", series.options().title);
                // Create the VolumeProfile instance in fixed range mode.
                const volumeProfile = new VolumeProfile(this.handler, defaultVolumeProfileOptions, drawing.p1, drawing.p2);
                // Attach the volume profile primitive to the selected series.
                series.attachPrimitive(volumeProfile, "Volume Profile", false, true);
                console.log("Volume Profile successfully created for selected series.");
                drawing.linkedObjects.push(volumeProfile);
            }
        }
        /**
         * Main entry point for the trend trace menu.
         *
         * @param event - The mouse event that triggered the menu.
         * @param trendTrace - The trend trace instance.
         */
        populateTrendTraceMenu(event, trendTrace) {
            this.div.innerHTML = ""; // Clear the menu
            this.addMenuItem("Color Options ▸", () => this.populateTrendColorMenu(event, trendTrace), false, true);
            this.addMenuItem("General Options ▸", () => this.populateTrendOptionsMenu(event, trendTrace), false, true);
            // Use the new DataExportMenu to open the export/import dialog.
            this.addMenuItem("Export/Import Data ▸", () => {
                if (!this.dataMenu) {
                    this.dataMenu = new DataMenu({ contextMenu: this, handler: this.handler });
                }
                this.dataMenu.openMenu(trendTrace, event, "Trend Trace");
            }, false);
            this.addMenuItem("⤝ Main Menu", () => this.populateChartMenu(event), false);
            this.showMenu(event);
        }
        populateTrendColorMenu(event, trendTrace) {
            this.div.innerHTML = ""; // Clear the menu
            const currentOptions = trendTrace.getOptions();
            const sequence = trendTrace._sequence;
            const ohlcData = sequence.data;
            const isOHLC = ohlcData.every((point) => point.open !== undefined &&
                point.high !== undefined &&
                point.low !== undefined &&
                point.close !== undefined);
            // Build a list of color options based on the data type.
            const colorOptions = [];
            if (isOHLC) {
                colorOptions.push({
                    name: "Up Color",
                    type: "color",
                    valuePath: "upColor",
                    defaultValue: currentOptions.upColor ?? "rgba(0,255,0,.25)",
                }, {
                    name: "Down Color",
                    type: "color",
                    valuePath: "downColor",
                    defaultValue: currentOptions.downColor ?? "rgba(255,0,0,.25)",
                }, {
                    name: "Border Up Color",
                    type: "color",
                    valuePath: "borderUpColor",
                    defaultValue: currentOptions.borderUpColor ?? "#1c9d1c",
                }, {
                    name: "Border Down Color",
                    type: "color",
                    valuePath: "borderDownColor",
                    defaultValue: currentOptions.borderDownColor ?? "#d5160c",
                }, {
                    name: "Wick Up Color",
                    type: "color",
                    valuePath: "wickUpColor",
                    defaultValue: currentOptions.wickUpColor ?? "#1c9d1c",
                }, {
                    name: "Wick Down Color",
                    type: "color",
                    valuePath: "wickDownColor",
                    defaultValue: currentOptions.wickDownColor ?? "#d5160c",
                });
            }
            else
                colorOptions.push({
                    name: "Line Color",
                    type: "color",
                    valuePath: "lineColor",
                    defaultValue: currentOptions.lineColor ?? "#ffffff",
                });
            // Iterate over each color option and add it using addColorPickerMenuItem.
            colorOptions.forEach((option) => {
                this.addColorPickerMenuItem(camelToTitle(option.name), option.defaultValue, option.valuePath, trendTrace);
            });
            // Back to Trend Trace Menu
            this.addMenuItem("⤝ Trend Trace Menu", () => this.populateTrendTraceMenu(event, trendTrace), false);
            this.showMenu(event);
        }
        /**
         * Populates the submenu for general options.
         *
         * Logical indices (P1/P2) are always shown.
         * However, appearance options that are relevant only for OHLC data—
         * such as Bar Spacing, Radius, Shape, Show Wicks, Show Borders, and Chandelier Size—
         * are added only if isOHLCData returns true.
         *
         * Each update uses buildOptions.
         *
         * @param event - The mouse event that triggered the menu.
         * @param trendTrace - The TrendTrace instance.
         */
        populateTrendOptionsMenu(event, trendTrace) {
            this.div.innerHTML = ""; // Clear the menu
            const currentOptions = trendTrace.getOptions();
            const sequence = trendTrace._sequence;
            const ohlcData = sequence.data;
            const isOHLC = ohlcData.every((point) => point.open !== undefined &&
                point.high !== undefined &&
                point.low !== undefined &&
                point.close !== undefined);
            // Define the generalOptions array with a consistent option type.
            const generalOptions = [];
            // If the series is OHLC, add appearance options specific to OHLC.
            if (isOHLC) {
                generalOptions.push({
                    name: "Bar Spacing",
                    type: "number",
                    valuePath: "barSpacing",
                    defaultValue: currentOptions.barSpacing ?? 0.8,
                    min: 0.1,
                    max: 10,
                    step: 0.1,
                }, {
                    name: "Radius",
                    type: "number",
                    valuePath: "radius",
                    defaultValue: currentOptions.radius ?? 0.6,
                    min: 0,
                    max: 1,
                    step: 0.1,
                }, {
                    name: "Shape",
                    type: "select",
                    valuePath: "shape",
                    defaultValue: currentOptions.shape ?? "Rounded",
                    options: [
                        { label: "Rectangle", value: CandleShape.Rectangle },
                        { label: "Rounded", value: CandleShape.Rounded },
                        { label: "Ellipse", value: CandleShape.Ellipse },
                        { label: "Arrow", value: CandleShape.Arrow },
                        { label: "Polygon", value: CandleShape.Polygon },
                        { label: "Bar", value: CandleShape.Bar },
                        { label: "Slanted", value: CandleShape.Slanted },
                    ],
                }, {
                    name: "Show Wicks",
                    type: "boolean",
                    valuePath: "wickVisible",
                    defaultValue: currentOptions.wickVisible ?? true,
                }, {
                    name: "Show Borders",
                    type: "boolean",
                    valuePath: "borderVisible",
                    defaultValue: currentOptions.borderVisible ?? true,
                }, {
                    name: "Chandelier Size",
                    type: "number",
                    valuePath: "chandelierSize",
                    defaultValue: currentOptions.chandelierSize ?? 1,
                    min: 1,
                    max: 100,
                    step: 1,
                }, {
                    name: "Auto Aggregate",
                    type: "boolean",
                    valuePath: "autoscale",
                    defaultValue: currentOptions.autoScale ?? true,
                });
            }
            // Always include the following default appearance options.
            // Line Style option with numeric mapping.
            generalOptions.push({
                name: "Line Style",
                type: "select",
                valuePath: "lineStyle",
                defaultValue: currentOptions.lineStyle ?? 0,
                options: [
                    { label: "Solid", value: 0 },
                    { label: "Dotted", value: 1 },
                    { label: "Dashed", value: 2 },
                    { label: "Large Dashed", value: 3 },
                    { label: "Sparse Dotted", value: 4 },
                ],
            });
            // Line Width option for adjusting the appearance of the line.
            generalOptions.push({
                name: "Line Width",
                type: "number",
                valuePath: "lineWidth",
                defaultValue: currentOptions.lineWidth ?? 1,
                min: 0.5,
                max: 10,
                step: 0.5,
            });
            // Visible toggle option. This option is always added.
            generalOptions.push({
                name: "Visible",
                type: "boolean",
                valuePath: "visible",
                defaultValue: currentOptions.visible ?? true,
            });
            // Iterate over each general option and add an input based on its type.
            generalOptions.forEach((option) => {
                if (option.type === "number") {
                    this.addNumberInput(camelToTitle(option.name), option.defaultValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        trendTrace.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to: ${newValue}`);
                    }, option.min, option.max, option.step);
                }
                else if (option.type === "boolean") {
                    this.addCheckbox(camelToTitle(option.name), option.defaultValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        trendTrace.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to: ${newValue}`);
                    });
                }
                else if (option.type === "select") {
                    // If options are objects, extract their labels.
                    const optionLabels = Array.isArray(option.options) && typeof option.options[0] === "object"
                        ? option.options.map((opt) => opt.label)
                        : option.options;
                    this.addSelectInput(camelToTitle(option.name), option.defaultValue, optionLabels, (newLabel) => {
                        // For option objects, find the corresponding numeric value.
                        const selectedOption = option.options.find((opt) => opt.label === newLabel);
                        if (selectedOption) {
                            const updatedOptions = buildOptions(option.valuePath, selectedOption.value);
                            trendTrace.applyOptions(updatedOptions);
                            console.log(`Updated ${option.name} to: ${selectedOption.value}`);
                        }
                    });
                }
                // (Color options are handled in the color submenu.)
            });
            // Add the Export option.
            // Back to Trend Trace Menu.
            this.addMenuItem("⤝ Trend Trace Menu", () => this.populateTrendTraceMenu(event, trendTrace), false);
            this.showMenu(event);
        }
        populateVolumeProfileMenu(event, volumeProfile) {
            this.div.innerHTML = ""; // Clear the menu
            const currentOptions = volumeProfile._options;
            // Define a unified array for all option types.
            const generalOptions = [];
            // Push non-color options.
            generalOptions.push({
                name: "Visible",
                type: "boolean",
                valuePath: "visible",
                defaultValue: currentOptions.visible ?? true,
            }, {
                name: "Sections",
                type: "number",
                valuePath: "sections",
                defaultValue: currentOptions.sections ?? 20,
                min: 1,
                step: 1,
            }, {
                name: "Right Side",
                type: "boolean",
                valuePath: "rightSide",
                defaultValue: currentOptions.rightSide ?? true,
            }, {
                name: "Width",
                type: "number",
                valuePath: "width",
                defaultValue: currentOptions.width ?? 30,
                min: 1,
                step: 1,
            }, {
                name: "Line Style",
                type: "select",
                valuePath: "lineStyle",
                defaultValue: currentOptions.lineStyle ?? 0,
                options: [
                    { label: "Solid", value: 0 },
                    { label: "Dotted", value: 1 },
                    { label: "Dashed", value: 2 },
                    { label: "Large Dashed", value: 3 },
                    { label: "Sparse Dotted", value: 4 },
                ],
            }, {
                name: "Draw Grid",
                type: "boolean",
                valuePath: "drawGrid",
                defaultValue: currentOptions.drawGrid ?? true,
            }, {
                name: "Grid Width",
                type: "number",
                valuePath: "gridWidth",
                defaultValue: currentOptions.gridWidth ?? undefined, // Undefined to use entire visible range
                min: 1,
                step: 1,
            }, {
                name: "Grid Line Style",
                type: "select",
                valuePath: "gridLineStyle",
                defaultValue: currentOptions.gridLineStyle ?? 4, // Assuming 1 corresponds to 'Dashed'
                options: [
                    { label: "Solid", value: 0 },
                    { label: "Dotted", value: 1 },
                    { label: "Dashed", value: 2 },
                    { label: "Large Dashed", value: 3 },
                    { label: "Sparse Dotted", value: 4 },
                ],
            });
            // Push color options.
            generalOptions.push({
                name: "Up Color",
                type: "color",
                valuePath: "upColor",
                defaultValue: currentOptions.upColor ?? defaultVolumeProfileOptions.upColor,
            }, {
                name: "Down Color",
                type: "color",
                valuePath: "downColor",
                defaultValue: currentOptions.downColor ?? defaultVolumeProfileOptions.downColor,
            }, {
                name: "Border Up Color",
                type: "color",
                valuePath: "borderUpColor",
                defaultValue: currentOptions.borderUpColor ??
                    defaultVolumeProfileOptions.borderUpColor,
            }, {
                name: "Border Down Color",
                type: "color",
                valuePath: "borderDownColor",
                defaultValue: currentOptions.borderDownColor ??
                    defaultVolumeProfileOptions.borderDownColor,
            }, {
                name: "Grid Color",
                type: "color",
                valuePath: "gridColor",
                defaultValue: currentOptions.gridColor ?? defaultVolumeProfileOptions.gridColor,
            });
            // Iterate over each general option and add an input based on its type.
            generalOptions.forEach((option) => {
                if (option.type === "number") {
                    this.addNumberInput(camelToTitle(option.name), option.defaultValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        volumeProfile.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to: ${newValue}`);
                    }, option.min, option.max, option.step);
                }
                else if (option.type === "boolean") {
                    this.addCheckbox(camelToTitle(option.name), option.defaultValue, (newValue) => {
                        const updatedOptions = buildOptions(option.valuePath, newValue);
                        volumeProfile.applyOptions(updatedOptions);
                        console.log(`Updated ${option.name} to: ${newValue}`);
                    });
                }
                else if (option.type === "select") {
                    // If options are objects, extract their labels; otherwise, assume an array of strings.
                    const optionLabels = Array.isArray(option.options) && typeof option.options[0] === "object"
                        ? option.options.map((opt) => opt.label)
                        : option.options;
                    this.addSelectInput(camelToTitle(option.name), option.defaultValue, optionLabels, (newLabel) => {
                        const selectedOption = option.options.find((opt) => opt.label === newLabel);
                        if (selectedOption) {
                            const updatedOptions = buildOptions(option.valuePath, selectedOption.value);
                            volumeProfile.applyOptions(updatedOptions);
                            console.log(`Updated ${option.name} to: ${selectedOption.value}`);
                        }
                    });
                }
                else if (option.type === "color") {
                    // Use the existing color picker method.
                    this.addColorPickerMenuItem(camelToTitle(option.name), option.defaultValue, option.valuePath, volumeProfile);
                }
            });
            this.addMenuItem("⤝ Main Menu", () => {
                this.populateChartMenu(event);
            }, false);
            this.showMenu(event);
        }
        /**
         * Here, we define the method that shows a minimal overlay listing all indicators,
         * letting the user click “Add” or “Remove.” We'll reuse references to `this.handler.chart`
         * and `this.handler.seriesMap`, etc. We also define `this.applyIndicator` and `this.removeIndicator`
         * as class methods that store a reference to each indicator's series in `indicatorSeriesMap`.
         */
        // A map from indicator name => { figureKey => ISeriesApi }
        indicatorSeriesMap = new Map();
        populateIndicatorMenu(series, event) {
            // Clear the menu first
            this.div.innerHTML = "";
            // Show each indicator
            INDICATORS.forEach((indicator) => {
                this.addMenuItem(`${indicator.name} (${indicator.shortName})`, () => {
                    // If indicator has paramMap, let user configure
                    if (indicator.paramMap) {
                        this.configureIndicatorParams({ series, indicator }, event, 1, true);
                    }
                    else {
                        // Otherwise, directly apply
                        this.applyIndicator(series, indicator, /* no overrides */ {}, 1);
                    }
                }, false);
            });
            // Add a back/cancel item
            this.addMenuItem("⤝ Back", () => {
                this.hideMenu();
                // or populate something else
            }, false);
            // Display
            this.showMenu(event);
        }
        configureIndicatorParams(indicatorInput, event, globalCountParam, init = false // Optional parameter for global figure count.
        ) {
            // Clear existing menu items
            this.div.innerHTML = "";
            let currentCount;
            // Extract the series and indicator from the input.
            const series = "sourceSeries" in indicatorInput
                ? indicatorInput
                : indicatorInput.series;
            const indicator = ("indicator" in indicatorInput
                ? indicatorInput.indicator
                : indicatorInput.indicator);
            // Use stored parameters if available; otherwise, use indicator defaults.
            const storedParams = "paramMap" in indicatorInput ? indicatorInput.paramMap : {};
            const overrides = {};
            /**************************************************
             * 1. Global Figure Count Input
             * If any parameter is an array type, add a top-level input for
             * "Number of Figures". Use the passed globalCountParam if provided,
             * otherwise default to indicatorInput.figureCount if it exists,
             * or else to the default count (derived from the param defaults).
             **************************************************/
            let hasArrayParams = false;
            let defaultCount = 0;
            Object.entries(indicator.paramMap).forEach(([_, paramSpec]) => {
                if (paramSpec.type === "numberArray" ||
                    paramSpec.type === "selectArray" ||
                    paramSpec.type === "booleanArray" ||
                    paramSpec.type === "stringArray") {
                    hasArrayParams = true;
                    const defArr = Array.isArray(paramSpec.defaultValue)
                        ? paramSpec.defaultValue
                        : [paramSpec.defaultValue];
                    defaultCount = Math.max(defaultCount, defArr.length);
                }
            });
            if (hasArrayParams && init) {
                // Determine the current global count:
                if (globalCountParam !== undefined) {
                    currentCount = globalCountParam;
                    indicatorInput.figureCount = globalCountParam;
                }
                else if ("figureCount" in indicatorInput &&
                    indicatorInput.figureCount !== undefined) {
                    currentCount = indicatorInput.figureCount;
                }
                else {
                    currentCount = defaultCount || 1;
                }
                // Add a top-level input for "Number of Figures"
                this.addNumberInput("Number of Figures", currentCount, (newCount) => {
                    // Update the indicator's property with the new count.
                    indicatorInput.figureCount = newCount;
                    // Redraw the parameter menu using the new global count.
                    this.configureIndicatorParams(indicatorInput, event, newCount, true);
                }, 1, 10, 1);
            }
            /**************************************************
             * 2. Process Each Parameter
             **************************************************/
            Object.entries(indicator.paramMap).forEach(([paramName, paramSpec]) => {
                const labelText = paramName; // Optionally, format the label.
                const defaultVal = storedParams[paramName] !== undefined
                    ? storedParams[paramName]
                    : paramSpec.defaultValue;
                if (paramSpec.type === "numberArray" ||
                    paramSpec.type === "selectArray" ||
                    paramSpec.type === "booleanArray" ||
                    paramSpec.type === "stringArray") {
                    // Get the global count from the indicator's property.
                    const count = globalCountParam ?? indicatorInput.figureCount;
                    // Determine base type by stripping "Array"
                    const baseType = paramSpec.type.replace("Array", "");
                    overrides[paramName] = [];
                    for (let i = 0; i < count; i++) {
                        let itemDefault;
                        if (Array.isArray(defaultVal)) {
                            itemDefault =
                                i < defaultVal.length
                                    ? defaultVal[i]
                                    : defaultVal[defaultVal.length - 1];
                        }
                        else {
                            itemDefault = defaultVal;
                        }
                        if (baseType === "number") {
                            this.addNumberInput(`${labelText} ${i + 1}`, itemDefault, (newVal) => {
                                if (!overrides[paramName]) {
                                    overrides[paramName] = [];
                                }
                                overrides[paramName][i] = newVal;
                            }, paramSpec.min, paramSpec.max, paramSpec.step);
                        }
                        else if (baseType === "boolean") {
                            this.addCheckbox(`${labelText} ${i + 1}`, Boolean(itemDefault), (checked) => {
                                if (!overrides[paramName]) {
                                    overrides[paramName] = [];
                                }
                                overrides[paramName][i] = checked;
                            });
                        }
                        else if (baseType === "select") {
                            this.addSelectInput(`${labelText} ${i + 1}`, String(itemDefault), paramSpec.options || [], (selected) => {
                                if (!overrides[paramName]) {
                                    overrides[paramName] = [];
                                }
                                overrides[paramName][i] = selected;
                            });
                        }
                        else if (baseType === "string") {
                            this.addMenuInput(this.div, {
                                type: "string",
                                label: `${labelText} ${i + 1}`,
                                value: itemDefault,
                                onChange: (val) => {
                                    if (!overrides[paramName]) {
                                        overrides[paramName] = [];
                                    }
                                    overrides[paramName][i] = val;
                                },
                            });
                        }
                        if (!overrides[paramName]) {
                            overrides[paramName] = [];
                        }
                        overrides[paramName][i] = itemDefault;
                    }
                }
                else {
                    // Non-array parameters: same as before.
                    if (paramSpec.type === "number") {
                        this.addNumberInput(labelText, defaultVal, (newVal) => {
                            overrides[paramName] = newVal;
                        }, paramSpec.min, paramSpec.max, paramSpec.step);
                        overrides[paramName] = defaultVal;
                    }
                    else if (paramSpec.type === "boolean") {
                        this.addCheckbox(labelText, Boolean(defaultVal), (checked) => {
                            overrides[paramName] = checked;
                        });
                        overrides[paramName] = defaultVal;
                    }
                    else if (paramSpec.type === "select") {
                        this.addSelectInput(labelText, String(defaultVal), paramSpec.options || [], (selected) => {
                            overrides[paramName] = selected;
                        });
                        overrides[paramName] = defaultVal;
                    }
                    else {
                        this.addMenuInput(this.div, {
                            type: "string",
                            label: labelText,
                            value: defaultVal,
                            onChange: (val) => {
                                overrides[paramName] = val;
                            },
                        });
                        overrides[paramName] = defaultVal;
                    }
                }
            });
            /**************************************************
             * 3. Apply and Cancel Buttons
             **************************************************/
            this.addMenuItem("Apply", () => {
                this.hideMenu();
                // Update the defaultValue for each parameter in the indicator's paramMap
                Object.entries(overrides).forEach(([paramName, newValue]) => {
                    if (indicator.paramMap[paramName]) {
                        indicator.paramMap[paramName].defaultValue = newValue;
                    }
                });
                if ("recalculate" in indicatorInput) {
                    indicatorInput.recalculate(overrides);
                    indicatorInput.figures.forEach((figSeries) => {
                        const legendItem = this.handler.legend._lines.find((item) => item.series === figSeries);
                        if (legendItem) {
                            this.handler.seriesMap.set(figSeries.options().title, series);
                            legendItem.name = figSeries.options().title;
                        }
                    });
                }
                else {
                    this.applyIndicator(series, indicator, overrides, currentCount);
                }
            }, false);
            this.addMenuItem("Cancel", () => {
                this.hideMenu();
            }, false);
            this.showMenu(event);
        }
        /**
         * Applies an indicator to the given series.
         *
         * This method now accepts any ISeriesApi (not just Candlestick or Bar) and converts the data
         * to OHLC data if needed before calling the indicator's calc function.
         *
         * After calculating indicator figures, it either updates existing series or creates new ones,
         * and moves them to the appropriate pane if the figure defines a pane offset.
         *
         * @param series - The series on which to apply the indicator.
         * @param ind - The indicator definition.
         * @param overrides - User-specified parameter overrides.
         * @param count - The figure count.
         */
        applyIndicator(series, ind, overrides, count) {
            // 1) Grab your main data.
            const data = [...series.data()];
            if (!data || data.length === 0) {
                console.warn("No data found on this series.");
                return;
            }
            // 2) Convert the data to OHLC if it isn't already.
            let ohlcData;
            if (data.every(isOHLCData)) {
                ohlcData = data;
            }
            else {
                // Assume data is SingleValueData and convert each point.
                ohlcData = data.map(singleToOhlcData);
            }
            const volumeData = this.handler.volumeSeries.data();
            // 2a) Calculate the figures from the indicator
            const figures = ind.calc([...ohlcData], overrides, volumeData ?? undefined);
            //// 2b) If we already have them, update the existing figures
            //if (isISeriesIndicator(series)) {
            //  const figMap = series.figures;
            //  if (figMap) {
            //    figures.forEach((f) => {
            //      const existing = figMap.get(f.key);
            //      if (existing) {
            //        existing.setData(f.data);
            //      }
            //    });
            //  }
            //  return;
            //}
            // 2c) Otherwise, create new indicator series
            const newMap = new Map();
            const colorShades = generateShades(figures.length); // Generate unique shades
            figures.forEach((f, index) => {
                const selectedColor = colorShades[index];
                let seriesInstance = null;
                if (f.type === "histogram") {
                    const hist = this.handler.createHistogramSeries(f.title, {
                        color: selectedColor,
                        base: 0,
                        title: f.title,
                        ...(figures.length > 1 ? { group: ind.name } : {}), // ✅ Only set `group` if multiple figures exist
                    });
                    if (hist.series) {
                        hist.series.setData(f.data);
                        seriesInstance = hist.series;
                        if (series.getPane().paneIndex() !== seriesInstance.getPane().paneIndex()) {
                            seriesInstance.moveToPane(series.getPane().paneIndex());
                        }
                    }
                }
                else {
                    const line = this.handler.createLineSeries(f.title, {
                        color: selectedColor,
                        lineWidth: 2,
                        title: f.title,
                        ...(figures.length > 1 ? { group: ind.name } : {}), // ✅ Only set `group` if multiple figures exist
                    });
                    if (line.series) {
                        line.series.setData(f.data);
                        seriesInstance = line.series;
                        if (series.getPane().paneIndex() !== seriesInstance.getPane().paneIndex()) {
                            seriesInstance.moveToPane(series.getPane().paneIndex());
                        }
                    }
                }
                if (seriesInstance) {
                    // 🎯 Decorate the series instance as an `ISeriesIndicator`
                    const indicatorInstance = decorateSeriesAsIndicator(seriesInstance, series, ind, newMap, count, overrides, recalculateIndicator);
                    // Store the decorated indicator series
                    newMap.set(f.key, indicatorInstance);
                    // If the indicator figure has a pane property, move the series to the appropriate pane.
                    if (f.pane) {
                        // Check if the current pane of the indicator is the same as the source series' pane.
                        if (indicatorInstance.getPane() === series.getPane()) {
                            const currentPane = indicatorInstance.getPane();
                            // Since paneIndex is a function, call it to get a number.
                            const paneIndex = currentPane.paneIndex();
                            // Move the indicator series to a new pane by adding the offset.
                            indicatorInstance.moveToPane(paneIndex + f.pane);
                        }
                    }
                }
            });
            // Store the new indicator in the map.
            this.indicatorSeriesMap.set(ind.name, newMap);
        }
        populateForkLineMainMenu(event, drawing) {
            // Clear the menu container.
            this.div.innerHTML = "";
            // Only applicable if the drawing is a PitchFork.
            if (drawing._type !== "PitchFork")
                return;
            const options = drawing._options;
            if (!options.forkLines) {
                options.forkLines = [];
            }
            const forkLines = options.forkLines;
            // For each fork line, add one menu item that will open its detailed options.
            forkLines.forEach((_, index) => {
                this.addMenuItem(`Fork Line ${index + 1}`, () => {
                    // When clicked, clear the menu and show the options for this fork line.
                    this.populateForkLineOptions(event, drawing, index);
                }, false, true);
            });
            // Add a menu item to add a new fork line.
            this.addMenuItem("Add Fork Line", () => {
                const newForkLine = {
                    value: 0.5, // Default offset value.
                    width: 1, // Default width.
                    style: lightweightCharts.LineStyle.Solid, // Default style (ensure this is valid per your LineStyle)
                    color: "#ffffff", // Default color.
                    fillColor: undefined, // No fill by default.
                };
                forkLines.push(newForkLine);
                if (this.saveDrawings) {
                    this.saveDrawings();
                }
                // Refresh the main fork line menu.
                this.populateForkLineMainMenu(event, drawing);
            }, false, true);
            // Add a back button to return to the drawing menu.
            this.addMenuItem("⤝ Back", () => {
                this.populateDrawingMenu(event, drawing);
            }, false, false);
            this.showMenu(event);
        }
        populateForkLineOptions(event, drawing, index) {
            // Clear the menu container.
            this.div.innerHTML = "";
            const options = drawing._options;
            if (!options.forkLines || !options.forkLines[index])
                return;
            const fork = options.forkLines[index];
            // Add a header for clarity.
            // Add a number input for "value".
            this.addNumberInput("Value", fork.value, (newValue) => {
                fork.value = newValue;
                if (this.saveDrawings) {
                    this.saveDrawings();
                }
            }, 0, // minimum value (adjust as needed)
            10, // maximum value (adjust as needed)
            0.1 // step (adjust as needed)
            );
            // Add a number input for "width".
            this.addNumberInput("Width", fork.width, (newValue) => {
                fork.width = newValue;
                if (this.saveDrawings) {
                    this.saveDrawings();
                }
            }, 1, // minimum width
            10, // maximum width (adjust as needed)
            1);
            // Define allowed styles for fork lines.
            const allowedStyles = [
                { name: "Solid", var: lightweightCharts.LineStyle.Solid },
                { name: "Dotted", var: lightweightCharts.LineStyle.Dotted },
                { name: "Dashed", var: lightweightCharts.LineStyle.Dashed },
                { name: "Large Dashed", var: lightweightCharts.LineStyle.LargeDashed },
                { name: "Sparse Dotted", var: lightweightCharts.LineStyle.SparseDotted },
            ];
            // In your populateForkLineOptions method, for the "Style" menu item:
            this.addSelectInput("Style", 
            // Show the current style name (by matching fork.style with the allowedStyles array)
            allowedStyles.find((styleObj) => styleObj.var === fork.style)?.name ||
                allowedStyles[0].name, 
            // Provide the names as the options for the select input.
            allowedStyles.map((styleObj) => styleObj.name), (newValue) => {
                // When a new style is selected, look it up in allowedStyles.
                const selected = allowedStyles.find((styleObj) => styleObj.name === newValue);
                if (selected) {
                    fork.style = selected.var;
                    if (this.saveDrawings) {
                        this.saveDrawings();
                    }
                }
            });
            // For the main color:
            this.addForkLineColorPickerMenuItem("Color", fork.color, fork, "color");
            // For the fill color (an empty string indicates no fill):
            this.addForkLineColorPickerMenuItem("Fill Color", fork.fillColor || "", fork, "fillColor");
            // Add a menu item to remove this fork line.
            this.addMenuItem("Remove Fork Line", () => {
                options.forkLines.splice(index, 1);
                if (this.saveDrawings) {
                    this.saveDrawings();
                }
                // Return to the main fork line menu.
                this.populateForkLineMainMenu(event, drawing);
            }, false, true);
            // Add a back button to return to the main fork line menu.
            this.addMenuItem("⤝ Back", () => {
                this.populateForkLineMainMenu(event, drawing);
            }, false, false);
            this.showMenu(event);
        }
        /**
         * Unified fork-line color picker menu item.
         *
         * @param label - Display label for the menu item.
         * @param currentColor - The current color value.
         * @param forkLine - The fork line object to update.
         * @param property - The property of the fork line to update ("color" or "fillColor").
         * @returns The created menu item HTMLElement.
         */
        addForkLineColorPickerMenuItem(label, currentColor, forkLine, property) {
            const menuItem = document.createElement("span");
            menuItem.classList.add("context-menu-item");
            menuItem.innerText = label;
            this.div.appendChild(menuItem);
            const applyColor = (newColor) => {
                forkLine[property] = newColor;
                console.log(`Updated fork line ${property} to ${newColor}`);
                if (this.saveDrawings) {
                    this.saveDrawings();
                }
            };
            menuItem.addEventListener("click", (event) => {
                event.stopPropagation();
                if (!this.colorPicker) {
                    this.colorPicker = new ColorPicker(currentColor ?? "#000000", applyColor);
                }
                this.colorPicker.openMenu(event, 225, applyColor);
            });
            return menuItem;
        }
    }

    /**
     * Default grid / crosshair line width in Bitmap sizing
     * @param horizontalPixelRatio - horizontal pixel ratio
     * @returns default grid / crosshair line width in Bitmap sizing
     */
    function gridAndCrosshairBitmapWidth(horizontalPixelRatio) {
        return Math.max(1, Math.floor(horizontalPixelRatio));
    }
    /**
     * Default grid / crosshair line width in Media sizing
     * @param horizontalPixelRatio - horizontal pixel ratio
     * @returns default grid / crosshair line width in Media sizing
     */
    function gridAndCrosshairMediaWidth(horizontalPixelRatio) {
        return (gridAndCrosshairBitmapWidth(horizontalPixelRatio) / horizontalPixelRatio);
    }

    // -------------------------------------
    // Imports
    // -------------------------------------
    // -------------------------------------
    // Constants
    // -------------------------------------
    /**
     * Default color for upward-moving candles.
     * Format: RGBA with 33.3% opacity.
     */
    /**
     * Default color for downward-moving candles.
     * Format: RGBA with 33.3% opacity.
     */
    /**
     * Default line style for candle borders.
     * 1 represents a solid line.
     */
    const DEFAULT_LINE_STYLE = 1;
    /**
     * Default line width for candle borders.
     * 1 pixel.
     */
    const DEFAULT_LINE_WIDTH = 1;
    // -------------------------------------
    // BarDataAggregator Class
    // -------------------------------------
    /**
     * Aggregates raw bar data into grouped bar items based on specified options.
     * Handles the styling and property consolidation for candle rendering.
     */
    class BarDataAggregator {
        /**
         * Configuration options for data aggregation and candle styling.
         */
        _options;
        /**
         * Constructs a new BarDataAggregator instance.
         * @param options - Aggregation and styling options. Can be null to use defaults.
         */
        constructor(options) {
            this._options = options;
        }
        /**
         * Aggregates an array of BarItem objects into grouped BarItem objects.
         * Handles the styling and property consolidation for candle rendering.
         *
         * @param data - The raw bar data to aggregate.
         * @param priceToCoordinate - Function to convert price values to canvas coordinates.
         * @returns An array of aggregated BarItem objects.
         */
        staticAggregate(data, priceToCoordinate) {
            // Determine the number of bars to group based on chandelierSize.
            const groupSize = this._options?.chandelierSize ?? 1;
            const aggregatedBars = [];
            // Iterate over the data in increments of groupSize to create buckets.
            for (let i = 0; i < data.length; i += groupSize) {
                const bucket = data.slice(i, i + groupSize);
                const isInProgress = bucket.length < groupSize && i + bucket.length === data.length;
                // Warn and skip if an empty bucket is encountered.
                if (bucket.length === 0) {
                    console.warn('Empty bucket encountered during aggregation.');
                    continue;
                }
                // Aggregate the current bucket into a single BarItem.
                const aggregatedBar = this._chandelier(bucket, i, i + bucket.length - 1, priceToCoordinate, isInProgress);
                aggregatedBars.push(aggregatedBar);
            }
            if (this._options?.enableVolumeOpacity) {
                // Ensure every aggregated bar has a volume property
                const hasVolumeData = aggregatedBars.every((bar) => bar.volume !== undefined && typeof bar.volume === 'number');
                if (!hasVolumeData) {
                    console.warn("Volume opacity enabled but not all aggregated bars have volume data. Skipping volume-based opacity adjustment.");
                }
                else {
                    // Check alpha of upColor and downColor
                    const upColor = this._options?.upColor || 'rgba(0,255,0,0.333)';
                    const downColor = this._options?.downColor || 'rgba(255,0,0,0.333)';
                    const upAlpha = getAlphaFromColor(upColor);
                    const downAlpha = getAlphaFromColor(downColor);
                    // Proceed only if both alpha values are non-zero
                    if (upAlpha !== 0 && downAlpha !== 0) {
                        // Use a base period from options or default to 20.
                        const basePeriod = this._options.volumeOpacityPeriod ?? 20;
                        // Multiply the base period by the chandelier size (groupSize).
                        const period = basePeriod * groupSize;
                        aggregatedBars.forEach((bar, i, arr) => {
                            if (bar.volume == null) {
                                return;
                            }
                            // Define the sliding window (the last `period` bars or fewer)
                            const windowStart = Math.max(0, i - period + 1);
                            const windowBars = arr.slice(windowStart, i + 1);
                            // Retrieve maxOpacity from options, defaulting to 0.3 if not set
                            const maxOpacity = this._options?.maxOpacity ?? 0.3;
                            let opacity = 1; // Default
                            // Determine opacity based on the selected volumeOpacityMode
                            if (this._options?.volumeOpacityMode === '/ max' || !this._options?.volumeOpacityMode) {
                                // "/ max" mode
                                const maxVolume = windowBars.reduce((max, current) => {
                                    return current.volume !== undefined && current.volume > max
                                        ? current.volume
                                        : max;
                                }, 0);
                                opacity = (maxVolume > 0 ? bar.volume / maxVolume : 1) * maxOpacity;
                            }
                            else if (this._options?.volumeOpacityMode === '> previous') {
                                // "> previous" mode
                                if (i === 0 || !arr[i - 1].volume || arr[i - 1].volume === 0) {
                                    opacity = maxOpacity;
                                }
                                else {
                                    const previousVolume = arr[i - 1].volume ?? 0;
                                    opacity = bar.volume > previousVolume ? maxOpacity : 0;
                                }
                            }
                            else if (this._options?.volumeOpacityMode === '> average') {
                                // "> average" mode
                                const totalVolume = windowBars.reduce((sum, current) => {
                                    return sum + (current.volume !== undefined ? current.volume : 0);
                                }, 0);
                                const averageVolume = windowBars.length > 0 ? totalVolume / windowBars.length : 0;
                                opacity = averageVolume > 0 && bar.volume > averageVolume ? maxOpacity : 0;
                            }
                            else {
                                // Unrecognized mode => default opacity to 0
                                opacity = 0;
                            }
                            // Set the bar's color using upColor or downColor, applying the computed opacity
                            if (bar.isUp) {
                                bar.color = setOpacity(upColor, opacity);
                            }
                            else {
                                bar.color = setOpacity(downColor, opacity);
                            }
                        });
                    }
                    else {
                        console.warn("Volume opacity enabled but upColor/downColor alpha is zero. Skipping volume-based opacity adjustment.");
                    }
                }
            }
            return aggregatedBars;
        }
        dynamicAggregate(data, priceToCoordinate) {
            if (data.length === 0 ||
                typeof this._options?.dynamicTrigger !== "function" ||
                !this._options?.dynamicCandles) {
                return [];
            }
            const aggregatedBars = [];
            let currentBucket = [];
            for (let i = 0; i < data.length; i++) {
                const bar = data[i];
                // Add current bar to the bucket
                currentBucket.push(bar);
                // **Check dynamic trigger** – if it signals a new bar, aggregate the bucket
                const dynamicTriggerActivated = this._options.dynamicTrigger().newBar || data[i].newBar;
                if (dynamicTriggerActivated) {
                    const startIndex = i - currentBucket.length + 1;
                    const endIndex = i;
                    // Aggregate the collected bucket
                    const aggregatedBar = this._chandelier(currentBucket, startIndex, endIndex, priceToCoordinate, false);
                    aggregatedBars.push(aggregatedBar);
                    console.log(`Aggregated candle from index ${startIndex} to ${endIndex} (Trigger: ${this._options.dynamicTrigger().newBar ?? data[i].newBar})`);
                    // Reset bucket for the next candle
                    currentBucket = [];
                }
            }
            return aggregatedBars;
        }
        /**
         * Aggregates a single bucket of BarItem objects into one consolidated BarItem.
         * @param bucket - The group of BarItem objects to aggregate.
         * @param startIndex - The starting index of the bucket in the original data array.
         * @param endIndex - The ending index of the bucket in the original data array.
         * @param priceToCoordinate - Function to convert price values to canvas coordinates.
         * @param isInProgress - Indicates if the aggregation is currently in progress.
         * @returns A single aggregated BarItem.
         * @throws Will throw an error if the bucket is empty.
         */
        _chandelier(bucket, startIndex, endIndex, priceToCoordinate, isInProgress = false) {
            if (bucket.length === 0) {
                throw new Error('Bucket cannot be empty in _chandelier method.');
            }
            // Extract open and close prices from the first and last bars in the bucket.
            const openPrice = bucket[0].originalData?.open ?? bucket[0].open ?? 0;
            const closePrice = bucket[bucket.length - 1].originalData?.close ??
                bucket[bucket.length - 1].close ??
                0;
            // Convert open and close prices to canvas coordinates.
            const open = priceToCoordinate(openPrice) ?? 0;
            const close = priceToCoordinate(closePrice) ?? 0;
            // Extract high and low prices from all bars in the bucket.
            const highPrices = bucket.map((bar) => bar.originalData?.high ?? bar.high);
            const lowPrices = bucket.map((bar) => bar.originalData?.low ?? bar.low);
            // Determine the highest and lowest prices in the bucket.
            const highPrice = highPrices.length > 0 ? Math.max(...highPrices) : 0;
            const lowPrice = lowPrices.length > 0 ? Math.min(...lowPrices) : 0;
            // Convert high and low prices to canvas coordinates.
            const high = priceToCoordinate(highPrice) ?? 0;
            const low = priceToCoordinate(lowPrice) ?? 0;
            // Position of the aggregated bar on the x-axis.
            const x = bucket[0].x;
            // Determine if the aggregated bar represents an upward movement.
            const isUp = closePrice > openPrice;
            // Explicitly map colors based on `isUp` status.
            const color = isUp
                ? (this._options?.upColor || 'rgba(0,255,0,0.333)')
                : (this._options?.downColor || 'rgba(255,0,0,0.333)');
            const borderColor = isUp
                ? (this._options?.borderUpColor || setOpacity(color, 1))
                : (this._options?.borderDownColor || setOpacity(color, 1));
            const wickColor = isUp
                ? (this._options?.wickUpColor || borderColor)
                : (this._options?.wickDownColor || borderColor);
            // Aggregate lineStyle similarly to other properties.
            const lineStyle = bucket.reduce((style, bar) => bar.lineStyle ?? bar.originalData?.lineStyle ?? style, this._options?.lineStyle ?? DEFAULT_LINE_STYLE);
            // Aggregate lineWidth similarly to other properties.
            const lineWidth = bucket.reduce((currentWidth, bar) => bar.lineWidth ?? bar.originalData?.lineWidth ?? currentWidth, this._options?.lineWidth ?? DEFAULT_LINE_WIDTH);
            // Aggregate shape similarly to other properties.
            const shape = bucket.reduce((currentShape, bar) => {
                const parsedShape = bar.shape
                    ? parseCandleShape(bar.shape)
                    : bar.originalData?.shape
                        ? parseCandleShape(bar.originalData.shape)
                        : undefined;
                // If parsing fails, retain the current shape.
                return parsedShape ?? currentShape;
            }, this._options?.shape ?? CandleShape.Rectangle);
            const volume = bucket.reduce((sum, bar) => sum + (bar.originalData?.volume ?? bar.volume ?? 0), 0);
            // Ensure that `shape` is never undefined. If it is, default to Rectangle.
            const finalShape = shape || CandleShape.Rectangle;
            // Return the aggregated BarItem with all consolidated properties.
            return {
                open,
                high,
                low,
                close,
                volume,
                x,
                isUp,
                startIndex,
                endIndex,
                isInProgress,
                color,
                borderColor,
                wickColor,
                shape: finalShape,
                lineStyle,
                lineWidth,
            };
        }
    }
    // -------------------------------------
    // ohlcSeriesRenderer Class
    // -------------------------------------
    /**
     * Custom renderer for candle series, implementing various candle shapes and styles.
     * Utilizes BarDataAggregator for data aggregation and rendering logic for different candle shapes.
     * @template TData - The type of custom candle series data.
     */
    class ohlcSeriesRenderer {
        /**
         * The current data to be rendered.
         */
        _data = null;
        /**
         * The current rendering options.
         */
        _options = null;
        /**
         * The data aggregator instance.
         */
        _aggregator = null;
        /**
         * Draws the candle series onto the provided canvas target.
         * @param target - The canvas rendering target.
         * @param priceConverter - Function to convert price values to canvas coordinates.
         */
        draw(target, priceConverter) {
            target.useBitmapCoordinateSpace((scope) => this._drawImpl(scope, priceConverter));
        }
        /**
         * Updates the renderer with new data and options.
         * @param data - The custom series data to render.
         * @param options - The custom series options for styling and behavior.
         */
        update(data, options) {
            this._data = data;
            this._options = options;
            this._aggregator = new BarDataAggregator(options);
        }
        /**
         * Internal implementation of the drawing logic.
         * Processes data, aggregates bars, and delegates drawing to specific methods.
         * @param renderingScope - The rendering scope containing canvas context and scaling information.
         * @param priceToCoordinate - Function to convert price values to canvas coordinates.
         */
        _drawImpl(renderingScope, priceToCoordinate) {
            // Exit early if there's no data or options to render.
            if (!this._data ||
                this._data.bars.length === 0 ||
                !this._data.visibleRange ||
                !this._options) {
                return;
            }
            // Transform raw data into BarItem objects with initial styling.
            const bars = this._data.bars.map((bar, index) => ({
                open: bar.originalData?.open ?? 0,
                high: bar.originalData?.high ?? 0,
                low: bar.originalData?.low ?? 0,
                close: bar.originalData?.close ?? 0,
                volume: bar.originalData?.volume ?? 0,
                x: bar.x,
                shape: (bar.originalData?.shape ??
                    this._options?.shape ??
                    'Rectangle'),
                lineStyle: bar.originalData?.lineStyle ??
                    this._options?.lineStyle ??
                    1,
                lineWidth: bar.originalData?.lineWidth ??
                    this._options?.lineWidth ??
                    1,
                isUp: (bar.originalData?.close ?? 0) >=
                    (bar.originalData?.open ?? 0),
                color: this._options?.color ?? 'rgba(0,0,0,0)',
                borderColor: this._options?.borderColor ?? 'rgba(0,0,0,0)',
                wickColor: this._options?.wickColor ?? 'rgba(0,0,0,0)',
                startIndex: index,
                endIndex: index,
            }));
            let aggregatedBars;
            // If volume candles are enabled and both volumeMALength and volumeMultiplier are defined, use aggregateByVolume.
            if (this._options.dynamicCandles &&
                typeof this._options.volumeMALength === "number" &&
                typeof this._options.volumeMultiplier === "number") {
                aggregatedBars =
                    this._aggregator?.dynamicAggregate(bars, priceToCoordinate) ?? [];
            }
            else {
                // Otherwise, use the standard aggregation method.
                aggregatedBars = this._aggregator?.staticAggregate(bars, priceToCoordinate) ?? [];
            }
            // Determine the radius for rounded shapes and candle width based on scaling.
            const radius = this._options.radius;
            const { horizontalPixelRatio, verticalPixelRatio } = renderingScope;
            const candleWidth = this._data.barSpacing * horizontalPixelRatio;
            // Delegate drawing of candle bodies and wicks.
            this._drawCandles(renderingScope, aggregatedBars, this._data.visibleRange, radius, candleWidth, horizontalPixelRatio, verticalPixelRatio);
            this._drawWicks(renderingScope, aggregatedBars, this._data.visibleRange);
        }
        /**
         * Draws the wicks (high-low lines) for each aggregated candle.
         * Skips rendering if the candle shape is '3d'.
         * @param renderingScope - The rendering scope containing canvas context and scaling information.
         * @param bars - Array of aggregated BarItem objects to draw wicks for.
         * @param visibleRange - The range of visible bars to render.
         */
        _drawWicks(renderingScope, bars, visibleRange) {
            // Exit early if there's no data or options.
            if (this._data === null || this._options === null) {
                return;
            }
            // Skip wick drawing if the candle shape is '3d'.
            if (this._options.shape === '3d') {
                return;
            }
            const { context: ctx, horizontalPixelRatio, verticalPixelRatio } = renderingScope;
            const candleWidth = this._data.barSpacing * horizontalPixelRatio;
            const wickWidth = gridAndCrosshairMediaWidth(horizontalPixelRatio);
            // Iterate over each aggregated bar to draw its wicks.
            for (const bar of bars) {
                // Skip bars outside the visible range.
                if (bar.startIndex < visibleRange.from ||
                    bar.endIndex > visibleRange.to) {
                    continue;
                }
                // Calculate pixel positions for high, low, open, and close.
                const low = bar.low * verticalPixelRatio;
                const high = bar.high * verticalPixelRatio;
                const openCloseTop = Math.min(bar.open, bar.close) * verticalPixelRatio;
                const openCloseBottom = Math.max(bar.open, bar.close) * verticalPixelRatio;
                // Determine the X position for the wick.
                let wickX = bar.x * horizontalPixelRatio;
                const groupSize = bar.endIndex - bar.startIndex;
                if (groupSize && groupSize > 1) {
                    wickX += candleWidth * Math.max(1, groupSize) / 2;
                }
                // Adjust wick heights for 'Polygon' shape candles.
                let upperWickTop = high;
                let upperWickBottom = openCloseTop;
                let lowerWickTop = openCloseBottom;
                let lowerWickBottom = low;
                if (this._options.shape === 'Polygon') {
                    // For 'Polygon' candles, set halfway points.
                    upperWickBottom = (high + openCloseTop) / 2;
                    lowerWickTop = (low + openCloseBottom) / 2;
                }
                // Set fill and stroke styles for the wick.
                ctx.fillStyle = bar.color;
                ctx.strokeStyle = bar.wickColor ?? bar.color;
                /**
                 * Draws a rounded rectangle or a standard rectangle as a wick.
                 * @param x - The X-coordinate of the top-left corner.
                 * @param y - The Y-coordinate of the top-left corner.
                 * @param width - The width of the rectangle.
                 * @param height - The height of the rectangle.
                 * @param radius - The corner radius for rounded rectangles.
                 */
                const drawRoundedRect = (x, y, width, height, radius) => {
                    if (ctx.roundRect) {
                        ctx.roundRect(x, y, width, height, radius);
                    }
                    else {
                        ctx.rect(x, y, width, height);
                    }
                };
                // Draw the upper wick.
                const upperWickHeight = upperWickBottom - upperWickTop;
                if (upperWickHeight > 0) {
                    ctx.beginPath();
                    drawRoundedRect(wickX - Math.floor(wickWidth / 2), upperWickTop, wickWidth, upperWickHeight, wickWidth / 2 // Radius for rounded corners.
                    );
                    ctx.fill();
                    ctx.stroke();
                }
                // Draw the lower wick.
                const lowerWickHeight = lowerWickBottom - lowerWickTop;
                if (lowerWickHeight > 0) {
                    ctx.beginPath();
                    drawRoundedRect(wickX - Math.floor(wickWidth / 2), lowerWickTop, wickWidth, lowerWickHeight, wickWidth / 2 // Radius for rounded corners.
                    );
                    ctx.fill();
                    ctx.stroke();
                }
            }
        }
        /**
         * Draws the candle bodies based on their specified shapes.
         * Supports multiple shapes like Rectangle, Rounded, Ellipse, Arrow, 3D, and Polygon.
         * @param renderingScope - The rendering scope containing canvas context and scaling information.
         * @param bars - Array of aggregated BarItem objects to draw candles for.
         * @param visibleRange - The range of visible bars to render.
         * @param radius - The radius for rounded candle shapes.
         * @param candleWidth - The width of the candle in pixels.
         * @param horizontalPixelRatio - Scaling factor for horizontal dimensions.
         * @param verticalPixelRatio - Scaling factor for vertical dimensions.
         */
        _drawCandles(renderingScope, bars, visibleRange, radius, candleWidth, horizontalPixelRatio, verticalPixelRatio) {
            const { context: ctx } = renderingScope;
            const barSpace = this._options?.barSpacing ?? 0.8;
            // Save the current canvas state before drawing.
            ctx.save();
            // Iterate over each aggregated bar to draw its body.
            for (const bar of bars) {
                const groupSize = bar.endIndex - bar.startIndex;
                // Calculate the horizontal span of the candle based on grouping.
                const barHorizontalSpan = this._options?.chandelierSize !== 1
                    ? candleWidth * Math.max(1, groupSize + 1) -
                        (1 - barSpace) * candleWidth
                    : candleWidth * barSpace;
                // Determine the X position for the candle.
                const barHorizontalPos = bar.x * horizontalPixelRatio;
                // Calculate the actual width of the candle body.
                const candleBodyWidth = candleWidth * barSpace;
                // Skip rendering if the bar is outside the visible range.
                if (bar.startIndex < visibleRange.from ||
                    bar.endIndex > visibleRange.to) {
                    continue;
                }
                // Calculate vertical positions for the candle body.
                const barVerticalMax = Math.min(bar.open, bar.close) * verticalPixelRatio;
                const barVerticalMin = Math.max(bar.open, bar.close) * verticalPixelRatio;
                const barVerticalSpan = barVerticalMax - barVerticalMin;
                const barY = (barVerticalMax + barVerticalMin) / 2;
                // Precompute common X coordinates for drawing.
                const leftSide = barHorizontalPos - candleBodyWidth / 2;
                const rightSide = leftSide + barHorizontalSpan;
                const middle = leftSide + barHorizontalSpan / 2;
                // Set fill and stroke styles from bar properties.
                ctx.fillStyle =
                    bar.color ?? this._options?.color ?? 'rgba(255,255,255,1)';
                ctx.strokeStyle =
                    bar.borderColor ??
                        this._options?.borderColor ??
                        bar.color ??
                        'rgba(255,255,255,1)';
                setLineStyle(ctx, bar.lineStyle);
                ctx.lineWidth = bar.lineWidth ?? DEFAULT_LINE_WIDTH;
                // Draw the candle based on its specified shape.
                switch (bar.shape) {
                    case 'Rectangle':
                        ohlcRectangle(ctx, leftSide, rightSide, barY, barVerticalSpan);
                        break;
                    case 'Rounded':
                        ohlcRounded(ctx, leftSide, rightSide, barY, barVerticalSpan, radius);
                        break;
                    case 'Ellipse':
                        ohlcEllipse(ctx, leftSide, rightSide, middle, barY, barVerticalSpan);
                        break;
                    case 'Arrow':
                        ohlcArrow(ctx, leftSide, rightSide, middle, barY, barVerticalSpan, bar.high * verticalPixelRatio, bar.low * verticalPixelRatio, bar.isUp);
                        break;
                    case '3d':
                        ohlc3d(ctx, barHorizontalPos, bar.high * verticalPixelRatio, bar.low * verticalPixelRatio, bar.open * verticalPixelRatio, bar.close * verticalPixelRatio, candleBodyWidth, barHorizontalSpan, bar.color ?? this._options?.color ?? 'rgba(255,255,255,1)', bar.borderColor ?? this._options?.borderColor ?? 'rgba(255,255,255,1)', bar.isUp, barSpace);
                        break;
                    case 'Polygon':
                        ohlcPolygon(ctx, leftSide, rightSide, barY, barVerticalSpan, bar.high * verticalPixelRatio, bar.low * verticalPixelRatio, bar.isUp);
                        break;
                    case "Bar":
                        ohlcBar(ctx, leftSide, rightSide, bar.high * verticalPixelRatio, bar.low * verticalPixelRatio, bar.open * verticalPixelRatio, bar.close * verticalPixelRatio);
                        break;
                    case "Slanted":
                        ohlcSlanted(ctx, leftSide, rightSide, barY, // yCenter
                        barVerticalSpan, // candleHeight
                        bar.isUp);
                        break;
                    default:
                        // Fallback to rectangle shape if unknown shape is specified.
                        ohlcRectangle(ctx, leftSide, rightSide, barY, barVerticalSpan);
                        break;
                }
            }
            // Restore the canvas state after drawing.
            ctx.restore();
        }
    }

    //upperUpColor: string|undefined
    //upperDownColor: string|undefined
    //lowerUpColor: string|undefined
    //lowerDownColor: string|undefined
    const ohlcdefaultOptions = {
        ...lightweightCharts.customSeriesDefaultOptions,
        upColor: '#008000',
        downColor: '#8C0000',
        wickVisible: true,
        borderVisible: true,
        borderColor: '#737375',
        borderUpColor: '#008000',
        borderDownColor: '#8C0000',
        wickColor: '#737375',
        wickUpColor: '#008000',
        wickDownColor: '#8C0000',
        radius: .6,
        shape: 'Rounded', // Default shape
        chandelierSize: 1,
        barSpacing: 0.8,
        lineStyle: 0,
        lineWidth: 2,
        enableVolumeOpacity: true,
        volumeOpacityMode: '> previous',
        volumeOpacityPeriod: 21,
        maxOpacity: 0.3,
        dynamicCandles: false,
        dynamicTrigger: () => ({ newBar: true }) // Corrected function implementation
    };
    //upperUpColor: undefined,
    //upperDownColor: undefined,
    //lowerUpColor: undefined,
    //lowerDownColor: undefined,
    class ohlcSeries {
        _renderer;
        constructor() {
            this._renderer = new ohlcSeriesRenderer();
        }
        priceValueBuilder(plotRow) {
            return [plotRow.high, plotRow.low, plotRow.close];
        }
        renderer() {
            return this._renderer;
        }
        isWhitespace(data) {
            return data.close === undefined;
        }
        update(data, options) {
            this._renderer.update(data, options);
        }
        defaultOptions() {
            return ohlcdefaultOptions;
        }
    }
    // ./types.ts

    /**
     * A simple DefaultOptionsManager to store default options in memory.
     *
     * This class provides a single method, `set`, to update the default options for a given key.
     * The defaults are stored in an in-memory Map.
     *
     * Usage:
     *   const manager = new DefaultOptionsManager();
     *   manager.set("area", { title: "Area", lineColor: "#021698", topColor: "rgba(9,32,210,0.4)", bottomColor: "rgba(0,0,0,0.5)" });
     *   const areaDefaults = manager.get("area");
     */
    class DefaultOptionsManager {
        // In-memory storage for default options.
        defaults;
        constructor() {
            this.defaults = new Map();
        }
        /**
           * Sets the default options for the given key.
           * If the provided data is a JSON string, it will be parsed into an object.
           *
           * @param key - A string identifying the default options (e.g., "area", "line").
           * @param data - The default options to store, either as an object or a JSON string.
           */
        set(key, data) {
            let parsedData;
            if (typeof data === 'string') {
                try {
                    parsedData = JSON.parse(data);
                }
                catch (error) {
                    console.error(`Error parsing JSON string for key "${key}":`, error);
                    // Optionally, you can throw an error here or fallback to the raw string.
                    parsedData = data; // fallback: store the string if parsing fails.
                }
            }
            else {
                parsedData = data;
            }
            this.defaults.set(key, parsedData);
            console.log(`Default options for key "${key}" set successfully.`);
            console.log(parsedData);
        }
        get(key) {
            if (this.defaults.has(key)) {
                return this.defaults.get(key);
            }
            else {
                return null;
            }
        }
        /**
         * Returns all stored defaults.
         *
         * @returns A Map containing all default options.
         */
        getAll() {
            return this.defaults;
        }
    }

    globalParamInit();
    class Handler {
        id;
        commandFunctions = [];
        static handlers = new Map();
        seriesOriginMap = new WeakMap();
        wrapper;
        div;
        chart;
        scale;
        precision = 2;
        series;
        volumeSeries;
        volumeUpColor = null;
        volumeDownColor = null;
        legend;
        _topBar;
        toolBox;
        spinner;
        _seriesList = [];
        seriesMap = new Map();
        seriesMetadata;
        colorPicker = null;
        // Series context menu
        ContextMenu;
        currentMouseEventParams = null;
        defaultsManager;
        // TODO find a better solution rather than the 'position' parameter
        constructor(chartId, innerWidth, innerHeight, position, autoSize) {
            this.reSize = this.reSize.bind(this);
            this.id = chartId;
            this.scale = {
                width: innerWidth,
                height: innerHeight,
            };
            this.defaultsManager = new DefaultOptionsManager();
            Handler.handlers.set(chartId, this);
            this.wrapper = document.createElement('div');
            this.wrapper.classList.add("handler");
            this.wrapper.style.float = position;
            this.div = document.createElement('div');
            this.div.style.position = 'relative';
            this.wrapper.appendChild(this.div);
            window.containerDiv.append(this.wrapper);
            this.chart = this._createChart();
            this.ContextMenu = new ContextMenu(this, Handler.handlers, // handlers: Map<string, Handler>
            () => window.MouseEventParams ?? null // returns null if undefined
            );
            this.legend = new Legend(this);
            // Create series using merged options.
            this.series = this.createCandlestickSeries();
            this.volumeSeries = this.createVolumeSeries();
            // Setup MouseEventParams tracking
            this.chart.subscribeCrosshairMove((param) => {
                this.currentMouseEventParams = param;
                window.MouseEventParams = param;
            });
            document.addEventListener("keydown", (event) => {
                for (let i = 0; i < this.commandFunctions.length; i++) {
                    if (this.commandFunctions[i](event))
                        break;
                }
            });
            window.handlerInFocus = this.id;
            this.wrapper.addEventListener("mouseover", () => {
                window.handlerInFocus = this.id;
                window.MouseEventParams = this.currentMouseEventParams || null;
            });
            this.seriesMetadata = new WeakMap();
            this.reSize();
            if (!autoSize)
                return;
            window.addEventListener("resize", () => this.reSize());
            // Additional MouseEventParams tracking
            this.chart.subscribeCrosshairMove((param) => {
                this.currentMouseEventParams = param;
            });
        }
        reSize() {
            let topBarOffset = this.scale.height !== 0 ? this._topBar?._div.offsetHeight || 0 : 0;
            this.chart.resize(window.innerWidth * this.scale.width, window.innerHeight * this.scale.height - topBarOffset);
            this.wrapper.style.width = `${100 * this.scale.width}%`;
            this.wrapper.style.height = `${100 * this.scale.height}%`;
            // TODO definitely a better way to do this
            if (this.scale.height === 0 || this.scale.width === 0) {
                // if (this.legend.div.style.display == 'flex') this.legend.div.style.display = 'none'
                if (this.toolBox) {
                    this.toolBox.div.style.display = 'none';
                }
            }
            else {
                // this.legend.div.style.display = 'flex'
                if (this.toolBox) {
                    this.toolBox.div.style.display = 'flex';
                }
            }
        }
        primitives = new Map(); // Map of plugin primitive instances by series name
        _createChart() {
            return lightweightCharts.createChart(this.div, {
                width: window.innerWidth * this.scale.width,
                height: window.innerHeight * this.scale.height,
                layout: {
                    textColor: window.pane.color,
                    background: {
                        color: '#000000',
                        type: lightweightCharts.ColorType.Solid,
                    },
                    fontSize: 12
                },
                rightPriceScale: {
                    scaleMargins: { top: 0.3, bottom: 0.25 },
                },
                timeScale: { timeVisible: true, secondsVisible: false },
                crosshair: {
                    mode: lightweightCharts.CrosshairMode.Normal,
                    vertLine: { labelBackgroundColor: 'rgb(46, 46, 46)' },
                    horzLine: { labelBackgroundColor: 'rgb(55, 55, 55)' }
                },
                grid: {
                    vertLines: { color: 'rgba(29, 30, 38, 5)' },
                    horzLines: { color: 'rgba(29, 30, 58, 5)' },
                },
                handleScroll: { vertTouchDrag: true },
            });
        }
        /**
         * Helper method to merge series options.
         * Merge order: { ...getDefaultSeriesOptions(type), ...fileDefaults, ...explicitOptions }
         *
         * @param type - The series type (SupportedSeriesType)
         * @param explicitOptions - Options provided explicitly
         */
        mergeSeriesOptions(type, explicitOptions) {
            // Get built–in defaults (base options)
            const baseOptions = getDefaultSeriesOptions(type);
            // File defaults: lookup by lowercased type (e.g. "line", "area", etc.)
            const fileDefaults = this.defaultsManager.defaults.get(type.toLowerCase()) || {};
            return { ...baseOptions, ...fileDefaults, ...explicitOptions };
        }
        /**
         * Creates a candlestick series using merged options.
         * (No explicit options provided; only built–in and file defaults are merged.)
         */
        createCandlestickSeries() {
            const type = "Candlestick";
            // Merge built–in defaults and file defaults
            const baseOptions = getDefaultSeriesOptions(type);
            const fileDefaults = this.defaultsManager.defaults.get(type.toLowerCase()) || {};
            const mergedOptions = { ...baseOptions, ...fileDefaults };
            const candleSeries = this.chart.addSeries(lightweightCharts.CandlestickSeries, mergedOptions);
            candleSeries.priceScale().applyOptions({ scaleMargins: { top: 0.2, bottom: 0.2 } });
            const decorated = decorateSeries(candleSeries, this.legend);
            decorated.applyOptions({ title: "OHLC" });
            this._seriesList.push(decorated);
            this.seriesMap.set("OHLC", decorated);
            const legendItem = {
                name: "OHLC",
                series: decorated,
                colors: [mergedOptions.upColor, mergedOptions.downColor],
                legendSymbol: ['⋰', '⋱'],
                seriesType: "Candlestick",
                group: undefined,
            };
            this.legend.addLegendItem(legendItem);
            return decorated;
        }
        createVolumeSeries(pane) {
            const volumeSeries = this.chart.addSeries(lightweightCharts.HistogramSeries, {
                color: "#26a69a",
                priceFormat: { type: "volume" },
                priceScaleId: "volume_scale",
            });
            volumeSeries.priceScale().applyOptions({
                scaleMargins: { top: 0, bottom: 0.2 },
            });
            // Optionally, move the series to the desired pane.
            if (pane !== undefined) {
                volumeSeries.moveToPane(pane);
            }
            const decorated = decorateSeries(volumeSeries, this.legend);
            decorated.applyOptions({ title: "Volume" });
            return decorated;
        }
        /**
         * Creates a line series using merged options.
         * @param name The series title.
         * @param options Optional line series options.
         * @param pane Optional pane index to move the series to.
         */
        createLineSeries(name, options, pane) {
            const mergedOptions = this.mergeSeriesOptions("Line", options ?? {});
            const symbol = (() => {
                switch (mergedOptions.lineStyle) {
                    case 0: return '―';
                    case 1: return ':··';
                    case 2: return '--';
                    case 3: return '- -';
                    case 4: return '· ·';
                    default: return '~';
                }
            })();
            const { group, legendSymbol = symbol, ...lineOptions } = mergedOptions;
            const line = this.chart.addSeries(lightweightCharts.LineSeries, lineOptions);
            const decorated = decorateSeries(line, this.legend);
            decorated.applyOptions({ title: name });
            this._seriesList.push(decorated);
            this.seriesMap.set(name, decorated);
            const color = decorated.options().color || "rgba(255,0,0,1)";
            const solidColor = color.startsWith("rgba") ? color.replace(/[^,]+(?=\))/, "1") : color;
            const legendItem = {
                name,
                series: decorated,
                colors: [solidColor],
                legendSymbol: Array.isArray(legendSymbol) ? legendSymbol : [legendSymbol],
                seriesType: "Line",
                group,
            };
            this.legend.addLegendItem(legendItem);
            if (pane !== undefined) {
                decorated.moveToPane(pane);
            }
            return { name, series: decorated };
        }
        /**
         * Creates a histogram series using merged options.
         * @param name The series title.
         * @param options Optional histogram series options.
         * @param pane Optional pane index to move the series to.
         */
        createHistogramSeries(name, options, pane) {
            const mergedOptions = this.mergeSeriesOptions("Histogram", options ?? {});
            const { group, legendSymbol = "▨", ...histogramOptions } = mergedOptions;
            const histogram = this.chart.addSeries(lightweightCharts.HistogramSeries, histogramOptions);
            const decorated = decorateSeries(histogram, this.legend);
            decorated.applyOptions({ title: name });
            this._seriesList.push(decorated);
            this.seriesMap.set(name, decorated);
            const color = decorated.options().color || "rgba(255,0,0,1)";
            const solidColor = color.startsWith("rgba") ? color.replace(/[^,]+(?=\))/, "1") : color;
            const legendItem = {
                name,
                series: decorated,
                colors: [solidColor],
                legendSymbol: Array.isArray(legendSymbol) ? legendSymbol : [legendSymbol],
                seriesType: "Histogram",
                group,
            };
            this.legend.addLegendItem(legendItem);
            if (pane !== undefined) {
                decorated.moveToPane(pane);
            }
            return { name, series: decorated };
        }
        /**
         * Creates an area series using merged options.
         * @param name The series title.
         * @param options Optional area series options.
         * @param pane Optional pane index to move the series to.
         */
        createAreaSeries(name, options, pane) {
            const mergedOptions = this.mergeSeriesOptions("Area", options ?? {});
            const { group, legendSymbol = "▨", ...areaOptions } = mergedOptions;
            const area = this.chart.addSeries(lightweightCharts.AreaSeries, areaOptions);
            const decorated = decorateSeries(area, this.legend);
            this._seriesList.push(decorated);
            this.seriesMap.set(name, decorated);
            const color = decorated.options().lineColor || "rgba(255,0,0,1)";
            const solidColor = color.startsWith("rgba") ? color.replace(/[^,]+(?=\))/, "1") : color;
            const legendItem = {
                name,
                series: decorated,
                colors: [solidColor],
                legendSymbol: Array.isArray(legendSymbol) ? legendSymbol : [legendSymbol],
                seriesType: "Area",
                group,
            };
            this.legend.addLegendItem(legendItem);
            if (pane !== undefined) {
                decorated.moveToPane(pane);
            }
            return { name, series: decorated };
        }
        /**
         * Creates a bar series using merged options.
         * @param name The series title.
         * @param options Optional bar series options.
         * @param pane Optional pane index to move the series to.
         */
        createBarSeries(name, options, pane) {
            const mergedOptions = this.mergeSeriesOptions("Bar", options ?? {});
            const { group, legendSymbol = ['┌', '└'], ...barOptions } = mergedOptions;
            const bar = this.chart.addSeries(lightweightCharts.BarSeries, barOptions);
            const decorated = decorateSeries(bar, this.legend);
            decorated.applyOptions({ title: name });
            this._seriesList.push(decorated);
            this.seriesMap.set(name, decorated);
            const upColor = decorated.options().upColor || "rgba(0,255,0,1)";
            const downColor = decorated.options().downColor || "rgba(255,0,0,1)";
            const legendItem = {
                name,
                series: decorated,
                colors: [upColor, downColor],
                legendSymbol: Array.isArray(legendSymbol) ? legendSymbol : [legendSymbol],
                seriesType: "Bar",
                group,
            };
            this.legend.addLegendItem(legendItem);
            if (pane !== undefined) {
                decorated.moveToPane(pane);
            }
            return { name, series: decorated };
        }
        /**
         * Creates a custom OHLC series using merged options.
         * @param name The series title.
         * @param options Optional OHLC series options.
         * @param pane Optional pane index to move the series to.
         */
        createCustomOHLCSeries(name, options, pane) {
            // Merge built–in defaults, file defaults, and explicit options for "Ohlc"
            const base = ohlcdefaultOptions;
            const fileDefaults = this.defaultsManager.defaults.get("ohlc") || {};
            const mergedOptions = {
                ...base,
                ...fileDefaults,
                ...options,
                seriesType: 'Ohlc',
            };
            const { group, legendSymbol = ['⑃', '⑂'], seriesType: _, chandelierSize, ...filteredOptions } = mergedOptions;
            const Instance = new ohlcSeries();
            const ohlcCustomSeries = this.chart.addCustomSeries(Instance, {
                ...filteredOptions,
                chandelierSize,
                title: name
            });
            const decorated = decorateSeries(ohlcCustomSeries, this.legend);
            this._seriesList.push(decorated);
            this.seriesMap.set(name, decorated);
            const borderUpColor = mergedOptions.borderUpColor || mergedOptions.upColor;
            const borderDownColor = mergedOptions.borderDownColor || mergedOptions.downColor;
            const colorsArray = [borderUpColor, borderDownColor];
            const legendItem = {
                name,
                series: decorated,
                colors: colorsArray,
                legendSymbol: Array.isArray(legendSymbol) ? legendSymbol : legendSymbol ? [legendSymbol] : [],
                seriesType: 'Ohlc',
                group,
            };
            this.legend.addLegendItem(legendItem);
            if (pane !== undefined) {
                decorated.moveToPane(pane);
            }
            return { name, series: decorated };
        }
        // /**
        //  * Creates a trade series using merged options.
        //  */
        // createTradeSeries(name: string, options?: Partial<TradeSeriesOptions> = {}): { name: string; series: ISeriesApiExtended  } {
        //     const mergedoptions?: TradeSeriesOptions & { seriesType?: string; group?: string; legendSymbol?: string[] | string; } = {
        //         ...tradeDefaultOptions,
        //         ...this.defaultsManager.defaults.get("trade"),
        //         ...options,
        //         seriesType: 'Trade',
        //     };
        //
        //     const { group, legendSymbol = ['$'], seriesType: _, ...filteredOptions } = mergedOptions;
        //
        //     const instance = new TradeSeries();
        //     const tradeCustomSeries = this.chart.addCustomSeries(instance, filteredOptions);
        //
        //     const decorated = decorateSeries(tradeCustomSeries, this.legend);
        //     this._seriesList.push(decorated);
        //     this.seriesMap.set(name ?? 'Trade', decorated);
        //
        //     const colorsArray = [
        //         mergedOptions.backgroundColorStop,
        //         mergedOptions.backgroundColorTarget
        //     ];
        //     const finalLegendSymbol = Array.isArray(legendSymbol) ? legendSymbol : [legendSymbol];
        //
        //     const legendItem: LegendItem = {
        //         name,
        //         series: decorated,
        //         colors: colorsArray,
        //         legendSymbol: finalLegendSymbol,
        //         seriesType: 'Trade',
        //         group,
        //     };
        //
        //     this.legend.addLegendItem(legendItem);
        //
        //     return { name, series: tradeCustomSeries };
        // }
        /**
         * Creates a fill area between two series.
         */
        createFillArea(name, origin, destination, originColor, destinationColor) {
            const originSeries = this._seriesList.find(s => s.options()?.title === origin);
            const destinationSeries = this._seriesList.find(s => s.options()?.title === destination);
            if (!originSeries) {
                console.warn(`Origin series with title "${origin}" not found.`);
                return undefined;
            }
            if (!destinationSeries) {
                console.warn(`Destination series with title "${destination}" not found.`);
                return undefined;
            }
            const extendedOriginSeries = ensureExtendedSeries(originSeries, this.legend);
            const fillArea = new FillArea(originSeries, destinationSeries, {
                originColor: originColor || null,
                destinationColor: destinationColor || null,
                lineWidth: null,
            });
            extendedOriginSeries.attachPrimitive(fillArea, name);
            return fillArea;
        }
        attachPrimitive(lineColor, primitiveType, series, seriesName) {
            let _series = series;
            try {
                if (seriesName && !series) {
                    _series = this.seriesMap.get(seriesName);
                }
                if (!_series) {
                    console.warn(`Series with the name "${seriesName}" not found.`);
                    return;
                }
                const extendedSeries = ensureExtendedSeries(_series, this.legend);
                let primitiveInstance;
                switch (primitiveType) {
                    case "Tooltip":
                        primitiveInstance = new TooltipPrimitive({ lineColor });
                        break;
                    default:
                        console.warn(`Unknown primitive type: ${primitiveType}`);
                        return;
                }
                extendedSeries.attachPrimitive(primitiveInstance, "Tooltip");
                this.primitives.set(_series, primitiveInstance);
            }
            catch (error) {
                console.error(`Failed to attach ${primitiveType}:`, error);
            }
        }
        removeSeries(series) {
            let seriesName;
            if (isISeriesApi(series)) {
                for (const [key, value] of this.seriesMap.entries()) {
                    if (value === series) {
                        seriesName = key;
                        break;
                    }
                }
            }
            else {
                seriesName = series;
                series = this.seriesMap.get(series);
            }
            if (!series || !seriesName) {
                console.warn(`❌ Series "${series}" does not exist and cannot be removed.`);
                return;
            }
            series = series;
            if (series.primitives && series.primitives.length > 0) {
                series.primitives.forEach((primitive) => {
                    series.detachPrimitive(primitive);
                    console.log(`✅ Detached primitive from series "${seriesName}".`);
                });
            }
            this._seriesList = this._seriesList.filter(s => s !== series);
            this.seriesMap.delete(seriesName);
            console.log(`✅ Series "${seriesName}" removed from internal maps.`);
            try {
                const legendItem = this.legend._items.find((item) => item.series === series);
                if (legendItem) {
                    if (legendItem.primitives && legendItem.primitives.length > 0) {
                        legendItem.primitives.forEach((primitive) => {
                            this.legend.removeLegendPrimitive(primitive);
                            console.log(`✅ Removed primitive from legend for series "${seriesName}".`);
                        });
                    }
                    this.legend.deleteLegendEntry(legendItem.name, legendItem.group ?? undefined);
                    console.log(`✅ Removed series "${seriesName}" from legend.`);
                }
                else {
                    console.warn(`⚠️ Legend item for series "${seriesName}" not found.`);
                }
            }
            catch (error) {
                console.error(`⚠️ Error removing legend entry for "${seriesName}":`, error);
            }
            this.chart.removeSeries(series);
            console.log(`✅ Series "${seriesName}" successfully removed.`);
        }
        createToolBox() {
            this.toolBox = new ToolBox(this, this.id, this.chart, this.series, this.commandFunctions);
            this.div.appendChild(this.toolBox.div);
        }
        createTopBar() {
            this._topBar = new TopBar(this);
            this.wrapper.prepend(this._topBar._div);
            return this._topBar;
        }
        //toJSON() {
        //    // Exclude the chart attribute from serialization
        //    const { chart, ...serialized } = this;
        //    return serialized;
        //}
        /**
         * Extracts data from a series in a format suitable for indicators.
         * @param series - The series to extract data from.
         * @returns An array of arrays containing `time` and `close` values.
         */
        extractSeriesData(series) {
            const seriesData = series.data(); // Ensure this retrieves the data from the series.
            if (!Array.isArray(seriesData)) {
                console.warn("Failed to extract data: series data is not in array format.");
                return [];
            }
            // Convert data into an array of arrays
            return seriesData.map((point) => [
                point.time,
                point.value || point.close || 0,
            ]);
        }
        static syncCharts(childChart, parentChart, crosshairOnly = false) {
            function crosshairHandler(chart, point) {
                //point: BarData | LineData) {
                if (!point) {
                    chart.chart.clearCrosshairPosition();
                    return;
                }
                // TODO fix any point ?
                chart.chart.setCrosshairPosition(point.value || point.close, point.time, chart.series);
                chart.legend.legendHandler(point, true);
            }
            function getPoint(series, param) {
                if (!param.time)
                    return null;
                return param.seriesData.get(series) || null;
            }
            const childTimeScale = childChart.chart.timeScale();
            const parentTimeScale = parentChart.chart.timeScale();
            const setChildRange = (timeRange) => {
                if (timeRange)
                    childTimeScale.setVisibleLogicalRange(timeRange);
            };
            const setParentRange = (timeRange) => {
                if (timeRange)
                    parentTimeScale.setVisibleLogicalRange(timeRange);
            };
            const setParentCrosshair = (param) => {
                crosshairHandler(parentChart, getPoint(childChart.series, param));
            };
            const setChildCrosshair = (param) => {
                crosshairHandler(childChart, getPoint(parentChart.series, param));
            };
            let selected = parentChart;
            function addMouseOverListener(thisChart, otherChart, thisCrosshair, otherCrosshair, thisRange, otherRange) {
                thisChart.wrapper.addEventListener('mouseover', () => {
                    if (selected === thisChart)
                        return;
                    selected = thisChart;
                    otherChart.chart.unsubscribeCrosshairMove(thisCrosshair);
                    thisChart.chart.subscribeCrosshairMove(otherCrosshair);
                    if (crosshairOnly)
                        return;
                    otherChart.chart.timeScale().unsubscribeVisibleLogicalRangeChange(thisRange);
                    thisChart.chart.timeScale().subscribeVisibleLogicalRangeChange(otherRange);
                });
            }
            addMouseOverListener(parentChart, childChart, setParentCrosshair, setChildCrosshair, setParentRange, setChildRange);
            addMouseOverListener(childChart, parentChart, setChildCrosshair, setParentCrosshair, setChildRange, setParentRange);
            parentChart.chart.subscribeCrosshairMove(setChildCrosshair);
            const parentRange = parentTimeScale.getVisibleLogicalRange();
            if (parentRange)
                childTimeScale.setVisibleLogicalRange(parentRange);
            if (crosshairOnly)
                return;
            parentChart.chart.timeScale().subscribeVisibleLogicalRangeChange(setChildRange);
        }
        static makeSearchBox(chart) {
            const searchWindow = document.createElement('div');
            searchWindow.classList.add('searchbox');
            searchWindow.style.display = 'none';
            const magnifyingGlass = document.createElement('div');
            magnifyingGlass.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="24px" viewBox="0 0 24 24" version="1.1"><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:lightgray;stroke-opacity:1;stroke-miterlimit:4;" d="M 15 15 L 21 21 M 10 17 C 6.132812 17 3 13.867188 3 10 C 3 6.132812 6.132812 3 10 3 C 13.867188 3 17 6.132812 17 10 C 17 13.867188 13.867188 17 10 17 Z M 10 17 "/></svg>`;
            const sBox = document.createElement('input');
            sBox.type = 'text';
            searchWindow.appendChild(magnifyingGlass);
            searchWindow.appendChild(sBox);
            chart.div.appendChild(searchWindow);
            chart.commandFunctions.push((event) => {
                if (window.handlerInFocus !== chart.id || window.textBoxFocused)
                    return false;
                if (searchWindow.style.display === 'none') {
                    if (/^[a-zA-Z0-9]$/.test(event.key)) {
                        searchWindow.style.display = 'flex';
                        sBox.focus();
                        return true;
                    }
                    else
                        return false;
                }
                else if (event.key === 'Enter' || event.key === 'Escape') {
                    if (event.key === 'Enter')
                        window.callbackFunction(`search${chart.id}_~_${sBox.value}`);
                    searchWindow.style.display = 'none';
                    sBox.value = '';
                    return true;
                }
                else
                    return false;
            });
            sBox.addEventListener('input', () => sBox.value = sBox.value.toUpperCase());
            return {
                window: searchWindow,
                box: sBox,
            };
        }
        static makeSpinner(chart) {
            chart.spinner = document.createElement('div');
            chart.spinner.classList.add('spinner');
            chart.wrapper.appendChild(chart.spinner);
            // TODO below can be css (animate)
            let rotation = 0;
            const speed = 10;
            function animateSpinner() {
                if (!chart.spinner)
                    return;
                rotation += speed;
                chart.spinner.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
                requestAnimationFrame(animateSpinner);
            }
            animateSpinner();
        }
        static _styleMap = {
            '--bg-color': 'backgroundColor',
            '--hover-bg-color': 'hoverBackgroundColor',
            '--click-bg-color': 'clickBackgroundColor',
            '--active-bg-color': 'activeBackgroundColor',
            '--muted-bg-color': 'mutedBackgroundColor',
            '--border-color': 'borderColor',
            '--color': 'color',
            '--active-color': 'activeColor',
        };
        static setRootStyles(styles) {
            const rootStyle = document.documentElement.style;
            for (const [property, valueKey] of Object.entries(this._styleMap)) {
                rootStyle.setProperty(property, styles[valueKey]);
            }
        }
        /**
         * Serializes the Handler's state into a JSON object.
         *
         * The serialization includes:
         *  - Chart options from the internal chart instance.
         *  - Scale and precision values.
         *
         * @returns A JSON object representing the Handler’s state.
         */
        toJSON() {
            return {
                id: this.id,
                options: this.chart.options(),
                scale: this.scale,
                precision: this.precision,
            };
        }
        /**
         * Restores the Handler’s state from a JSON object.
         *
         * This includes:
         *  - Updating the internal chart’s options via chart.applyOptions.
         *  - Restoring scale and precision.
         *
         * @param json The JSON object containing state.
         */
        fromJSON(json) {
            if (!json) {
                console.warn("No JSON data provided for handler deserialization.");
                return;
            }
            // Update chart options by delegating to the Chart class.
            if (json.options) {
                this.chart.applyOptions(json.options);
            }
            // Restore scale and precision.
            if (json.scale !== undefined) {
                this.scale = json.scale;
            }
            if (json.precision !== undefined) {
                this.precision = json.precision;
            }
        }
        _type = "chart";
        title = "chart";
    }

    class Table {
        _div;
        callbackName;
        borderColor;
        borderWidth;
        table;
        rows = {};
        headings;
        widths;
        alignments;
        footer;
        header;
        constructor(width, height, headings, widths, alignments, position, draggable = false, tableBackgroundColor, borderColor, borderWidth, textColors, backgroundColors) {
            this._div = document.createElement('div');
            this.callbackName = null;
            this.borderColor = borderColor;
            this.borderWidth = borderWidth;
            if (draggable) {
                this._div.style.position = 'absolute';
                this._div.style.cursor = 'move';
            }
            else {
                this._div.style.position = 'relative';
                this._div.style.float = position;
            }
            this._div.style.zIndex = '2000';
            this.reSize(width, height);
            this._div.style.display = 'flex';
            this._div.style.flexDirection = 'column';
            // this._div.style.justifyContent = 'space-between'
            this._div.style.borderRadius = '5px';
            this._div.style.color = 'white';
            this._div.style.fontSize = '12px';
            this._div.style.fontVariantNumeric = 'tabular-nums';
            this.table = document.createElement('table');
            this.table.style.width = '100%';
            this.table.style.borderCollapse = 'collapse';
            this._div.style.overflow = 'hidden';
            this.headings = headings;
            this.widths = widths.map((width) => `${width * 100}%`);
            this.alignments = alignments;
            let head = this.table.createTHead();
            let row = head.insertRow();
            for (let i = 0; i < this.headings.length; i++) {
                let th = document.createElement('th');
                th.textContent = this.headings[i];
                th.style.width = this.widths[i];
                th.style.letterSpacing = '0.03rem';
                th.style.padding = '0.2rem 0px';
                th.style.fontWeight = '500';
                th.style.textAlign = 'center';
                if (i !== 0)
                    th.style.borderLeft = borderWidth + 'px solid ' + borderColor;
                th.style.position = 'sticky';
                th.style.top = '0';
                th.style.backgroundColor = backgroundColors.length > 0 ? backgroundColors[i] : tableBackgroundColor;
                th.style.color = textColors[i];
                row.appendChild(th);
            }
            let overflowWrapper = document.createElement('div');
            overflowWrapper.style.overflowY = 'auto';
            overflowWrapper.style.overflowX = 'hidden';
            overflowWrapper.style.backgroundColor = tableBackgroundColor;
            overflowWrapper.appendChild(this.table);
            this._div.appendChild(overflowWrapper);
            window.containerDiv.appendChild(this._div);
            if (!draggable)
                return;
            let offsetX, offsetY;
            let onMouseDown = (event) => {
                offsetX = event.clientX - this._div.offsetLeft;
                offsetY = event.clientY - this._div.offsetTop;
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            };
            let onMouseMove = (event) => {
                this._div.style.left = (event.clientX - offsetX) + 'px';
                this._div.style.top = (event.clientY - offsetY) + 'px';
            };
            let onMouseUp = () => {
                // Remove the event listeners for dragging
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };
            this._div.addEventListener('mousedown', onMouseDown);
        }
        divToButton(div, callbackString) {
            div.addEventListener('mouseover', () => div.style.backgroundColor = 'rgba(60, 60, 60, 0.6)');
            div.addEventListener('mouseout', () => div.style.backgroundColor = 'transparent');
            div.addEventListener('mousedown', () => div.style.backgroundColor = 'rgba(60, 60, 60)');
            div.addEventListener('click', () => window.callbackFunction(callbackString));
            div.addEventListener('mouseup', () => div.style.backgroundColor = 'rgba(60, 60, 60, 0.6)');
        }
        newRow(id, returnClickedCell = false) {
            let row = this.table.insertRow();
            row.style.cursor = 'default';
            for (let i = 0; i < this.headings.length; i++) {
                let cell = row.insertCell();
                cell.style.width = this.widths[i];
                cell.style.textAlign = this.alignments[i];
                cell.style.border = this.borderWidth + 'px solid ' + this.borderColor;
                if (returnClickedCell) {
                    this.divToButton(cell, `${this.callbackName}_~_${id};;;${this.headings[i]}`);
                }
            }
            if (!returnClickedCell) {
                this.divToButton(row, `${this.callbackName}_~_${id}`);
            }
            this.rows[id] = row;
        }
        deleteRow(id) {
            this.table.deleteRow(this.rows[id].rowIndex);
            delete this.rows[id];
        }
        clearRows() {
            let numRows = Object.keys(this.rows).length;
            for (let i = 0; i < numRows; i++)
                this.table.deleteRow(-1);
            this.rows = {};
        }
        _getCell(rowId, column) {
            return this.rows[rowId].cells[this.headings.indexOf(column)];
        }
        updateCell(rowId, column, val) {
            this._getCell(rowId, column).textContent = val;
        }
        styleCell(rowId, column, styleAttribute, value) {
            const style = this._getCell(rowId, column).style;
            style[styleAttribute] = value;
        }
        makeSection(id, type, numBoxes, func = false) {
            let section = document.createElement('div');
            section.style.display = 'flex';
            section.style.width = '100%';
            section.style.padding = '3px 0px';
            section.style.backgroundColor = 'rgb(30, 30, 30)';
            type === 'footer' ? this._div.appendChild(section) : this._div.prepend(section);
            const textBoxes = [];
            for (let i = 0; i < numBoxes; i++) {
                let textBox = document.createElement('div');
                section.appendChild(textBox);
                textBox.style.flex = '1';
                textBox.style.textAlign = 'center';
                if (func) {
                    this.divToButton(textBox, `${id}_~_${i}`);
                    textBox.style.borderRadius = '2px';
                }
                textBoxes.push(textBox);
            }
            if (type === 'footer') {
                this.footer = textBoxes;
            }
            else {
                this.header = textBoxes;
            }
        }
        reSize(width, height) {
            this._div.style.width = width <= 1 ? width * 100 + '%' : width + 'px';
            this._div.style.height = height <= 1 ? height * 100 + '%' : height + 'px';
        }
    }

    exports.Box = Box;
    exports.CodeEditor = CodeEditor;
    exports.FillArea = FillArea;
    exports.Handler = Handler;
    exports.HorizontalLine = HorizontalLine;
    exports.Legend = Legend;
    exports.RayLine = RayLine;
    exports.Table = Table;
    exports.ToolBox = ToolBox;
    exports.TooltipPrimitive = TooltipPrimitive;
    exports.TopBar = TopBar;
    exports.TrendLine = TrendLine;
    exports.VerticalLine = VerticalLine;
    exports.addPlotToHandler = addPlotToHandler;
    exports.closedEye = closedEye;
    exports.defaultFillAreaOptions = defaultFillAreaOptions;
    exports.globalParamInit = globalParamInit;
    exports.ohlcSeries = ohlcSeries;
    exports.ohlcdefaultOptions = ohlcdefaultOptions;
    exports.openEye = openEye;
    exports.paneStyleDefault = paneStyleDefault;
    exports.setCursor = setCursor;

    return exports;

})({}, LightweightCharts, monaco);
//# sourceMappingURL=bundle.js.map
